import CGLib
import GLib
import GLibObject

// MARK: - DBusAnnotationInfo Record

/// Information about an annotation.
///
/// The `DBusAnnotationInfoProtocol` protocol exposes the methods and properties of an underlying `GDBusAnnotationInfo` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusAnnotationInfo`.
/// Alternatively, use `DBusAnnotationInfoRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusAnnotationInfoProtocol {
        /// Untyped pointer to the underlying `GDBusAnnotationInfo` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusAnnotationInfo` instance.
    var dbus_annotation_info_ptr: UnsafeMutablePointer<GDBusAnnotationInfo>! { get }

    /// Required Initialiser for types conforming to `DBusAnnotationInfoProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Information about an annotation.
///
/// The `DBusAnnotationInfoRef` type acts as a lightweight Swift reference to an underlying `GDBusAnnotationInfo` instance.
/// It exposes methods that can operate on this data type through `DBusAnnotationInfoProtocol` conformance.
/// Use `DBusAnnotationInfoRef` only as an `unowned` reference to an existing `GDBusAnnotationInfo` instance.
///
public struct DBusAnnotationInfoRef: DBusAnnotationInfoProtocol {
        /// Untyped pointer to the underlying `GDBusAnnotationInfo` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_annotation_info_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusAnnotationInfoRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusAnnotationInfo>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusAnnotationInfo>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusAnnotationInfo>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusAnnotationInfo>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusAnnotationInfoProtocol`
    @inlinable init<T: DBusAnnotationInfoProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAnnotationInfoProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAnnotationInfoProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAnnotationInfoProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAnnotationInfoProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAnnotationInfoProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// Information about an annotation.
///
/// The `DBusAnnotationInfo` type acts as a reference-counted owner of an underlying `GDBusAnnotationInfo` instance.
/// It provides the methods that can operate on this data type through `DBusAnnotationInfoProtocol` conformance.
/// Use `DBusAnnotationInfo` as a strong reference or owner of a `GDBusAnnotationInfo` instance.
///
open class DBusAnnotationInfo: DBusAnnotationInfoProtocol {
        /// Untyped pointer to the underlying `GDBusAnnotationInfo` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_annotation_info_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusAnnotationInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusAnnotationInfo>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusAnnotationInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusAnnotationInfo>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusAnnotationInfo` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusAnnotationInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusAnnotationInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusAnnotationInfo>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusAnnotationInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusAnnotationInfo>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDBusAnnotationInfo`.
    /// i.e., ownership is transferred to the `DBusAnnotationInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusAnnotationInfo>) {
        ptr = UnsafeMutableRawPointer(op)
        g_dbus_annotation_info_ref(ptr.assumingMemoryBound(to: GDBusAnnotationInfo.self))
    }

    /// Reference intialiser for a related type that implements `DBusAnnotationInfoProtocol`
    /// Will retain `GDBusAnnotationInfo`.
    /// - Parameter other: an instance of a related type that implements `DBusAnnotationInfoProtocol`
    @inlinable public init<T: DBusAnnotationInfoProtocol>(_ other: T) {
        ptr = other.ptr
        g_dbus_annotation_info_ref(ptr.assumingMemoryBound(to: GDBusAnnotationInfo.self))
    }

    /// Releases the underlying `GDBusAnnotationInfo` instance using `g_dbus_annotation_info_unref`.
    deinit {
        g_dbus_annotation_info_unref(ptr.assumingMemoryBound(to: GDBusAnnotationInfo.self))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAnnotationInfoProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAnnotationInfoProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        g_dbus_annotation_info_ref(ptr.assumingMemoryBound(to: GDBusAnnotationInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAnnotationInfoProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAnnotationInfoProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        g_dbus_annotation_info_ref(ptr.assumingMemoryBound(to: GDBusAnnotationInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAnnotationInfoProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAnnotationInfoProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        g_dbus_annotation_info_ref(ptr.assumingMemoryBound(to: GDBusAnnotationInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAnnotationInfoProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAnnotationInfoProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        g_dbus_annotation_info_ref(ptr.assumingMemoryBound(to: GDBusAnnotationInfo.self))
    }



}

// MARK: no DBusAnnotationInfo properties

// MARK: no DBusAnnotationInfo signals

// MARK: DBusAnnotationInfo has no signals
// MARK: DBusAnnotationInfo Record: DBusAnnotationInfoProtocol extension (methods and fields)
public extension DBusAnnotationInfoProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusAnnotationInfo` instance.
    @inlinable var dbus_annotation_info_ptr: UnsafeMutablePointer<GDBusAnnotationInfo>! { return ptr?.assumingMemoryBound(to: GDBusAnnotationInfo.self) }

    /// If `info` is statically allocated does nothing. Otherwise increases
    /// the reference count.
    @discardableResult @inlinable func ref() -> GIO.DBusAnnotationInfoRef! {
        let result = g_dbus_annotation_info_ref(dbus_annotation_info_ptr)
        guard let rv = DBusAnnotationInfoRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// If `info` is statically allocated, does nothing. Otherwise decreases
    /// the reference count of `info`. When its reference count drops to 0,
    /// the memory used is freed.
    @inlinable func unref() {
        
        g_dbus_annotation_info_unref(dbus_annotation_info_ptr)
        
    }

    /// The reference count or -1 if statically allocated.
    @inlinable var refCount: gint {
        /// The reference count or -1 if statically allocated.
        get {
            let rv = dbus_annotation_info_ptr.pointee.ref_count
    return rv
        }
        /// The reference count or -1 if statically allocated.
         set {
            dbus_annotation_info_ptr.pointee.ref_count = newValue
        }
    }

    /// The name of the annotation, e.g. "org.freedesktop.DBus.Deprecated".
    @inlinable var key: UnsafeMutablePointer<gchar>! {
        /// The name of the annotation, e.g. "org.freedesktop.DBus.Deprecated".
        get {
            let rv = dbus_annotation_info_ptr.pointee.key
    return rv
        }
        /// The name of the annotation, e.g. "org.freedesktop.DBus.Deprecated".
         set {
            dbus_annotation_info_ptr.pointee.key = newValue
        }
    }

    /// The value of the annotation.
    @inlinable var value: UnsafeMutablePointer<gchar>! {
        /// The value of the annotation.
        get {
            let rv = dbus_annotation_info_ptr.pointee.value
    return rv
        }
        /// The value of the annotation.
         set {
            dbus_annotation_info_ptr.pointee.value = newValue
        }
    }

    /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
    @inlinable var annotations: UnsafeMutablePointer<UnsafeMutablePointer<GDBusAnnotationInfo>?>! {
        /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
        get {
            let rv = dbus_annotation_info_ptr.pointee.annotations
    return rv
        }
        /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
         set {
            dbus_annotation_info_ptr.pointee.annotations = newValue
        }
    }

}



// MARK: - DBusArgInfo Record

/// Information about an argument for a method or a signal.
///
/// The `DBusArgInfoProtocol` protocol exposes the methods and properties of an underlying `GDBusArgInfo` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusArgInfo`.
/// Alternatively, use `DBusArgInfoRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusArgInfoProtocol {
        /// Untyped pointer to the underlying `GDBusArgInfo` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusArgInfo` instance.
    var dbus_arg_info_ptr: UnsafeMutablePointer<GDBusArgInfo>! { get }

    /// Required Initialiser for types conforming to `DBusArgInfoProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Information about an argument for a method or a signal.
///
/// The `DBusArgInfoRef` type acts as a lightweight Swift reference to an underlying `GDBusArgInfo` instance.
/// It exposes methods that can operate on this data type through `DBusArgInfoProtocol` conformance.
/// Use `DBusArgInfoRef` only as an `unowned` reference to an existing `GDBusArgInfo` instance.
///
public struct DBusArgInfoRef: DBusArgInfoProtocol {
        /// Untyped pointer to the underlying `GDBusArgInfo` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_arg_info_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusArgInfoRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusArgInfo>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusArgInfo>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusArgInfo>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusArgInfo>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusArgInfoProtocol`
    @inlinable init<T: DBusArgInfoProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusArgInfoProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusArgInfoProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusArgInfoProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusArgInfoProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusArgInfoProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// Information about an argument for a method or a signal.
///
/// The `DBusArgInfo` type acts as a reference-counted owner of an underlying `GDBusArgInfo` instance.
/// It provides the methods that can operate on this data type through `DBusArgInfoProtocol` conformance.
/// Use `DBusArgInfo` as a strong reference or owner of a `GDBusArgInfo` instance.
///
open class DBusArgInfo: DBusArgInfoProtocol {
        /// Untyped pointer to the underlying `GDBusArgInfo` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_arg_info_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusArgInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusArgInfo>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusArgInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusArgInfo>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusArgInfo` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusArgInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusArgInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusArgInfo>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusArgInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusArgInfo>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDBusArgInfo`.
    /// i.e., ownership is transferred to the `DBusArgInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusArgInfo>) {
        ptr = UnsafeMutableRawPointer(op)
        g_dbus_arg_info_ref(ptr.assumingMemoryBound(to: GDBusArgInfo.self))
    }

    /// Reference intialiser for a related type that implements `DBusArgInfoProtocol`
    /// Will retain `GDBusArgInfo`.
    /// - Parameter other: an instance of a related type that implements `DBusArgInfoProtocol`
    @inlinable public init<T: DBusArgInfoProtocol>(_ other: T) {
        ptr = other.ptr
        g_dbus_arg_info_ref(ptr.assumingMemoryBound(to: GDBusArgInfo.self))
    }

    /// Releases the underlying `GDBusArgInfo` instance using `g_dbus_arg_info_unref`.
    deinit {
        g_dbus_arg_info_unref(ptr.assumingMemoryBound(to: GDBusArgInfo.self))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusArgInfoProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusArgInfoProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        g_dbus_arg_info_ref(ptr.assumingMemoryBound(to: GDBusArgInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusArgInfoProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusArgInfoProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        g_dbus_arg_info_ref(ptr.assumingMemoryBound(to: GDBusArgInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusArgInfoProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusArgInfoProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        g_dbus_arg_info_ref(ptr.assumingMemoryBound(to: GDBusArgInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusArgInfoProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusArgInfoProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        g_dbus_arg_info_ref(ptr.assumingMemoryBound(to: GDBusArgInfo.self))
    }



}

// MARK: no DBusArgInfo properties

// MARK: no DBusArgInfo signals

// MARK: DBusArgInfo has no signals
// MARK: DBusArgInfo Record: DBusArgInfoProtocol extension (methods and fields)
public extension DBusArgInfoProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusArgInfo` instance.
    @inlinable var dbus_arg_info_ptr: UnsafeMutablePointer<GDBusArgInfo>! { return ptr?.assumingMemoryBound(to: GDBusArgInfo.self) }

    /// If `info` is statically allocated does nothing. Otherwise increases
    /// the reference count.
    @discardableResult @inlinable func ref() -> GIO.DBusArgInfoRef! {
        let result = g_dbus_arg_info_ref(dbus_arg_info_ptr)
        guard let rv = DBusArgInfoRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// If `info` is statically allocated, does nothing. Otherwise decreases
    /// the reference count of `info`. When its reference count drops to 0,
    /// the memory used is freed.
    @inlinable func unref() {
        
        g_dbus_arg_info_unref(dbus_arg_info_ptr)
        
    }

    /// The reference count or -1 if statically allocated.
    @inlinable var refCount: gint {
        /// The reference count or -1 if statically allocated.
        get {
            let rv = dbus_arg_info_ptr.pointee.ref_count
    return rv
        }
        /// The reference count or -1 if statically allocated.
         set {
            dbus_arg_info_ptr.pointee.ref_count = newValue
        }
    }

    /// Name of the argument, e.g. `unix_user_id`.
    @inlinable var name: UnsafeMutablePointer<gchar>! {
        /// Name of the argument, e.g. `unix_user_id`.
        get {
            let rv = dbus_arg_info_ptr.pointee.name
    return rv
        }
        /// Name of the argument, e.g. `unix_user_id`.
         set {
            dbus_arg_info_ptr.pointee.name = newValue
        }
    }

    /// D-Bus signature of the argument (a single complete type).
    @inlinable var signature: UnsafeMutablePointer<gchar>! {
        /// D-Bus signature of the argument (a single complete type).
        get {
            let rv = dbus_arg_info_ptr.pointee.signature
    return rv
        }
        /// D-Bus signature of the argument (a single complete type).
         set {
            dbus_arg_info_ptr.pointee.signature = newValue
        }
    }

    /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
    @inlinable var annotations: UnsafeMutablePointer<UnsafeMutablePointer<GDBusAnnotationInfo>?>! {
        /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
        get {
            let rv = dbus_arg_info_ptr.pointee.annotations
    return rv
        }
        /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
         set {
            dbus_arg_info_ptr.pointee.annotations = newValue
        }
    }

}



// MARK: - DBusErrorEntry Record

/// Struct used in `g_dbus_error_register_error_domain()`.
///
/// The `DBusErrorEntryProtocol` protocol exposes the methods and properties of an underlying `GDBusErrorEntry` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusErrorEntry`.
/// Alternatively, use `DBusErrorEntryRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusErrorEntryProtocol {
        /// Untyped pointer to the underlying `GDBusErrorEntry` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusErrorEntry` instance.
    var _ptr: UnsafeMutablePointer<GDBusErrorEntry>! { get }

    /// Required Initialiser for types conforming to `DBusErrorEntryProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Struct used in `g_dbus_error_register_error_domain()`.
///
/// The `DBusErrorEntryRef` type acts as a lightweight Swift reference to an underlying `GDBusErrorEntry` instance.
/// It exposes methods that can operate on this data type through `DBusErrorEntryProtocol` conformance.
/// Use `DBusErrorEntryRef` only as an `unowned` reference to an existing `GDBusErrorEntry` instance.
///
public struct DBusErrorEntryRef: DBusErrorEntryProtocol {
        /// Untyped pointer to the underlying `GDBusErrorEntry` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusErrorEntryRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusErrorEntry>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusErrorEntry>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusErrorEntry>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusErrorEntry>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusErrorEntryProtocol`
    @inlinable init<T: DBusErrorEntryProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusErrorEntryProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusErrorEntryProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusErrorEntryProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusErrorEntryProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusErrorEntryProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// Struct used in `g_dbus_error_register_error_domain()`.
///
/// The `DBusErrorEntry` type acts as an owner of an underlying `GDBusErrorEntry` instance.
/// It provides the methods that can operate on this data type through `DBusErrorEntryProtocol` conformance.
/// Use `DBusErrorEntry` as a strong reference or owner of a `GDBusErrorEntry` instance.
///
open class DBusErrorEntry: DBusErrorEntryProtocol {
        /// Untyped pointer to the underlying `GDBusErrorEntry` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusErrorEntry` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusErrorEntry>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusErrorEntry` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusErrorEntry>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusErrorEntry` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusErrorEntry` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusErrorEntry` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusErrorEntry>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusErrorEntry` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusErrorEntry>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GDBusErrorEntry` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `DBusErrorEntry` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusErrorEntry>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GDBusErrorEntry, cannot ref(_ptr)
    }

    /// Reference intialiser for a related type that implements `DBusErrorEntryProtocol`
    /// `GDBusErrorEntry` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `DBusErrorEntryProtocol`
    @inlinable public init<T: DBusErrorEntryProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GDBusErrorEntry, cannot ref(_ptr)
    }

    /// Do-nothing destructor for `GDBusErrorEntry`.
    deinit {
        // no reference counting for GDBusErrorEntry, cannot unref(_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusErrorEntryProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusErrorEntryProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GDBusErrorEntry, cannot ref(_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusErrorEntryProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusErrorEntryProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GDBusErrorEntry, cannot ref(_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusErrorEntryProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusErrorEntryProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GDBusErrorEntry, cannot ref(_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusErrorEntryProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusErrorEntryProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GDBusErrorEntry, cannot ref(_ptr)
    }



}

// MARK: no DBusErrorEntry properties

// MARK: no DBusErrorEntry signals

// MARK: DBusErrorEntry has no signals
// MARK: DBusErrorEntry Record: DBusErrorEntryProtocol extension (methods and fields)
public extension DBusErrorEntryProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusErrorEntry` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDBusErrorEntry>! { return ptr?.assumingMemoryBound(to: GDBusErrorEntry.self) }


    /// An error code.
    @inlinable var errorCode: gint {
        /// An error code.
        get {
            let rv = _ptr.pointee.error_code
    return rv
        }
        /// An error code.
         set {
            _ptr.pointee.error_code = newValue
        }
    }

    /// The D-Bus error name to associate with `error_code`.
    @inlinable var dbusErrorName: UnsafePointer<gchar>! {
        /// The D-Bus error name to associate with `error_code`.
        get {
            let rv = _ptr.pointee.dbus_error_name
    return rv
        }
        /// The D-Bus error name to associate with `error_code`.
         set {
            _ptr.pointee.dbus_error_name = newValue
        }
    }

}



/// Metatype/GType declaration for DBusInterface
public extension DBusInterfaceIfaceRef {
    
    /// This getter returns the GLib type identifier registered for `DBusInterface`
    static var metatypeReference: GType { g_dbus_interface_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GDBusInterfaceIface>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GDBusInterfaceIface.self) }
    
    static var metatype: GDBusInterfaceIface? { metatypePointer?.pointee } 
    
    static var wrapper: DBusInterfaceIfaceRef? { DBusInterfaceIfaceRef(metatypePointer) }
    
    
}

// MARK: - DBusInterfaceIface Record

/// Base type for D-Bus interfaces.
///
/// The `DBusInterfaceIfaceProtocol` protocol exposes the methods and properties of an underlying `GDBusInterfaceIface` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusInterfaceIface`.
/// Alternatively, use `DBusInterfaceIfaceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusInterfaceIfaceProtocol {
        /// Untyped pointer to the underlying `GDBusInterfaceIface` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusInterfaceIface` instance.
    var _ptr: UnsafeMutablePointer<GDBusInterfaceIface>! { get }

    /// Required Initialiser for types conforming to `DBusInterfaceIfaceProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Base type for D-Bus interfaces.
///
/// The `DBusInterfaceIfaceRef` type acts as a lightweight Swift reference to an underlying `GDBusInterfaceIface` instance.
/// It exposes methods that can operate on this data type through `DBusInterfaceIfaceProtocol` conformance.
/// Use `DBusInterfaceIfaceRef` only as an `unowned` reference to an existing `GDBusInterfaceIface` instance.
///
public struct DBusInterfaceIfaceRef: DBusInterfaceIfaceProtocol {
        /// Untyped pointer to the underlying `GDBusInterfaceIface` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusInterfaceIfaceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusInterfaceIface>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusInterfaceIface>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusInterfaceIface>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusInterfaceIface>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusInterfaceIfaceProtocol`
    @inlinable init<T: DBusInterfaceIfaceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceIfaceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceIfaceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceIfaceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceIfaceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceIfaceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: DBusInterfaceIface Record: DBusInterfaceIfaceProtocol extension (methods and fields)
public extension DBusInterfaceIfaceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusInterfaceIface` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDBusInterfaceIface>! { return ptr?.assumingMemoryBound(to: GDBusInterfaceIface.self) }


    /// The parent interface.
    @inlinable var parentIface: GTypeInterface {
        /// The parent interface.
        get {
            let rv = _ptr.pointee.parent_iface
    return rv
        }
    }

    // var getInfo is unavailable because get_info is void

    // var getObject is unavailable because get_object is void

    // var setObject is unavailable because set_object is void

    // var dupObject is unavailable because dup_object is void

}



// MARK: - DBusInterfaceInfo Record

/// Information about a D-Bus interface.
///
/// The `DBusInterfaceInfoProtocol` protocol exposes the methods and properties of an underlying `GDBusInterfaceInfo` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusInterfaceInfo`.
/// Alternatively, use `DBusInterfaceInfoRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusInterfaceInfoProtocol {
        /// Untyped pointer to the underlying `GDBusInterfaceInfo` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusInterfaceInfo` instance.
    var dbus_interface_info_ptr: UnsafeMutablePointer<GDBusInterfaceInfo>! { get }

    /// Required Initialiser for types conforming to `DBusInterfaceInfoProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Information about a D-Bus interface.
///
/// The `DBusInterfaceInfoRef` type acts as a lightweight Swift reference to an underlying `GDBusInterfaceInfo` instance.
/// It exposes methods that can operate on this data type through `DBusInterfaceInfoProtocol` conformance.
/// Use `DBusInterfaceInfoRef` only as an `unowned` reference to an existing `GDBusInterfaceInfo` instance.
///
public struct DBusInterfaceInfoRef: DBusInterfaceInfoProtocol {
        /// Untyped pointer to the underlying `GDBusInterfaceInfo` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_interface_info_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusInterfaceInfoRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusInterfaceInfo>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusInterfaceInfo>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusInterfaceInfo>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusInterfaceInfo>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusInterfaceInfoProtocol`
    @inlinable init<T: DBusInterfaceInfoProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceInfoProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceInfoProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceInfoProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceInfoProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceInfoProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// Information about a D-Bus interface.
///
/// The `DBusInterfaceInfo` type acts as a reference-counted owner of an underlying `GDBusInterfaceInfo` instance.
/// It provides the methods that can operate on this data type through `DBusInterfaceInfoProtocol` conformance.
/// Use `DBusInterfaceInfo` as a strong reference or owner of a `GDBusInterfaceInfo` instance.
///
open class DBusInterfaceInfo: DBusInterfaceInfoProtocol {
        /// Untyped pointer to the underlying `GDBusInterfaceInfo` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_interface_info_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterfaceInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusInterfaceInfo>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterfaceInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusInterfaceInfo>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterfaceInfo` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterfaceInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterfaceInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusInterfaceInfo>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterfaceInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusInterfaceInfo>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDBusInterfaceInfo`.
    /// i.e., ownership is transferred to the `DBusInterfaceInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusInterfaceInfo>) {
        ptr = UnsafeMutableRawPointer(op)
        g_dbus_interface_info_ref(ptr.assumingMemoryBound(to: GDBusInterfaceInfo.self))
    }

    /// Reference intialiser for a related type that implements `DBusInterfaceInfoProtocol`
    /// Will retain `GDBusInterfaceInfo`.
    /// - Parameter other: an instance of a related type that implements `DBusInterfaceInfoProtocol`
    @inlinable public init<T: DBusInterfaceInfoProtocol>(_ other: T) {
        ptr = other.ptr
        g_dbus_interface_info_ref(ptr.assumingMemoryBound(to: GDBusInterfaceInfo.self))
    }

    /// Releases the underlying `GDBusInterfaceInfo` instance using `g_dbus_interface_info_unref`.
    deinit {
        g_dbus_interface_info_unref(ptr.assumingMemoryBound(to: GDBusInterfaceInfo.self))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceInfoProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceInfoProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        g_dbus_interface_info_ref(ptr.assumingMemoryBound(to: GDBusInterfaceInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceInfoProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceInfoProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        g_dbus_interface_info_ref(ptr.assumingMemoryBound(to: GDBusInterfaceInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceInfoProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceInfoProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        g_dbus_interface_info_ref(ptr.assumingMemoryBound(to: GDBusInterfaceInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceInfoProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceInfoProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        g_dbus_interface_info_ref(ptr.assumingMemoryBound(to: GDBusInterfaceInfo.self))
    }



}

// MARK: no DBusInterfaceInfo properties

// MARK: no DBusInterfaceInfo signals

// MARK: DBusInterfaceInfo has no signals
// MARK: DBusInterfaceInfo Record: DBusInterfaceInfoProtocol extension (methods and fields)
public extension DBusInterfaceInfoProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusInterfaceInfo` instance.
    @inlinable var dbus_interface_info_ptr: UnsafeMutablePointer<GDBusInterfaceInfo>! { return ptr?.assumingMemoryBound(to: GDBusInterfaceInfo.self) }

    /// Builds a lookup-cache to speed up
    /// `g_dbus_interface_info_lookup_method()`,
    /// `g_dbus_interface_info_lookup_signal()` and
    /// `g_dbus_interface_info_lookup_property()`.
    /// 
    /// If this has already been called with `info`, the existing cache is
    /// used and its use count is increased.
    /// 
    /// Note that `info` cannot be modified until
    /// `g_dbus_interface_info_cache_release()` is called.
    @inlinable func cacheBuild() {
        
        g_dbus_interface_info_cache_build(dbus_interface_info_ptr)
        
    }

    /// Decrements the usage count for the cache for `info` built by
    /// `g_dbus_interface_info_cache_build()` (if any) and frees the
    /// resources used by the cache if the usage count drops to zero.
    @inlinable func cacheRelease() {
        
        g_dbus_interface_info_cache_release(dbus_interface_info_ptr)
        
    }

    /// Appends an XML representation of `info` (and its children) to `string_builder`.
    /// 
    /// This function is typically used for generating introspection XML
    /// documents at run-time for handling the
    /// `org.freedesktop.DBus.Introspectable.Introspect`
    /// method.
    @inlinable func generateXml<GLibStringTypeT: GLib.StringProtocol>(indent: Int, stringBuilder: GLibStringTypeT) {
        
        g_dbus_interface_info_generate_xml(dbus_interface_info_ptr, guint(indent), stringBuilder.gstring_ptr)
        
    }

    /// Looks up information about a method.
    /// 
    /// The cost of this function is `O(n)` in number of methods unless
    /// `g_dbus_interface_info_cache_build()` has been used on `info`.
    @inlinable func lookupMethod(name: UnsafePointer<gchar>!) -> GIO.DBusMethodInfoRef! {
        let result = g_dbus_interface_info_lookup_method(dbus_interface_info_ptr, name)
        let rv = DBusMethodInfoRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Looks up information about a property.
    /// 
    /// The cost of this function is `O(n)` in number of properties unless
    /// `g_dbus_interface_info_cache_build()` has been used on `info`.
    @inlinable func lookupProperty(name: UnsafePointer<gchar>!) -> GIO.DBusPropertyInfoRef! {
        let result = g_dbus_interface_info_lookup_property(dbus_interface_info_ptr, name)
        let rv = DBusPropertyInfoRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Looks up information about a signal.
    /// 
    /// The cost of this function is `O(n)` in number of signals unless
    /// `g_dbus_interface_info_cache_build()` has been used on `info`.
    @inlinable func lookupSignal(name: UnsafePointer<gchar>!) -> GIO.DBusSignalInfoRef! {
        let result = g_dbus_interface_info_lookup_signal(dbus_interface_info_ptr, name)
        let rv = DBusSignalInfoRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// If `info` is statically allocated does nothing. Otherwise increases
    /// the reference count.
    @discardableResult @inlinable func ref() -> GIO.DBusInterfaceInfoRef! {
        let result = g_dbus_interface_info_ref(dbus_interface_info_ptr)
        guard let rv = DBusInterfaceInfoRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// If `info` is statically allocated, does nothing. Otherwise decreases
    /// the reference count of `info`. When its reference count drops to 0,
    /// the memory used is freed.
    @inlinable func unref() {
        
        g_dbus_interface_info_unref(dbus_interface_info_ptr)
        
    }

    /// The reference count or -1 if statically allocated.
    @inlinable var refCount: gint {
        /// The reference count or -1 if statically allocated.
        get {
            let rv = dbus_interface_info_ptr.pointee.ref_count
    return rv
        }
        /// The reference count or -1 if statically allocated.
         set {
            dbus_interface_info_ptr.pointee.ref_count = newValue
        }
    }

    /// The name of the D-Bus interface, e.g. "org.freedesktop.DBus.Properties".
    @inlinable var name: UnsafeMutablePointer<gchar>! {
        /// The name of the D-Bus interface, e.g. "org.freedesktop.DBus.Properties".
        get {
            let rv = dbus_interface_info_ptr.pointee.name
    return rv
        }
        /// The name of the D-Bus interface, e.g. "org.freedesktop.DBus.Properties".
         set {
            dbus_interface_info_ptr.pointee.name = newValue
        }
    }

    /// A pointer to a `nil`-terminated array of pointers to `GDBusMethodInfo` structures or `nil` if there are no methods.
    @inlinable var methods: UnsafeMutablePointer<UnsafeMutablePointer<GDBusMethodInfo>?>! {
        /// A pointer to a `nil`-terminated array of pointers to `GDBusMethodInfo` structures or `nil` if there are no methods.
        get {
            let rv = dbus_interface_info_ptr.pointee.methods
    return rv
        }
        /// A pointer to a `nil`-terminated array of pointers to `GDBusMethodInfo` structures or `nil` if there are no methods.
         set {
            dbus_interface_info_ptr.pointee.methods = newValue
        }
    }

    /// A pointer to a `nil`-terminated array of pointers to `GDBusSignalInfo` structures or `nil` if there are no signals.
    @inlinable var signals: UnsafeMutablePointer<UnsafeMutablePointer<GDBusSignalInfo>?>! {
        /// A pointer to a `nil`-terminated array of pointers to `GDBusSignalInfo` structures or `nil` if there are no signals.
        get {
            let rv = dbus_interface_info_ptr.pointee.signals
    return rv
        }
        /// A pointer to a `nil`-terminated array of pointers to `GDBusSignalInfo` structures or `nil` if there are no signals.
         set {
            dbus_interface_info_ptr.pointee.signals = newValue
        }
    }

    /// A pointer to a `nil`-terminated array of pointers to `GDBusPropertyInfo` structures or `nil` if there are no properties.
    @inlinable var properties: UnsafeMutablePointer<UnsafeMutablePointer<GDBusPropertyInfo>?>! {
        /// A pointer to a `nil`-terminated array of pointers to `GDBusPropertyInfo` structures or `nil` if there are no properties.
        get {
            let rv = dbus_interface_info_ptr.pointee.properties
    return rv
        }
        /// A pointer to a `nil`-terminated array of pointers to `GDBusPropertyInfo` structures or `nil` if there are no properties.
         set {
            dbus_interface_info_ptr.pointee.properties = newValue
        }
    }

    /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
    @inlinable var annotations: UnsafeMutablePointer<UnsafeMutablePointer<GDBusAnnotationInfo>?>! {
        /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
        get {
            let rv = dbus_interface_info_ptr.pointee.annotations
    return rv
        }
        /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
         set {
            dbus_interface_info_ptr.pointee.annotations = newValue
        }
    }

}



/// Metatype/GType declaration for DBusInterfaceSkeleton
public extension DBusInterfaceSkeletonClassRef {
    
    /// This getter returns the GLib type identifier registered for `DBusInterfaceSkeleton`
    static var metatypeReference: GType { g_dbus_interface_skeleton_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GDBusInterfaceSkeletonClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GDBusInterfaceSkeletonClass.self) }
    
    static var metatype: GDBusInterfaceSkeletonClass? { metatypePointer?.pointee } 
    
    static var wrapper: DBusInterfaceSkeletonClassRef? { DBusInterfaceSkeletonClassRef(metatypePointer) }
    
    
}

// MARK: - DBusInterfaceSkeletonClass Record

/// Class structure for `GDBusInterfaceSkeleton`.
///
/// The `DBusInterfaceSkeletonClassProtocol` protocol exposes the methods and properties of an underlying `GDBusInterfaceSkeletonClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusInterfaceSkeletonClass`.
/// Alternatively, use `DBusInterfaceSkeletonClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusInterfaceSkeletonClassProtocol {
        /// Untyped pointer to the underlying `GDBusInterfaceSkeletonClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusInterfaceSkeletonClass` instance.
    var _ptr: UnsafeMutablePointer<GDBusInterfaceSkeletonClass>! { get }

    /// Required Initialiser for types conforming to `DBusInterfaceSkeletonClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Class structure for `GDBusInterfaceSkeleton`.
///
/// The `DBusInterfaceSkeletonClassRef` type acts as a lightweight Swift reference to an underlying `GDBusInterfaceSkeletonClass` instance.
/// It exposes methods that can operate on this data type through `DBusInterfaceSkeletonClassProtocol` conformance.
/// Use `DBusInterfaceSkeletonClassRef` only as an `unowned` reference to an existing `GDBusInterfaceSkeletonClass` instance.
///
public struct DBusInterfaceSkeletonClassRef: DBusInterfaceSkeletonClassProtocol {
        /// Untyped pointer to the underlying `GDBusInterfaceSkeletonClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusInterfaceSkeletonClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusInterfaceSkeletonClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusInterfaceSkeletonClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusInterfaceSkeletonClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusInterfaceSkeletonClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusInterfaceSkeletonClassProtocol`
    @inlinable init<T: DBusInterfaceSkeletonClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceSkeletonClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceSkeletonClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceSkeletonClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceSkeletonClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceSkeletonClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: DBusInterfaceSkeletonClass Record: DBusInterfaceSkeletonClassProtocol extension (methods and fields)
public extension DBusInterfaceSkeletonClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusInterfaceSkeletonClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDBusInterfaceSkeletonClass>! { return ptr?.assumingMemoryBound(to: GDBusInterfaceSkeletonClass.self) }


    /// The parent class.
    @inlinable var parentClass: GObjectClass {
        /// The parent class.
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var getInfo is unavailable because get_info is void

    // var getVtable is unavailable because get_vtable is void

    // var getProperties is unavailable because get_properties is void

    // var flush is unavailable because flush is void

    // var vfuncPadding is unavailable because vfunc_padding is private

    // var gAuthorizeMethod is unavailable because g_authorize_method is void

    // var signalPadding is unavailable because signal_padding is private

}



// MARK: - DBusInterfaceVTable Record

/// Virtual table for handling properties and method calls for a D-Bus
/// interface.
/// 
/// Since 2.38, if you want to handle getting/setting D-Bus properties
/// asynchronously, give `nil` as your `get_property()` or `set_property()`
/// function. The D-Bus call will be directed to your `method_call` function,
/// with the provided `interface_name` set to "org.freedesktop.DBus.Properties".
/// 
/// Ownership of the `GDBusMethodInvocation` object passed to the
/// `method_call()` function is transferred to your handler; you must
/// call one of the methods of `GDBusMethodInvocation` to return a reply
/// (possibly empty), or an error. These functions also take ownership
/// of the passed-in invocation object, so unless the invocation
/// object has otherwise been referenced, it will be then be freed.
/// Calling one of these functions may be done within your
/// `method_call()` implementation but it also can be done at a later
/// point to handle the method asynchronously.
/// 
/// The usual checks on the validity of the calls is performed. For
/// `Get` calls, an error is automatically returned if the property does
/// not exist or the permissions do not allow access. The same checks are
/// performed for `Set` calls, and the provided value is also checked for
/// being the correct type.
/// 
/// For both `Get` and `Set` calls, the `GDBusMethodInvocation`
/// passed to the `method_call` handler can be queried with
/// `g_dbus_method_invocation_get_property_info()` to get a pointer
/// to the `GDBusPropertyInfo` of the property.
/// 
/// If you have readable properties specified in your interface info,
/// you must ensure that you either provide a non-`nil` `get_property``()`
/// function or provide implementations of both the `Get` and `GetAll`
/// methods on org.freedesktop.DBus.Properties interface in your `method_call`
/// function. Note that the required return type of the `Get` call is
/// `(v)`, not the type of the property. `GetAll` expects a return value
/// of type `a{sv}`.
/// 
/// If you have writable properties specified in your interface info,
/// you must ensure that you either provide a non-`nil` `set_property``()`
/// function or provide an implementation of the `Set` call. If implementing
/// the call, you must return the value of type `G_VARIANT_TYPE_UNIT`.
///
/// The `DBusInterfaceVTableProtocol` protocol exposes the methods and properties of an underlying `GDBusInterfaceVTable` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusInterfaceVTable`.
/// Alternatively, use `DBusInterfaceVTableRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusInterfaceVTableProtocol {
        /// Untyped pointer to the underlying `GDBusInterfaceVTable` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusInterfaceVTable` instance.
    var _ptr: UnsafeMutablePointer<GDBusInterfaceVTable>! { get }

    /// Required Initialiser for types conforming to `DBusInterfaceVTableProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Virtual table for handling properties and method calls for a D-Bus
/// interface.
/// 
/// Since 2.38, if you want to handle getting/setting D-Bus properties
/// asynchronously, give `nil` as your `get_property()` or `set_property()`
/// function. The D-Bus call will be directed to your `method_call` function,
/// with the provided `interface_name` set to "org.freedesktop.DBus.Properties".
/// 
/// Ownership of the `GDBusMethodInvocation` object passed to the
/// `method_call()` function is transferred to your handler; you must
/// call one of the methods of `GDBusMethodInvocation` to return a reply
/// (possibly empty), or an error. These functions also take ownership
/// of the passed-in invocation object, so unless the invocation
/// object has otherwise been referenced, it will be then be freed.
/// Calling one of these functions may be done within your
/// `method_call()` implementation but it also can be done at a later
/// point to handle the method asynchronously.
/// 
/// The usual checks on the validity of the calls is performed. For
/// `Get` calls, an error is automatically returned if the property does
/// not exist or the permissions do not allow access. The same checks are
/// performed for `Set` calls, and the provided value is also checked for
/// being the correct type.
/// 
/// For both `Get` and `Set` calls, the `GDBusMethodInvocation`
/// passed to the `method_call` handler can be queried with
/// `g_dbus_method_invocation_get_property_info()` to get a pointer
/// to the `GDBusPropertyInfo` of the property.
/// 
/// If you have readable properties specified in your interface info,
/// you must ensure that you either provide a non-`nil` `get_property``()`
/// function or provide implementations of both the `Get` and `GetAll`
/// methods on org.freedesktop.DBus.Properties interface in your `method_call`
/// function. Note that the required return type of the `Get` call is
/// `(v)`, not the type of the property. `GetAll` expects a return value
/// of type `a{sv}`.
/// 
/// If you have writable properties specified in your interface info,
/// you must ensure that you either provide a non-`nil` `set_property``()`
/// function or provide an implementation of the `Set` call. If implementing
/// the call, you must return the value of type `G_VARIANT_TYPE_UNIT`.
///
/// The `DBusInterfaceVTableRef` type acts as a lightweight Swift reference to an underlying `GDBusInterfaceVTable` instance.
/// It exposes methods that can operate on this data type through `DBusInterfaceVTableProtocol` conformance.
/// Use `DBusInterfaceVTableRef` only as an `unowned` reference to an existing `GDBusInterfaceVTable` instance.
///
public struct DBusInterfaceVTableRef: DBusInterfaceVTableProtocol {
        /// Untyped pointer to the underlying `GDBusInterfaceVTable` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusInterfaceVTableRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusInterfaceVTable>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusInterfaceVTable>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusInterfaceVTable>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusInterfaceVTable>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusInterfaceVTableProtocol`
    @inlinable init<T: DBusInterfaceVTableProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceVTableProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceVTableProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceVTableProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceVTableProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceVTableProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// Virtual table for handling properties and method calls for a D-Bus
/// interface.
/// 
/// Since 2.38, if you want to handle getting/setting D-Bus properties
/// asynchronously, give `nil` as your `get_property()` or `set_property()`
/// function. The D-Bus call will be directed to your `method_call` function,
/// with the provided `interface_name` set to "org.freedesktop.DBus.Properties".
/// 
/// Ownership of the `GDBusMethodInvocation` object passed to the
/// `method_call()` function is transferred to your handler; you must
/// call one of the methods of `GDBusMethodInvocation` to return a reply
/// (possibly empty), or an error. These functions also take ownership
/// of the passed-in invocation object, so unless the invocation
/// object has otherwise been referenced, it will be then be freed.
/// Calling one of these functions may be done within your
/// `method_call()` implementation but it also can be done at a later
/// point to handle the method asynchronously.
/// 
/// The usual checks on the validity of the calls is performed. For
/// `Get` calls, an error is automatically returned if the property does
/// not exist or the permissions do not allow access. The same checks are
/// performed for `Set` calls, and the provided value is also checked for
/// being the correct type.
/// 
/// For both `Get` and `Set` calls, the `GDBusMethodInvocation`
/// passed to the `method_call` handler can be queried with
/// `g_dbus_method_invocation_get_property_info()` to get a pointer
/// to the `GDBusPropertyInfo` of the property.
/// 
/// If you have readable properties specified in your interface info,
/// you must ensure that you either provide a non-`nil` `get_property``()`
/// function or provide implementations of both the `Get` and `GetAll`
/// methods on org.freedesktop.DBus.Properties interface in your `method_call`
/// function. Note that the required return type of the `Get` call is
/// `(v)`, not the type of the property. `GetAll` expects a return value
/// of type `a{sv}`.
/// 
/// If you have writable properties specified in your interface info,
/// you must ensure that you either provide a non-`nil` `set_property``()`
/// function or provide an implementation of the `Set` call. If implementing
/// the call, you must return the value of type `G_VARIANT_TYPE_UNIT`.
///
/// The `DBusInterfaceVTable` type acts as an owner of an underlying `GDBusInterfaceVTable` instance.
/// It provides the methods that can operate on this data type through `DBusInterfaceVTableProtocol` conformance.
/// Use `DBusInterfaceVTable` as a strong reference or owner of a `GDBusInterfaceVTable` instance.
///
open class DBusInterfaceVTable: DBusInterfaceVTableProtocol {
        /// Untyped pointer to the underlying `GDBusInterfaceVTable` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterfaceVTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusInterfaceVTable>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterfaceVTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusInterfaceVTable>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterfaceVTable` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterfaceVTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterfaceVTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusInterfaceVTable>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterfaceVTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusInterfaceVTable>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GDBusInterfaceVTable` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `DBusInterfaceVTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusInterfaceVTable>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GDBusInterfaceVTable, cannot ref(_ptr)
    }

    /// Reference intialiser for a related type that implements `DBusInterfaceVTableProtocol`
    /// `GDBusInterfaceVTable` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `DBusInterfaceVTableProtocol`
    @inlinable public init<T: DBusInterfaceVTableProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GDBusInterfaceVTable, cannot ref(_ptr)
    }

    /// Do-nothing destructor for `GDBusInterfaceVTable`.
    deinit {
        // no reference counting for GDBusInterfaceVTable, cannot unref(_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceVTableProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceVTableProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GDBusInterfaceVTable, cannot ref(_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceVTableProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceVTableProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GDBusInterfaceVTable, cannot ref(_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceVTableProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceVTableProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GDBusInterfaceVTable, cannot ref(_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceVTableProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceVTableProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GDBusInterfaceVTable, cannot ref(_ptr)
    }



}

// MARK: no DBusInterfaceVTable properties

// MARK: no DBusInterfaceVTable signals

// MARK: DBusInterfaceVTable has no signals
// MARK: DBusInterfaceVTable Record: DBusInterfaceVTableProtocol extension (methods and fields)
public extension DBusInterfaceVTableProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusInterfaceVTable` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDBusInterfaceVTable>! { return ptr?.assumingMemoryBound(to: GDBusInterfaceVTable.self) }


    /// Function for handling incoming method calls.
    @inlinable var methodCall: GDBusInterfaceMethodCallFunc! {
        /// Function for handling incoming method calls.
        get {
            let rv = _ptr.pointee.method_call
    return rv
        }
        /// Function for handling incoming method calls.
         set {
            _ptr.pointee.method_call = newValue
        }
    }

    /// Function for getting a property.
    @inlinable var getProperty: GDBusInterfaceGetPropertyFunc! {
        /// Function for getting a property.
        get {
            let rv = _ptr.pointee.get_property
    return rv
        }
        /// Function for getting a property.
         set {
            _ptr.pointee.get_property = newValue
        }
    }

    /// Function for setting a property.
    @inlinable var setProperty: GDBusInterfaceSetPropertyFunc! {
        /// Function for setting a property.
        get {
            let rv = _ptr.pointee.set_property
    return rv
        }
        /// Function for setting a property.
         set {
            _ptr.pointee.set_property = newValue
        }
    }

    // var padding is unavailable because padding is private

}



// MARK: - DBusMethodInfo Record

/// Information about a method on an D-Bus interface.
///
/// The `DBusMethodInfoProtocol` protocol exposes the methods and properties of an underlying `GDBusMethodInfo` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusMethodInfo`.
/// Alternatively, use `DBusMethodInfoRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusMethodInfoProtocol {
        /// Untyped pointer to the underlying `GDBusMethodInfo` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusMethodInfo` instance.
    var dbus_method_info_ptr: UnsafeMutablePointer<GDBusMethodInfo>! { get }

    /// Required Initialiser for types conforming to `DBusMethodInfoProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Information about a method on an D-Bus interface.
///
/// The `DBusMethodInfoRef` type acts as a lightweight Swift reference to an underlying `GDBusMethodInfo` instance.
/// It exposes methods that can operate on this data type through `DBusMethodInfoProtocol` conformance.
/// Use `DBusMethodInfoRef` only as an `unowned` reference to an existing `GDBusMethodInfo` instance.
///
public struct DBusMethodInfoRef: DBusMethodInfoProtocol {
        /// Untyped pointer to the underlying `GDBusMethodInfo` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_method_info_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusMethodInfoRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusMethodInfo>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusMethodInfo>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusMethodInfo>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusMethodInfo>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusMethodInfoProtocol`
    @inlinable init<T: DBusMethodInfoProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInfoProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInfoProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInfoProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInfoProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInfoProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// Information about a method on an D-Bus interface.
///
/// The `DBusMethodInfo` type acts as a reference-counted owner of an underlying `GDBusMethodInfo` instance.
/// It provides the methods that can operate on this data type through `DBusMethodInfoProtocol` conformance.
/// Use `DBusMethodInfo` as a strong reference or owner of a `GDBusMethodInfo` instance.
///
open class DBusMethodInfo: DBusMethodInfoProtocol {
        /// Untyped pointer to the underlying `GDBusMethodInfo` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_method_info_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMethodInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusMethodInfo>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMethodInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusMethodInfo>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMethodInfo` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMethodInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMethodInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusMethodInfo>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMethodInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusMethodInfo>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDBusMethodInfo`.
    /// i.e., ownership is transferred to the `DBusMethodInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusMethodInfo>) {
        ptr = UnsafeMutableRawPointer(op)
        g_dbus_method_info_ref(ptr.assumingMemoryBound(to: GDBusMethodInfo.self))
    }

    /// Reference intialiser for a related type that implements `DBusMethodInfoProtocol`
    /// Will retain `GDBusMethodInfo`.
    /// - Parameter other: an instance of a related type that implements `DBusMethodInfoProtocol`
    @inlinable public init<T: DBusMethodInfoProtocol>(_ other: T) {
        ptr = other.ptr
        g_dbus_method_info_ref(ptr.assumingMemoryBound(to: GDBusMethodInfo.self))
    }

    /// Releases the underlying `GDBusMethodInfo` instance using `g_dbus_method_info_unref`.
    deinit {
        g_dbus_method_info_unref(ptr.assumingMemoryBound(to: GDBusMethodInfo.self))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInfoProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInfoProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        g_dbus_method_info_ref(ptr.assumingMemoryBound(to: GDBusMethodInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInfoProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInfoProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        g_dbus_method_info_ref(ptr.assumingMemoryBound(to: GDBusMethodInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInfoProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInfoProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        g_dbus_method_info_ref(ptr.assumingMemoryBound(to: GDBusMethodInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInfoProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInfoProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        g_dbus_method_info_ref(ptr.assumingMemoryBound(to: GDBusMethodInfo.self))
    }



}

// MARK: no DBusMethodInfo properties

// MARK: no DBusMethodInfo signals

// MARK: DBusMethodInfo has no signals
// MARK: DBusMethodInfo Record: DBusMethodInfoProtocol extension (methods and fields)
public extension DBusMethodInfoProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusMethodInfo` instance.
    @inlinable var dbus_method_info_ptr: UnsafeMutablePointer<GDBusMethodInfo>! { return ptr?.assumingMemoryBound(to: GDBusMethodInfo.self) }

    /// If `info` is statically allocated does nothing. Otherwise increases
    /// the reference count.
    @discardableResult @inlinable func ref() -> GIO.DBusMethodInfoRef! {
        let result = g_dbus_method_info_ref(dbus_method_info_ptr)
        guard let rv = DBusMethodInfoRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// If `info` is statically allocated, does nothing. Otherwise decreases
    /// the reference count of `info`. When its reference count drops to 0,
    /// the memory used is freed.
    @inlinable func unref() {
        
        g_dbus_method_info_unref(dbus_method_info_ptr)
        
    }

    /// The reference count or -1 if statically allocated.
    @inlinable var refCount: gint {
        /// The reference count or -1 if statically allocated.
        get {
            let rv = dbus_method_info_ptr.pointee.ref_count
    return rv
        }
        /// The reference count or -1 if statically allocated.
         set {
            dbus_method_info_ptr.pointee.ref_count = newValue
        }
    }

    /// The name of the D-Bus method, e.g. `RequestName`.
    @inlinable var name: UnsafeMutablePointer<gchar>! {
        /// The name of the D-Bus method, e.g. `RequestName`.
        get {
            let rv = dbus_method_info_ptr.pointee.name
    return rv
        }
        /// The name of the D-Bus method, e.g. `RequestName`.
         set {
            dbus_method_info_ptr.pointee.name = newValue
        }
    }

    /// A pointer to a `nil`-terminated array of pointers to `GDBusArgInfo` structures or `nil` if there are no in arguments.
    @inlinable var inArgs: UnsafeMutablePointer<UnsafeMutablePointer<GDBusArgInfo>?>! {
        /// A pointer to a `nil`-terminated array of pointers to `GDBusArgInfo` structures or `nil` if there are no in arguments.
        get {
            let rv = dbus_method_info_ptr.pointee.in_args
    return rv
        }
        /// A pointer to a `nil`-terminated array of pointers to `GDBusArgInfo` structures or `nil` if there are no in arguments.
         set {
            dbus_method_info_ptr.pointee.in_args = newValue
        }
    }

    /// A pointer to a `nil`-terminated array of pointers to `GDBusArgInfo` structures or `nil` if there are no out arguments.
    @inlinable var outArgs: UnsafeMutablePointer<UnsafeMutablePointer<GDBusArgInfo>?>! {
        /// A pointer to a `nil`-terminated array of pointers to `GDBusArgInfo` structures or `nil` if there are no out arguments.
        get {
            let rv = dbus_method_info_ptr.pointee.out_args
    return rv
        }
        /// A pointer to a `nil`-terminated array of pointers to `GDBusArgInfo` structures or `nil` if there are no out arguments.
         set {
            dbus_method_info_ptr.pointee.out_args = newValue
        }
    }

    /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
    @inlinable var annotations: UnsafeMutablePointer<UnsafeMutablePointer<GDBusAnnotationInfo>?>! {
        /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
        get {
            let rv = dbus_method_info_ptr.pointee.annotations
    return rv
        }
        /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
         set {
            dbus_method_info_ptr.pointee.annotations = newValue
        }
    }

}



// MARK: - DBusNodeInfo Record

/// Information about nodes in a remote object hierarchy.
///
/// The `DBusNodeInfoProtocol` protocol exposes the methods and properties of an underlying `GDBusNodeInfo` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusNodeInfo`.
/// Alternatively, use `DBusNodeInfoRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusNodeInfoProtocol {
        /// Untyped pointer to the underlying `GDBusNodeInfo` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusNodeInfo` instance.
    var dbus_node_info_ptr: UnsafeMutablePointer<GDBusNodeInfo>! { get }

    /// Required Initialiser for types conforming to `DBusNodeInfoProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Information about nodes in a remote object hierarchy.
///
/// The `DBusNodeInfoRef` type acts as a lightweight Swift reference to an underlying `GDBusNodeInfo` instance.
/// It exposes methods that can operate on this data type through `DBusNodeInfoProtocol` conformance.
/// Use `DBusNodeInfoRef` only as an `unowned` reference to an existing `GDBusNodeInfo` instance.
///
public struct DBusNodeInfoRef: DBusNodeInfoProtocol {
        /// Untyped pointer to the underlying `GDBusNodeInfo` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_node_info_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusNodeInfoRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusNodeInfo>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusNodeInfo>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusNodeInfo>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusNodeInfo>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusNodeInfoProtocol`
    @inlinable init<T: DBusNodeInfoProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusNodeInfoProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusNodeInfoProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusNodeInfoProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusNodeInfoProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusNodeInfoProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Parses `xml_data` and returns a `GDBusNodeInfo` representing the data.
    /// 
    /// The introspection XML must contain exactly one top-level
    /// &lt;node&gt; element.
    /// 
    /// Note that this routine is using a
    /// [GMarkup](#glib-Simple-XML-Subset-Parser.description)-based
    /// parser that only accepts a subset of valid XML documents.
    @inlinable init(xml xmlData: UnsafePointer<gchar>!) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_node_info_new_for_xml(xmlData, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
    /// Parses `xml_data` and returns a `GDBusNodeInfo` representing the data.
    /// 
    /// The introspection XML must contain exactly one top-level
    /// &lt;node&gt; element.
    /// 
    /// Note that this routine is using a
    /// [GMarkup](#glib-Simple-XML-Subset-Parser.description)-based
    /// parser that only accepts a subset of valid XML documents.
    @inlinable static func newFor(xml xmlData: UnsafePointer<gchar>!) throws -> GIO.DBusNodeInfoRef! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_node_info_new_for_xml(xmlData, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusNodeInfoRef(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
        return rv
    }
}

/// Information about nodes in a remote object hierarchy.
///
/// The `DBusNodeInfo` type acts as a reference-counted owner of an underlying `GDBusNodeInfo` instance.
/// It provides the methods that can operate on this data type through `DBusNodeInfoProtocol` conformance.
/// Use `DBusNodeInfo` as a strong reference or owner of a `GDBusNodeInfo` instance.
///
open class DBusNodeInfo: DBusNodeInfoProtocol {
        /// Untyped pointer to the underlying `GDBusNodeInfo` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_node_info_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusNodeInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusNodeInfo>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusNodeInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusNodeInfo>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusNodeInfo` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusNodeInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusNodeInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusNodeInfo>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusNodeInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusNodeInfo>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDBusNodeInfo`.
    /// i.e., ownership is transferred to the `DBusNodeInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusNodeInfo>) {
        ptr = UnsafeMutableRawPointer(op)
        g_dbus_node_info_ref(ptr.assumingMemoryBound(to: GDBusNodeInfo.self))
    }

    /// Reference intialiser for a related type that implements `DBusNodeInfoProtocol`
    /// Will retain `GDBusNodeInfo`.
    /// - Parameter other: an instance of a related type that implements `DBusNodeInfoProtocol`
    @inlinable public init<T: DBusNodeInfoProtocol>(_ other: T) {
        ptr = other.ptr
        g_dbus_node_info_ref(ptr.assumingMemoryBound(to: GDBusNodeInfo.self))
    }

    /// Releases the underlying `GDBusNodeInfo` instance using `g_dbus_node_info_unref`.
    deinit {
        g_dbus_node_info_unref(ptr.assumingMemoryBound(to: GDBusNodeInfo.self))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusNodeInfoProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusNodeInfoProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        g_dbus_node_info_ref(ptr.assumingMemoryBound(to: GDBusNodeInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusNodeInfoProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusNodeInfoProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        g_dbus_node_info_ref(ptr.assumingMemoryBound(to: GDBusNodeInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusNodeInfoProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusNodeInfoProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        g_dbus_node_info_ref(ptr.assumingMemoryBound(to: GDBusNodeInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusNodeInfoProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusNodeInfoProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        g_dbus_node_info_ref(ptr.assumingMemoryBound(to: GDBusNodeInfo.self))
    }

    /// Parses `xml_data` and returns a `GDBusNodeInfo` representing the data.
    /// 
    /// The introspection XML must contain exactly one top-level
    /// &lt;node&gt; element.
    /// 
    /// Note that this routine is using a
    /// [GMarkup](#glib-Simple-XML-Subset-Parser.description)-based
    /// parser that only accepts a subset of valid XML documents.
    @inlinable public init(xml xmlData: UnsafePointer<gchar>!) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_node_info_new_for_xml(xmlData, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Parses `xml_data` and returns a `GDBusNodeInfo` representing the data.
    /// 
    /// The introspection XML must contain exactly one top-level
    /// &lt;node&gt; element.
    /// 
    /// Note that this routine is using a
    /// [GMarkup](#glib-Simple-XML-Subset-Parser.description)-based
    /// parser that only accepts a subset of valid XML documents.
    @inlinable public static func newFor(xml xmlData: UnsafePointer<gchar>!) throws -> GIO.DBusNodeInfo! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_node_info_new_for_xml(xmlData, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusNodeInfo(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
        return rv
    }

}

// MARK: no DBusNodeInfo properties

// MARK: no DBusNodeInfo signals

// MARK: DBusNodeInfo has no signals
// MARK: DBusNodeInfo Record: DBusNodeInfoProtocol extension (methods and fields)
public extension DBusNodeInfoProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusNodeInfo` instance.
    @inlinable var dbus_node_info_ptr: UnsafeMutablePointer<GDBusNodeInfo>! { return ptr?.assumingMemoryBound(to: GDBusNodeInfo.self) }

    /// Appends an XML representation of `info` (and its children) to `string_builder`.
    /// 
    /// This function is typically used for generating introspection XML documents at run-time for
    /// handling the `org.freedesktop.DBus.Introspectable.Introspect`  method.
    @inlinable func generateXml<GLibStringTypeT: GLib.StringProtocol>(indent: Int, stringBuilder: GLibStringTypeT) {
        
        g_dbus_node_info_generate_xml(dbus_node_info_ptr, guint(indent), stringBuilder.gstring_ptr)
        
    }

    /// Looks up information about an interface.
    /// 
    /// The cost of this function is `O(n)` in number of interfaces.
    @inlinable func lookupInterface(name: UnsafePointer<gchar>!) -> GIO.DBusInterfaceInfoRef! {
        let result = g_dbus_node_info_lookup_interface(dbus_node_info_ptr, name)
        let rv = DBusInterfaceInfoRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// If `info` is statically allocated does nothing. Otherwise increases
    /// the reference count.
    @discardableResult @inlinable func ref() -> GIO.DBusNodeInfoRef! {
        let result = g_dbus_node_info_ref(dbus_node_info_ptr)
        guard let rv = DBusNodeInfoRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// If `info` is statically allocated, does nothing. Otherwise decreases
    /// the reference count of `info`. When its reference count drops to 0,
    /// the memory used is freed.
    @inlinable func unref() {
        
        g_dbus_node_info_unref(dbus_node_info_ptr)
        
    }

    /// The reference count or -1 if statically allocated.
    @inlinable var refCount: gint {
        /// The reference count or -1 if statically allocated.
        get {
            let rv = dbus_node_info_ptr.pointee.ref_count
    return rv
        }
        /// The reference count or -1 if statically allocated.
         set {
            dbus_node_info_ptr.pointee.ref_count = newValue
        }
    }

    /// The path of the node or `nil` if omitted. Note that this may be a relative path. See the D-Bus specification for more details.
    @inlinable var path: UnsafeMutablePointer<gchar>! {
        /// The path of the node or `nil` if omitted. Note that this may be a relative path. See the D-Bus specification for more details.
        get {
            let rv = dbus_node_info_ptr.pointee.path
    return rv
        }
        /// The path of the node or `nil` if omitted. Note that this may be a relative path. See the D-Bus specification for more details.
         set {
            dbus_node_info_ptr.pointee.path = newValue
        }
    }

    /// A pointer to a `nil`-terminated array of pointers to `GDBusInterfaceInfo` structures or `nil` if there are no interfaces.
    @inlinable var interfaces: UnsafeMutablePointer<UnsafeMutablePointer<GDBusInterfaceInfo>?>! {
        /// A pointer to a `nil`-terminated array of pointers to `GDBusInterfaceInfo` structures or `nil` if there are no interfaces.
        get {
            let rv = dbus_node_info_ptr.pointee.interfaces
    return rv
        }
        /// A pointer to a `nil`-terminated array of pointers to `GDBusInterfaceInfo` structures or `nil` if there are no interfaces.
         set {
            dbus_node_info_ptr.pointee.interfaces = newValue
        }
    }

    /// A pointer to a `nil`-terminated array of pointers to `GDBusNodeInfo` structures or `nil` if there are no nodes.
    @inlinable var nodes: UnsafeMutablePointer<UnsafeMutablePointer<GDBusNodeInfo>?>! {
        /// A pointer to a `nil`-terminated array of pointers to `GDBusNodeInfo` structures or `nil` if there are no nodes.
        get {
            let rv = dbus_node_info_ptr.pointee.nodes
    return rv
        }
        /// A pointer to a `nil`-terminated array of pointers to `GDBusNodeInfo` structures or `nil` if there are no nodes.
         set {
            dbus_node_info_ptr.pointee.nodes = newValue
        }
    }

    /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
    @inlinable var annotations: UnsafeMutablePointer<UnsafeMutablePointer<GDBusAnnotationInfo>?>! {
        /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
        get {
            let rv = dbus_node_info_ptr.pointee.annotations
    return rv
        }
        /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
         set {
            dbus_node_info_ptr.pointee.annotations = newValue
        }
    }

}



/// Metatype/GType declaration for DBusObject
public extension DBusObjectIfaceRef {
    
    /// This getter returns the GLib type identifier registered for `DBusObject`
    static var metatypeReference: GType { g_dbus_object_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GDBusObjectIface>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GDBusObjectIface.self) }
    
    static var metatype: GDBusObjectIface? { metatypePointer?.pointee } 
    
    static var wrapper: DBusObjectIfaceRef? { DBusObjectIfaceRef(metatypePointer) }
    
    
}

// MARK: - DBusObjectIface Record

/// Base object type for D-Bus objects.
///
/// The `DBusObjectIfaceProtocol` protocol exposes the methods and properties of an underlying `GDBusObjectIface` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusObjectIface`.
/// Alternatively, use `DBusObjectIfaceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusObjectIfaceProtocol {
        /// Untyped pointer to the underlying `GDBusObjectIface` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusObjectIface` instance.
    var _ptr: UnsafeMutablePointer<GDBusObjectIface>! { get }

    /// Required Initialiser for types conforming to `DBusObjectIfaceProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Base object type for D-Bus objects.
///
/// The `DBusObjectIfaceRef` type acts as a lightweight Swift reference to an underlying `GDBusObjectIface` instance.
/// It exposes methods that can operate on this data type through `DBusObjectIfaceProtocol` conformance.
/// Use `DBusObjectIfaceRef` only as an `unowned` reference to an existing `GDBusObjectIface` instance.
///
public struct DBusObjectIfaceRef: DBusObjectIfaceProtocol {
        /// Untyped pointer to the underlying `GDBusObjectIface` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusObjectIfaceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusObjectIface>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusObjectIface>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusObjectIface>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusObjectIface>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusObjectIfaceProtocol`
    @inlinable init<T: DBusObjectIfaceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectIfaceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectIfaceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectIfaceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectIfaceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectIfaceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: DBusObjectIface Record: DBusObjectIfaceProtocol extension (methods and fields)
public extension DBusObjectIfaceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusObjectIface` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDBusObjectIface>! { return ptr?.assumingMemoryBound(to: GDBusObjectIface.self) }


    /// The parent interface.
    @inlinable var parentIface: GTypeInterface {
        /// The parent interface.
        get {
            let rv = _ptr.pointee.parent_iface
    return rv
        }
    }

    // var getObjectPath is unavailable because get_object_path is void

    // var getInterfaces is unavailable because get_interfaces is void

    // var getInterface is unavailable because get_interface is void

    // var interfaceAdded is unavailable because interface_added is void

    // var interfaceRemoved is unavailable because interface_removed is void

}



/// Metatype/GType declaration for DBusObjectManagerClient
public extension DBusObjectManagerClientClassRef {
    
    /// This getter returns the GLib type identifier registered for `DBusObjectManagerClient`
    static var metatypeReference: GType { g_dbus_object_manager_client_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GDBusObjectManagerClientClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GDBusObjectManagerClientClass.self) }
    
    static var metatype: GDBusObjectManagerClientClass? { metatypePointer?.pointee } 
    
    static var wrapper: DBusObjectManagerClientClassRef? { DBusObjectManagerClientClassRef(metatypePointer) }
    
    
}

// MARK: - DBusObjectManagerClientClass Record

/// Class structure for `GDBusObjectManagerClient`.
///
/// The `DBusObjectManagerClientClassProtocol` protocol exposes the methods and properties of an underlying `GDBusObjectManagerClientClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusObjectManagerClientClass`.
/// Alternatively, use `DBusObjectManagerClientClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusObjectManagerClientClassProtocol {
        /// Untyped pointer to the underlying `GDBusObjectManagerClientClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusObjectManagerClientClass` instance.
    var _ptr: UnsafeMutablePointer<GDBusObjectManagerClientClass>! { get }

    /// Required Initialiser for types conforming to `DBusObjectManagerClientClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Class structure for `GDBusObjectManagerClient`.
///
/// The `DBusObjectManagerClientClassRef` type acts as a lightweight Swift reference to an underlying `GDBusObjectManagerClientClass` instance.
/// It exposes methods that can operate on this data type through `DBusObjectManagerClientClassProtocol` conformance.
/// Use `DBusObjectManagerClientClassRef` only as an `unowned` reference to an existing `GDBusObjectManagerClientClass` instance.
///
public struct DBusObjectManagerClientClassRef: DBusObjectManagerClientClassProtocol {
        /// Untyped pointer to the underlying `GDBusObjectManagerClientClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusObjectManagerClientClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusObjectManagerClientClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusObjectManagerClientClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusObjectManagerClientClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusObjectManagerClientClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusObjectManagerClientClassProtocol`
    @inlinable init<T: DBusObjectManagerClientClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerClientClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerClientClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerClientClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerClientClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerClientClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: DBusObjectManagerClientClass Record: DBusObjectManagerClientClassProtocol extension (methods and fields)
public extension DBusObjectManagerClientClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusObjectManagerClientClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDBusObjectManagerClientClass>! { return ptr?.assumingMemoryBound(to: GDBusObjectManagerClientClass.self) }


    /// The parent class.
    @inlinable var parentClass: GObjectClass {
        /// The parent class.
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var interfaceProxySignal is unavailable because interface_proxy_signal is void

    // var interfaceProxyPropertiesChanged is unavailable because interface_proxy_properties_changed is void

    // var padding is unavailable because padding is private

}



/// Metatype/GType declaration for DBusObjectManager
public extension DBusObjectManagerIfaceRef {
    
    /// This getter returns the GLib type identifier registered for `DBusObjectManager`
    static var metatypeReference: GType { g_dbus_object_manager_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GDBusObjectManagerIface>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GDBusObjectManagerIface.self) }
    
    static var metatype: GDBusObjectManagerIface? { metatypePointer?.pointee } 
    
    static var wrapper: DBusObjectManagerIfaceRef? { DBusObjectManagerIfaceRef(metatypePointer) }
    
    
}

// MARK: - DBusObjectManagerIface Record

/// Base type for D-Bus object managers.
///
/// The `DBusObjectManagerIfaceProtocol` protocol exposes the methods and properties of an underlying `GDBusObjectManagerIface` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusObjectManagerIface`.
/// Alternatively, use `DBusObjectManagerIfaceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusObjectManagerIfaceProtocol {
        /// Untyped pointer to the underlying `GDBusObjectManagerIface` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusObjectManagerIface` instance.
    var _ptr: UnsafeMutablePointer<GDBusObjectManagerIface>! { get }

    /// Required Initialiser for types conforming to `DBusObjectManagerIfaceProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Base type for D-Bus object managers.
///
/// The `DBusObjectManagerIfaceRef` type acts as a lightweight Swift reference to an underlying `GDBusObjectManagerIface` instance.
/// It exposes methods that can operate on this data type through `DBusObjectManagerIfaceProtocol` conformance.
/// Use `DBusObjectManagerIfaceRef` only as an `unowned` reference to an existing `GDBusObjectManagerIface` instance.
///
public struct DBusObjectManagerIfaceRef: DBusObjectManagerIfaceProtocol {
        /// Untyped pointer to the underlying `GDBusObjectManagerIface` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusObjectManagerIfaceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusObjectManagerIface>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusObjectManagerIface>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusObjectManagerIface>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusObjectManagerIface>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusObjectManagerIfaceProtocol`
    @inlinable init<T: DBusObjectManagerIfaceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerIfaceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerIfaceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerIfaceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerIfaceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerIfaceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: DBusObjectManagerIface Record: DBusObjectManagerIfaceProtocol extension (methods and fields)
public extension DBusObjectManagerIfaceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusObjectManagerIface` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDBusObjectManagerIface>! { return ptr?.assumingMemoryBound(to: GDBusObjectManagerIface.self) }


    /// The parent interface.
    @inlinable var parentIface: GTypeInterface {
        /// The parent interface.
        get {
            let rv = _ptr.pointee.parent_iface
    return rv
        }
    }

    // var getObjectPath is unavailable because get_object_path is void

    // var getObjects is unavailable because get_objects is void

    // var getObject is unavailable because get_object is void

    // var getInterface is unavailable because get_interface is void

    // var objectAdded is unavailable because object_added is void

    // var objectRemoved is unavailable because object_removed is void

    // var interfaceAdded is unavailable because interface_added is void

    // var interfaceRemoved is unavailable because interface_removed is void

}



/// Metatype/GType declaration for DBusObjectManagerServer
public extension DBusObjectManagerServerClassRef {
    
    /// This getter returns the GLib type identifier registered for `DBusObjectManagerServer`
    static var metatypeReference: GType { g_dbus_object_manager_server_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GDBusObjectManagerServerClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GDBusObjectManagerServerClass.self) }
    
    static var metatype: GDBusObjectManagerServerClass? { metatypePointer?.pointee } 
    
    static var wrapper: DBusObjectManagerServerClassRef? { DBusObjectManagerServerClassRef(metatypePointer) }
    
    
}

// MARK: - DBusObjectManagerServerClass Record

/// Class structure for `GDBusObjectManagerServer`.
///
/// The `DBusObjectManagerServerClassProtocol` protocol exposes the methods and properties of an underlying `GDBusObjectManagerServerClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusObjectManagerServerClass`.
/// Alternatively, use `DBusObjectManagerServerClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusObjectManagerServerClassProtocol {
        /// Untyped pointer to the underlying `GDBusObjectManagerServerClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusObjectManagerServerClass` instance.
    var _ptr: UnsafeMutablePointer<GDBusObjectManagerServerClass>! { get }

    /// Required Initialiser for types conforming to `DBusObjectManagerServerClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Class structure for `GDBusObjectManagerServer`.
///
/// The `DBusObjectManagerServerClassRef` type acts as a lightweight Swift reference to an underlying `GDBusObjectManagerServerClass` instance.
/// It exposes methods that can operate on this data type through `DBusObjectManagerServerClassProtocol` conformance.
/// Use `DBusObjectManagerServerClassRef` only as an `unowned` reference to an existing `GDBusObjectManagerServerClass` instance.
///
public struct DBusObjectManagerServerClassRef: DBusObjectManagerServerClassProtocol {
        /// Untyped pointer to the underlying `GDBusObjectManagerServerClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusObjectManagerServerClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusObjectManagerServerClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusObjectManagerServerClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusObjectManagerServerClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusObjectManagerServerClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusObjectManagerServerClassProtocol`
    @inlinable init<T: DBusObjectManagerServerClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerServerClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerServerClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerServerClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerServerClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerServerClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: DBusObjectManagerServerClass Record: DBusObjectManagerServerClassProtocol extension (methods and fields)
public extension DBusObjectManagerServerClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusObjectManagerServerClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDBusObjectManagerServerClass>! { return ptr?.assumingMemoryBound(to: GDBusObjectManagerServerClass.self) }


    /// The parent class.
    @inlinable var parentClass: GObjectClass {
        /// The parent class.
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var padding is unavailable because padding is private

}



/// Metatype/GType declaration for DBusObjectProxy
public extension DBusObjectProxyClassRef {
    
    /// This getter returns the GLib type identifier registered for `DBusObjectProxy`
    static var metatypeReference: GType { g_dbus_object_proxy_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GDBusObjectProxyClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GDBusObjectProxyClass.self) }
    
    static var metatype: GDBusObjectProxyClass? { metatypePointer?.pointee } 
    
    static var wrapper: DBusObjectProxyClassRef? { DBusObjectProxyClassRef(metatypePointer) }
    
    
}

// MARK: - DBusObjectProxyClass Record

/// Class structure for `GDBusObjectProxy`.
///
/// The `DBusObjectProxyClassProtocol` protocol exposes the methods and properties of an underlying `GDBusObjectProxyClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusObjectProxyClass`.
/// Alternatively, use `DBusObjectProxyClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusObjectProxyClassProtocol {
        /// Untyped pointer to the underlying `GDBusObjectProxyClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusObjectProxyClass` instance.
    var _ptr: UnsafeMutablePointer<GDBusObjectProxyClass>! { get }

    /// Required Initialiser for types conforming to `DBusObjectProxyClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Class structure for `GDBusObjectProxy`.
///
/// The `DBusObjectProxyClassRef` type acts as a lightweight Swift reference to an underlying `GDBusObjectProxyClass` instance.
/// It exposes methods that can operate on this data type through `DBusObjectProxyClassProtocol` conformance.
/// Use `DBusObjectProxyClassRef` only as an `unowned` reference to an existing `GDBusObjectProxyClass` instance.
///
public struct DBusObjectProxyClassRef: DBusObjectProxyClassProtocol {
        /// Untyped pointer to the underlying `GDBusObjectProxyClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusObjectProxyClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusObjectProxyClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusObjectProxyClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusObjectProxyClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusObjectProxyClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusObjectProxyClassProtocol`
    @inlinable init<T: DBusObjectProxyClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProxyClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProxyClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProxyClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProxyClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProxyClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: DBusObjectProxyClass Record: DBusObjectProxyClassProtocol extension (methods and fields)
public extension DBusObjectProxyClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusObjectProxyClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDBusObjectProxyClass>! { return ptr?.assumingMemoryBound(to: GDBusObjectProxyClass.self) }


    /// The parent class.
    @inlinable var parentClass: GObjectClass {
        /// The parent class.
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var padding is unavailable because padding is private

}



/// Metatype/GType declaration for DBusObjectSkeleton
public extension DBusObjectSkeletonClassRef {
    
    /// This getter returns the GLib type identifier registered for `DBusObjectSkeleton`
    static var metatypeReference: GType { g_dbus_object_skeleton_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GDBusObjectSkeletonClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GDBusObjectSkeletonClass.self) }
    
    static var metatype: GDBusObjectSkeletonClass? { metatypePointer?.pointee } 
    
    static var wrapper: DBusObjectSkeletonClassRef? { DBusObjectSkeletonClassRef(metatypePointer) }
    
    
}

// MARK: - DBusObjectSkeletonClass Record

/// Class structure for `GDBusObjectSkeleton`.
///
/// The `DBusObjectSkeletonClassProtocol` protocol exposes the methods and properties of an underlying `GDBusObjectSkeletonClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusObjectSkeletonClass`.
/// Alternatively, use `DBusObjectSkeletonClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusObjectSkeletonClassProtocol {
        /// Untyped pointer to the underlying `GDBusObjectSkeletonClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusObjectSkeletonClass` instance.
    var _ptr: UnsafeMutablePointer<GDBusObjectSkeletonClass>! { get }

    /// Required Initialiser for types conforming to `DBusObjectSkeletonClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Class structure for `GDBusObjectSkeleton`.
///
/// The `DBusObjectSkeletonClassRef` type acts as a lightweight Swift reference to an underlying `GDBusObjectSkeletonClass` instance.
/// It exposes methods that can operate on this data type through `DBusObjectSkeletonClassProtocol` conformance.
/// Use `DBusObjectSkeletonClassRef` only as an `unowned` reference to an existing `GDBusObjectSkeletonClass` instance.
///
public struct DBusObjectSkeletonClassRef: DBusObjectSkeletonClassProtocol {
        /// Untyped pointer to the underlying `GDBusObjectSkeletonClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusObjectSkeletonClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusObjectSkeletonClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusObjectSkeletonClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusObjectSkeletonClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusObjectSkeletonClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusObjectSkeletonClassProtocol`
    @inlinable init<T: DBusObjectSkeletonClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectSkeletonClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectSkeletonClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectSkeletonClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectSkeletonClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectSkeletonClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: DBusObjectSkeletonClass Record: DBusObjectSkeletonClassProtocol extension (methods and fields)
public extension DBusObjectSkeletonClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusObjectSkeletonClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDBusObjectSkeletonClass>! { return ptr?.assumingMemoryBound(to: GDBusObjectSkeletonClass.self) }


    /// The parent class.
    @inlinable var parentClass: GObjectClass {
        /// The parent class.
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var authorizeMethod is unavailable because authorize_method is void

    // var padding is unavailable because padding is private

}



// MARK: - DBusPropertyInfo Record

/// Information about a D-Bus property on a D-Bus interface.
///
/// The `DBusPropertyInfoProtocol` protocol exposes the methods and properties of an underlying `GDBusPropertyInfo` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusPropertyInfo`.
/// Alternatively, use `DBusPropertyInfoRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusPropertyInfoProtocol {
        /// Untyped pointer to the underlying `GDBusPropertyInfo` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusPropertyInfo` instance.
    var dbus_property_info_ptr: UnsafeMutablePointer<GDBusPropertyInfo>! { get }

    /// Required Initialiser for types conforming to `DBusPropertyInfoProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Information about a D-Bus property on a D-Bus interface.
///
/// The `DBusPropertyInfoRef` type acts as a lightweight Swift reference to an underlying `GDBusPropertyInfo` instance.
/// It exposes methods that can operate on this data type through `DBusPropertyInfoProtocol` conformance.
/// Use `DBusPropertyInfoRef` only as an `unowned` reference to an existing `GDBusPropertyInfo` instance.
///
public struct DBusPropertyInfoRef: DBusPropertyInfoProtocol {
        /// Untyped pointer to the underlying `GDBusPropertyInfo` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_property_info_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusPropertyInfoRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusPropertyInfo>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusPropertyInfo>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusPropertyInfo>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusPropertyInfo>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusPropertyInfoProtocol`
    @inlinable init<T: DBusPropertyInfoProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusPropertyInfoProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusPropertyInfoProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusPropertyInfoProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusPropertyInfoProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusPropertyInfoProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// Information about a D-Bus property on a D-Bus interface.
///
/// The `DBusPropertyInfo` type acts as a reference-counted owner of an underlying `GDBusPropertyInfo` instance.
/// It provides the methods that can operate on this data type through `DBusPropertyInfoProtocol` conformance.
/// Use `DBusPropertyInfo` as a strong reference or owner of a `GDBusPropertyInfo` instance.
///
open class DBusPropertyInfo: DBusPropertyInfoProtocol {
        /// Untyped pointer to the underlying `GDBusPropertyInfo` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_property_info_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusPropertyInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusPropertyInfo>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusPropertyInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusPropertyInfo>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusPropertyInfo` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusPropertyInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusPropertyInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusPropertyInfo>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusPropertyInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusPropertyInfo>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDBusPropertyInfo`.
    /// i.e., ownership is transferred to the `DBusPropertyInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusPropertyInfo>) {
        ptr = UnsafeMutableRawPointer(op)
        g_dbus_property_info_ref(ptr.assumingMemoryBound(to: GDBusPropertyInfo.self))
    }

    /// Reference intialiser for a related type that implements `DBusPropertyInfoProtocol`
    /// Will retain `GDBusPropertyInfo`.
    /// - Parameter other: an instance of a related type that implements `DBusPropertyInfoProtocol`
    @inlinable public init<T: DBusPropertyInfoProtocol>(_ other: T) {
        ptr = other.ptr
        g_dbus_property_info_ref(ptr.assumingMemoryBound(to: GDBusPropertyInfo.self))
    }

    /// Releases the underlying `GDBusPropertyInfo` instance using `g_dbus_property_info_unref`.
    deinit {
        g_dbus_property_info_unref(ptr.assumingMemoryBound(to: GDBusPropertyInfo.self))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusPropertyInfoProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusPropertyInfoProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        g_dbus_property_info_ref(ptr.assumingMemoryBound(to: GDBusPropertyInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusPropertyInfoProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusPropertyInfoProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        g_dbus_property_info_ref(ptr.assumingMemoryBound(to: GDBusPropertyInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusPropertyInfoProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusPropertyInfoProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        g_dbus_property_info_ref(ptr.assumingMemoryBound(to: GDBusPropertyInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusPropertyInfoProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusPropertyInfoProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        g_dbus_property_info_ref(ptr.assumingMemoryBound(to: GDBusPropertyInfo.self))
    }



}

// MARK: no DBusPropertyInfo properties

// MARK: no DBusPropertyInfo signals

// MARK: DBusPropertyInfo has no signals
// MARK: DBusPropertyInfo Record: DBusPropertyInfoProtocol extension (methods and fields)
public extension DBusPropertyInfoProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusPropertyInfo` instance.
    @inlinable var dbus_property_info_ptr: UnsafeMutablePointer<GDBusPropertyInfo>! { return ptr?.assumingMemoryBound(to: GDBusPropertyInfo.self) }

    /// If `info` is statically allocated does nothing. Otherwise increases
    /// the reference count.
    @discardableResult @inlinable func ref() -> GIO.DBusPropertyInfoRef! {
        let result = g_dbus_property_info_ref(dbus_property_info_ptr)
        guard let rv = DBusPropertyInfoRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// If `info` is statically allocated, does nothing. Otherwise decreases
    /// the reference count of `info`. When its reference count drops to 0,
    /// the memory used is freed.
    @inlinable func unref() {
        
        g_dbus_property_info_unref(dbus_property_info_ptr)
        
    }

    /// The reference count or -1 if statically allocated.
    @inlinable var refCount: gint {
        /// The reference count or -1 if statically allocated.
        get {
            let rv = dbus_property_info_ptr.pointee.ref_count
    return rv
        }
        /// The reference count or -1 if statically allocated.
         set {
            dbus_property_info_ptr.pointee.ref_count = newValue
        }
    }

    /// The name of the D-Bus property, e.g. "SupportedFilesystems".
    @inlinable var name: UnsafeMutablePointer<gchar>! {
        /// The name of the D-Bus property, e.g. "SupportedFilesystems".
        get {
            let rv = dbus_property_info_ptr.pointee.name
    return rv
        }
        /// The name of the D-Bus property, e.g. "SupportedFilesystems".
         set {
            dbus_property_info_ptr.pointee.name = newValue
        }
    }

    /// The D-Bus signature of the property (a single complete type).
    @inlinable var signature: UnsafeMutablePointer<gchar>! {
        /// The D-Bus signature of the property (a single complete type).
        get {
            let rv = dbus_property_info_ptr.pointee.signature
    return rv
        }
        /// The D-Bus signature of the property (a single complete type).
         set {
            dbus_property_info_ptr.pointee.signature = newValue
        }
    }

    /// Access control flags for the property.
    @inlinable var flags: GIO.DBusPropertyInfoFlags {
        /// Access control flags for the property.
        get {
            let rv = DBusPropertyInfoFlags(dbus_property_info_ptr.pointee.flags)
    return rv
        }
        /// Access control flags for the property.
         set {
            dbus_property_info_ptr.pointee.flags = newValue.value
        }
    }

    /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
    @inlinable var annotations: UnsafeMutablePointer<UnsafeMutablePointer<GDBusAnnotationInfo>?>! {
        /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
        get {
            let rv = dbus_property_info_ptr.pointee.annotations
    return rv
        }
        /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
         set {
            dbus_property_info_ptr.pointee.annotations = newValue
        }
    }

}



/// Metatype/GType declaration for DBusProxy
public extension DBusProxyClassRef {
    
    /// This getter returns the GLib type identifier registered for `DBusProxy`
    static var metatypeReference: GType { g_dbus_proxy_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GDBusProxyClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GDBusProxyClass.self) }
    
    static var metatype: GDBusProxyClass? { metatypePointer?.pointee } 
    
    static var wrapper: DBusProxyClassRef? { DBusProxyClassRef(metatypePointer) }
    
    
}

// MARK: - DBusProxyClass Record

/// Class structure for `GDBusProxy`.
///
/// The `DBusProxyClassProtocol` protocol exposes the methods and properties of an underlying `GDBusProxyClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusProxyClass`.
/// Alternatively, use `DBusProxyClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusProxyClassProtocol {
        /// Untyped pointer to the underlying `GDBusProxyClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusProxyClass` instance.
    var _ptr: UnsafeMutablePointer<GDBusProxyClass>! { get }

    /// Required Initialiser for types conforming to `DBusProxyClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Class structure for `GDBusProxy`.
///
/// The `DBusProxyClassRef` type acts as a lightweight Swift reference to an underlying `GDBusProxyClass` instance.
/// It exposes methods that can operate on this data type through `DBusProxyClassProtocol` conformance.
/// Use `DBusProxyClassRef` only as an `unowned` reference to an existing `GDBusProxyClass` instance.
///
public struct DBusProxyClassRef: DBusProxyClassProtocol {
        /// Untyped pointer to the underlying `GDBusProxyClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusProxyClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusProxyClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusProxyClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusProxyClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusProxyClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusProxyClassProtocol`
    @inlinable init<T: DBusProxyClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusProxyClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusProxyClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusProxyClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusProxyClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusProxyClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: DBusProxyClass Record: DBusProxyClassProtocol extension (methods and fields)
public extension DBusProxyClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusProxyClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDBusProxyClass>! { return ptr?.assumingMemoryBound(to: GDBusProxyClass.self) }


    // var parentClass is unavailable because parent_class is private

    // var gPropertiesChanged is unavailable because g_properties_changed is void

    // var gSignal is unavailable because g_signal is void

    // var padding is unavailable because padding is private

}



// MARK: - DBusSignalInfo Record

/// Information about a signal on a D-Bus interface.
///
/// The `DBusSignalInfoProtocol` protocol exposes the methods and properties of an underlying `GDBusSignalInfo` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusSignalInfo`.
/// Alternatively, use `DBusSignalInfoRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusSignalInfoProtocol {
        /// Untyped pointer to the underlying `GDBusSignalInfo` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusSignalInfo` instance.
    var dbus_signal_info_ptr: UnsafeMutablePointer<GDBusSignalInfo>! { get }

    /// Required Initialiser for types conforming to `DBusSignalInfoProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Information about a signal on a D-Bus interface.
///
/// The `DBusSignalInfoRef` type acts as a lightweight Swift reference to an underlying `GDBusSignalInfo` instance.
/// It exposes methods that can operate on this data type through `DBusSignalInfoProtocol` conformance.
/// Use `DBusSignalInfoRef` only as an `unowned` reference to an existing `GDBusSignalInfo` instance.
///
public struct DBusSignalInfoRef: DBusSignalInfoProtocol {
        /// Untyped pointer to the underlying `GDBusSignalInfo` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_signal_info_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusSignalInfoRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusSignalInfo>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusSignalInfo>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusSignalInfo>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusSignalInfo>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusSignalInfoProtocol`
    @inlinable init<T: DBusSignalInfoProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSignalInfoProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSignalInfoProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSignalInfoProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSignalInfoProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSignalInfoProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// Information about a signal on a D-Bus interface.
///
/// The `DBusSignalInfo` type acts as a reference-counted owner of an underlying `GDBusSignalInfo` instance.
/// It provides the methods that can operate on this data type through `DBusSignalInfoProtocol` conformance.
/// Use `DBusSignalInfo` as a strong reference or owner of a `GDBusSignalInfo` instance.
///
open class DBusSignalInfo: DBusSignalInfoProtocol {
        /// Untyped pointer to the underlying `GDBusSignalInfo` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_signal_info_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusSignalInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusSignalInfo>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusSignalInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusSignalInfo>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusSignalInfo` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusSignalInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusSignalInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusSignalInfo>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusSignalInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusSignalInfo>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDBusSignalInfo`.
    /// i.e., ownership is transferred to the `DBusSignalInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusSignalInfo>) {
        ptr = UnsafeMutableRawPointer(op)
        g_dbus_signal_info_ref(ptr.assumingMemoryBound(to: GDBusSignalInfo.self))
    }

    /// Reference intialiser for a related type that implements `DBusSignalInfoProtocol`
    /// Will retain `GDBusSignalInfo`.
    /// - Parameter other: an instance of a related type that implements `DBusSignalInfoProtocol`
    @inlinable public init<T: DBusSignalInfoProtocol>(_ other: T) {
        ptr = other.ptr
        g_dbus_signal_info_ref(ptr.assumingMemoryBound(to: GDBusSignalInfo.self))
    }

    /// Releases the underlying `GDBusSignalInfo` instance using `g_dbus_signal_info_unref`.
    deinit {
        g_dbus_signal_info_unref(ptr.assumingMemoryBound(to: GDBusSignalInfo.self))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSignalInfoProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSignalInfoProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        g_dbus_signal_info_ref(ptr.assumingMemoryBound(to: GDBusSignalInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSignalInfoProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSignalInfoProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        g_dbus_signal_info_ref(ptr.assumingMemoryBound(to: GDBusSignalInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSignalInfoProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSignalInfoProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        g_dbus_signal_info_ref(ptr.assumingMemoryBound(to: GDBusSignalInfo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSignalInfoProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSignalInfoProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        g_dbus_signal_info_ref(ptr.assumingMemoryBound(to: GDBusSignalInfo.self))
    }



}

// MARK: no DBusSignalInfo properties

// MARK: no DBusSignalInfo signals

// MARK: DBusSignalInfo has no signals
// MARK: DBusSignalInfo Record: DBusSignalInfoProtocol extension (methods and fields)
public extension DBusSignalInfoProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusSignalInfo` instance.
    @inlinable var dbus_signal_info_ptr: UnsafeMutablePointer<GDBusSignalInfo>! { return ptr?.assumingMemoryBound(to: GDBusSignalInfo.self) }

    /// If `info` is statically allocated does nothing. Otherwise increases
    /// the reference count.
    @discardableResult @inlinable func ref() -> GIO.DBusSignalInfoRef! {
        let result = g_dbus_signal_info_ref(dbus_signal_info_ptr)
        guard let rv = DBusSignalInfoRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// If `info` is statically allocated, does nothing. Otherwise decreases
    /// the reference count of `info`. When its reference count drops to 0,
    /// the memory used is freed.
    @inlinable func unref() {
        
        g_dbus_signal_info_unref(dbus_signal_info_ptr)
        
    }

    /// The reference count or -1 if statically allocated.
    @inlinable var refCount: gint {
        /// The reference count or -1 if statically allocated.
        get {
            let rv = dbus_signal_info_ptr.pointee.ref_count
    return rv
        }
        /// The reference count or -1 if statically allocated.
         set {
            dbus_signal_info_ptr.pointee.ref_count = newValue
        }
    }

    /// The name of the D-Bus signal, e.g. "NameOwnerChanged".
    @inlinable var name: UnsafeMutablePointer<gchar>! {
        /// The name of the D-Bus signal, e.g. "NameOwnerChanged".
        get {
            let rv = dbus_signal_info_ptr.pointee.name
    return rv
        }
        /// The name of the D-Bus signal, e.g. "NameOwnerChanged".
         set {
            dbus_signal_info_ptr.pointee.name = newValue
        }
    }

    /// A pointer to a `nil`-terminated array of pointers to `GDBusArgInfo` structures or `nil` if there are no arguments.
    @inlinable var args: UnsafeMutablePointer<UnsafeMutablePointer<GDBusArgInfo>?>! {
        /// A pointer to a `nil`-terminated array of pointers to `GDBusArgInfo` structures or `nil` if there are no arguments.
        get {
            let rv = dbus_signal_info_ptr.pointee.args
    return rv
        }
        /// A pointer to a `nil`-terminated array of pointers to `GDBusArgInfo` structures or `nil` if there are no arguments.
         set {
            dbus_signal_info_ptr.pointee.args = newValue
        }
    }

    /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
    @inlinable var annotations: UnsafeMutablePointer<UnsafeMutablePointer<GDBusAnnotationInfo>?>! {
        /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
        get {
            let rv = dbus_signal_info_ptr.pointee.annotations
    return rv
        }
        /// A pointer to a `nil`-terminated array of pointers to `GDBusAnnotationInfo` structures or `nil` if there are no annotations.
         set {
            dbus_signal_info_ptr.pointee.annotations = newValue
        }
    }

}



// MARK: - DBusSubtreeVTable Record

/// Virtual table for handling subtrees registered with `g_dbus_connection_register_subtree()`.
///
/// The `DBusSubtreeVTableProtocol` protocol exposes the methods and properties of an underlying `GDBusSubtreeVTable` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusSubtreeVTable`.
/// Alternatively, use `DBusSubtreeVTableRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusSubtreeVTableProtocol {
        /// Untyped pointer to the underlying `GDBusSubtreeVTable` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusSubtreeVTable` instance.
    var _ptr: UnsafeMutablePointer<GDBusSubtreeVTable>! { get }

    /// Required Initialiser for types conforming to `DBusSubtreeVTableProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Virtual table for handling subtrees registered with `g_dbus_connection_register_subtree()`.
///
/// The `DBusSubtreeVTableRef` type acts as a lightweight Swift reference to an underlying `GDBusSubtreeVTable` instance.
/// It exposes methods that can operate on this data type through `DBusSubtreeVTableProtocol` conformance.
/// Use `DBusSubtreeVTableRef` only as an `unowned` reference to an existing `GDBusSubtreeVTable` instance.
///
public struct DBusSubtreeVTableRef: DBusSubtreeVTableProtocol {
        /// Untyped pointer to the underlying `GDBusSubtreeVTable` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusSubtreeVTableRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusSubtreeVTable>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusSubtreeVTable>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusSubtreeVTable>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusSubtreeVTable>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusSubtreeVTableProtocol`
    @inlinable init<T: DBusSubtreeVTableProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSubtreeVTableProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSubtreeVTableProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSubtreeVTableProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSubtreeVTableProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSubtreeVTableProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// Virtual table for handling subtrees registered with `g_dbus_connection_register_subtree()`.
///
/// The `DBusSubtreeVTable` type acts as an owner of an underlying `GDBusSubtreeVTable` instance.
/// It provides the methods that can operate on this data type through `DBusSubtreeVTableProtocol` conformance.
/// Use `DBusSubtreeVTable` as a strong reference or owner of a `GDBusSubtreeVTable` instance.
///
open class DBusSubtreeVTable: DBusSubtreeVTableProtocol {
        /// Untyped pointer to the underlying `GDBusSubtreeVTable` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusSubtreeVTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusSubtreeVTable>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusSubtreeVTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusSubtreeVTable>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusSubtreeVTable` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusSubtreeVTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusSubtreeVTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusSubtreeVTable>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusSubtreeVTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusSubtreeVTable>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GDBusSubtreeVTable` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `DBusSubtreeVTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusSubtreeVTable>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GDBusSubtreeVTable, cannot ref(_ptr)
    }

    /// Reference intialiser for a related type that implements `DBusSubtreeVTableProtocol`
    /// `GDBusSubtreeVTable` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `DBusSubtreeVTableProtocol`
    @inlinable public init<T: DBusSubtreeVTableProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GDBusSubtreeVTable, cannot ref(_ptr)
    }

    /// Do-nothing destructor for `GDBusSubtreeVTable`.
    deinit {
        // no reference counting for GDBusSubtreeVTable, cannot unref(_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSubtreeVTableProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSubtreeVTableProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GDBusSubtreeVTable, cannot ref(_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSubtreeVTableProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSubtreeVTableProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GDBusSubtreeVTable, cannot ref(_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSubtreeVTableProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSubtreeVTableProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GDBusSubtreeVTable, cannot ref(_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSubtreeVTableProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusSubtreeVTableProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GDBusSubtreeVTable, cannot ref(_ptr)
    }



}

// MARK: no DBusSubtreeVTable properties

// MARK: no DBusSubtreeVTable signals

// MARK: DBusSubtreeVTable has no signals
// MARK: DBusSubtreeVTable Record: DBusSubtreeVTableProtocol extension (methods and fields)
public extension DBusSubtreeVTableProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusSubtreeVTable` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDBusSubtreeVTable>! { return ptr?.assumingMemoryBound(to: GDBusSubtreeVTable.self) }


    /// Function for enumerating child nodes.
    @inlinable var enumerate: GDBusSubtreeEnumerateFunc! {
        /// Function for enumerating child nodes.
        get {
            let rv = _ptr.pointee.enumerate
    return rv
        }
        /// Function for enumerating child nodes.
         set {
            _ptr.pointee.enumerate = newValue
        }
    }

    /// Function for introspecting a child node.
    @inlinable var introspect: GDBusSubtreeIntrospectFunc! {
        /// Function for introspecting a child node.
        get {
            let rv = _ptr.pointee.introspect
    return rv
        }
        /// Function for introspecting a child node.
         set {
            _ptr.pointee.introspect = newValue
        }
    }

    /// Function for dispatching a remote call on a child node.
    @inlinable var dispatch: GDBusSubtreeDispatchFunc! {
        /// Function for dispatching a remote call on a child node.
        get {
            let rv = _ptr.pointee.dispatch
    return rv
        }
        /// Function for dispatching a remote call on a child node.
         set {
            _ptr.pointee.dispatch = newValue
        }
    }

    // var padding is unavailable because padding is private

}



/// Metatype/GType declaration for DataInputStream
public extension DataInputStreamClassRef {
    
    /// This getter returns the GLib type identifier registered for `DataInputStream`
    static var metatypeReference: GType { g_data_input_stream_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GDataInputStreamClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GDataInputStreamClass.self) }
    
    static var metatype: GDataInputStreamClass? { metatypePointer?.pointee } 
    
    static var wrapper: DataInputStreamClassRef? { DataInputStreamClassRef(metatypePointer) }
    
    
}

// MARK: - DataInputStreamClass Record


///
/// The `DataInputStreamClassProtocol` protocol exposes the methods and properties of an underlying `GDataInputStreamClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DataInputStreamClass`.
/// Alternatively, use `DataInputStreamClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DataInputStreamClassProtocol {
        /// Untyped pointer to the underlying `GDataInputStreamClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDataInputStreamClass` instance.
    var _ptr: UnsafeMutablePointer<GDataInputStreamClass>! { get }

    /// Required Initialiser for types conforming to `DataInputStreamClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `DataInputStreamClassRef` type acts as a lightweight Swift reference to an underlying `GDataInputStreamClass` instance.
/// It exposes methods that can operate on this data type through `DataInputStreamClassProtocol` conformance.
/// Use `DataInputStreamClassRef` only as an `unowned` reference to an existing `GDataInputStreamClass` instance.
///
public struct DataInputStreamClassRef: DataInputStreamClassProtocol {
        /// Untyped pointer to the underlying `GDataInputStreamClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DataInputStreamClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDataInputStreamClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDataInputStreamClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDataInputStreamClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDataInputStreamClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DataInputStreamClassProtocol`
    @inlinable init<T: DataInputStreamClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataInputStreamClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataInputStreamClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataInputStreamClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataInputStreamClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataInputStreamClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: DataInputStreamClass Record: DataInputStreamClassProtocol extension (methods and fields)
public extension DataInputStreamClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDataInputStreamClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDataInputStreamClass>! { return ptr?.assumingMemoryBound(to: GDataInputStreamClass.self) }


    @inlinable var parentClass: GBufferedInputStreamClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var GReserved1 is unavailable because _g_reserved1 is void

    // var GReserved2 is unavailable because _g_reserved2 is void

    // var GReserved3 is unavailable because _g_reserved3 is void

    // var GReserved4 is unavailable because _g_reserved4 is void

    // var GReserved5 is unavailable because _g_reserved5 is void

}



/// Metatype/GType declaration for DataOutputStream
public extension DataOutputStreamClassRef {
    
    /// This getter returns the GLib type identifier registered for `DataOutputStream`
    static var metatypeReference: GType { g_data_output_stream_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GDataOutputStreamClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GDataOutputStreamClass.self) }
    
    static var metatype: GDataOutputStreamClass? { metatypePointer?.pointee } 
    
    static var wrapper: DataOutputStreamClassRef? { DataOutputStreamClassRef(metatypePointer) }
    
    
}

// MARK: - DataOutputStreamClass Record


///
/// The `DataOutputStreamClassProtocol` protocol exposes the methods and properties of an underlying `GDataOutputStreamClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DataOutputStreamClass`.
/// Alternatively, use `DataOutputStreamClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DataOutputStreamClassProtocol {
        /// Untyped pointer to the underlying `GDataOutputStreamClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDataOutputStreamClass` instance.
    var _ptr: UnsafeMutablePointer<GDataOutputStreamClass>! { get }

    /// Required Initialiser for types conforming to `DataOutputStreamClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `DataOutputStreamClassRef` type acts as a lightweight Swift reference to an underlying `GDataOutputStreamClass` instance.
/// It exposes methods that can operate on this data type through `DataOutputStreamClassProtocol` conformance.
/// Use `DataOutputStreamClassRef` only as an `unowned` reference to an existing `GDataOutputStreamClass` instance.
///
public struct DataOutputStreamClassRef: DataOutputStreamClassProtocol {
        /// Untyped pointer to the underlying `GDataOutputStreamClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DataOutputStreamClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDataOutputStreamClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDataOutputStreamClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDataOutputStreamClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDataOutputStreamClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DataOutputStreamClassProtocol`
    @inlinable init<T: DataOutputStreamClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataOutputStreamClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataOutputStreamClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataOutputStreamClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataOutputStreamClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataOutputStreamClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: DataOutputStreamClass Record: DataOutputStreamClassProtocol extension (methods and fields)
public extension DataOutputStreamClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDataOutputStreamClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDataOutputStreamClass>! { return ptr?.assumingMemoryBound(to: GDataOutputStreamClass.self) }


    @inlinable var parentClass: GFilterOutputStreamClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var GReserved1 is unavailable because _g_reserved1 is void

    // var GReserved2 is unavailable because _g_reserved2 is void

    // var GReserved3 is unavailable because _g_reserved3 is void

    // var GReserved4 is unavailable because _g_reserved4 is void

    // var GReserved5 is unavailable because _g_reserved5 is void

}



/// Metatype/GType declaration for DatagramBased
public extension DatagramBasedInterfaceRef {
    
    /// This getter returns the GLib type identifier registered for `DatagramBased`
    static var metatypeReference: GType { g_datagram_based_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GDatagramBasedInterface>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GDatagramBasedInterface.self) }
    
    static var metatype: GDatagramBasedInterface? { metatypePointer?.pointee } 
    
    static var wrapper: DatagramBasedInterfaceRef? { DatagramBasedInterfaceRef(metatypePointer) }
    
    
}

// MARK: - DatagramBasedInterface Record

/// Provides an interface for socket-like objects which have datagram semantics,
/// following the Berkeley sockets API. The interface methods are thin wrappers
/// around the corresponding virtual methods, and no pre-processing of inputs is
/// implemented  so implementations of this API must handle all functionality
/// documented in the interface methods.
///
/// The `DatagramBasedInterfaceProtocol` protocol exposes the methods and properties of an underlying `GDatagramBasedInterface` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DatagramBasedInterface`.
/// Alternatively, use `DatagramBasedInterfaceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DatagramBasedInterfaceProtocol {
        /// Untyped pointer to the underlying `GDatagramBasedInterface` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDatagramBasedInterface` instance.
    var _ptr: UnsafeMutablePointer<GDatagramBasedInterface>! { get }

    /// Required Initialiser for types conforming to `DatagramBasedInterfaceProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Provides an interface for socket-like objects which have datagram semantics,
/// following the Berkeley sockets API. The interface methods are thin wrappers
/// around the corresponding virtual methods, and no pre-processing of inputs is
/// implemented  so implementations of this API must handle all functionality
/// documented in the interface methods.
///
/// The `DatagramBasedInterfaceRef` type acts as a lightweight Swift reference to an underlying `GDatagramBasedInterface` instance.
/// It exposes methods that can operate on this data type through `DatagramBasedInterfaceProtocol` conformance.
/// Use `DatagramBasedInterfaceRef` only as an `unowned` reference to an existing `GDatagramBasedInterface` instance.
///
public struct DatagramBasedInterfaceRef: DatagramBasedInterfaceProtocol {
        /// Untyped pointer to the underlying `GDatagramBasedInterface` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DatagramBasedInterfaceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDatagramBasedInterface>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDatagramBasedInterface>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDatagramBasedInterface>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDatagramBasedInterface>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DatagramBasedInterfaceProtocol`
    @inlinable init<T: DatagramBasedInterfaceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DatagramBasedInterfaceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DatagramBasedInterfaceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DatagramBasedInterfaceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DatagramBasedInterfaceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DatagramBasedInterfaceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: DatagramBasedInterface Record: DatagramBasedInterfaceProtocol extension (methods and fields)
public extension DatagramBasedInterfaceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDatagramBasedInterface` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDatagramBasedInterface>! { return ptr?.assumingMemoryBound(to: GDatagramBasedInterface.self) }


    /// The parent interface.
    @inlinable var gIface: GTypeInterface {
        /// The parent interface.
        get {
            let rv = _ptr.pointee.g_iface
    return rv
        }
    }

    // var receiveMessages is unavailable because receive_messages is void

    // var sendMessages is unavailable because send_messages is void

    // var createSource is unavailable because create_source is void

    // var conditionCheck is unavailable because condition_check is void

    // var conditionWait is unavailable because condition_wait is void

}



/// Metatype/GType declaration for DebugControllerDBus
public extension DebugControllerDBusClassRef {
    
    /// This getter returns the GLib type identifier registered for `DebugControllerDBus`
    static var metatypeReference: GType { g_debug_controller_dbus_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GDebugControllerDBusClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GDebugControllerDBusClass.self) }
    
    static var metatype: GDebugControllerDBusClass? { metatypePointer?.pointee } 
    
    static var wrapper: DebugControllerDBusClassRef? { DebugControllerDBusClassRef(metatypePointer) }
    
    
}

// MARK: - DebugControllerDBusClass Record

/// The virtual function table for `GDebugControllerDBus`.
///
/// The `DebugControllerDBusClassProtocol` protocol exposes the methods and properties of an underlying `GDebugControllerDBusClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DebugControllerDBusClass`.
/// Alternatively, use `DebugControllerDBusClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DebugControllerDBusClassProtocol {
        /// Untyped pointer to the underlying `GDebugControllerDBusClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDebugControllerDBusClass` instance.
    var _ptr: UnsafeMutablePointer<GDebugControllerDBusClass>! { get }

    /// Required Initialiser for types conforming to `DebugControllerDBusClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The virtual function table for `GDebugControllerDBus`.
///
/// The `DebugControllerDBusClassRef` type acts as a lightweight Swift reference to an underlying `GDebugControllerDBusClass` instance.
/// It exposes methods that can operate on this data type through `DebugControllerDBusClassProtocol` conformance.
/// Use `DebugControllerDBusClassRef` only as an `unowned` reference to an existing `GDebugControllerDBusClass` instance.
///
public struct DebugControllerDBusClassRef: DebugControllerDBusClassProtocol {
        /// Untyped pointer to the underlying `GDebugControllerDBusClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DebugControllerDBusClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDebugControllerDBusClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDebugControllerDBusClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDebugControllerDBusClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDebugControllerDBusClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DebugControllerDBusClassProtocol`
    @inlinable init<T: DebugControllerDBusClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerDBusClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerDBusClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerDBusClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerDBusClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerDBusClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: DebugControllerDBusClass Record: DebugControllerDBusClassProtocol extension (methods and fields)
public extension DebugControllerDBusClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDebugControllerDBusClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDebugControllerDBusClass>! { return ptr?.assumingMemoryBound(to: GDebugControllerDBusClass.self) }


    /// The parent class.
    @inlinable var parentClass: GObjectClass {
        /// The parent class.
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var authorize is unavailable because authorize is void

    @inlinable var padding: (gpointer?, gpointer?, gpointer?, gpointer?, gpointer?, gpointer?, gpointer?, gpointer?, gpointer?, gpointer?, gpointer?, gpointer?) {
        get {
            let rv = _ptr.pointee.padding
    return rv
        }
    }

}



/// Metatype/GType declaration for DebugController
public extension DebugControllerInterfaceRef {
    
    /// This getter returns the GLib type identifier registered for `DebugController`
    static var metatypeReference: GType { g_debug_controller_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GDebugControllerInterface>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GDebugControllerInterface.self) }
    
    static var metatype: GDebugControllerInterface? { metatypePointer?.pointee } 
    
    static var wrapper: DebugControllerInterfaceRef? { DebugControllerInterfaceRef(metatypePointer) }
    
    
}

// MARK: - DebugControllerInterface Record

/// The virtual function table for `GDebugController`.
///
/// The `DebugControllerInterfaceProtocol` protocol exposes the methods and properties of an underlying `GDebugControllerInterface` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DebugControllerInterface`.
/// Alternatively, use `DebugControllerInterfaceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DebugControllerInterfaceProtocol {
        /// Untyped pointer to the underlying `GDebugControllerInterface` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDebugControllerInterface` instance.
    var _ptr: UnsafeMutablePointer<GDebugControllerInterface>! { get }

    /// Required Initialiser for types conforming to `DebugControllerInterfaceProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The virtual function table for `GDebugController`.
///
/// The `DebugControllerInterfaceRef` type acts as a lightweight Swift reference to an underlying `GDebugControllerInterface` instance.
/// It exposes methods that can operate on this data type through `DebugControllerInterfaceProtocol` conformance.
/// Use `DebugControllerInterfaceRef` only as an `unowned` reference to an existing `GDebugControllerInterface` instance.
///
public struct DebugControllerInterfaceRef: DebugControllerInterfaceProtocol {
        /// Untyped pointer to the underlying `GDebugControllerInterface` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DebugControllerInterfaceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDebugControllerInterface>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDebugControllerInterface>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDebugControllerInterface>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDebugControllerInterface>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DebugControllerInterfaceProtocol`
    @inlinable init<T: DebugControllerInterfaceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerInterfaceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerInterfaceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerInterfaceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerInterfaceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerInterfaceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: DebugControllerInterface Record: DebugControllerInterfaceProtocol extension (methods and fields)
public extension DebugControllerInterfaceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDebugControllerInterface` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDebugControllerInterface>! { return ptr?.assumingMemoryBound(to: GDebugControllerInterface.self) }


    // var gIface is unavailable because g_iface is private

}



/// Metatype/GType declaration for DesktopAppInfo
public extension DesktopAppInfoClassRef {
    
    /// This getter returns the GLib type identifier registered for `DesktopAppInfo`
    static var metatypeReference: GType { g_desktop_app_info_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GDesktopAppInfoClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GDesktopAppInfoClass.self) }
    
    static var metatype: GDesktopAppInfoClass? { metatypePointer?.pointee } 
    
    static var wrapper: DesktopAppInfoClassRef? { DesktopAppInfoClassRef(metatypePointer) }
    
    
}

// MARK: - DesktopAppInfoClass Record


///
/// The `DesktopAppInfoClassProtocol` protocol exposes the methods and properties of an underlying `GDesktopAppInfoClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DesktopAppInfoClass`.
/// Alternatively, use `DesktopAppInfoClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DesktopAppInfoClassProtocol {
        /// Untyped pointer to the underlying `GDesktopAppInfoClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDesktopAppInfoClass` instance.
    var _ptr: UnsafeMutablePointer<GDesktopAppInfoClass>! { get }

    /// Required Initialiser for types conforming to `DesktopAppInfoClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `DesktopAppInfoClassRef` type acts as a lightweight Swift reference to an underlying `GDesktopAppInfoClass` instance.
/// It exposes methods that can operate on this data type through `DesktopAppInfoClassProtocol` conformance.
/// Use `DesktopAppInfoClassRef` only as an `unowned` reference to an existing `GDesktopAppInfoClass` instance.
///
public struct DesktopAppInfoClassRef: DesktopAppInfoClassProtocol {
        /// Untyped pointer to the underlying `GDesktopAppInfoClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DesktopAppInfoClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDesktopAppInfoClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDesktopAppInfoClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDesktopAppInfoClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDesktopAppInfoClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DesktopAppInfoClassProtocol`
    @inlinable init<T: DesktopAppInfoClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: DesktopAppInfoClass Record: DesktopAppInfoClassProtocol extension (methods and fields)
public extension DesktopAppInfoClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDesktopAppInfoClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDesktopAppInfoClass>! { return ptr?.assumingMemoryBound(to: GDesktopAppInfoClass.self) }


    @inlinable var parentClass: GObjectClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

}



/// Metatype/GType declaration for DesktopAppInfoLookup
public extension DesktopAppInfoLookupIfaceRef {
    
    /// This getter returns the GLib type identifier registered for `DesktopAppInfoLookup`
    static var metatypeReference: GType { g_desktop_app_info_lookup_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GDesktopAppInfoLookupIface>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GDesktopAppInfoLookupIface.self) }
    
    static var metatype: GDesktopAppInfoLookupIface? { metatypePointer?.pointee } 
    
    static var wrapper: DesktopAppInfoLookupIfaceRef? { DesktopAppInfoLookupIfaceRef(metatypePointer) }
    
    
}

// MARK: - DesktopAppInfoLookupIface Record

/// Interface that is used by backends to associate default
/// handlers with URI schemes.
///
/// The `DesktopAppInfoLookupIfaceProtocol` protocol exposes the methods and properties of an underlying `GDesktopAppInfoLookupIface` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DesktopAppInfoLookupIface`.
/// Alternatively, use `DesktopAppInfoLookupIfaceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DesktopAppInfoLookupIfaceProtocol {
        /// Untyped pointer to the underlying `GDesktopAppInfoLookupIface` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDesktopAppInfoLookupIface` instance.
    var _ptr: UnsafeMutablePointer<GDesktopAppInfoLookupIface>! { get }

    /// Required Initialiser for types conforming to `DesktopAppInfoLookupIfaceProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Interface that is used by backends to associate default
/// handlers with URI schemes.
///
/// The `DesktopAppInfoLookupIfaceRef` type acts as a lightweight Swift reference to an underlying `GDesktopAppInfoLookupIface` instance.
/// It exposes methods that can operate on this data type through `DesktopAppInfoLookupIfaceProtocol` conformance.
/// Use `DesktopAppInfoLookupIfaceRef` only as an `unowned` reference to an existing `GDesktopAppInfoLookupIface` instance.
///
public struct DesktopAppInfoLookupIfaceRef: DesktopAppInfoLookupIfaceProtocol {
        /// Untyped pointer to the underlying `GDesktopAppInfoLookupIface` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DesktopAppInfoLookupIfaceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDesktopAppInfoLookupIface>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDesktopAppInfoLookupIface>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDesktopAppInfoLookupIface>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDesktopAppInfoLookupIface>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DesktopAppInfoLookupIfaceProtocol`
    @inlinable init<T: DesktopAppInfoLookupIfaceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoLookupIfaceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoLookupIfaceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoLookupIfaceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoLookupIfaceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoLookupIfaceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: DesktopAppInfoLookupIface Record: DesktopAppInfoLookupIfaceProtocol extension (methods and fields)
public extension DesktopAppInfoLookupIfaceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDesktopAppInfoLookupIface` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDesktopAppInfoLookupIface>! { return ptr?.assumingMemoryBound(to: GDesktopAppInfoLookupIface.self) }


    @inlinable var gIface: GTypeInterface {
        get {
            let rv = _ptr.pointee.g_iface
    return rv
        }
    }

    // var getDefaultForURIScheme is unavailable because get_default_for_uri_scheme is void

}



/// Metatype/GType declaration for Drive
public extension DriveIfaceRef {
    
    /// This getter returns the GLib type identifier registered for `Drive`
    static var metatypeReference: GType { g_drive_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GDriveIface>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GDriveIface.self) }
    
    static var metatype: GDriveIface? { metatypePointer?.pointee } 
    
    static var wrapper: DriveIfaceRef? { DriveIfaceRef(metatypePointer) }
    
    
}

// MARK: - DriveIface Record

/// Interface for creating `GDrive` implementations.
///
/// The `DriveIfaceProtocol` protocol exposes the methods and properties of an underlying `GDriveIface` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DriveIface`.
/// Alternatively, use `DriveIfaceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DriveIfaceProtocol {
        /// Untyped pointer to the underlying `GDriveIface` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDriveIface` instance.
    var _ptr: UnsafeMutablePointer<GDriveIface>! { get }

    /// Required Initialiser for types conforming to `DriveIfaceProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Interface for creating `GDrive` implementations.
///
/// The `DriveIfaceRef` type acts as a lightweight Swift reference to an underlying `GDriveIface` instance.
/// It exposes methods that can operate on this data type through `DriveIfaceProtocol` conformance.
/// Use `DriveIfaceRef` only as an `unowned` reference to an existing `GDriveIface` instance.
///
public struct DriveIfaceRef: DriveIfaceProtocol {
        /// Untyped pointer to the underlying `GDriveIface` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DriveIfaceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDriveIface>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDriveIface>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDriveIface>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDriveIface>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DriveIfaceProtocol`
    @inlinable init<T: DriveIfaceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DriveIfaceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DriveIfaceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DriveIfaceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DriveIfaceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DriveIfaceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: DriveIface Record: DriveIfaceProtocol extension (methods and fields)
public extension DriveIfaceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDriveIface` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDriveIface>! { return ptr?.assumingMemoryBound(to: GDriveIface.self) }


    /// The parent interface.
    @inlinable var gIface: GTypeInterface {
        /// The parent interface.
        get {
            let rv = _ptr.pointee.g_iface
    return rv
        }
    }

    // var changed is unavailable because changed is void

    // var disconnected is unavailable because disconnected is void

    // var ejectButton is unavailable because eject_button is void

    // var getName is unavailable because get_name is void

    // var getIcon is unavailable because get_icon is void

    // var hasVolumes is unavailable because has_volumes is void

    // var getVolumes is unavailable because get_volumes is void

    // var isMediaRemovable is unavailable because is_media_removable is void

    // var hasMedia is unavailable because has_media is void

    // var isMediaCheckAutomatic is unavailable because is_media_check_automatic is void

    // var canEject is unavailable because can_eject is void

    // var canPollForMedia is unavailable because can_poll_for_media is void

    // var eject is unavailable because eject is void

    // var ejectFinish is unavailable because eject_finish is void

    // var pollForMedia is unavailable because poll_for_media is void

    // var pollForMediaFinish is unavailable because poll_for_media_finish is void

    // var getIdentifier is unavailable because get_identifier is void

    // var enumerateIdentifiers is unavailable because enumerate_identifiers is void

    // var getStartStopType is unavailable because get_start_stop_type is void

    // var canStart is unavailable because can_start is void

    // var canStartDegraded is unavailable because can_start_degraded is void

    // var start is unavailable because start is void

    // var startFinish is unavailable because start_finish is void

    // var canStop is unavailable because can_stop is void

    // var stop is unavailable because stop is void

    // var stopFinish is unavailable because stop_finish is void

    // var stopButton is unavailable because stop_button is void

    // var ejectWithOperation is unavailable because eject_with_operation is void

    // var ejectWithOperationFinish is unavailable because eject_with_operation_finish is void

    // var getSortKey is unavailable because get_sort_key is void

    // var getSymbolicIcon is unavailable because get_symbolic_icon is void

    // var isRemovable is unavailable because is_removable is void

}



/// Metatype/GType declaration for DtlsClientConnection
public extension DtlsClientConnectionInterfaceRef {
    
    /// This getter returns the GLib type identifier registered for `DtlsClientConnection`
    static var metatypeReference: GType { g_dtls_client_connection_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GDtlsClientConnectionInterface>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GDtlsClientConnectionInterface.self) }
    
    static var metatype: GDtlsClientConnectionInterface? { metatypePointer?.pointee } 
    
    static var wrapper: DtlsClientConnectionInterfaceRef? { DtlsClientConnectionInterfaceRef(metatypePointer) }
    
    
}

// MARK: - DtlsClientConnectionInterface Record

/// vtable for a `GDtlsClientConnection` implementation.
///
/// The `DtlsClientConnectionInterfaceProtocol` protocol exposes the methods and properties of an underlying `GDtlsClientConnectionInterface` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DtlsClientConnectionInterface`.
/// Alternatively, use `DtlsClientConnectionInterfaceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DtlsClientConnectionInterfaceProtocol {
        /// Untyped pointer to the underlying `GDtlsClientConnectionInterface` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDtlsClientConnectionInterface` instance.
    var _ptr: UnsafeMutablePointer<GDtlsClientConnectionInterface>! { get }

    /// Required Initialiser for types conforming to `DtlsClientConnectionInterfaceProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// vtable for a `GDtlsClientConnection` implementation.
///
/// The `DtlsClientConnectionInterfaceRef` type acts as a lightweight Swift reference to an underlying `GDtlsClientConnectionInterface` instance.
/// It exposes methods that can operate on this data type through `DtlsClientConnectionInterfaceProtocol` conformance.
/// Use `DtlsClientConnectionInterfaceRef` only as an `unowned` reference to an existing `GDtlsClientConnectionInterface` instance.
///
public struct DtlsClientConnectionInterfaceRef: DtlsClientConnectionInterfaceProtocol {
        /// Untyped pointer to the underlying `GDtlsClientConnectionInterface` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DtlsClientConnectionInterfaceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDtlsClientConnectionInterface>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDtlsClientConnectionInterface>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDtlsClientConnectionInterface>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDtlsClientConnectionInterface>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DtlsClientConnectionInterfaceProtocol`
    @inlinable init<T: DtlsClientConnectionInterfaceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsClientConnectionInterfaceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsClientConnectionInterfaceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsClientConnectionInterfaceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsClientConnectionInterfaceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsClientConnectionInterfaceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: DtlsClientConnectionInterface Record: DtlsClientConnectionInterfaceProtocol extension (methods and fields)
public extension DtlsClientConnectionInterfaceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDtlsClientConnectionInterface` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDtlsClientConnectionInterface>! { return ptr?.assumingMemoryBound(to: GDtlsClientConnectionInterface.self) }


    /// The parent interface.
    @inlinable var gIface: GTypeInterface {
        /// The parent interface.
        get {
            let rv = _ptr.pointee.g_iface
    return rv
        }
    }

}



/// Metatype/GType declaration for DtlsConnection
public extension DtlsConnectionInterfaceRef {
    
    /// This getter returns the GLib type identifier registered for `DtlsConnection`
    static var metatypeReference: GType { g_dtls_connection_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GDtlsConnectionInterface>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GDtlsConnectionInterface.self) }
    
    static var metatype: GDtlsConnectionInterface? { metatypePointer?.pointee } 
    
    static var wrapper: DtlsConnectionInterfaceRef? { DtlsConnectionInterfaceRef(metatypePointer) }
    
    
}

// MARK: - DtlsConnectionInterface Record

/// Virtual method table for a `GDtlsConnection` implementation.
///
/// The `DtlsConnectionInterfaceProtocol` protocol exposes the methods and properties of an underlying `GDtlsConnectionInterface` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DtlsConnectionInterface`.
/// Alternatively, use `DtlsConnectionInterfaceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DtlsConnectionInterfaceProtocol {
        /// Untyped pointer to the underlying `GDtlsConnectionInterface` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDtlsConnectionInterface` instance.
    var _ptr: UnsafeMutablePointer<GDtlsConnectionInterface>! { get }

    /// Required Initialiser for types conforming to `DtlsConnectionInterfaceProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Virtual method table for a `GDtlsConnection` implementation.
///
/// The `DtlsConnectionInterfaceRef` type acts as a lightweight Swift reference to an underlying `GDtlsConnectionInterface` instance.
/// It exposes methods that can operate on this data type through `DtlsConnectionInterfaceProtocol` conformance.
/// Use `DtlsConnectionInterfaceRef` only as an `unowned` reference to an existing `GDtlsConnectionInterface` instance.
///
public struct DtlsConnectionInterfaceRef: DtlsConnectionInterfaceProtocol {
        /// Untyped pointer to the underlying `GDtlsConnectionInterface` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DtlsConnectionInterfaceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDtlsConnectionInterface>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDtlsConnectionInterface>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDtlsConnectionInterface>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDtlsConnectionInterface>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DtlsConnectionInterfaceProtocol`
    @inlinable init<T: DtlsConnectionInterfaceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsConnectionInterfaceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsConnectionInterfaceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsConnectionInterfaceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsConnectionInterfaceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsConnectionInterfaceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: DtlsConnectionInterface Record: DtlsConnectionInterfaceProtocol extension (methods and fields)
public extension DtlsConnectionInterfaceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDtlsConnectionInterface` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDtlsConnectionInterface>! { return ptr?.assumingMemoryBound(to: GDtlsConnectionInterface.self) }


    /// The parent interface.
    @inlinable var gIface: GTypeInterface {
        /// The parent interface.
        get {
            let rv = _ptr.pointee.g_iface
    return rv
        }
    }

    // var acceptCertificate is unavailable because accept_certificate is void

    // var handshake is unavailable because handshake is void

    // var handshakeAsync is unavailable because handshake_async is void

    // var handshakeFinish is unavailable because handshake_finish is void

    // var shutdown is unavailable because shutdown is void

    // var shutdownAsync is unavailable because shutdown_async is void

    // var shutdownFinish is unavailable because shutdown_finish is void

    // var setAdvertisedProtocols is unavailable because set_advertised_protocols is void

    // var getNegotiatedProtocol is unavailable because get_negotiated_protocol is void

    // var getBindingData is unavailable because get_binding_data is void

}



/// Metatype/GType declaration for DtlsServerConnection
public extension DtlsServerConnectionInterfaceRef {
    
    /// This getter returns the GLib type identifier registered for `DtlsServerConnection`
    static var metatypeReference: GType { g_dtls_server_connection_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GDtlsServerConnectionInterface>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GDtlsServerConnectionInterface.self) }
    
    static var metatype: GDtlsServerConnectionInterface? { metatypePointer?.pointee } 
    
    static var wrapper: DtlsServerConnectionInterfaceRef? { DtlsServerConnectionInterfaceRef(metatypePointer) }
    
    
}

// MARK: - DtlsServerConnectionInterface Record

/// vtable for a `GDtlsServerConnection` implementation.
///
/// The `DtlsServerConnectionInterfaceProtocol` protocol exposes the methods and properties of an underlying `GDtlsServerConnectionInterface` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DtlsServerConnectionInterface`.
/// Alternatively, use `DtlsServerConnectionInterfaceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DtlsServerConnectionInterfaceProtocol {
        /// Untyped pointer to the underlying `GDtlsServerConnectionInterface` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDtlsServerConnectionInterface` instance.
    var _ptr: UnsafeMutablePointer<GDtlsServerConnectionInterface>! { get }

    /// Required Initialiser for types conforming to `DtlsServerConnectionInterfaceProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// vtable for a `GDtlsServerConnection` implementation.
///
/// The `DtlsServerConnectionInterfaceRef` type acts as a lightweight Swift reference to an underlying `GDtlsServerConnectionInterface` instance.
/// It exposes methods that can operate on this data type through `DtlsServerConnectionInterfaceProtocol` conformance.
/// Use `DtlsServerConnectionInterfaceRef` only as an `unowned` reference to an existing `GDtlsServerConnectionInterface` instance.
///
public struct DtlsServerConnectionInterfaceRef: DtlsServerConnectionInterfaceProtocol {
        /// Untyped pointer to the underlying `GDtlsServerConnectionInterface` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DtlsServerConnectionInterfaceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDtlsServerConnectionInterface>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDtlsServerConnectionInterface>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDtlsServerConnectionInterface>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDtlsServerConnectionInterface>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DtlsServerConnectionInterfaceProtocol`
    @inlinable init<T: DtlsServerConnectionInterfaceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsServerConnectionInterfaceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsServerConnectionInterfaceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsServerConnectionInterfaceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsServerConnectionInterfaceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsServerConnectionInterfaceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: DtlsServerConnectionInterface Record: DtlsServerConnectionInterfaceProtocol extension (methods and fields)
public extension DtlsServerConnectionInterfaceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDtlsServerConnectionInterface` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GDtlsServerConnectionInterface>! { return ptr?.assumingMemoryBound(to: GDtlsServerConnectionInterface.self) }


    /// The parent interface.
    @inlinable var gIface: GTypeInterface {
        /// The parent interface.
        get {
            let rv = _ptr.pointee.g_iface
    return rv
        }
    }

}



// MARK: - DBusInterface Interface

/// The `GDBusInterface` type is the base type for D-Bus interfaces both
/// on the service side (see `GDBusInterfaceSkeleton`) and client side
/// (see `GDBusProxy`).
///
/// The `DBusInterfaceProtocol` protocol exposes the methods and properties of an underlying `GDBusInterface` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusInterface`.
/// Alternatively, use `DBusInterfaceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusInterfaceProtocol {
        /// Untyped pointer to the underlying `GDBusInterface` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusInterface` instance.
    var dbus_interface_ptr: UnsafeMutablePointer<GDBusInterface>! { get }

    /// Required Initialiser for types conforming to `DBusInterfaceProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `GDBusInterface` type is the base type for D-Bus interfaces both
/// on the service side (see `GDBusInterfaceSkeleton`) and client side
/// (see `GDBusProxy`).
///
/// The `DBusInterfaceRef` type acts as a lightweight Swift reference to an underlying `GDBusInterface` instance.
/// It exposes methods that can operate on this data type through `DBusInterfaceProtocol` conformance.
/// Use `DBusInterfaceRef` only as an `unowned` reference to an existing `GDBusInterface` instance.
///
public struct DBusInterfaceRef: DBusInterfaceProtocol {
        /// Untyped pointer to the underlying `GDBusInterface` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_interface_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusInterfaceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusInterface>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusInterface>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusInterface>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusInterface>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusInterfaceProtocol`
    @inlinable init<T: DBusInterfaceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `GDBusInterface` type is the base type for D-Bus interfaces both
/// on the service side (see `GDBusInterfaceSkeleton`) and client side
/// (see `GDBusProxy`).
///
/// The `DBusInterface` type acts as an owner of an underlying `GDBusInterface` instance.
/// It provides the methods that can operate on this data type through `DBusInterfaceProtocol` conformance.
/// Use `DBusInterface` as a strong reference or owner of a `GDBusInterface` instance.
///
open class DBusInterface: DBusInterfaceProtocol {
        /// Untyped pointer to the underlying `GDBusInterface` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_interface_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterface` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusInterface>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterface` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusInterface>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterface` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterface` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterface` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusInterface>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterface` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusInterface>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GDBusInterface` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `DBusInterface` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusInterface>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GDBusInterface, cannot ref(dbus_interface_ptr)
    }

    /// Reference intialiser for a related type that implements `DBusInterfaceProtocol`
    /// `GDBusInterface` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `DBusInterfaceProtocol`
    @inlinable public init<T: DBusInterfaceProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GDBusInterface, cannot ref(dbus_interface_ptr)
    }

    /// Do-nothing destructor for `GDBusInterface`.
    deinit {
        // no reference counting for GDBusInterface, cannot unref(dbus_interface_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GDBusInterface, cannot ref(dbus_interface_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GDBusInterface, cannot ref(dbus_interface_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GDBusInterface, cannot ref(dbus_interface_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GDBusInterface, cannot ref(dbus_interface_ptr)
    }



}

// MARK: no DBusInterface properties

// MARK: no DBusInterface signals

// MARK: DBusInterface has no signals
// MARK: DBusInterface Interface: DBusInterfaceProtocol extension (methods and fields)
public extension DBusInterfaceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusInterface` instance.
    @inlinable var dbus_interface_ptr: UnsafeMutablePointer<GDBusInterface>! { return ptr?.assumingMemoryBound(to: GDBusInterface.self) }

    /// Gets the `GDBusObject` that `interface_` belongs to, if any.
    @inlinable func dupObject() -> GIO.DBusObjectRef! {
        let result = g_dbus_interface_dup_object(dbus_interface_ptr)
        let rv = DBusObjectRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets D-Bus introspection information for the D-Bus interface
    /// implemented by `interface_`.
    @inlinable func getInfo() -> GIO.DBusInterfaceInfoRef! {
        let result = g_dbus_interface_get_info(dbus_interface_ptr)
        let rv = DBusInterfaceInfoRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the `GDBusObject` that `interface_` belongs to, if any.
    /// 
    /// It is not safe to use the returned object if `interface_` or
    /// the returned object is being used from other threads. See
    /// `g_dbus_interface_dup_object()` for a thread-safe alternative.
    @inlinable func getObject() -> GIO.DBusObjectRef! {
        let result = g_dbus_interface_get_object(dbus_interface_ptr)
        let rv = DBusObjectRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Sets the `GDBusObject` for `interface_` to `object`.
    /// 
    /// Note that `interface_` will hold a weak reference to `object`.
    @inlinable func set(object: DBusObjectRef? = nil) {
            
        g_dbus_interface_set_object(dbus_interface_ptr, object?.dbus_object_ptr)
            
    }
    /// Sets the `GDBusObject` for `interface_` to `object`.
    /// 
    /// Note that `interface_` will hold a weak reference to `object`.
    @inlinable func set<DBusObjectT: DBusObjectProtocol>(object: DBusObjectT?) {
        
        g_dbus_interface_set_object(dbus_interface_ptr, object?.dbus_object_ptr)
        
    }
    /// Gets D-Bus introspection information for the D-Bus interface
    /// implemented by `interface_`.
    @inlinable var info: GIO.DBusInterfaceInfoRef! {
        /// Gets D-Bus introspection information for the D-Bus interface
        /// implemented by `interface_`.
        get {
            let result = g_dbus_interface_get_info(dbus_interface_ptr)
        let rv = DBusInterfaceInfoRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Gets the `GDBusObject` that `interface_` belongs to, if any.
    /// 
    /// It is not safe to use the returned object if `interface_` or
    /// the returned object is being used from other threads. See
    /// `g_dbus_interface_dup_object()` for a thread-safe alternative.
    @inlinable var object: GIO.DBusObjectRef! {
        /// Gets the `GDBusObject` that `interface_` belongs to, if any.
        /// 
        /// It is not safe to use the returned object if `interface_` or
        /// the returned object is being used from other threads. See
        /// `g_dbus_interface_dup_object()` for a thread-safe alternative.
        get {
            let result = g_dbus_interface_get_object(dbus_interface_ptr)
        let rv = DBusObjectRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets the `GDBusObject` for `interface_` to `object`.
        /// 
        /// Note that `interface_` will hold a weak reference to `object`.
        nonmutating set {
            g_dbus_interface_set_object(dbus_interface_ptr, UnsafeMutablePointer<GDBusObject>(newValue?.dbus_object_ptr))
        }
    }


}



// MARK: - DBusObject Interface

/// The `GDBusObject` type is the base type for D-Bus objects on both
/// the service side (see `GDBusObjectSkeleton`) and the client side
/// (see `GDBusObjectProxy`). It is essentially just a container of
/// interfaces.
///
/// The `DBusObjectProtocol` protocol exposes the methods and properties of an underlying `GDBusObject` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusObject`.
/// Alternatively, use `DBusObjectRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusObjectProtocol {
        /// Untyped pointer to the underlying `GDBusObject` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusObject` instance.
    var dbus_object_ptr: UnsafeMutablePointer<GDBusObject>! { get }

    /// Required Initialiser for types conforming to `DBusObjectProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `GDBusObject` type is the base type for D-Bus objects on both
/// the service side (see `GDBusObjectSkeleton`) and the client side
/// (see `GDBusObjectProxy`). It is essentially just a container of
/// interfaces.
///
/// The `DBusObjectRef` type acts as a lightweight Swift reference to an underlying `GDBusObject` instance.
/// It exposes methods that can operate on this data type through `DBusObjectProtocol` conformance.
/// Use `DBusObjectRef` only as an `unowned` reference to an existing `GDBusObject` instance.
///
public struct DBusObjectRef: DBusObjectProtocol {
        /// Untyped pointer to the underlying `GDBusObject` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_object_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusObjectRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusObject>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusObject>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusObject>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusObject>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusObjectProtocol`
    @inlinable init<T: DBusObjectProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `GDBusObject` type is the base type for D-Bus objects on both
/// the service side (see `GDBusObjectSkeleton`) and the client side
/// (see `GDBusObjectProxy`). It is essentially just a container of
/// interfaces.
///
/// The `DBusObject` type acts as an owner of an underlying `GDBusObject` instance.
/// It provides the methods that can operate on this data type through `DBusObjectProtocol` conformance.
/// Use `DBusObject` as a strong reference or owner of a `GDBusObject` instance.
///
open class DBusObject: DBusObjectProtocol {
        /// Untyped pointer to the underlying `GDBusObject` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_object_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObject` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusObject>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObject` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusObject>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObject` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObject` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObject` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusObject>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObject` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusObject>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GDBusObject` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `DBusObject` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusObject>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GDBusObject, cannot ref(dbus_object_ptr)
    }

    /// Reference intialiser for a related type that implements `DBusObjectProtocol`
    /// `GDBusObject` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `DBusObjectProtocol`
    @inlinable public init<T: DBusObjectProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GDBusObject, cannot ref(dbus_object_ptr)
    }

    /// Do-nothing destructor for `GDBusObject`.
    deinit {
        // no reference counting for GDBusObject, cannot unref(dbus_object_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GDBusObject, cannot ref(dbus_object_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GDBusObject, cannot ref(dbus_object_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GDBusObject, cannot ref(dbus_object_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GDBusObject, cannot ref(dbus_object_ptr)
    }



}

// MARK: no DBusObject properties

public enum DBusObjectSignalName: String, SignalNameProtocol {
    /// Emitted when `interface` is added to `object`.
    case interfaceAdded = "interface-added"
    /// Emitted when `interface` is removed from `object`.
    case interfaceRemoved = "interface-removed"

}

// MARK: DBusObject signals
public extension DBusObjectProtocol {
    /// Connect a Swift signal handler to the given, typed `DBusObjectSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DBusObjectSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        GLibObject.ObjectRef(raw: ptr).connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `DBusObjectSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DBusObjectSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        GLibObject.ObjectRef(raw: ptr).connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when `interface` is added to `object`.
    /// - Note: This represents the underlying `interface-added` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter interface: The `GDBusInterface` that was added.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `interfaceAdded` signal is emitted
    @discardableResult @inlinable func onInterfaceAdded(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusObjectRef, _ interface: DBusInterfaceRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusObjectRef, DBusInterfaceRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusObjectRef(raw: unownedSelf), DBusInterfaceRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .interfaceAdded,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `interface-added` signal for using the `connect(signal:)` methods
    static var interfaceAddedSignal: DBusObjectSignalName { .interfaceAdded }
    
    /// Emitted when `interface` is removed from `object`.
    /// - Note: This represents the underlying `interface-removed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter interface: The `GDBusInterface` that was removed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `interfaceRemoved` signal is emitted
    @discardableResult @inlinable func onInterfaceRemoved(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusObjectRef, _ interface: DBusInterfaceRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusObjectRef, DBusInterfaceRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusObjectRef(raw: unownedSelf), DBusInterfaceRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .interfaceRemoved,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `interface-removed` signal for using the `connect(signal:)` methods
    static var interfaceRemovedSignal: DBusObjectSignalName { .interfaceRemoved }
    
    
}

// MARK: DBusObject Interface: DBusObjectProtocol extension (methods and fields)
public extension DBusObjectProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusObject` instance.
    @inlinable var dbus_object_ptr: UnsafeMutablePointer<GDBusObject>! { return ptr?.assumingMemoryBound(to: GDBusObject.self) }

    /// Gets the D-Bus interface with name `interface_name` associated with
    /// `object`, if any.
    @inlinable func getInterface(interfaceName: UnsafePointer<gchar>!) -> GIO.DBusInterfaceRef! {
        let result = g_dbus_object_get_interface(dbus_object_ptr, interfaceName)
        let rv = DBusInterfaceRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the D-Bus interfaces associated with `object`.
    @inlinable func getInterfaces() -> GLib.ListRef! {
        let result = g_dbus_object_get_interfaces(dbus_object_ptr)
        let rv = GLib.ListRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the object path for `object`.
    @inlinable func getObjectPath() -> String! {
        let result = g_dbus_object_get_object_path(dbus_object_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }
    /// Gets the D-Bus interfaces associated with `object`.
    @inlinable var interfaces: GLib.ListRef! {
        /// Gets the D-Bus interfaces associated with `object`.
        get {
            let result = g_dbus_object_get_interfaces(dbus_object_ptr)
        let rv = GLib.ListRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Gets the object path for `object`.
    @inlinable var objectPath: String! {
        /// Gets the object path for `object`.
        get {
            let result = g_dbus_object_get_object_path(dbus_object_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }


}



// MARK: - DBusObjectManager Interface

/// The `GDBusObjectManager` type is the base type for service- and
/// client-side implementations of the standardized
/// [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html`standard-interfaces-objectmanager`)
/// interface.
/// 
/// See `GDBusObjectManagerClient` for the client-side implementation
/// and `GDBusObjectManagerServer` for the service-side implementation.
///
/// The `DBusObjectManagerProtocol` protocol exposes the methods and properties of an underlying `GDBusObjectManager` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusObjectManager`.
/// Alternatively, use `DBusObjectManagerRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusObjectManagerProtocol {
        /// Untyped pointer to the underlying `GDBusObjectManager` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusObjectManager` instance.
    var dbus_object_manager_ptr: UnsafeMutablePointer<GDBusObjectManager>! { get }

    /// Required Initialiser for types conforming to `DBusObjectManagerProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `GDBusObjectManager` type is the base type for service- and
/// client-side implementations of the standardized
/// [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html`standard-interfaces-objectmanager`)
/// interface.
/// 
/// See `GDBusObjectManagerClient` for the client-side implementation
/// and `GDBusObjectManagerServer` for the service-side implementation.
///
/// The `DBusObjectManagerRef` type acts as a lightweight Swift reference to an underlying `GDBusObjectManager` instance.
/// It exposes methods that can operate on this data type through `DBusObjectManagerProtocol` conformance.
/// Use `DBusObjectManagerRef` only as an `unowned` reference to an existing `GDBusObjectManager` instance.
///
public struct DBusObjectManagerRef: DBusObjectManagerProtocol {
        /// Untyped pointer to the underlying `GDBusObjectManager` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_object_manager_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusObjectManagerRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusObjectManager>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusObjectManager>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusObjectManager>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusObjectManager>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusObjectManagerProtocol`
    @inlinable init<T: DBusObjectManagerProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `GDBusObjectManager` type is the base type for service- and
/// client-side implementations of the standardized
/// [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html`standard-interfaces-objectmanager`)
/// interface.
/// 
/// See `GDBusObjectManagerClient` for the client-side implementation
/// and `GDBusObjectManagerServer` for the service-side implementation.
///
/// The `DBusObjectManager` type acts as an owner of an underlying `GDBusObjectManager` instance.
/// It provides the methods that can operate on this data type through `DBusObjectManagerProtocol` conformance.
/// Use `DBusObjectManager` as a strong reference or owner of a `GDBusObjectManager` instance.
///
open class DBusObjectManager: DBusObjectManagerProtocol {
        /// Untyped pointer to the underlying `GDBusObjectManager` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_object_manager_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectManager` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusObjectManager>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectManager` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusObjectManager>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectManager` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectManager` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectManager` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusObjectManager>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectManager` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusObjectManager>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GDBusObjectManager` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `DBusObjectManager` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusObjectManager>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GDBusObjectManager, cannot ref(dbus_object_manager_ptr)
    }

    /// Reference intialiser for a related type that implements `DBusObjectManagerProtocol`
    /// `GDBusObjectManager` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `DBusObjectManagerProtocol`
    @inlinable public init<T: DBusObjectManagerProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GDBusObjectManager, cannot ref(dbus_object_manager_ptr)
    }

    /// Do-nothing destructor for `GDBusObjectManager`.
    deinit {
        // no reference counting for GDBusObjectManager, cannot unref(dbus_object_manager_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GDBusObjectManager, cannot ref(dbus_object_manager_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GDBusObjectManager, cannot ref(dbus_object_manager_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GDBusObjectManager, cannot ref(dbus_object_manager_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GDBusObjectManager, cannot ref(dbus_object_manager_ptr)
    }



}

// MARK: no DBusObjectManager properties

public enum DBusObjectManagerSignalName: String, SignalNameProtocol {
    /// Emitted when `interface` is added to `object`.
    /// 
    /// This signal exists purely as a convenience to avoid having to
    /// connect signals to all objects managed by `manager`.
    case interfaceAdded = "interface-added"
    /// Emitted when `interface` has been removed from `object`.
    /// 
    /// This signal exists purely as a convenience to avoid having to
    /// connect signals to all objects managed by `manager`.
    case interfaceRemoved = "interface-removed"
    /// Emitted when `object` is added to `manager`.
    case objectAdded = "object-added"
    /// Emitted when `object` is removed from `manager`.
    case objectRemoved = "object-removed"

}

// MARK: DBusObjectManager signals
public extension DBusObjectManagerProtocol {
    /// Connect a Swift signal handler to the given, typed `DBusObjectManagerSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DBusObjectManagerSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        GLibObject.ObjectRef(raw: ptr).connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `DBusObjectManagerSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DBusObjectManagerSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        GLibObject.ObjectRef(raw: ptr).connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when `interface` is added to `object`.
    /// 
    /// This signal exists purely as a convenience to avoid having to
    /// connect signals to all objects managed by `manager`.
    /// - Note: This represents the underlying `interface-added` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter object: The `GDBusObject` on which an interface was added.
    /// - Parameter interface: The `GDBusInterface` that was added.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `interfaceAdded` signal is emitted
    @discardableResult @inlinable func onInterfaceAdded(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusObjectManagerRef, _ object: DBusObjectRef, _ interface: DBusInterfaceRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusObjectManagerRef, DBusObjectRef, DBusInterfaceRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusObjectManagerRef(raw: unownedSelf), DBusObjectRef(raw: arg1), DBusInterfaceRef(raw: arg2)))
            return output
        }
        return connect(
            signal: .interfaceAdded,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `interface-added` signal for using the `connect(signal:)` methods
    static var interfaceAddedSignal: DBusObjectManagerSignalName { .interfaceAdded }
    
    /// Emitted when `interface` has been removed from `object`.
    /// 
    /// This signal exists purely as a convenience to avoid having to
    /// connect signals to all objects managed by `manager`.
    /// - Note: This represents the underlying `interface-removed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter object: The `GDBusObject` on which an interface was removed.
    /// - Parameter interface: The `GDBusInterface` that was removed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `interfaceRemoved` signal is emitted
    @discardableResult @inlinable func onInterfaceRemoved(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusObjectManagerRef, _ object: DBusObjectRef, _ interface: DBusInterfaceRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusObjectManagerRef, DBusObjectRef, DBusInterfaceRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusObjectManagerRef(raw: unownedSelf), DBusObjectRef(raw: arg1), DBusInterfaceRef(raw: arg2)))
            return output
        }
        return connect(
            signal: .interfaceRemoved,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `interface-removed` signal for using the `connect(signal:)` methods
    static var interfaceRemovedSignal: DBusObjectManagerSignalName { .interfaceRemoved }
    
    /// Emitted when `object` is added to `manager`.
    /// - Note: This represents the underlying `object-added` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter object: The `GDBusObject` that was added.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `objectAdded` signal is emitted
    @discardableResult @inlinable func onObjectAdded(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusObjectManagerRef, _ object: DBusObjectRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusObjectManagerRef, DBusObjectRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusObjectManagerRef(raw: unownedSelf), DBusObjectRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .objectAdded,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `object-added` signal for using the `connect(signal:)` methods
    static var objectAddedSignal: DBusObjectManagerSignalName { .objectAdded }
    
    /// Emitted when `object` is removed from `manager`.
    /// - Note: This represents the underlying `object-removed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter object: The `GDBusObject` that was removed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `objectRemoved` signal is emitted
    @discardableResult @inlinable func onObjectRemoved(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusObjectManagerRef, _ object: DBusObjectRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusObjectManagerRef, DBusObjectRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusObjectManagerRef(raw: unownedSelf), DBusObjectRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .objectRemoved,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `object-removed` signal for using the `connect(signal:)` methods
    static var objectRemovedSignal: DBusObjectManagerSignalName { .objectRemoved }
    
    
}

// MARK: DBusObjectManager Interface: DBusObjectManagerProtocol extension (methods and fields)
public extension DBusObjectManagerProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusObjectManager` instance.
    @inlinable var dbus_object_manager_ptr: UnsafeMutablePointer<GDBusObjectManager>! { return ptr?.assumingMemoryBound(to: GDBusObjectManager.self) }

    /// Gets the interface proxy for `interface_name` at `object_path`, if
    /// any.
    @inlinable func getInterface(objectPath: UnsafePointer<gchar>!, interfaceName: UnsafePointer<gchar>!) -> GIO.DBusInterfaceRef! {
        let result = g_dbus_object_manager_get_interface(dbus_object_manager_ptr, objectPath, interfaceName)
        let rv = DBusInterfaceRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the `GDBusObject` at `object_path`, if any.
    @inlinable func getObject(objectPath: UnsafePointer<gchar>!) -> GIO.DBusObjectRef! {
        let result = g_dbus_object_manager_get_object(dbus_object_manager_ptr, objectPath)
        let rv = DBusObjectRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the object path that `manager` is for.
    @inlinable func getObjectPath() -> String! {
        let result = g_dbus_object_manager_get_object_path(dbus_object_manager_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets all `GDBusObject` objects known to `manager`.
    @inlinable func getObjects() -> GLib.ListRef! {
        let result = g_dbus_object_manager_get_objects(dbus_object_manager_ptr)
        let rv = GLib.ListRef(gconstpointer: gconstpointer(result))
        return rv
    }
    /// Gets the object path that `manager` is for.
    @inlinable var objectPath: String! {
        /// Gets the object path that `manager` is for.
        get {
            let result = g_dbus_object_manager_get_object_path(dbus_object_manager_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// Gets all `GDBusObject` objects known to `manager`.
    @inlinable var objects: GLib.ListRef! {
        /// Gets all `GDBusObject` objects known to `manager`.
        get {
            let result = g_dbus_object_manager_get_objects(dbus_object_manager_ptr)
        let rv = GLib.ListRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }


}



// MARK: - DatagramBased Interface

/// A `GDatagramBased` is a networking interface for representing datagram-based
/// communications. It is a more or less direct mapping of the core parts of the
/// BSD socket API in a portable GObject interface. It is implemented by
/// `GSocket`, which wraps the UNIX socket API on UNIX and winsock2 on Windows.
/// 
/// `GDatagramBased` is entirely platform independent, and is intended to be used
/// alongside higher-level networking APIs such as `GIOStream`.
/// 
/// It uses vectored scatter/gather I/O by default, allowing for many messages
/// to be sent or received in a single call. Where possible, implementations of
/// the interface should take advantage of vectored I/O to minimise processing
/// or system calls. For example, `GSocket` uses `recvmmsg()` and `sendmmsg()` where
/// possible. Callers should take advantage of scatter/gather I/O (the use of
/// multiple buffers per message) to avoid unnecessary copying of data to
/// assemble or disassemble a message.
/// 
/// Each `GDatagramBased` operation has a timeout parameter which may be negative
/// for blocking behaviour, zero for non-blocking behaviour, or positive for
/// timeout behaviour. A blocking operation blocks until finished or there is an
/// error. A non-blocking operation will return immediately with a
/// `G_IO_ERROR_WOULD_BLOCK` error if it cannot make progress. A timeout operation
/// will block until the operation is complete or the timeout expires; if the
/// timeout expires it will return what progress it made, or
/// `G_IO_ERROR_TIMED_OUT` if no progress was made. To know when a call would
/// successfully run you can call `g_datagram_based_condition_check()` or
/// `g_datagram_based_condition_wait()`. You can also use
/// `g_datagram_based_create_source()` and attach it to a `GMainContext` to get
/// callbacks when I/O is possible.
/// 
/// When running a non-blocking operation applications should always be able to
/// handle getting a `G_IO_ERROR_WOULD_BLOCK` error even when some other function
/// said that I/O was possible. This can easily happen in case of a race
/// condition in the application, but it can also happen for other reasons. For
/// instance, on Windows a socket is always seen as writable until a write
/// returns `G_IO_ERROR_WOULD_BLOCK`.
/// 
/// As with `GSocket`, `GDatagramBaseds` can be either connection oriented (for
/// example, SCTP) or connectionless (for example, UDP). `GDatagramBaseds` must be
/// datagram-based, not stream-based. The interface does not cover connection
/// establishment  use methods on the underlying type to establish a connection
/// before sending and receiving data through the `GDatagramBased` API. For
/// connectionless socket types the target/source address is specified or
/// received in each I/O operation.
/// 
/// Like most other APIs in GLib, `GDatagramBased` is not inherently thread safe.
/// To use a `GDatagramBased` concurrently from multiple threads, you must
/// implement your own locking.
///
/// The `DatagramBasedProtocol` protocol exposes the methods and properties of an underlying `GDatagramBased` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DatagramBased`.
/// Alternatively, use `DatagramBasedRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DatagramBasedProtocol {
        /// Untyped pointer to the underlying `GDatagramBased` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDatagramBased` instance.
    var datagram_based_ptr: UnsafeMutablePointer<GDatagramBased>! { get }

    /// Required Initialiser for types conforming to `DatagramBasedProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GDatagramBased` is a networking interface for representing datagram-based
/// communications. It is a more or less direct mapping of the core parts of the
/// BSD socket API in a portable GObject interface. It is implemented by
/// `GSocket`, which wraps the UNIX socket API on UNIX and winsock2 on Windows.
/// 
/// `GDatagramBased` is entirely platform independent, and is intended to be used
/// alongside higher-level networking APIs such as `GIOStream`.
/// 
/// It uses vectored scatter/gather I/O by default, allowing for many messages
/// to be sent or received in a single call. Where possible, implementations of
/// the interface should take advantage of vectored I/O to minimise processing
/// or system calls. For example, `GSocket` uses `recvmmsg()` and `sendmmsg()` where
/// possible. Callers should take advantage of scatter/gather I/O (the use of
/// multiple buffers per message) to avoid unnecessary copying of data to
/// assemble or disassemble a message.
/// 
/// Each `GDatagramBased` operation has a timeout parameter which may be negative
/// for blocking behaviour, zero for non-blocking behaviour, or positive for
/// timeout behaviour. A blocking operation blocks until finished or there is an
/// error. A non-blocking operation will return immediately with a
/// `G_IO_ERROR_WOULD_BLOCK` error if it cannot make progress. A timeout operation
/// will block until the operation is complete or the timeout expires; if the
/// timeout expires it will return what progress it made, or
/// `G_IO_ERROR_TIMED_OUT` if no progress was made. To know when a call would
/// successfully run you can call `g_datagram_based_condition_check()` or
/// `g_datagram_based_condition_wait()`. You can also use
/// `g_datagram_based_create_source()` and attach it to a `GMainContext` to get
/// callbacks when I/O is possible.
/// 
/// When running a non-blocking operation applications should always be able to
/// handle getting a `G_IO_ERROR_WOULD_BLOCK` error even when some other function
/// said that I/O was possible. This can easily happen in case of a race
/// condition in the application, but it can also happen for other reasons. For
/// instance, on Windows a socket is always seen as writable until a write
/// returns `G_IO_ERROR_WOULD_BLOCK`.
/// 
/// As with `GSocket`, `GDatagramBaseds` can be either connection oriented (for
/// example, SCTP) or connectionless (for example, UDP). `GDatagramBaseds` must be
/// datagram-based, not stream-based. The interface does not cover connection
/// establishment  use methods on the underlying type to establish a connection
/// before sending and receiving data through the `GDatagramBased` API. For
/// connectionless socket types the target/source address is specified or
/// received in each I/O operation.
/// 
/// Like most other APIs in GLib, `GDatagramBased` is not inherently thread safe.
/// To use a `GDatagramBased` concurrently from multiple threads, you must
/// implement your own locking.
///
/// The `DatagramBasedRef` type acts as a lightweight Swift reference to an underlying `GDatagramBased` instance.
/// It exposes methods that can operate on this data type through `DatagramBasedProtocol` conformance.
/// Use `DatagramBasedRef` only as an `unowned` reference to an existing `GDatagramBased` instance.
///
public struct DatagramBasedRef: DatagramBasedProtocol {
        /// Untyped pointer to the underlying `GDatagramBased` instance.
    /// For type-safe access, use the generated, typed pointer `datagram_based_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DatagramBasedRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDatagramBased>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDatagramBased>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDatagramBased>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDatagramBased>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DatagramBasedProtocol`
    @inlinable init<T: DatagramBasedProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DatagramBasedProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DatagramBasedProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DatagramBasedProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DatagramBasedProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DatagramBasedProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// A `GDatagramBased` is a networking interface for representing datagram-based
/// communications. It is a more or less direct mapping of the core parts of the
/// BSD socket API in a portable GObject interface. It is implemented by
/// `GSocket`, which wraps the UNIX socket API on UNIX and winsock2 on Windows.
/// 
/// `GDatagramBased` is entirely platform independent, and is intended to be used
/// alongside higher-level networking APIs such as `GIOStream`.
/// 
/// It uses vectored scatter/gather I/O by default, allowing for many messages
/// to be sent or received in a single call. Where possible, implementations of
/// the interface should take advantage of vectored I/O to minimise processing
/// or system calls. For example, `GSocket` uses `recvmmsg()` and `sendmmsg()` where
/// possible. Callers should take advantage of scatter/gather I/O (the use of
/// multiple buffers per message) to avoid unnecessary copying of data to
/// assemble or disassemble a message.
/// 
/// Each `GDatagramBased` operation has a timeout parameter which may be negative
/// for blocking behaviour, zero for non-blocking behaviour, or positive for
/// timeout behaviour. A blocking operation blocks until finished or there is an
/// error. A non-blocking operation will return immediately with a
/// `G_IO_ERROR_WOULD_BLOCK` error if it cannot make progress. A timeout operation
/// will block until the operation is complete or the timeout expires; if the
/// timeout expires it will return what progress it made, or
/// `G_IO_ERROR_TIMED_OUT` if no progress was made. To know when a call would
/// successfully run you can call `g_datagram_based_condition_check()` or
/// `g_datagram_based_condition_wait()`. You can also use
/// `g_datagram_based_create_source()` and attach it to a `GMainContext` to get
/// callbacks when I/O is possible.
/// 
/// When running a non-blocking operation applications should always be able to
/// handle getting a `G_IO_ERROR_WOULD_BLOCK` error even when some other function
/// said that I/O was possible. This can easily happen in case of a race
/// condition in the application, but it can also happen for other reasons. For
/// instance, on Windows a socket is always seen as writable until a write
/// returns `G_IO_ERROR_WOULD_BLOCK`.
/// 
/// As with `GSocket`, `GDatagramBaseds` can be either connection oriented (for
/// example, SCTP) or connectionless (for example, UDP). `GDatagramBaseds` must be
/// datagram-based, not stream-based. The interface does not cover connection
/// establishment  use methods on the underlying type to establish a connection
/// before sending and receiving data through the `GDatagramBased` API. For
/// connectionless socket types the target/source address is specified or
/// received in each I/O operation.
/// 
/// Like most other APIs in GLib, `GDatagramBased` is not inherently thread safe.
/// To use a `GDatagramBased` concurrently from multiple threads, you must
/// implement your own locking.
///
/// The `DatagramBased` type acts as an owner of an underlying `GDatagramBased` instance.
/// It provides the methods that can operate on this data type through `DatagramBasedProtocol` conformance.
/// Use `DatagramBased` as a strong reference or owner of a `GDatagramBased` instance.
///
open class DatagramBased: DatagramBasedProtocol {
        /// Untyped pointer to the underlying `GDatagramBased` instance.
    /// For type-safe access, use the generated, typed pointer `datagram_based_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DatagramBased` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDatagramBased>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DatagramBased` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDatagramBased>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DatagramBased` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DatagramBased` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DatagramBased` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDatagramBased>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DatagramBased` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDatagramBased>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GDatagramBased` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `DatagramBased` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDatagramBased>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GDatagramBased, cannot ref(datagram_based_ptr)
    }

    /// Reference intialiser for a related type that implements `DatagramBasedProtocol`
    /// `GDatagramBased` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `DatagramBasedProtocol`
    @inlinable public init<T: DatagramBasedProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GDatagramBased, cannot ref(datagram_based_ptr)
    }

    /// Do-nothing destructor for `GDatagramBased`.
    deinit {
        // no reference counting for GDatagramBased, cannot unref(datagram_based_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DatagramBasedProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DatagramBasedProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GDatagramBased, cannot ref(datagram_based_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DatagramBasedProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DatagramBasedProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GDatagramBased, cannot ref(datagram_based_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DatagramBasedProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DatagramBasedProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GDatagramBased, cannot ref(datagram_based_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DatagramBasedProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DatagramBasedProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GDatagramBased, cannot ref(datagram_based_ptr)
    }



}

// MARK: no DatagramBased properties

// MARK: no DatagramBased signals

// MARK: DatagramBased has no signals
// MARK: DatagramBased Interface: DatagramBasedProtocol extension (methods and fields)
public extension DatagramBasedProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDatagramBased` instance.
    @inlinable var datagram_based_ptr: UnsafeMutablePointer<GDatagramBased>! { return ptr?.assumingMemoryBound(to: GDatagramBased.self) }

    /// Checks on the readiness of `datagram_based` to perform operations. The
    /// operations specified in `condition` are checked for and masked against the
    /// currently-satisfied conditions on `datagram_based`. The result is returned.
    /// 
    /// `G_IO_IN` will be set in the return value if data is available to read with
    /// `g_datagram_based_receive_messages()`, or if the connection is closed remotely
    /// (EOS); and if the datagram_based has not been closed locally using some
    /// implementation-specific method (such as `g_socket_close()` or
    /// `g_socket_shutdown()` with `shutdown_read` set, if its a `GSocket`).
    /// 
    /// If the connection is shut down or closed (by calling `g_socket_close()` or
    /// `g_socket_shutdown()` with `shutdown_read` set, if its a `GSocket`, for
    /// example), all calls to this function will return `G_IO_ERROR_CLOSED`.
    /// 
    /// `G_IO_OUT` will be set if it is expected that at least one byte can be sent
    /// using `g_datagram_based_send_messages()` without blocking. It will not be set
    /// if the datagram_based has been closed locally.
    /// 
    /// `G_IO_HUP` will be set if the connection has been closed locally.
    /// 
    /// `G_IO_ERR` will be set if there was an asynchronous error in transmitting data
    /// previously enqueued using `g_datagram_based_send_messages()`.
    /// 
    /// Note that on Windows, it is possible for an operation to return
    /// `G_IO_ERROR_WOULD_BLOCK` even immediately after
    /// `g_datagram_based_condition_check()` has claimed that the `GDatagramBased` is
    /// ready for writing. Rather than calling `g_datagram_based_condition_check()` and
    /// then writing to the `GDatagramBased` if it succeeds, it is generally better to
    /// simply try writing right away, and try again later if the initial attempt
    /// returns `G_IO_ERROR_WOULD_BLOCK`.
    /// 
    /// It is meaningless to specify `G_IO_ERR` or `G_IO_HUP` in `condition`; these
    /// conditions will always be set in the output if they are true. Apart from
    /// these flags, the output is guaranteed to be masked by `condition`.
    /// 
    /// This call never blocks.
    @inlinable func conditionCheck(condition: GLib.IOCondition) -> GLib.IOCondition {
        let result = g_datagram_based_condition_check(datagram_based_ptr, condition.value)
        let rv = IOCondition(result)
        return rv
    }

    /// Waits for up to `timeout` microseconds for condition to become true on
    /// `datagram_based`. If the condition is met, `true` is returned.
    /// 
    /// If `cancellable` is cancelled before the condition is met, or if `timeout` is
    /// reached before the condition is met, then `false` is returned and `error` is
    /// set appropriately (`G_IO_ERROR_CANCELLED` or `G_IO_ERROR_TIMED_OUT`).
    @inlinable func conditionWait(condition: GLib.IOCondition, timeout: gint64, cancellable: CancellableRef? = nil) throws -> Bool {
            var error: UnsafeMutablePointer<GError>?
        let result = g_datagram_based_condition_wait(datagram_based_ptr, condition.value, timeout, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
            return rv
    }
    /// Waits for up to `timeout` microseconds for condition to become true on
    /// `datagram_based`. If the condition is met, `true` is returned.
    /// 
    /// If `cancellable` is cancelled before the condition is met, or if `timeout` is
    /// reached before the condition is met, then `false` is returned and `error` is
    /// set appropriately (`G_IO_ERROR_CANCELLED` or `G_IO_ERROR_TIMED_OUT`).
    @inlinable func conditionWait<CancellableT: CancellableProtocol>(condition: GLib.IOCondition, timeout: gint64, cancellable: CancellableT?) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_datagram_based_condition_wait(datagram_based_ptr, condition.value, timeout, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Creates a `GSource` that can be attached to a `GMainContext` to monitor for
    /// the availability of the specified `condition` on the `GDatagramBased`. The
    /// `GSource` keeps a reference to the `datagram_based`.
    /// 
    /// The callback on the source is of the `GDatagramBasedSourceFunc` type.
    /// 
    /// It is meaningless to specify `G_IO_ERR` or `G_IO_HUP` in `condition`; these
    /// conditions will always be reported in the callback if they are true.
    /// 
    /// If non-`nil`, `cancellable` can be used to cancel the source, which will
    /// cause the source to trigger, reporting the current condition (which is
    /// likely 0 unless cancellation happened at the same time as a condition
    /// change). You can check for this in the callback using
    /// `g_cancellable_is_cancelled()`.
    @inlinable func createSource(condition: GLib.IOCondition, cancellable: CancellableRef? = nil) -> GLib.SourceRef! {
            let result = g_datagram_based_create_source(datagram_based_ptr, condition.value, cancellable?.cancellable_ptr)
        let rv = GLib.SourceRef(gconstpointer: gconstpointer(result))
            return rv
    }
    /// Creates a `GSource` that can be attached to a `GMainContext` to monitor for
    /// the availability of the specified `condition` on the `GDatagramBased`. The
    /// `GSource` keeps a reference to the `datagram_based`.
    /// 
    /// The callback on the source is of the `GDatagramBasedSourceFunc` type.
    /// 
    /// It is meaningless to specify `G_IO_ERR` or `G_IO_HUP` in `condition`; these
    /// conditions will always be reported in the callback if they are true.
    /// 
    /// If non-`nil`, `cancellable` can be used to cancel the source, which will
    /// cause the source to trigger, reporting the current condition (which is
    /// likely 0 unless cancellation happened at the same time as a condition
    /// change). You can check for this in the callback using
    /// `g_cancellable_is_cancelled()`.
    @inlinable func createSource<CancellableT: CancellableProtocol>(condition: GLib.IOCondition, cancellable: CancellableT?) -> GLib.SourceRef! {
        let result = g_datagram_based_create_source(datagram_based_ptr, condition.value, cancellable?.cancellable_ptr)
        let rv = GLib.SourceRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Receive one or more data messages from `datagram_based` in one go.
    /// 
    /// `messages` must point to an array of `GInputMessage` structs and
    /// `num_messages` must be the length of this array. Each `GInputMessage`
    /// contains a pointer to an array of `GInputVector` structs describing the
    /// buffers that the data received in each message will be written to.
    /// 
    /// `flags` modify how all messages are received. The commonly available
    /// arguments for this are available in the `GSocketMsgFlags` enum, but the
    /// values there are the same as the system values, and the flags
    /// are passed in as-is, so you can pass in system-specific flags too. These
    /// flags affect the overall receive operation. Flags affecting individual
    /// messages are returned in `GInputMessage.flags`.
    /// 
    /// The other members of `GInputMessage` are treated as described in its
    /// documentation.
    /// 
    /// If `timeout` is negative the call will block until `num_messages` have been
    /// received, the connection is closed remotely (EOS), `cancellable` is cancelled,
    /// or an error occurs.
    /// 
    /// If `timeout` is 0 the call will return up to `num_messages` without blocking,
    /// or `G_IO_ERROR_WOULD_BLOCK` if no messages are queued in the operating system
    /// to be received.
    /// 
    /// If `timeout` is positive the call will block on the same conditions as if
    /// `timeout` were negative. If the timeout is reached
    /// before any messages are received, `G_IO_ERROR_TIMED_OUT` is returned,
    /// otherwise it will return the number of messages received before timing out.
    /// (Note: This is effectively the behaviour of `MSG_WAITFORONE` with
    /// `recvmmsg()`.)
    /// 
    /// To be notified when messages are available, wait for the `G_IO_IN` condition.
    /// Note though that you may still receive `G_IO_ERROR_WOULD_BLOCK` from
    /// `g_datagram_based_receive_messages()` even if you were previously notified of a
    /// `G_IO_IN` condition.
    /// 
    /// If the remote peer closes the connection, any messages queued in the
    /// underlying receive buffer will be returned, and subsequent calls to
    /// `g_datagram_based_receive_messages()` will return 0 (with no error set).
    /// 
    /// If the connection is shut down or closed (by calling `g_socket_close()` or
    /// `g_socket_shutdown()` with `shutdown_read` set, if its a `GSocket`, for
    /// example), all calls to this function will return `G_IO_ERROR_CLOSED`.
    /// 
    /// On error -1 is returned and `error` is set accordingly. An error will only
    /// be returned if zero messages could be received; otherwise the number of
    /// messages successfully received before the error will be returned. If
    /// `cancellable` is cancelled, `G_IO_ERROR_CANCELLED` is returned as with any
    /// other error.
    @inlinable func receive(messages: UnsafeMutablePointer<GInputMessage>!, numMessages: Int, flags: Int, timeout: gint64, cancellable: CancellableRef? = nil) throws -> Int {
            var error: UnsafeMutablePointer<GError>?
        let result = g_datagram_based_receive_messages(datagram_based_ptr, messages, guint(numMessages), gint(flags), timeout, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = Int(result)
            return rv
    }
    /// Receive one or more data messages from `datagram_based` in one go.
    /// 
    /// `messages` must point to an array of `GInputMessage` structs and
    /// `num_messages` must be the length of this array. Each `GInputMessage`
    /// contains a pointer to an array of `GInputVector` structs describing the
    /// buffers that the data received in each message will be written to.
    /// 
    /// `flags` modify how all messages are received. The commonly available
    /// arguments for this are available in the `GSocketMsgFlags` enum, but the
    /// values there are the same as the system values, and the flags
    /// are passed in as-is, so you can pass in system-specific flags too. These
    /// flags affect the overall receive operation. Flags affecting individual
    /// messages are returned in `GInputMessage.flags`.
    /// 
    /// The other members of `GInputMessage` are treated as described in its
    /// documentation.
    /// 
    /// If `timeout` is negative the call will block until `num_messages` have been
    /// received, the connection is closed remotely (EOS), `cancellable` is cancelled,
    /// or an error occurs.
    /// 
    /// If `timeout` is 0 the call will return up to `num_messages` without blocking,
    /// or `G_IO_ERROR_WOULD_BLOCK` if no messages are queued in the operating system
    /// to be received.
    /// 
    /// If `timeout` is positive the call will block on the same conditions as if
    /// `timeout` were negative. If the timeout is reached
    /// before any messages are received, `G_IO_ERROR_TIMED_OUT` is returned,
    /// otherwise it will return the number of messages received before timing out.
    /// (Note: This is effectively the behaviour of `MSG_WAITFORONE` with
    /// `recvmmsg()`.)
    /// 
    /// To be notified when messages are available, wait for the `G_IO_IN` condition.
    /// Note though that you may still receive `G_IO_ERROR_WOULD_BLOCK` from
    /// `g_datagram_based_receive_messages()` even if you were previously notified of a
    /// `G_IO_IN` condition.
    /// 
    /// If the remote peer closes the connection, any messages queued in the
    /// underlying receive buffer will be returned, and subsequent calls to
    /// `g_datagram_based_receive_messages()` will return 0 (with no error set).
    /// 
    /// If the connection is shut down or closed (by calling `g_socket_close()` or
    /// `g_socket_shutdown()` with `shutdown_read` set, if its a `GSocket`, for
    /// example), all calls to this function will return `G_IO_ERROR_CLOSED`.
    /// 
    /// On error -1 is returned and `error` is set accordingly. An error will only
    /// be returned if zero messages could be received; otherwise the number of
    /// messages successfully received before the error will be returned. If
    /// `cancellable` is cancelled, `G_IO_ERROR_CANCELLED` is returned as with any
    /// other error.
    @inlinable func receive<CancellableT: CancellableProtocol>(messages: UnsafeMutablePointer<GInputMessage>!, numMessages: Int, flags: Int, timeout: gint64, cancellable: CancellableT?) throws -> Int {
        var error: UnsafeMutablePointer<GError>?
        let result = g_datagram_based_receive_messages(datagram_based_ptr, messages, guint(numMessages), gint(flags), timeout, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = Int(result)
        return rv
    }

    /// Send one or more data messages from `datagram_based` in one go.
    /// 
    /// `messages` must point to an array of `GOutputMessage` structs and
    /// `num_messages` must be the length of this array. Each `GOutputMessage`
    /// contains an address to send the data to, and a pointer to an array of
    /// `GOutputVector` structs to describe the buffers that the data to be sent
    /// for each message will be gathered from.
    /// 
    /// `flags` modify how the message is sent. The commonly available arguments
    /// for this are available in the `GSocketMsgFlags` enum, but the
    /// values there are the same as the system values, and the flags
    /// are passed in as-is, so you can pass in system-specific flags too.
    /// 
    /// The other members of `GOutputMessage` are treated as described in its
    /// documentation.
    /// 
    /// If `timeout` is negative the call will block until `num_messages` have been
    /// sent, `cancellable` is cancelled, or an error occurs.
    /// 
    /// If `timeout` is 0 the call will send up to `num_messages` without blocking,
    /// or will return `G_IO_ERROR_WOULD_BLOCK` if there is no space to send messages.
    /// 
    /// If `timeout` is positive the call will block on the same conditions as if
    /// `timeout` were negative. If the timeout is reached before any messages are
    /// sent, `G_IO_ERROR_TIMED_OUT` is returned, otherwise it will return the number
    /// of messages sent before timing out.
    /// 
    /// To be notified when messages can be sent, wait for the `G_IO_OUT` condition.
    /// Note though that you may still receive `G_IO_ERROR_WOULD_BLOCK` from
    /// `g_datagram_based_send_messages()` even if you were previously notified of a
    /// `G_IO_OUT` condition. (On Windows in particular, this is very common due to
    /// the way the underlying APIs work.)
    /// 
    /// If the connection is shut down or closed (by calling `g_socket_close()` or
    /// `g_socket_shutdown()` with `shutdown_write` set, if its a `GSocket`, for
    /// example), all calls to this function will return `G_IO_ERROR_CLOSED`.
    /// 
    /// On error -1 is returned and `error` is set accordingly. An error will only
    /// be returned if zero messages could be sent; otherwise the number of messages
    /// successfully sent before the error will be returned. If `cancellable` is
    /// cancelled, `G_IO_ERROR_CANCELLED` is returned as with any other error.
    @inlinable func send(messages: UnsafeMutablePointer<GOutputMessage>!, numMessages: Int, flags: Int, timeout: gint64, cancellable: CancellableRef? = nil) throws -> Int {
            var error: UnsafeMutablePointer<GError>?
        let result = g_datagram_based_send_messages(datagram_based_ptr, messages, guint(numMessages), gint(flags), timeout, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = Int(result)
            return rv
    }
    /// Send one or more data messages from `datagram_based` in one go.
    /// 
    /// `messages` must point to an array of `GOutputMessage` structs and
    /// `num_messages` must be the length of this array. Each `GOutputMessage`
    /// contains an address to send the data to, and a pointer to an array of
    /// `GOutputVector` structs to describe the buffers that the data to be sent
    /// for each message will be gathered from.
    /// 
    /// `flags` modify how the message is sent. The commonly available arguments
    /// for this are available in the `GSocketMsgFlags` enum, but the
    /// values there are the same as the system values, and the flags
    /// are passed in as-is, so you can pass in system-specific flags too.
    /// 
    /// The other members of `GOutputMessage` are treated as described in its
    /// documentation.
    /// 
    /// If `timeout` is negative the call will block until `num_messages` have been
    /// sent, `cancellable` is cancelled, or an error occurs.
    /// 
    /// If `timeout` is 0 the call will send up to `num_messages` without blocking,
    /// or will return `G_IO_ERROR_WOULD_BLOCK` if there is no space to send messages.
    /// 
    /// If `timeout` is positive the call will block on the same conditions as if
    /// `timeout` were negative. If the timeout is reached before any messages are
    /// sent, `G_IO_ERROR_TIMED_OUT` is returned, otherwise it will return the number
    /// of messages sent before timing out.
    /// 
    /// To be notified when messages can be sent, wait for the `G_IO_OUT` condition.
    /// Note though that you may still receive `G_IO_ERROR_WOULD_BLOCK` from
    /// `g_datagram_based_send_messages()` even if you were previously notified of a
    /// `G_IO_OUT` condition. (On Windows in particular, this is very common due to
    /// the way the underlying APIs work.)
    /// 
    /// If the connection is shut down or closed (by calling `g_socket_close()` or
    /// `g_socket_shutdown()` with `shutdown_write` set, if its a `GSocket`, for
    /// example), all calls to this function will return `G_IO_ERROR_CLOSED`.
    /// 
    /// On error -1 is returned and `error` is set accordingly. An error will only
    /// be returned if zero messages could be sent; otherwise the number of messages
    /// successfully sent before the error will be returned. If `cancellable` is
    /// cancelled, `G_IO_ERROR_CANCELLED` is returned as with any other error.
    @inlinable func send<CancellableT: CancellableProtocol>(messages: UnsafeMutablePointer<GOutputMessage>!, numMessages: Int, flags: Int, timeout: gint64, cancellable: CancellableT?) throws -> Int {
        var error: UnsafeMutablePointer<GError>?
        let result = g_datagram_based_send_messages(datagram_based_ptr, messages, guint(numMessages), gint(flags), timeout, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = Int(result)
        return rv
    }

    /// Creates a new `GDtlsClientConnection` wrapping `base_socket` which is
    /// assumed to communicate with the server identified by `server_identity`.
    @inlinable func dtlsClientConnectionNew(serverIdentity: SocketConnectableRef? = nil) throws -> GIO.DtlsClientConnectionRef! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dtls_client_connection_new(datagram_based_ptr, serverIdentity?.socket_connectable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = DtlsClientConnectionRef(gconstpointer: gconstpointer(result))
            return rv
    }
    /// Creates a new `GDtlsClientConnection` wrapping `base_socket` which is
    /// assumed to communicate with the server identified by `server_identity`.
    @inlinable func dtlsClientConnectionNew<SocketConnectableT: SocketConnectableProtocol>(serverIdentity: SocketConnectableT?) throws -> GIO.DtlsClientConnectionRef! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dtls_client_connection_new(datagram_based_ptr, serverIdentity?.socket_connectable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = DtlsClientConnectionRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Creates a new `GDtlsServerConnection` wrapping `base_socket`.
    @inlinable func dtlsServerConnectionNew(certificate: TLSCertificateRef? = nil) throws -> GIO.DtlsServerConnectionRef! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dtls_server_connection_new(datagram_based_ptr, certificate?.tls_certificate_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = DtlsServerConnectionRef(gconstpointer: gconstpointer(result))
            return rv
    }
    /// Creates a new `GDtlsServerConnection` wrapping `base_socket`.
    @inlinable func dtlsServerConnectionNew<TLSCertificateT: TLSCertificateProtocol>(certificate: TLSCertificateT?) throws -> GIO.DtlsServerConnectionRef! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dtls_server_connection_new(datagram_based_ptr, certificate?.tls_certificate_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = DtlsServerConnectionRef(gconstpointer: gconstpointer(result))
        return rv
    }


}



// MARK: - DebugController Interface

/// `GDebugController` is an interface to expose control of debugging features and
/// debug output.
/// 
/// It is implemented on Linux using `GDebugControllerDBus`, which exposes a D-Bus
/// interface to allow authenticated peers to control debug features in this
/// process.
/// 
/// Whether debug output is enabled is exposed as
/// `GDebugController:debug-enabled`. This controls `g_log_set_debug_enabled()` by
/// default. Application code may connect to the `GObject::notify` signal for it
/// to control other parts of its debug infrastructure as necessary.
/// 
/// If your application or service is using the default GLib log writer function,
/// creating one of the built-in implementations of `GDebugController` should be
/// all thats needed to dynamically enable or disable debug output.
///
/// The `DebugControllerProtocol` protocol exposes the methods and properties of an underlying `GDebugController` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DebugController`.
/// Alternatively, use `DebugControllerRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DebugControllerProtocol: InitableProtocol {
        /// Untyped pointer to the underlying `GDebugController` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDebugController` instance.
    var debug_controller_ptr: UnsafeMutablePointer<GDebugController>! { get }

    /// Required Initialiser for types conforming to `DebugControllerProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GDebugController` is an interface to expose control of debugging features and
/// debug output.
/// 
/// It is implemented on Linux using `GDebugControllerDBus`, which exposes a D-Bus
/// interface to allow authenticated peers to control debug features in this
/// process.
/// 
/// Whether debug output is enabled is exposed as
/// `GDebugController:debug-enabled`. This controls `g_log_set_debug_enabled()` by
/// default. Application code may connect to the `GObject::notify` signal for it
/// to control other parts of its debug infrastructure as necessary.
/// 
/// If your application or service is using the default GLib log writer function,
/// creating one of the built-in implementations of `GDebugController` should be
/// all thats needed to dynamically enable or disable debug output.
///
/// The `DebugControllerRef` type acts as a lightweight Swift reference to an underlying `GDebugController` instance.
/// It exposes methods that can operate on this data type through `DebugControllerProtocol` conformance.
/// Use `DebugControllerRef` only as an `unowned` reference to an existing `GDebugController` instance.
///
public struct DebugControllerRef: DebugControllerProtocol {
        /// Untyped pointer to the underlying `GDebugController` instance.
    /// For type-safe access, use the generated, typed pointer `debug_controller_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DebugControllerRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDebugController>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDebugController>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDebugController>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDebugController>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DebugControllerProtocol`
    @inlinable init<T: DebugControllerProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// `GDebugController` is an interface to expose control of debugging features and
/// debug output.
/// 
/// It is implemented on Linux using `GDebugControllerDBus`, which exposes a D-Bus
/// interface to allow authenticated peers to control debug features in this
/// process.
/// 
/// Whether debug output is enabled is exposed as
/// `GDebugController:debug-enabled`. This controls `g_log_set_debug_enabled()` by
/// default. Application code may connect to the `GObject::notify` signal for it
/// to control other parts of its debug infrastructure as necessary.
/// 
/// If your application or service is using the default GLib log writer function,
/// creating one of the built-in implementations of `GDebugController` should be
/// all thats needed to dynamically enable or disable debug output.
///
/// The `DebugController` type acts as an owner of an underlying `GDebugController` instance.
/// It provides the methods that can operate on this data type through `DebugControllerProtocol` conformance.
/// Use `DebugController` as a strong reference or owner of a `GDebugController` instance.
///
open class DebugController: Initable, DebugControllerProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DebugController` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDebugController>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DebugController` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDebugController>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DebugController` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DebugController` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DebugController` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDebugController>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DebugController` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDebugController>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GDebugController` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `DebugController` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDebugController>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DebugControllerProtocol`
    /// `GDebugController` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `DebugControllerProtocol`
    @inlinable public init<T: DebugControllerProtocol>(debugController other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum DebugControllerPropertyName: String, PropertyNameProtocol {
    /// `true` if debug output should be exposed (for example by forwarding it to
    /// the journal), `false` otherwise.
    case debugEnabled = "debug-enabled"
}

public extension DebugControllerProtocol {
    /// Bind a `DebugControllerPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: DebugControllerPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a DebugController property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: DebugControllerPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a DebugController property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: DebugControllerPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum DebugControllerSignalName: String, SignalNameProtocol {

    /// `true` if debug output should be exposed (for example by forwarding it to
    /// the journal), `false` otherwise.
    case notifyDebugEnabled = "notify::debug-enabled"
}

// MARK: DebugController has no signals
// MARK: DebugController Interface: DebugControllerProtocol extension (methods and fields)
public extension DebugControllerProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDebugController` instance.
    @inlinable var debug_controller_ptr: UnsafeMutablePointer<GDebugController>! { return ptr?.assumingMemoryBound(to: GDebugController.self) }

    /// Get the value of `GDebugController:debug-enabled`.
    @inlinable func getDebugEnabled() -> Bool {
        let result = g_debug_controller_get_debug_enabled(debug_controller_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Set the value of `GDebugController:debug-enabled`.
    @inlinable func set(debugEnabled: Bool) {
        
        g_debug_controller_set_debug_enabled(debug_controller_ptr, gboolean((debugEnabled) ? 1 : 0))
        
    }
    /// Get the value of `GDebugController:debug-enabled`.
    @inlinable var debugEnabled: Bool {
        /// Get the value of `GDebugController:debug-enabled`.
        get {
            let result = g_debug_controller_get_debug_enabled(debug_controller_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Set the value of `GDebugController:debug-enabled`.
        nonmutating set {
            g_debug_controller_set_debug_enabled(debug_controller_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - DesktopAppInfoLookup Interface

/// `GDesktopAppInfoLookup` is an opaque data structure and can only be accessed
/// using the following functions.
///
/// The `DesktopAppInfoLookupProtocol` protocol exposes the methods and properties of an underlying `GDesktopAppInfoLookup` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DesktopAppInfoLookup`.
/// Alternatively, use `DesktopAppInfoLookupRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DesktopAppInfoLookupProtocol {
        /// Untyped pointer to the underlying `GDesktopAppInfoLookup` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDesktopAppInfoLookup` instance.
    var desktop_app_info_lookup_ptr: UnsafeMutablePointer<GDesktopAppInfoLookup>! { get }

    /// Required Initialiser for types conforming to `DesktopAppInfoLookupProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GDesktopAppInfoLookup` is an opaque data structure and can only be accessed
/// using the following functions.
///
/// The `DesktopAppInfoLookupRef` type acts as a lightweight Swift reference to an underlying `GDesktopAppInfoLookup` instance.
/// It exposes methods that can operate on this data type through `DesktopAppInfoLookupProtocol` conformance.
/// Use `DesktopAppInfoLookupRef` only as an `unowned` reference to an existing `GDesktopAppInfoLookup` instance.
///
public struct DesktopAppInfoLookupRef: DesktopAppInfoLookupProtocol {
        /// Untyped pointer to the underlying `GDesktopAppInfoLookup` instance.
    /// For type-safe access, use the generated, typed pointer `desktop_app_info_lookup_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DesktopAppInfoLookupRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDesktopAppInfoLookup>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDesktopAppInfoLookup>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDesktopAppInfoLookup>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDesktopAppInfoLookup>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DesktopAppInfoLookupProtocol`
    @inlinable init<T: DesktopAppInfoLookupProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoLookupProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoLookupProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoLookupProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoLookupProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoLookupProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// `GDesktopAppInfoLookup` is an opaque data structure and can only be accessed
/// using the following functions.
///
/// The `DesktopAppInfoLookup` type acts as an owner of an underlying `GDesktopAppInfoLookup` instance.
/// It provides the methods that can operate on this data type through `DesktopAppInfoLookupProtocol` conformance.
/// Use `DesktopAppInfoLookup` as a strong reference or owner of a `GDesktopAppInfoLookup` instance.
///
open class DesktopAppInfoLookup: DesktopAppInfoLookupProtocol {
        /// Untyped pointer to the underlying `GDesktopAppInfoLookup` instance.
    /// For type-safe access, use the generated, typed pointer `desktop_app_info_lookup_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DesktopAppInfoLookup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDesktopAppInfoLookup>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DesktopAppInfoLookup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDesktopAppInfoLookup>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DesktopAppInfoLookup` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DesktopAppInfoLookup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DesktopAppInfoLookup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDesktopAppInfoLookup>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DesktopAppInfoLookup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDesktopAppInfoLookup>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GDesktopAppInfoLookup` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `DesktopAppInfoLookup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDesktopAppInfoLookup>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GDesktopAppInfoLookup, cannot ref(desktop_app_info_lookup_ptr)
    }

    /// Reference intialiser for a related type that implements `DesktopAppInfoLookupProtocol`
    /// `GDesktopAppInfoLookup` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `DesktopAppInfoLookupProtocol`
    @inlinable public init<T: DesktopAppInfoLookupProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GDesktopAppInfoLookup, cannot ref(desktop_app_info_lookup_ptr)
    }

    /// Do-nothing destructor for `GDesktopAppInfoLookup`.
    deinit {
        // no reference counting for GDesktopAppInfoLookup, cannot unref(desktop_app_info_lookup_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoLookupProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoLookupProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GDesktopAppInfoLookup, cannot ref(desktop_app_info_lookup_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoLookupProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoLookupProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GDesktopAppInfoLookup, cannot ref(desktop_app_info_lookup_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoLookupProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoLookupProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GDesktopAppInfoLookup, cannot ref(desktop_app_info_lookup_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoLookupProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoLookupProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GDesktopAppInfoLookup, cannot ref(desktop_app_info_lookup_ptr)
    }



}

// MARK: no DesktopAppInfoLookup properties

// MARK: no DesktopAppInfoLookup signals

// MARK: DesktopAppInfoLookup has no signals
// MARK: DesktopAppInfoLookup Interface: DesktopAppInfoLookupProtocol extension (methods and fields)
public extension DesktopAppInfoLookupProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDesktopAppInfoLookup` instance.
    @inlinable var desktop_app_info_lookup_ptr: UnsafeMutablePointer<GDesktopAppInfoLookup>! { return ptr?.assumingMemoryBound(to: GDesktopAppInfoLookup.self) }

    /// Gets the default application for launching applications
    /// using this URI scheme for a particular `GDesktopAppInfoLookup`
    /// implementation.
    /// 
    /// The `GDesktopAppInfoLookup` interface and this function is used
    /// to implement `g_app_info_get_default_for_uri_scheme()` backends
    /// in a GIO module. There is no reason for applications to use it
    /// directly. Applications should use `g_app_info_get_default_for_uri_scheme()`.
    ///
    /// **get_default_for_uri_scheme is deprecated:**
    /// The #GDesktopAppInfoLookup interface is deprecated and
    ///    unused by GIO.
    @available(*, deprecated) @inlinable func getDefaultFor(uriScheme: UnsafePointer<CChar>!) -> GIO.AppInfoRef! {
        let result = g_desktop_app_info_lookup_get_default_for_uri_scheme(desktop_app_info_lookup_ptr, uriScheme)
        let rv = AppInfoRef(gconstpointer: gconstpointer(result))
        return rv
    }


}



// MARK: - Drive Interface

/// `GDrive` - this represent a piece of hardware connected to the machine.
/// It's generally only created for removable hardware or hardware with
/// removable media.
/// 
/// `GDrive` is a container class for `GVolume` objects that stem from
/// the same piece of media. As such, `GDrive` abstracts a drive with
/// (or without) removable media and provides operations for querying
/// whether media is available, determining whether media change is
/// automatically detected and ejecting the media.
/// 
/// If the `GDrive` reports that media isn't automatically detected, one
/// can poll for media; typically one should not do this periodically
/// as a poll for media operation is potentially expensive and may
/// spin up the drive creating noise.
/// 
/// `GDrive` supports starting and stopping drives with authentication
/// support for the former. This can be used to support a diverse set
/// of use cases including connecting/disconnecting iSCSI devices,
/// powering down external disk enclosures and starting/stopping
/// multi-disk devices such as RAID devices. Note that the actual
/// semantics and side-effects of starting/stopping a `GDrive` may vary
/// according to implementation. To choose the correct verbs in e.g. a
/// file manager, use `g_drive_get_start_stop_type()`.
/// 
/// For porting from GnomeVFS note that there is no equivalent of
/// `GDrive` in that API.
///
/// The `DriveProtocol` protocol exposes the methods and properties of an underlying `GDrive` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Drive`.
/// Alternatively, use `DriveRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DriveProtocol {
        /// Untyped pointer to the underlying `GDrive` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDrive` instance.
    var drive_ptr: UnsafeMutablePointer<GDrive>! { get }

    /// Required Initialiser for types conforming to `DriveProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GDrive` - this represent a piece of hardware connected to the machine.
/// It's generally only created for removable hardware or hardware with
/// removable media.
/// 
/// `GDrive` is a container class for `GVolume` objects that stem from
/// the same piece of media. As such, `GDrive` abstracts a drive with
/// (or without) removable media and provides operations for querying
/// whether media is available, determining whether media change is
/// automatically detected and ejecting the media.
/// 
/// If the `GDrive` reports that media isn't automatically detected, one
/// can poll for media; typically one should not do this periodically
/// as a poll for media operation is potentially expensive and may
/// spin up the drive creating noise.
/// 
/// `GDrive` supports starting and stopping drives with authentication
/// support for the former. This can be used to support a diverse set
/// of use cases including connecting/disconnecting iSCSI devices,
/// powering down external disk enclosures and starting/stopping
/// multi-disk devices such as RAID devices. Note that the actual
/// semantics and side-effects of starting/stopping a `GDrive` may vary
/// according to implementation. To choose the correct verbs in e.g. a
/// file manager, use `g_drive_get_start_stop_type()`.
/// 
/// For porting from GnomeVFS note that there is no equivalent of
/// `GDrive` in that API.
///
/// The `DriveRef` type acts as a lightweight Swift reference to an underlying `GDrive` instance.
/// It exposes methods that can operate on this data type through `DriveProtocol` conformance.
/// Use `DriveRef` only as an `unowned` reference to an existing `GDrive` instance.
///
public struct DriveRef: DriveProtocol {
        /// Untyped pointer to the underlying `GDrive` instance.
    /// For type-safe access, use the generated, typed pointer `drive_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DriveRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDrive>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDrive>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDrive>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDrive>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DriveProtocol`
    @inlinable init<T: DriveProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DriveProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DriveProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DriveProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DriveProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DriveProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// `GDrive` - this represent a piece of hardware connected to the machine.
/// It's generally only created for removable hardware or hardware with
/// removable media.
/// 
/// `GDrive` is a container class for `GVolume` objects that stem from
/// the same piece of media. As such, `GDrive` abstracts a drive with
/// (or without) removable media and provides operations for querying
/// whether media is available, determining whether media change is
/// automatically detected and ejecting the media.
/// 
/// If the `GDrive` reports that media isn't automatically detected, one
/// can poll for media; typically one should not do this periodically
/// as a poll for media operation is potentially expensive and may
/// spin up the drive creating noise.
/// 
/// `GDrive` supports starting and stopping drives with authentication
/// support for the former. This can be used to support a diverse set
/// of use cases including connecting/disconnecting iSCSI devices,
/// powering down external disk enclosures and starting/stopping
/// multi-disk devices such as RAID devices. Note that the actual
/// semantics and side-effects of starting/stopping a `GDrive` may vary
/// according to implementation. To choose the correct verbs in e.g. a
/// file manager, use `g_drive_get_start_stop_type()`.
/// 
/// For porting from GnomeVFS note that there is no equivalent of
/// `GDrive` in that API.
///
/// The `Drive` type acts as an owner of an underlying `GDrive` instance.
/// It provides the methods that can operate on this data type through `DriveProtocol` conformance.
/// Use `Drive` as a strong reference or owner of a `GDrive` instance.
///
open class Drive: DriveProtocol {
        /// Untyped pointer to the underlying `GDrive` instance.
    /// For type-safe access, use the generated, typed pointer `drive_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Drive` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDrive>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Drive` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDrive>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Drive` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Drive` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Drive` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDrive>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Drive` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDrive>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GDrive` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `Drive` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDrive>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GDrive, cannot ref(drive_ptr)
    }

    /// Reference intialiser for a related type that implements `DriveProtocol`
    /// `GDrive` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `DriveProtocol`
    @inlinable public init<T: DriveProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GDrive, cannot ref(drive_ptr)
    }

    /// Do-nothing destructor for `GDrive`.
    deinit {
        // no reference counting for GDrive, cannot unref(drive_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DriveProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DriveProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GDrive, cannot ref(drive_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DriveProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DriveProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GDrive, cannot ref(drive_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DriveProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DriveProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GDrive, cannot ref(drive_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DriveProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DriveProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GDrive, cannot ref(drive_ptr)
    }



}

// MARK: no Drive properties

public enum DriveSignalName: String, SignalNameProtocol {
    /// Emitted when the drive's state has changed.
    case changed = "changed"
    /// This signal is emitted when the `GDrive` have been
    /// disconnected. If the recipient is holding references to the
    /// object they should release them so the object can be
    /// finalized.
    case disconnected = "disconnected"
    /// Emitted when the physical eject button (if any) of a drive has
    /// been pressed.
    case ejectButton = "eject-button"
    /// Emitted when the physical stop button (if any) of a drive has
    /// been pressed.
    case stopButton = "stop-button"

}

// MARK: Drive signals
public extension DriveProtocol {
    /// Connect a Swift signal handler to the given, typed `DriveSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DriveSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        GLibObject.ObjectRef(raw: ptr).connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `DriveSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DriveSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        GLibObject.ObjectRef(raw: ptr).connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when the drive's state has changed.
    /// - Note: This represents the underlying `changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `changed` signal is emitted
    @discardableResult @inlinable func onChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DriveRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DriveRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DriveRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .changed,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `changed` signal for using the `connect(signal:)` methods
    static var changedSignal: DriveSignalName { .changed }
    
    /// This signal is emitted when the `GDrive` have been
    /// disconnected. If the recipient is holding references to the
    /// object they should release them so the object can be
    /// finalized.
    /// - Note: This represents the underlying `disconnected` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `disconnected` signal is emitted
    @discardableResult @inlinable func onDisconnected(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DriveRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DriveRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DriveRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .disconnected,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `disconnected` signal for using the `connect(signal:)` methods
    static var disconnectedSignal: DriveSignalName { .disconnected }
    
    /// Emitted when the physical eject button (if any) of a drive has
    /// been pressed.
    /// - Note: This represents the underlying `eject-button` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `ejectButton` signal is emitted
    @discardableResult @inlinable func onEjectButton(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DriveRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DriveRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DriveRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .ejectButton,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `eject-button` signal for using the `connect(signal:)` methods
    static var ejectButtonSignal: DriveSignalName { .ejectButton }
    
    /// Emitted when the physical stop button (if any) of a drive has
    /// been pressed.
    /// - Note: This represents the underlying `stop-button` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `stopButton` signal is emitted
    @discardableResult @inlinable func onStopButton(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DriveRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DriveRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DriveRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .stopButton,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `stop-button` signal for using the `connect(signal:)` methods
    static var stopButtonSignal: DriveSignalName { .stopButton }
    
    
}

// MARK: Drive Interface: DriveProtocol extension (methods and fields)
public extension DriveProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDrive` instance.
    @inlinable var drive_ptr: UnsafeMutablePointer<GDrive>! { return ptr?.assumingMemoryBound(to: GDrive.self) }

    /// Checks if a drive can be ejected.
    @inlinable func canEject() -> Bool {
        let result = g_drive_can_eject(drive_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Checks if a drive can be polled for media changes.
    @inlinable func canPollForMedia() -> Bool {
        let result = g_drive_can_poll_for_media(drive_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Checks if a drive can be started.
    @inlinable func canStart() -> Bool {
        let result = g_drive_can_start(drive_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Checks if a drive can be started degraded.
    @inlinable func canStartDegraded() -> Bool {
        let result = g_drive_can_start_degraded(drive_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Checks if a drive can be stopped.
    @inlinable func canStop() -> Bool {
        let result = g_drive_can_stop(drive_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Asynchronously ejects a drive.
    /// 
    /// When the operation is finished, `callback` will be called.
    /// You can then call `g_drive_eject_finish()` to obtain the
    /// result of the operation.
    ///
    /// **eject is deprecated:**
    /// Use g_drive_eject_with_operation() instead.
    @available(*, deprecated) @inlinable func eject(flags: MountUnmountFlags, cancellable: CancellableRef? = nil, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
            
        g_drive_eject(drive_ptr, flags.value, cancellable?.cancellable_ptr, callback, userData)
            
    }
    /// Asynchronously ejects a drive.
    /// 
    /// When the operation is finished, `callback` will be called.
    /// You can then call `g_drive_eject_finish()` to obtain the
    /// result of the operation.
    ///
    /// **eject is deprecated:**
    /// Use g_drive_eject_with_operation() instead.
    @available(*, deprecated) @inlinable func eject<CancellableT: CancellableProtocol>(flags: MountUnmountFlags, cancellable: CancellableT?, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
        
        g_drive_eject(drive_ptr, flags.value, cancellable?.cancellable_ptr, callback, userData)
        
    }

    /// Finishes ejecting a drive.
    ///
    /// **eject_finish is deprecated:**
    /// Use g_drive_eject_with_operation_finish() instead.
    @available(*, deprecated) @inlinable func ejectFinish<AsyncResultT: AsyncResultProtocol>(result: AsyncResultT) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_drive_eject_finish(drive_ptr, result.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Ejects a drive. This is an asynchronous operation, and is
    /// finished by calling `g_drive_eject_with_operation_finish()` with the `drive`
    /// and `GAsyncResult` data returned in the `callback`.
    @inlinable func ejectWithOperation(flags: MountUnmountFlags, mountOperation: MountOperationRef? = nil, cancellable: CancellableRef? = nil, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
            
        g_drive_eject_with_operation(drive_ptr, flags.value, mountOperation?.mount_operation_ptr, cancellable?.cancellable_ptr, callback, userData)
            
    }
    /// Ejects a drive. This is an asynchronous operation, and is
    /// finished by calling `g_drive_eject_with_operation_finish()` with the `drive`
    /// and `GAsyncResult` data returned in the `callback`.
    @inlinable func ejectWithOperation<CancellableT: CancellableProtocol, MountOperationT: MountOperationProtocol>(flags: MountUnmountFlags, mountOperation: MountOperationT?, cancellable: CancellableT?, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
        
        g_drive_eject_with_operation(drive_ptr, flags.value, mountOperation?.mount_operation_ptr, cancellable?.cancellable_ptr, callback, userData)
        
    }

    /// Finishes ejecting a drive. If any errors occurred during the operation,
    /// `error` will be set to contain the errors and `false` will be returned.
    @inlinable func ejectWithOperationFinish<AsyncResultT: AsyncResultProtocol>(result: AsyncResultT) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_drive_eject_with_operation_finish(drive_ptr, result.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the kinds of identifiers that `drive` has.
    /// Use `g_drive_get_identifier()` to obtain the identifiers
    /// themselves.
    @inlinable func enumerateIdentifiers() -> UnsafeMutablePointer<UnsafeMutablePointer<CChar>?>! {
        let result = g_drive_enumerate_identifiers(drive_ptr)
        let rv = result
        return rv
    }

    /// Gets the icon for `drive`.
    @inlinable func getIcon() -> GIO.IconRef! {
        let result = g_drive_get_icon(drive_ptr)
        let rv = IconRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the identifier of the given kind for `drive`. The only
    /// identifier currently available is
    /// `G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE`.
    @inlinable func getIdentifier(kind: UnsafePointer<CChar>!) -> String! {
        let result = g_drive_get_identifier(drive_ptr, kind)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets the name of `drive`.
    @inlinable func getName() -> String! {
        let result = g_drive_get_name(drive_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets the sort key for `drive`, if any.
    @inlinable func getSortKey() -> String! {
        let result = g_drive_get_sort_key(drive_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets a hint about how a drive can be started/stopped.
    @inlinable func getStartStopType() -> GDriveStartStopType {
        let result = g_drive_get_start_stop_type(drive_ptr)
        let rv = result
        return rv
    }

    /// Gets the icon for `drive`.
    @inlinable func getSymbolicIcon() -> GIO.IconRef! {
        let result = g_drive_get_symbolic_icon(drive_ptr)
        let rv = IconRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Get a list of mountable volumes for `drive`.
    /// 
    /// The returned list should be freed with `g_list_free()`, after
    /// its elements have been unreffed with `g_object_unref()`.
    @inlinable func getVolumes() -> GLib.ListRef! {
        let result = g_drive_get_volumes(drive_ptr)
        let rv = GLib.ListRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Checks if the `drive` has media. Note that the OS may not be polling
    /// the drive for media changes; see `g_drive_is_media_check_automatic()`
    /// for more details.
    @inlinable func hasMedia() -> Bool {
        let result = g_drive_has_media(drive_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Check if `drive` has any mountable volumes.
    @inlinable func hasVolumes() -> Bool {
        let result = g_drive_has_volumes(drive_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Asynchronously polls `drive` to see if media has been inserted or removed.
    /// 
    /// When the operation is finished, `callback` will be called.
    /// You can then call `g_drive_poll_for_media_finish()` to obtain the
    /// result of the operation.
    @inlinable func pollForMedia(cancellable: CancellableRef? = nil, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
            
        g_drive_poll_for_media(drive_ptr, cancellable?.cancellable_ptr, callback, userData)
            
    }
    /// Asynchronously polls `drive` to see if media has been inserted or removed.
    /// 
    /// When the operation is finished, `callback` will be called.
    /// You can then call `g_drive_poll_for_media_finish()` to obtain the
    /// result of the operation.
    @inlinable func pollForMedia<CancellableT: CancellableProtocol>(cancellable: CancellableT?, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
        
        g_drive_poll_for_media(drive_ptr, cancellable?.cancellable_ptr, callback, userData)
        
    }

    /// Finishes an operation started with `g_drive_poll_for_media()` on a drive.
    @inlinable func pollForMediaFinish<AsyncResultT: AsyncResultProtocol>(result: AsyncResultT) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_drive_poll_for_media_finish(drive_ptr, result.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Asynchronously starts a drive.
    /// 
    /// When the operation is finished, `callback` will be called.
    /// You can then call `g_drive_start_finish()` to obtain the
    /// result of the operation.
    @inlinable func start(flags: DriveStartFlags, mountOperation: MountOperationRef? = nil, cancellable: CancellableRef? = nil, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
            
        g_drive_start(drive_ptr, flags.value, mountOperation?.mount_operation_ptr, cancellable?.cancellable_ptr, callback, userData)
            
    }
    /// Asynchronously starts a drive.
    /// 
    /// When the operation is finished, `callback` will be called.
    /// You can then call `g_drive_start_finish()` to obtain the
    /// result of the operation.
    @inlinable func start<CancellableT: CancellableProtocol, MountOperationT: MountOperationProtocol>(flags: DriveStartFlags, mountOperation: MountOperationT?, cancellable: CancellableT?, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
        
        g_drive_start(drive_ptr, flags.value, mountOperation?.mount_operation_ptr, cancellable?.cancellable_ptr, callback, userData)
        
    }

    /// Finishes starting a drive.
    @inlinable func startFinish<AsyncResultT: AsyncResultProtocol>(result: AsyncResultT) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_drive_start_finish(drive_ptr, result.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Asynchronously stops a drive.
    /// 
    /// When the operation is finished, `callback` will be called.
    /// You can then call `g_drive_stop_finish()` to obtain the
    /// result of the operation.
    @inlinable func stop(flags: MountUnmountFlags, mountOperation: MountOperationRef? = nil, cancellable: CancellableRef? = nil, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
            
        g_drive_stop(drive_ptr, flags.value, mountOperation?.mount_operation_ptr, cancellable?.cancellable_ptr, callback, userData)
            
    }
    /// Asynchronously stops a drive.
    /// 
    /// When the operation is finished, `callback` will be called.
    /// You can then call `g_drive_stop_finish()` to obtain the
    /// result of the operation.
    @inlinable func stop<CancellableT: CancellableProtocol, MountOperationT: MountOperationProtocol>(flags: MountUnmountFlags, mountOperation: MountOperationT?, cancellable: CancellableT?, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
        
        g_drive_stop(drive_ptr, flags.value, mountOperation?.mount_operation_ptr, cancellable?.cancellable_ptr, callback, userData)
        
    }

    /// Finishes stopping a drive.
    @inlinable func stopFinish<AsyncResultT: AsyncResultProtocol>(result: AsyncResultT) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_drive_stop_finish(drive_ptr, result.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }
    /// Gets the icon for `drive`.
    @inlinable var icon: GIO.IconRef! {
        /// Gets the icon for `drive`.
        get {
            let result = g_drive_get_icon(drive_ptr)
        let rv = IconRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Checks if `drive` is capable of automatically detecting media changes.
    @inlinable var isMediaCheckAutomatic: Bool {
        /// Checks if `drive` is capable of automatically detecting media changes.
        get {
            let result = g_drive_is_media_check_automatic(drive_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// Checks if the `drive` supports removable media.
    @inlinable var isMediaRemovable: Bool {
        /// Checks if the `drive` supports removable media.
        get {
            let result = g_drive_is_media_removable(drive_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// Checks if the `GDrive` and/or its media is considered removable by the user.
    /// See `g_drive_is_media_removable()`.
    @inlinable var isRemovable: Bool {
        /// Checks if the `GDrive` and/or its media is considered removable by the user.
        /// See `g_drive_is_media_removable()`.
        get {
            let result = g_drive_is_removable(drive_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// Gets the name of `drive`.
    @inlinable var name: String! {
        /// Gets the name of `drive`.
        get {
            let result = g_drive_get_name(drive_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// Gets the sort key for `drive`, if any.
    @inlinable var sortKey: String! {
        /// Gets the sort key for `drive`, if any.
        get {
            let result = g_drive_get_sort_key(drive_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// Gets a hint about how a drive can be started/stopped.
    @inlinable var startStopType: GDriveStartStopType {
        /// Gets a hint about how a drive can be started/stopped.
        get {
            let result = g_drive_get_start_stop_type(drive_ptr)
        let rv = result
            return rv
        }
    }

    /// Gets the icon for `drive`.
    @inlinable var symbolicIcon: GIO.IconRef! {
        /// Gets the icon for `drive`.
        get {
            let result = g_drive_get_symbolic_icon(drive_ptr)
        let rv = IconRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Get a list of mountable volumes for `drive`.
    /// 
    /// The returned list should be freed with `g_list_free()`, after
    /// its elements have been unreffed with `g_object_unref()`.
    @inlinable var volumes: GLib.ListRef! {
        /// Get a list of mountable volumes for `drive`.
        /// 
        /// The returned list should be freed with `g_list_free()`, after
        /// its elements have been unreffed with `g_object_unref()`.
        get {
            let result = g_drive_get_volumes(drive_ptr)
        let rv = GLib.ListRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }


}



// MARK: - DtlsClientConnection Interface

/// `GDtlsClientConnection` is the client-side subclass of
/// `GDtlsConnection`, representing a client-side DTLS connection.
///
/// The `DtlsClientConnectionProtocol` protocol exposes the methods and properties of an underlying `GDtlsClientConnection` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DtlsClientConnection`.
/// Alternatively, use `DtlsClientConnectionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DtlsClientConnectionProtocol: DatagramBasedProtocol {
        /// Untyped pointer to the underlying `GDtlsClientConnection` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDtlsClientConnection` instance.
    var dtls_client_connection_ptr: UnsafeMutablePointer<GDtlsClientConnection>! { get }

    /// Required Initialiser for types conforming to `DtlsClientConnectionProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GDtlsClientConnection` is the client-side subclass of
/// `GDtlsConnection`, representing a client-side DTLS connection.
///
/// The `DtlsClientConnectionRef` type acts as a lightweight Swift reference to an underlying `GDtlsClientConnection` instance.
/// It exposes methods that can operate on this data type through `DtlsClientConnectionProtocol` conformance.
/// Use `DtlsClientConnectionRef` only as an `unowned` reference to an existing `GDtlsClientConnection` instance.
///
public struct DtlsClientConnectionRef: DtlsClientConnectionProtocol {
        /// Untyped pointer to the underlying `GDtlsClientConnection` instance.
    /// For type-safe access, use the generated, typed pointer `dtls_client_connection_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DtlsClientConnectionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDtlsClientConnection>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDtlsClientConnection>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDtlsClientConnection>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDtlsClientConnection>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DtlsClientConnectionProtocol`
    @inlinable init<T: DtlsClientConnectionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsClientConnectionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsClientConnectionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsClientConnectionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsClientConnectionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsClientConnectionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// `GDtlsClientConnection` is the client-side subclass of
/// `GDtlsConnection`, representing a client-side DTLS connection.
///
/// The `DtlsClientConnection` type acts as an owner of an underlying `GDtlsClientConnection` instance.
/// It provides the methods that can operate on this data type through `DtlsClientConnectionProtocol` conformance.
/// Use `DtlsClientConnection` as a strong reference or owner of a `GDtlsClientConnection` instance.
///
open class DtlsClientConnection: DatagramBased, DtlsClientConnectionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DtlsClientConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDtlsClientConnection>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DtlsClientConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDtlsClientConnection>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DtlsClientConnection` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DtlsClientConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DtlsClientConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDtlsClientConnection>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DtlsClientConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDtlsClientConnection>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GDtlsClientConnection` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `DtlsClientConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDtlsClientConnection>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DtlsClientConnectionProtocol`
    /// `GDtlsClientConnection` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `DtlsClientConnectionProtocol`
    @inlinable public init<T: DtlsClientConnectionProtocol>(dtlsClientConnection other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsClientConnectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsClientConnectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsClientConnectionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsClientConnectionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsClientConnectionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsClientConnectionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsClientConnectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsClientConnectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum DtlsClientConnectionPropertyName: String, PropertyNameProtocol {
    /// A list of the distinguished names of the Certificate Authorities
    /// that the server will accept client certificates signed by. If the
    /// server requests a client certificate during the handshake, then
    /// this property will be set after the handshake completes.
    /// 
    /// Each item in the list is a `GByteArray` which contains the complete
    /// subject DN of the certificate authority.
    case acceptedCas = "accepted-cas"
    /// A `GSocketConnectable` describing the identity of the server that
    /// is expected on the other end of the connection.
    /// 
    /// If the `G_TLS_CERTIFICATE_BAD_IDENTITY` flag is set in
    /// `GDtlsClientConnection:validation-flags`, this object will be used
    /// to determine the expected identify of the remote end of the
    /// connection; if `GDtlsClientConnection:server-identity` is not set,
    /// or does not match the identity presented by the server, then the
    /// `G_TLS_CERTIFICATE_BAD_IDENTITY` validation will fail.
    /// 
    /// In addition to its use in verifying the server certificate,
    /// this is also used to give a hint to the server about what
    /// certificate we expect, which is useful for servers that serve
    /// virtual hosts.
    case serverIdentity = "server-identity"
    /// What steps to perform when validating a certificate received from
    /// a server. Server certificates that fail to validate in any of the
    /// ways indicated here will be rejected unless the application
    /// overrides the default via `GDtlsConnection::accept-certificate`.
    /// 
    /// GLib guarantees that if certificate verification fails, at least one
    /// flag will be set, but it does not guarantee that all possible flags
    /// will be set. Accordingly, you may not safely decide to ignore any
    /// particular type of error. For example, it would be incorrect to mask
    /// `G_TLS_CERTIFICATE_EXPIRED` if you want to allow expired certificates,
    /// because this could potentially be the only error flag set even if
    /// other problems exist with the certificate. Therefore, there is no
    /// safe way to use this property. This is not a horrible problem,
    /// though, because you should not be attempting to ignore validation
    /// errors anyway. If you really must ignore TLS certificate errors,
    /// connect to `GDtlsConnection::accept-certificate`.
    ///
    /// **validation-flags is deprecated:**
    /// Do not attempt to ignore validation errors.
    case validationFlags = "validation-flags"
}

public extension DtlsClientConnectionProtocol {
    /// Bind a `DtlsClientConnectionPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: DtlsClientConnectionPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a DtlsClientConnection property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: DtlsClientConnectionPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a DtlsClientConnection property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: DtlsClientConnectionPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum DtlsClientConnectionSignalName: String, SignalNameProtocol {

    /// A list of the distinguished names of the Certificate Authorities
    /// that the server will accept client certificates signed by. If the
    /// server requests a client certificate during the handshake, then
    /// this property will be set after the handshake completes.
    /// 
    /// Each item in the list is a `GByteArray` which contains the complete
    /// subject DN of the certificate authority.
    case notifyAcceptedCas = "notify::accepted-cas"
    /// A `GSocketConnectable` describing the identity of the server that
    /// is expected on the other end of the connection.
    /// 
    /// If the `G_TLS_CERTIFICATE_BAD_IDENTITY` flag is set in
    /// `GDtlsClientConnection:validation-flags`, this object will be used
    /// to determine the expected identify of the remote end of the
    /// connection; if `GDtlsClientConnection:server-identity` is not set,
    /// or does not match the identity presented by the server, then the
    /// `G_TLS_CERTIFICATE_BAD_IDENTITY` validation will fail.
    /// 
    /// In addition to its use in verifying the server certificate,
    /// this is also used to give a hint to the server about what
    /// certificate we expect, which is useful for servers that serve
    /// virtual hosts.
    case notifyServerIdentity = "notify::server-identity"
    /// What steps to perform when validating a certificate received from
    /// a server. Server certificates that fail to validate in any of the
    /// ways indicated here will be rejected unless the application
    /// overrides the default via `GDtlsConnection::accept-certificate`.
    /// 
    /// GLib guarantees that if certificate verification fails, at least one
    /// flag will be set, but it does not guarantee that all possible flags
    /// will be set. Accordingly, you may not safely decide to ignore any
    /// particular type of error. For example, it would be incorrect to mask
    /// `G_TLS_CERTIFICATE_EXPIRED` if you want to allow expired certificates,
    /// because this could potentially be the only error flag set even if
    /// other problems exist with the certificate. Therefore, there is no
    /// safe way to use this property. This is not a horrible problem,
    /// though, because you should not be attempting to ignore validation
    /// errors anyway. If you really must ignore TLS certificate errors,
    /// connect to `GDtlsConnection::accept-certificate`.
    ///
    /// **validation-flags is deprecated:**
    /// Do not attempt to ignore validation errors.
    case notifyValidationFlags = "notify::validation-flags"
}

// MARK: DtlsClientConnection has no signals
// MARK: DtlsClientConnection Interface: DtlsClientConnectionProtocol extension (methods and fields)
public extension DtlsClientConnectionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDtlsClientConnection` instance.
    @inlinable var dtls_client_connection_ptr: UnsafeMutablePointer<GDtlsClientConnection>! { return ptr?.assumingMemoryBound(to: GDtlsClientConnection.self) }

    /// Gets the list of distinguished names of the Certificate Authorities
    /// that the server will accept certificates from. This will be set
    /// during the TLS handshake if the server requests a certificate.
    /// Otherwise, it will be `nil`.
    /// 
    /// Each item in the list is a `GByteArray` which contains the complete
    /// subject DN of the certificate authority.
    @inlinable func getAcceptedCas() -> GLib.ListRef! {
        let result = g_dtls_client_connection_get_accepted_cas(dtls_client_connection_ptr)
        let rv = GLib.ListRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets `conn`'s expected server identity
    @inlinable func getServerIdentity() -> GIO.SocketConnectableRef! {
        let result = g_dtls_client_connection_get_server_identity(dtls_client_connection_ptr)
        let rv = SocketConnectableRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets `conn`'s validation flags
    /// 
    /// This function does not work as originally designed and is impossible
    /// to use correctly. See `GDtlsClientConnection:validation-flags` for more
    /// information.
    ///
    /// **get_validation_flags is deprecated:**
    /// Do not attempt to ignore validation errors.
    @available(*, deprecated) @inlinable func getValidationFlags() -> GIO.TLSCertificateFlags {
        let result = g_dtls_client_connection_get_validation_flags(dtls_client_connection_ptr)
        let rv = TLSCertificateFlags(result)
        return rv
    }

    /// Sets `conn`'s expected server identity, which is used both to tell
    /// servers on virtual hosts which certificate to present, and also
    /// to let `conn` know what name to look for in the certificate when
    /// performing `G_TLS_CERTIFICATE_BAD_IDENTITY` validation, if enabled.
    @inlinable func setServer<SocketConnectableT: SocketConnectableProtocol>(identity: SocketConnectableT) {
        
        g_dtls_client_connection_set_server_identity(dtls_client_connection_ptr, identity.socket_connectable_ptr)
        
    }

    /// Sets `conn`'s validation flags, to override the default set of
    /// checks performed when validating a server certificate. By default,
    /// `G_TLS_CERTIFICATE_VALIDATE_ALL` is used.
    /// 
    /// This function does not work as originally designed and is impossible
    /// to use correctly. See `GDtlsClientConnection:validation-flags` for more
    /// information.
    ///
    /// **set_validation_flags is deprecated:**
    /// Do not attempt to ignore validation errors.
    @available(*, deprecated) @inlinable func setValidation(flags: TLSCertificateFlags) {
        
        g_dtls_client_connection_set_validation_flags(dtls_client_connection_ptr, flags.value)
        
    }
    /// Gets the list of distinguished names of the Certificate Authorities
    /// that the server will accept certificates from. This will be set
    /// during the TLS handshake if the server requests a certificate.
    /// Otherwise, it will be `nil`.
    /// 
    /// Each item in the list is a `GByteArray` which contains the complete
    /// subject DN of the certificate authority.
    @inlinable var acceptedCas: GLib.ListRef! {
        /// Gets the list of distinguished names of the Certificate Authorities
        /// that the server will accept certificates from. This will be set
        /// during the TLS handshake if the server requests a certificate.
        /// Otherwise, it will be `nil`.
        /// 
        /// Each item in the list is a `GByteArray` which contains the complete
        /// subject DN of the certificate authority.
        get {
            let result = g_dtls_client_connection_get_accepted_cas(dtls_client_connection_ptr)
        let rv = GLib.ListRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Gets `conn`'s expected server identity
    @inlinable var serverIdentity: GIO.SocketConnectableRef! {
        /// Gets `conn`'s expected server identity
        get {
            let result = g_dtls_client_connection_get_server_identity(dtls_client_connection_ptr)
        let rv = SocketConnectableRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets `conn`'s expected server identity, which is used both to tell
        /// servers on virtual hosts which certificate to present, and also
        /// to let `conn` know what name to look for in the certificate when
        /// performing `G_TLS_CERTIFICATE_BAD_IDENTITY` validation, if enabled.
        nonmutating set {
            g_dtls_client_connection_set_server_identity(dtls_client_connection_ptr, UnsafeMutablePointer<GSocketConnectable>(newValue?.socket_connectable_ptr))
        }
    }

    /// Gets `conn`'s validation flags
    /// 
    /// This function does not work as originally designed and is impossible
    /// to use correctly. See `GDtlsClientConnection:validation-flags` for more
    /// information.
    ///
    /// **get_validation_flags is deprecated:**
    /// Do not attempt to ignore validation errors.
    @inlinable var validationFlags: GIO.TLSCertificateFlags {
        /// Gets `conn`'s validation flags
        /// 
        /// This function does not work as originally designed and is impossible
        /// to use correctly. See `GDtlsClientConnection:validation-flags` for more
        /// information.
        ///
        /// **get_validation_flags is deprecated:**
        /// Do not attempt to ignore validation errors.
        @available(*, deprecated) get {
            let result = g_dtls_client_connection_get_validation_flags(dtls_client_connection_ptr)
        let rv = TLSCertificateFlags(result)
            return rv
        }
        /// Sets `conn`'s validation flags, to override the default set of
        /// checks performed when validating a server certificate. By default,
        /// `G_TLS_CERTIFICATE_VALIDATE_ALL` is used.
        /// 
        /// This function does not work as originally designed and is impossible
        /// to use correctly. See `GDtlsClientConnection:validation-flags` for more
        /// information.
        ///
        /// **set_validation_flags is deprecated:**
        /// Do not attempt to ignore validation errors.
        @available(*, deprecated) nonmutating set {
            g_dtls_client_connection_set_validation_flags(dtls_client_connection_ptr, newValue.value)
        }
    }


}



// MARK: - DBusActionGroup Class

/// `GDBusActionGroup` is an implementation of the `GActionGroup`
/// interface that can be used as a proxy for an action group
/// that is exported over D-Bus with `g_dbus_connection_export_action_group()`.
///
/// The `DBusActionGroupProtocol` protocol exposes the methods and properties of an underlying `GDBusActionGroup` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusActionGroup`.
/// Alternatively, use `DBusActionGroupRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusActionGroupProtocol: GLibObject.ObjectProtocol, ActionGroupProtocol, RemoteActionGroupProtocol {
        /// Untyped pointer to the underlying `GDBusActionGroup` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusActionGroup` instance.
    var dbus_action_group_ptr: UnsafeMutablePointer<GDBusActionGroup>! { get }

    /// Required Initialiser for types conforming to `DBusActionGroupProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GDBusActionGroup` is an implementation of the `GActionGroup`
/// interface that can be used as a proxy for an action group
/// that is exported over D-Bus with `g_dbus_connection_export_action_group()`.
///
/// The `DBusActionGroupRef` type acts as a lightweight Swift reference to an underlying `GDBusActionGroup` instance.
/// It exposes methods that can operate on this data type through `DBusActionGroupProtocol` conformance.
/// Use `DBusActionGroupRef` only as an `unowned` reference to an existing `GDBusActionGroup` instance.
///
public struct DBusActionGroupRef: DBusActionGroupProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GDBusActionGroup` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_action_group_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusActionGroupRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusActionGroup>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusActionGroup>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusActionGroup>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusActionGroup>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusActionGroupProtocol`
    @inlinable init<T: DBusActionGroupProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: DBusActionGroupProtocol>(_ other: T) -> DBusActionGroupRef { DBusActionGroupRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusActionGroupProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusActionGroupProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusActionGroupProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusActionGroupProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusActionGroupProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Obtains a `GDBusActionGroup` for the action group which is exported at
    /// the given `bus_name` and `object_path`.
    /// 
    /// The thread default main context is taken at the time of this call.
    /// All signals on the menu model (and any linked models) are reported
    /// with respect to this context.  All calls on the returned menu model
    /// (and linked models) must also originate from this same context, with
    /// the thread default main context unchanged.
    /// 
    /// This call is non-blocking.  The returned action group may or may not
    /// already be filled in.  The correct thing to do is connect the signals
    /// for the action group to monitor for changes and then to call
    /// `g_action_group_list_actions()` to get the initial list.
    @inlinable static func dbusActionGroupGet<DBusConnectionT: DBusConnectionProtocol>(connection: DBusConnectionT, busName: UnsafePointer<gchar>? = nil, objectPath: UnsafePointer<gchar>!) -> GIO.DBusActionGroupRef! {
            let result = g_dbus_action_group_get(connection.dbus_connection_ptr, busName, objectPath)
        guard let rv = DBusActionGroupRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }
}

/// `GDBusActionGroup` is an implementation of the `GActionGroup`
/// interface that can be used as a proxy for an action group
/// that is exported over D-Bus with `g_dbus_connection_export_action_group()`.
///
/// The `DBusActionGroup` type acts as a reference-counted owner of an underlying `GDBusActionGroup` instance.
/// It provides the methods that can operate on this data type through `DBusActionGroupProtocol` conformance.
/// Use `DBusActionGroup` as a strong reference or owner of a `GDBusActionGroup` instance.
///
open class DBusActionGroup: GLibObject.Object, DBusActionGroupProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusActionGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusActionGroup>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusActionGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusActionGroup>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusActionGroup` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusActionGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusActionGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusActionGroup>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusActionGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusActionGroup>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDBusActionGroup`.
    /// i.e., ownership is transferred to the `DBusActionGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusActionGroup>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DBusActionGroupProtocol`
    /// Will retain `GDBusActionGroup`.
    /// - Parameter other: an instance of a related type that implements `DBusActionGroupProtocol`
    @inlinable public init<T: DBusActionGroupProtocol>(dBusActionGroup other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusActionGroupProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusActionGroupProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusActionGroupProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusActionGroupProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusActionGroupProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusActionGroupProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusActionGroupProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusActionGroupProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }


    /// Obtains a `GDBusActionGroup` for the action group which is exported at
    /// the given `bus_name` and `object_path`.
    /// 
    /// The thread default main context is taken at the time of this call.
    /// All signals on the menu model (and any linked models) are reported
    /// with respect to this context.  All calls on the returned menu model
    /// (and linked models) must also originate from this same context, with
    /// the thread default main context unchanged.
    /// 
    /// This call is non-blocking.  The returned action group may or may not
    /// already be filled in.  The correct thing to do is connect the signals
    /// for the action group to monitor for changes and then to call
    /// `g_action_group_list_actions()` to get the initial list.
    @inlinable public static func dbusActionGroupGet<DBusConnectionT: DBusConnectionProtocol>(connection: DBusConnectionT, busName: UnsafePointer<gchar>? = nil, objectPath: UnsafePointer<gchar>!) -> GIO.DBusActionGroup! {
            let result = g_dbus_action_group_get(connection.dbus_connection_ptr, busName, objectPath)
        guard let rv = DBusActionGroup(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

}

// MARK: no DBusActionGroup properties

public enum DBusActionGroupSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: DBusActionGroup has no signals
// MARK: DBusActionGroup Class: DBusActionGroupProtocol extension (methods and fields)
public extension DBusActionGroupProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusActionGroup` instance.
    @inlinable var dbus_action_group_ptr: UnsafeMutablePointer<GDBusActionGroup>! { return ptr?.assumingMemoryBound(to: GDBusActionGroup.self) }



}



// MARK: - DtlsConnection Interface

/// `GDtlsConnection` is the base DTLS connection class type, which wraps
/// a `GDatagramBased` and provides DTLS encryption on top of it. Its
/// subclasses, `GDtlsClientConnection` and `GDtlsServerConnection`,
/// implement client-side and server-side DTLS, respectively.
/// 
/// For TLS support, see `GTlsConnection`.
/// 
/// As DTLS is datagram based, `GDtlsConnection` implements `GDatagramBased`,
/// presenting a datagram-socket-like API for the encrypted connection. This
/// operates over a base datagram connection, which is also a `GDatagramBased`
/// (`GDtlsConnection:base-socket`).
/// 
/// To close a DTLS connection, use `g_dtls_connection_close()`.
/// 
/// Neither `GDtlsServerConnection` or `GDtlsClientConnection` set the peer address
/// on their base `GDatagramBased` if it is a `GSocket`  it is up to the caller to
/// do that if they wish. If they do not, and `g_socket_close()` is called on the
/// base socket, the `GDtlsConnection` will not raise a `G_IO_ERROR_NOT_CONNECTED`
/// error on further I/O.
///
/// The `DtlsConnectionProtocol` protocol exposes the methods and properties of an underlying `GDtlsConnection` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DtlsConnection`.
/// Alternatively, use `DtlsConnectionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DtlsConnectionProtocol: DatagramBasedProtocol {
        /// Untyped pointer to the underlying `GDtlsConnection` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDtlsConnection` instance.
    var dtls_connection_ptr: UnsafeMutablePointer<GDtlsConnection>! { get }

    /// Required Initialiser for types conforming to `DtlsConnectionProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GDtlsConnection` is the base DTLS connection class type, which wraps
/// a `GDatagramBased` and provides DTLS encryption on top of it. Its
/// subclasses, `GDtlsClientConnection` and `GDtlsServerConnection`,
/// implement client-side and server-side DTLS, respectively.
/// 
/// For TLS support, see `GTlsConnection`.
/// 
/// As DTLS is datagram based, `GDtlsConnection` implements `GDatagramBased`,
/// presenting a datagram-socket-like API for the encrypted connection. This
/// operates over a base datagram connection, which is also a `GDatagramBased`
/// (`GDtlsConnection:base-socket`).
/// 
/// To close a DTLS connection, use `g_dtls_connection_close()`.
/// 
/// Neither `GDtlsServerConnection` or `GDtlsClientConnection` set the peer address
/// on their base `GDatagramBased` if it is a `GSocket`  it is up to the caller to
/// do that if they wish. If they do not, and `g_socket_close()` is called on the
/// base socket, the `GDtlsConnection` will not raise a `G_IO_ERROR_NOT_CONNECTED`
/// error on further I/O.
///
/// The `DtlsConnectionRef` type acts as a lightweight Swift reference to an underlying `GDtlsConnection` instance.
/// It exposes methods that can operate on this data type through `DtlsConnectionProtocol` conformance.
/// Use `DtlsConnectionRef` only as an `unowned` reference to an existing `GDtlsConnection` instance.
///
public struct DtlsConnectionRef: DtlsConnectionProtocol {
        /// Untyped pointer to the underlying `GDtlsConnection` instance.
    /// For type-safe access, use the generated, typed pointer `dtls_connection_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DtlsConnectionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDtlsConnection>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDtlsConnection>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDtlsConnection>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDtlsConnection>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DtlsConnectionProtocol`
    @inlinable init<T: DtlsConnectionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsConnectionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsConnectionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsConnectionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsConnectionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsConnectionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// `GDtlsConnection` is the base DTLS connection class type, which wraps
/// a `GDatagramBased` and provides DTLS encryption on top of it. Its
/// subclasses, `GDtlsClientConnection` and `GDtlsServerConnection`,
/// implement client-side and server-side DTLS, respectively.
/// 
/// For TLS support, see `GTlsConnection`.
/// 
/// As DTLS is datagram based, `GDtlsConnection` implements `GDatagramBased`,
/// presenting a datagram-socket-like API for the encrypted connection. This
/// operates over a base datagram connection, which is also a `GDatagramBased`
/// (`GDtlsConnection:base-socket`).
/// 
/// To close a DTLS connection, use `g_dtls_connection_close()`.
/// 
/// Neither `GDtlsServerConnection` or `GDtlsClientConnection` set the peer address
/// on their base `GDatagramBased` if it is a `GSocket`  it is up to the caller to
/// do that if they wish. If they do not, and `g_socket_close()` is called on the
/// base socket, the `GDtlsConnection` will not raise a `G_IO_ERROR_NOT_CONNECTED`
/// error on further I/O.
///
/// The `DtlsConnection` type acts as an owner of an underlying `GDtlsConnection` instance.
/// It provides the methods that can operate on this data type through `DtlsConnectionProtocol` conformance.
/// Use `DtlsConnection` as a strong reference or owner of a `GDtlsConnection` instance.
///
open class DtlsConnection: DatagramBased, DtlsConnectionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DtlsConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDtlsConnection>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DtlsConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDtlsConnection>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DtlsConnection` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DtlsConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DtlsConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDtlsConnection>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DtlsConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDtlsConnection>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GDtlsConnection` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `DtlsConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDtlsConnection>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DtlsConnectionProtocol`
    /// `GDtlsConnection` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `DtlsConnectionProtocol`
    @inlinable public init<T: DtlsConnectionProtocol>(dtlsConnection other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsConnectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsConnectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsConnectionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsConnectionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsConnectionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsConnectionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsConnectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsConnectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum DtlsConnectionPropertyName: String, PropertyNameProtocol {
    /// The list of application-layer protocols that the connection
    /// advertises that it is willing to speak. See
    /// `g_dtls_connection_set_advertised_protocols()`.
    case advertisedProtocols = "advertised-protocols"
    /// The `GDatagramBased` that the connection wraps. Note that this may be any
    /// implementation of `GDatagramBased`, not just a `GSocket`.
    case baseSocket = "base-socket"
    /// The connection's certificate; see
    /// `g_dtls_connection_set_certificate()`.
    case certificate = "certificate"
    /// The name of the DTLS ciphersuite in use. See `g_dtls_connection_get_ciphersuite_name()`.
    case ciphersuiteName = "ciphersuite-name"
    /// The certificate database to use when verifying this TLS connection.
    /// If no certificate database is set, then the default database will be
    /// used. See `g_tls_backend_get_default_database()`.
    /// 
    /// When using a non-default database, `GDtlsConnection` must fall back to using
    /// the `GTlsDatabase` to perform certificate verification using
    /// `g_tls_database_verify_chain()`, which means certificate verification will
    /// not be able to make use of TLS session context. This may be less secure.
    /// For example, if you create your own `GTlsDatabase` that just wraps the
    /// default `GTlsDatabase`, you might expect that you have not changed anything,
    /// but this is not true because you may have altered the behavior of
    /// `GDtlsConnection` by causing it to use `g_tls_database_verify_chain()`. See the
    /// documentation of `g_tls_database_verify_chain()` for more details on specific
    /// security checks that may not be performed. Accordingly, setting a
    /// non-default database is discouraged except for specialty applications with
    /// unusual security requirements.
    case database = "database"
    /// A `GTlsInteraction` object to be used when the connection or certificate
    /// database need to interact with the user. This will be used to prompt the
    /// user for passwords where necessary.
    case interaction = "interaction"
    /// The application-layer protocol negotiated during the TLS
    /// handshake. See `g_dtls_connection_get_negotiated_protocol()`.
    case negotiatedProtocol = "negotiated-protocol"
    /// The connection's peer's certificate, after the TLS handshake has
    /// completed or failed. Note in particular that this is not yet set
    /// during the emission of `GDtlsConnection::accept-certificate`.
    /// 
    /// (You can watch for a `GObject::notify` signal on this property to
    /// detect when a handshake has occurred.)
    case peerCertificate = "peer-certificate"
    /// The errors noticed while verifying
    /// `GDtlsConnection:peer-certificate`. Normally this should be 0, but
    /// it may not be if `GDtlsClientConnection:validation-flags` is not
    /// `G_TLS_CERTIFICATE_VALIDATE_ALL`, or if
    /// `GDtlsConnection::accept-certificate` overrode the default
    /// behavior.
    /// 
    /// GLib guarantees that if certificate verification fails, at least
    /// one error will be set, but it does not guarantee that all possible
    /// errors will be set. Accordingly, you may not safely decide to
    /// ignore any particular type of error. For example, it would be
    /// incorrect to mask `G_TLS_CERTIFICATE_EXPIRED` if you want to allow
    /// expired certificates, because this could potentially be the only
    /// error flag set even if other problems exist with the certificate.
    case peerCertificateErrors = "peer-certificate-errors"
    /// The DTLS protocol version in use. See `g_dtls_connection_get_protocol_version()`.
    case protocolVersion = "protocol-version"
    /// The rehandshaking mode. See
    /// `g_dtls_connection_set_rehandshake_mode()`.
    ///
    /// **rehandshake-mode is deprecated:**
    /// The rehandshake mode is ignored.
    case rehandshakeMode = "rehandshake-mode"
    /// Whether or not proper TLS close notification is required.
    /// See `g_dtls_connection_set_require_close_notify()`.
    case requireCloseNotify = "require-close-notify"
}

public extension DtlsConnectionProtocol {
    /// Bind a `DtlsConnectionPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: DtlsConnectionPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a DtlsConnection property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: DtlsConnectionPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a DtlsConnection property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: DtlsConnectionPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum DtlsConnectionSignalName: String, SignalNameProtocol {
    /// Emitted during the TLS handshake after the peer certificate has
    /// been received. You can examine `peer_cert`'s certification path by
    /// calling `g_tls_certificate_get_issuer()` on it.
    /// 
    /// For a client-side connection, `peer_cert` is the server's
    /// certificate, and the signal will only be emitted if the
    /// certificate was not acceptable according to `conn`'s
    /// `GDtlsClientConnection:validation_flags`. If you would like the
    /// certificate to be accepted despite `errors`, return `true` from the
    /// signal handler. Otherwise, if no handler accepts the certificate,
    /// the handshake will fail with `G_TLS_ERROR_BAD_CERTIFICATE`.
    /// 
    /// GLib guarantees that if certificate verification fails, this signal
    /// will be emitted with at least one error will be set in `errors`, but
    /// it does not guarantee that all possible errors will be set.
    /// Accordingly, you may not safely decide to ignore any particular
    /// type of error. For example, it would be incorrect to ignore
    /// `G_TLS_CERTIFICATE_EXPIRED` if you want to allow expired
    /// certificates, because this could potentially be the only error flag
    /// set even if other problems exist with the certificate.
    /// 
    /// For a server-side connection, `peer_cert` is the certificate
    /// presented by the client, if this was requested via the server's
    /// `GDtlsServerConnection:authentication_mode`. On the server side,
    /// the signal is always emitted when the client presents a
    /// certificate, and the certificate will only be accepted if a
    /// handler returns `true`.
    /// 
    /// Note that if this signal is emitted as part of asynchronous I/O
    /// in the main thread, then you should not attempt to interact with
    /// the user before returning from the signal handler. If you want to
    /// let the user decide whether or not to accept the certificate, you
    /// would have to return `false` from the signal handler on the first
    /// attempt, and then after the connection attempt returns a
    /// `G_TLS_ERROR_BAD_CERTIFICATE`, you can interact with the user, and
    /// if the user decides to accept the certificate, remember that fact,
    /// create a new connection, and return `true` from the signal handler
    /// the next time.
    /// 
    /// If you are doing I/O in another thread, you do not
    /// need to worry about this, and can simply block in the signal
    /// handler until the UI thread returns an answer.
    case acceptCertificate = "accept-certificate"
    /// The list of application-layer protocols that the connection
    /// advertises that it is willing to speak. See
    /// `g_dtls_connection_set_advertised_protocols()`.
    case notifyAdvertisedProtocols = "notify::advertised-protocols"
    /// The `GDatagramBased` that the connection wraps. Note that this may be any
    /// implementation of `GDatagramBased`, not just a `GSocket`.
    case notifyBaseSocket = "notify::base-socket"
    /// The connection's certificate; see
    /// `g_dtls_connection_set_certificate()`.
    case notifyCertificate = "notify::certificate"
    /// The name of the DTLS ciphersuite in use. See `g_dtls_connection_get_ciphersuite_name()`.
    case notifyCiphersuiteName = "notify::ciphersuite-name"
    /// The certificate database to use when verifying this TLS connection.
    /// If no certificate database is set, then the default database will be
    /// used. See `g_tls_backend_get_default_database()`.
    /// 
    /// When using a non-default database, `GDtlsConnection` must fall back to using
    /// the `GTlsDatabase` to perform certificate verification using
    /// `g_tls_database_verify_chain()`, which means certificate verification will
    /// not be able to make use of TLS session context. This may be less secure.
    /// For example, if you create your own `GTlsDatabase` that just wraps the
    /// default `GTlsDatabase`, you might expect that you have not changed anything,
    /// but this is not true because you may have altered the behavior of
    /// `GDtlsConnection` by causing it to use `g_tls_database_verify_chain()`. See the
    /// documentation of `g_tls_database_verify_chain()` for more details on specific
    /// security checks that may not be performed. Accordingly, setting a
    /// non-default database is discouraged except for specialty applications with
    /// unusual security requirements.
    case notifyDatabase = "notify::database"
    /// A `GTlsInteraction` object to be used when the connection or certificate
    /// database need to interact with the user. This will be used to prompt the
    /// user for passwords where necessary.
    case notifyInteraction = "notify::interaction"
    /// The application-layer protocol negotiated during the TLS
    /// handshake. See `g_dtls_connection_get_negotiated_protocol()`.
    case notifyNegotiatedProtocol = "notify::negotiated-protocol"
    /// The connection's peer's certificate, after the TLS handshake has
    /// completed or failed. Note in particular that this is not yet set
    /// during the emission of `GDtlsConnection::accept-certificate`.
    /// 
    /// (You can watch for a `GObject::notify` signal on this property to
    /// detect when a handshake has occurred.)
    case notifyPeerCertificate = "notify::peer-certificate"
    /// The errors noticed while verifying
    /// `GDtlsConnection:peer-certificate`. Normally this should be 0, but
    /// it may not be if `GDtlsClientConnection:validation-flags` is not
    /// `G_TLS_CERTIFICATE_VALIDATE_ALL`, or if
    /// `GDtlsConnection::accept-certificate` overrode the default
    /// behavior.
    /// 
    /// GLib guarantees that if certificate verification fails, at least
    /// one error will be set, but it does not guarantee that all possible
    /// errors will be set. Accordingly, you may not safely decide to
    /// ignore any particular type of error. For example, it would be
    /// incorrect to mask `G_TLS_CERTIFICATE_EXPIRED` if you want to allow
    /// expired certificates, because this could potentially be the only
    /// error flag set even if other problems exist with the certificate.
    case notifyPeerCertificateErrors = "notify::peer-certificate-errors"
    /// The DTLS protocol version in use. See `g_dtls_connection_get_protocol_version()`.
    case notifyProtocolVersion = "notify::protocol-version"
    /// The rehandshaking mode. See
    /// `g_dtls_connection_set_rehandshake_mode()`.
    ///
    /// **rehandshake-mode is deprecated:**
    /// The rehandshake mode is ignored.
    case notifyRehandshakeMode = "notify::rehandshake-mode"
    /// Whether or not proper TLS close notification is required.
    /// See `g_dtls_connection_set_require_close_notify()`.
    case notifyRequireCloseNotify = "notify::require-close-notify"
}

// MARK: DtlsConnection signals
public extension DtlsConnectionProtocol {
    /// Connect a Swift signal handler to the given, typed `DtlsConnectionSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DtlsConnectionSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        GLibObject.ObjectRef(raw: ptr).connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `DtlsConnectionSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DtlsConnectionSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        GLibObject.ObjectRef(raw: ptr).connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted during the TLS handshake after the peer certificate has
    /// been received. You can examine `peer_cert`'s certification path by
    /// calling `g_tls_certificate_get_issuer()` on it.
    /// 
    /// For a client-side connection, `peer_cert` is the server's
    /// certificate, and the signal will only be emitted if the
    /// certificate was not acceptable according to `conn`'s
    /// `GDtlsClientConnection:validation_flags`. If you would like the
    /// certificate to be accepted despite `errors`, return `true` from the
    /// signal handler. Otherwise, if no handler accepts the certificate,
    /// the handshake will fail with `G_TLS_ERROR_BAD_CERTIFICATE`.
    /// 
    /// GLib guarantees that if certificate verification fails, this signal
    /// will be emitted with at least one error will be set in `errors`, but
    /// it does not guarantee that all possible errors will be set.
    /// Accordingly, you may not safely decide to ignore any particular
    /// type of error. For example, it would be incorrect to ignore
    /// `G_TLS_CERTIFICATE_EXPIRED` if you want to allow expired
    /// certificates, because this could potentially be the only error flag
    /// set even if other problems exist with the certificate.
    /// 
    /// For a server-side connection, `peer_cert` is the certificate
    /// presented by the client, if this was requested via the server's
    /// `GDtlsServerConnection:authentication_mode`. On the server side,
    /// the signal is always emitted when the client presents a
    /// certificate, and the certificate will only be accepted if a
    /// handler returns `true`.
    /// 
    /// Note that if this signal is emitted as part of asynchronous I/O
    /// in the main thread, then you should not attempt to interact with
    /// the user before returning from the signal handler. If you want to
    /// let the user decide whether or not to accept the certificate, you
    /// would have to return `false` from the signal handler on the first
    /// attempt, and then after the connection attempt returns a
    /// `G_TLS_ERROR_BAD_CERTIFICATE`, you can interact with the user, and
    /// if the user decides to accept the certificate, remember that fact,
    /// create a new connection, and return `true` from the signal handler
    /// the next time.
    /// 
    /// If you are doing I/O in another thread, you do not
    /// need to worry about this, and can simply block in the signal
    /// handler until the UI thread returns an answer.
    /// - Note: This represents the underlying `accept-certificate` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter peerCert: the peer's `GTlsCertificate`
    /// - Parameter errors: the problems with `peer_cert`.
    /// - Parameter handler: `true` to accept `peer_cert` (which will also immediately end the signal emission). `false` to allow the signal emission to continue, which will cause the handshake to fail if no one else overrides it.
    /// Run the given callback whenever the `acceptCertificate` signal is emitted
    @discardableResult @inlinable func onAcceptCertificate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DtlsConnectionRef, _ peerCert: TLSCertificateRef, _ errors: TLSCertificateFlags) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DtlsConnectionRef, TLSCertificateRef, TLSCertificateFlags), Bool>
        let cCallback: @convention(c) (gpointer, gpointer, UInt32, gpointer) -> gboolean = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call((DtlsConnectionRef(raw: unownedSelf), TLSCertificateRef(raw: arg1), TLSCertificateFlags(arg2)))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .acceptCertificate,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `accept-certificate` signal for using the `connect(signal:)` methods
    static var acceptCertificateSignal: DtlsConnectionSignalName { .acceptCertificate }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::advertised-protocols` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAdvertisedProtocols` signal is emitted
    @discardableResult @inlinable func onNotifyAdvertisedProtocols(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DtlsConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DtlsConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DtlsConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyAdvertisedProtocols,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::advertised-protocols` signal for using the `connect(signal:)` methods
    static var notifyAdvertisedProtocolsSignal: DtlsConnectionSignalName { .notifyAdvertisedProtocols }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::base-socket` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyBaseSocket` signal is emitted
    @discardableResult @inlinable func onNotifyBaseSocket(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DtlsConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DtlsConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DtlsConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyBaseSocket,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::base-socket` signal for using the `connect(signal:)` methods
    static var notifyBaseSocketSignal: DtlsConnectionSignalName { .notifyBaseSocket }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::certificate` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyCertificate` signal is emitted
    @discardableResult @inlinable func onNotifyCertificate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DtlsConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DtlsConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DtlsConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyCertificate,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::certificate` signal for using the `connect(signal:)` methods
    static var notifyCertificateSignal: DtlsConnectionSignalName { .notifyCertificate }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::ciphersuite-name` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyCiphersuiteName` signal is emitted
    @discardableResult @inlinable func onNotifyCiphersuiteName(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DtlsConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DtlsConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DtlsConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyCiphersuiteName,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::ciphersuite-name` signal for using the `connect(signal:)` methods
    static var notifyCiphersuiteNameSignal: DtlsConnectionSignalName { .notifyCiphersuiteName }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::database` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyDatabase` signal is emitted
    @discardableResult @inlinable func onNotifyDatabase(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DtlsConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DtlsConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DtlsConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyDatabase,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::database` signal for using the `connect(signal:)` methods
    static var notifyDatabaseSignal: DtlsConnectionSignalName { .notifyDatabase }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::interaction` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyInteraction` signal is emitted
    @discardableResult @inlinable func onNotifyInteraction(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DtlsConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DtlsConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DtlsConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyInteraction,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::interaction` signal for using the `connect(signal:)` methods
    static var notifyInteractionSignal: DtlsConnectionSignalName { .notifyInteraction }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::negotiated-protocol` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyNegotiatedProtocol` signal is emitted
    @discardableResult @inlinable func onNotifyNegotiatedProtocol(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DtlsConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DtlsConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DtlsConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyNegotiatedProtocol,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::negotiated-protocol` signal for using the `connect(signal:)` methods
    static var notifyNegotiatedProtocolSignal: DtlsConnectionSignalName { .notifyNegotiatedProtocol }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::peer-certificate` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPeerCertificate` signal is emitted
    @discardableResult @inlinable func onNotifyPeerCertificate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DtlsConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DtlsConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DtlsConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyPeerCertificate,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::peer-certificate` signal for using the `connect(signal:)` methods
    static var notifyPeerCertificateSignal: DtlsConnectionSignalName { .notifyPeerCertificate }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::peer-certificate-errors` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPeerCertificateErrors` signal is emitted
    @discardableResult @inlinable func onNotifyPeerCertificateErrors(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DtlsConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DtlsConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DtlsConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyPeerCertificateErrors,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::peer-certificate-errors` signal for using the `connect(signal:)` methods
    static var notifyPeerCertificateErrorsSignal: DtlsConnectionSignalName { .notifyPeerCertificateErrors }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::protocol-version` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyProtocolVersion` signal is emitted
    @discardableResult @inlinable func onNotifyProtocolVersion(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DtlsConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DtlsConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DtlsConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyProtocolVersion,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::protocol-version` signal for using the `connect(signal:)` methods
    static var notifyProtocolVersionSignal: DtlsConnectionSignalName { .notifyProtocolVersion }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::rehandshake-mode` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyRehandshakeMode` signal is emitted
    @discardableResult @inlinable func onNotifyRehandshakeMode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DtlsConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DtlsConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DtlsConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyRehandshakeMode,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::rehandshake-mode` signal for using the `connect(signal:)` methods
    static var notifyRehandshakeModeSignal: DtlsConnectionSignalName { .notifyRehandshakeMode }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::require-close-notify` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyRequireCloseNotify` signal is emitted
    @discardableResult @inlinable func onNotifyRequireCloseNotify(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DtlsConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DtlsConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DtlsConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyRequireCloseNotify,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::require-close-notify` signal for using the `connect(signal:)` methods
    static var notifyRequireCloseNotifySignal: DtlsConnectionSignalName { .notifyRequireCloseNotify }
    
}

// MARK: DtlsConnection Interface: DtlsConnectionProtocol extension (methods and fields)
public extension DtlsConnectionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDtlsConnection` instance.
    @inlinable var dtls_connection_ptr: UnsafeMutablePointer<GDtlsConnection>! { return ptr?.assumingMemoryBound(to: GDtlsConnection.self) }

    /// Close the DTLS connection. This is equivalent to calling
    /// `g_dtls_connection_shutdown()` to shut down both sides of the connection.
    /// 
    /// Closing a `GDtlsConnection` waits for all buffered but untransmitted data to
    /// be sent before it completes. It then sends a `close_notify` DTLS alert to the
    /// peer and may wait for a `close_notify` to be received from the peer. It does
    /// not close the underlying `GDtlsConnection:base-socket`; that must be closed
    /// separately.
    /// 
    /// Once `conn` is closed, all other operations will return `G_IO_ERROR_CLOSED`.
    /// Closing a `GDtlsConnection` multiple times will not return an error.
    /// 
    /// `GDtlsConnections` will be automatically closed when the last reference is
    /// dropped, but you might want to call this function to make sure resources are
    /// released as early as possible.
    /// 
    /// If `cancellable` is cancelled, the `GDtlsConnection` may be left
    /// partially-closed and any pending untransmitted data may be lost. Call
    /// `g_dtls_connection_close()` again to complete closing the `GDtlsConnection`.
    @inlinable func close(cancellable: CancellableRef? = nil) throws -> Bool {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dtls_connection_close(dtls_connection_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
            return rv
    }
    /// Close the DTLS connection. This is equivalent to calling
    /// `g_dtls_connection_shutdown()` to shut down both sides of the connection.
    /// 
    /// Closing a `GDtlsConnection` waits for all buffered but untransmitted data to
    /// be sent before it completes. It then sends a `close_notify` DTLS alert to the
    /// peer and may wait for a `close_notify` to be received from the peer. It does
    /// not close the underlying `GDtlsConnection:base-socket`; that must be closed
    /// separately.
    /// 
    /// Once `conn` is closed, all other operations will return `G_IO_ERROR_CLOSED`.
    /// Closing a `GDtlsConnection` multiple times will not return an error.
    /// 
    /// `GDtlsConnections` will be automatically closed when the last reference is
    /// dropped, but you might want to call this function to make sure resources are
    /// released as early as possible.
    /// 
    /// If `cancellable` is cancelled, the `GDtlsConnection` may be left
    /// partially-closed and any pending untransmitted data may be lost. Call
    /// `g_dtls_connection_close()` again to complete closing the `GDtlsConnection`.
    @inlinable func close<CancellableT: CancellableProtocol>(cancellable: CancellableT?) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dtls_connection_close(dtls_connection_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Asynchronously close the DTLS connection. See `g_dtls_connection_close()` for
    /// more information.
    @inlinable func closeAsync(ioPriority: Int, cancellable: CancellableRef? = nil, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
            
        g_dtls_connection_close_async(dtls_connection_ptr, gint(ioPriority), cancellable?.cancellable_ptr, callback, userData)
            
    }
    /// Asynchronously close the DTLS connection. See `g_dtls_connection_close()` for
    /// more information.
    @inlinable func closeAsync<CancellableT: CancellableProtocol>(ioPriority: Int, cancellable: CancellableT?, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
        
        g_dtls_connection_close_async(dtls_connection_ptr, gint(ioPriority), cancellable?.cancellable_ptr, callback, userData)
        
    }

    /// Finish an asynchronous TLS close operation. See `g_dtls_connection_close()`
    /// for more information.
    @inlinable func closeFinish<AsyncResultT: AsyncResultProtocol>(result: AsyncResultT) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dtls_connection_close_finish(dtls_connection_ptr, result.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Used by `GDtlsConnection` implementations to emit the
    /// `GDtlsConnection::accept-certificate` signal.
    @inlinable func emitAcceptCertificate<TLSCertificateT: TLSCertificateProtocol>(peerCert: TLSCertificateT, errors: TLSCertificateFlags) -> Bool {
        let result = g_dtls_connection_emit_accept_certificate(dtls_connection_ptr, peerCert.tls_certificate_ptr, errors.value)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets `conn`'s certificate, as set by
    /// `g_dtls_connection_set_certificate()`.
    @inlinable func getCertificate() -> GIO.TLSCertificateRef! {
        let result = g_dtls_connection_get_certificate(dtls_connection_ptr)
        let rv = TLSCertificateRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Query the TLS backend for TLS channel binding data of `type` for `conn`.
    /// 
    /// This call retrieves TLS channel binding data as specified in RFC
    /// [5056](https://tools.ietf.org/html/rfc5056), RFC
    /// [5929](https://tools.ietf.org/html/rfc5929), and related RFCs.  The
    /// binding data is returned in `data`.  The `data` is resized by the callee
    /// using `GByteArray` buffer management and will be freed when the `data`
    /// is destroyed by `g_byte_array_unref()`. If `data` is `nil`, it will only
    /// check whether TLS backend is able to fetch the data (e.g. whether `type`
    /// is supported by the TLS backend). It does not guarantee that the data
    /// will be available though.  That could happen if TLS connection does not
    /// support `type` or the binding data is not available yet due to additional
    /// negotiation or input required.
    @inlinable func getChannelBindingData(type: GTlsChannelBindingType, data: GLib.ByteArrayRef? = nil) throws -> Bool {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dtls_connection_get_channel_binding_data(dtls_connection_ptr, type, data?.byte_array_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
            return rv
    }
    /// Query the TLS backend for TLS channel binding data of `type` for `conn`.
    /// 
    /// This call retrieves TLS channel binding data as specified in RFC
    /// [5056](https://tools.ietf.org/html/rfc5056), RFC
    /// [5929](https://tools.ietf.org/html/rfc5929), and related RFCs.  The
    /// binding data is returned in `data`.  The `data` is resized by the callee
    /// using `GByteArray` buffer management and will be freed when the `data`
    /// is destroyed by `g_byte_array_unref()`. If `data` is `nil`, it will only
    /// check whether TLS backend is able to fetch the data (e.g. whether `type`
    /// is supported by the TLS backend). It does not guarantee that the data
    /// will be available though.  That could happen if TLS connection does not
    /// support `type` or the binding data is not available yet due to additional
    /// negotiation or input required.
    @inlinable func getChannelBindingData<GLibByteArrayT: GLib.ByteArrayProtocol>(type: GTlsChannelBindingType, data: GLibByteArrayT?) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dtls_connection_get_channel_binding_data(dtls_connection_ptr, type, data?.byte_array_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Returns the name of the current DTLS ciphersuite, or `nil` if the
    /// connection has not handshaked or has been closed. Beware that the TLS
    /// backend may use any of multiple different naming conventions, because
    /// OpenSSL and GnuTLS have their own ciphersuite naming conventions that
    /// are different from each other and different from the standard, IANA-
    /// registered ciphersuite names. The ciphersuite name is intended to be
    /// displayed to the user for informative purposes only, and parsing it
    /// is not recommended.
    @inlinable func getCiphersuiteName() -> String! {
        let result = g_dtls_connection_get_ciphersuite_name(dtls_connection_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets the certificate database that `conn` uses to verify
    /// peer certificates. See `g_dtls_connection_set_database()`.
    @inlinable func getDatabase() -> GIO.TLSDatabaseRef! {
        let result = g_dtls_connection_get_database(dtls_connection_ptr)
        let rv = TLSDatabaseRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Get the object that will be used to interact with the user. It will be used
    /// for things like prompting the user for passwords. If `nil` is returned, then
    /// no user interaction will occur for this connection.
    @inlinable func getInteraction() -> GIO.TLSInteractionRef! {
        let result = g_dtls_connection_get_interaction(dtls_connection_ptr)
        let rv = TLSInteractionRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the name of the application-layer protocol negotiated during
    /// the handshake.
    /// 
    /// If the peer did not use the ALPN extension, or did not advertise a
    /// protocol that matched one of `conn`'s protocols, or the TLS backend
    /// does not support ALPN, then this will be `nil`. See
    /// `g_dtls_connection_set_advertised_protocols()`.
    @inlinable func getNegotiatedProtocol() -> String! {
        let result = g_dtls_connection_get_negotiated_protocol(dtls_connection_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets `conn`'s peer's certificate after the handshake has completed
    /// or failed. (It is not set during the emission of
    /// `GDtlsConnection::accept-certificate`.)
    @inlinable func getPeerCertificate() -> GIO.TLSCertificateRef! {
        let result = g_dtls_connection_get_peer_certificate(dtls_connection_ptr)
        let rv = TLSCertificateRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the errors associated with validating `conn`'s peer's
    /// certificate, after the handshake has completed or failed. (It is
    /// not set during the emission of `GDtlsConnection::accept-certificate`.)
    @inlinable func getPeerCertificateErrors() -> GIO.TLSCertificateFlags {
        let result = g_dtls_connection_get_peer_certificate_errors(dtls_connection_ptr)
        let rv = TLSCertificateFlags(result)
        return rv
    }

    /// Returns the current DTLS protocol version, which may be
    /// `G_TLS_PROTOCOL_VERSION_UNKNOWN` if the connection has not handshaked, or
    /// has been closed, or if the TLS backend has implemented a protocol version
    /// that is not a recognized `GTlsProtocolVersion`.
    @inlinable func getProtocolVersion() -> GTlsProtocolVersion {
        let result = g_dtls_connection_get_protocol_version(dtls_connection_ptr)
        let rv = result
        return rv
    }

    /// Gets `conn` rehandshaking mode. See
    /// `g_dtls_connection_set_rehandshake_mode()` for details.
    ///
    /// **get_rehandshake_mode is deprecated:**
    /// Changing the rehandshake mode is no longer
    ///   required for compatibility. Also, rehandshaking has been removed
    ///   from the TLS protocol in TLS 1.3.
    @available(*, deprecated) @inlinable func getRehandshakeMode() -> GTlsRehandshakeMode {
        let result = g_dtls_connection_get_rehandshake_mode(dtls_connection_ptr)
        let rv = result
        return rv
    }

    /// Tests whether or not `conn` expects a proper TLS close notification
    /// when the connection is closed. See
    /// `g_dtls_connection_set_require_close_notify()` for details.
    @inlinable func getRequireCloseNotify() -> Bool {
        let result = g_dtls_connection_get_require_close_notify(dtls_connection_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Attempts a TLS handshake on `conn`.
    /// 
    /// On the client side, it is never necessary to call this method;
    /// although the connection needs to perform a handshake after
    /// connecting, `GDtlsConnection` will handle this for you automatically
    /// when you try to send or receive data on the connection. You can call
    /// `g_dtls_connection_handshake()` manually if you want to know whether
    /// the initial handshake succeeded or failed (as opposed to just
    /// immediately trying to use `conn` to read or write, in which case,
    /// if it fails, it may not be possible to tell if it failed before
    /// or after completing the handshake), but beware that servers may reject
    /// client authentication after the handshake has completed, so a
    /// successful handshake does not indicate the connection will be usable.
    /// 
    /// Likewise, on the server side, although a handshake is necessary at
    /// the beginning of the communication, you do not need to call this
    /// function explicitly unless you want clearer error reporting.
    /// 
    /// Previously, calling `g_dtls_connection_handshake()` after the initial
    /// handshake would trigger a rehandshake; however, this usage was
    /// deprecated in GLib 2.60 because rehandshaking was removed from the
    /// TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
    /// the initial handshake will no longer do anything.
    /// 
    /// `GDtlsConnection::accept_certificate` may be emitted during the
    /// handshake.
    @inlinable func handshake(cancellable: CancellableRef? = nil) throws -> Bool {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dtls_connection_handshake(dtls_connection_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
            return rv
    }
    /// Attempts a TLS handshake on `conn`.
    /// 
    /// On the client side, it is never necessary to call this method;
    /// although the connection needs to perform a handshake after
    /// connecting, `GDtlsConnection` will handle this for you automatically
    /// when you try to send or receive data on the connection. You can call
    /// `g_dtls_connection_handshake()` manually if you want to know whether
    /// the initial handshake succeeded or failed (as opposed to just
    /// immediately trying to use `conn` to read or write, in which case,
    /// if it fails, it may not be possible to tell if it failed before
    /// or after completing the handshake), but beware that servers may reject
    /// client authentication after the handshake has completed, so a
    /// successful handshake does not indicate the connection will be usable.
    /// 
    /// Likewise, on the server side, although a handshake is necessary at
    /// the beginning of the communication, you do not need to call this
    /// function explicitly unless you want clearer error reporting.
    /// 
    /// Previously, calling `g_dtls_connection_handshake()` after the initial
    /// handshake would trigger a rehandshake; however, this usage was
    /// deprecated in GLib 2.60 because rehandshaking was removed from the
    /// TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
    /// the initial handshake will no longer do anything.
    /// 
    /// `GDtlsConnection::accept_certificate` may be emitted during the
    /// handshake.
    @inlinable func handshake<CancellableT: CancellableProtocol>(cancellable: CancellableT?) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dtls_connection_handshake(dtls_connection_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Asynchronously performs a TLS handshake on `conn`. See
    /// `g_dtls_connection_handshake()` for more information.
    @inlinable func handshakeAsync(ioPriority: Int, cancellable: CancellableRef? = nil, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
            
        g_dtls_connection_handshake_async(dtls_connection_ptr, gint(ioPriority), cancellable?.cancellable_ptr, callback, userData)
            
    }
    /// Asynchronously performs a TLS handshake on `conn`. See
    /// `g_dtls_connection_handshake()` for more information.
    @inlinable func handshakeAsync<CancellableT: CancellableProtocol>(ioPriority: Int, cancellable: CancellableT?, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
        
        g_dtls_connection_handshake_async(dtls_connection_ptr, gint(ioPriority), cancellable?.cancellable_ptr, callback, userData)
        
    }

    /// Finish an asynchronous TLS handshake operation. See
    /// `g_dtls_connection_handshake()` for more information.
    @inlinable func handshakeFinish<AsyncResultT: AsyncResultProtocol>(result: AsyncResultT) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dtls_connection_handshake_finish(dtls_connection_ptr, result.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Sets the list of application-layer protocols to advertise that the
    /// caller is willing to speak on this connection. The
    /// Application-Layer Protocol Negotiation (ALPN) extension will be
    /// used to negotiate a compatible protocol with the peer; use
    /// `g_dtls_connection_get_negotiated_protocol()` to find the negotiated
    /// protocol after the handshake.  Specifying `nil` for the the value
    /// of `protocols` will disable ALPN negotiation.
    /// 
    /// See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml`alpn-protocol-ids`)
    /// for a list of registered protocol IDs.
    @inlinable func setAdvertised(protocols: UnsafePointer<UnsafePointer<gchar>?>! = nil) {
        
        g_dtls_connection_set_advertised_protocols(dtls_connection_ptr, protocols)
        
    }

    /// This sets the certificate that `conn` will present to its peer
    /// during the TLS handshake. For a `GDtlsServerConnection`, it is
    /// mandatory to set this, and that will normally be done at construct
    /// time.
    /// 
    /// For a `GDtlsClientConnection`, this is optional. If a handshake fails
    /// with `G_TLS_ERROR_CERTIFICATE_REQUIRED`, that means that the server
    /// requires a certificate, and if you try connecting again, you should
    /// call this method first. You can call
    /// `g_dtls_client_connection_get_accepted_cas()` on the failed connection
    /// to get a list of Certificate Authorities that the server will
    /// accept certificates from.
    /// 
    /// (It is also possible that a server will allow the connection with
    /// or without a certificate; in that case, if you don't provide a
    /// certificate, you can tell that the server requested one by the fact
    /// that `g_dtls_client_connection_get_accepted_cas()` will return
    /// non-`nil`.)
    @inlinable func set<TLSCertificateT: TLSCertificateProtocol>(certificate: TLSCertificateT) {
        
        g_dtls_connection_set_certificate(dtls_connection_ptr, certificate.tls_certificate_ptr)
        
    }

    /// Sets the certificate database that is used to verify peer certificates.
    /// This is set to the default database by default. See
    /// `g_tls_backend_get_default_database()`. If set to `nil`, then
    /// peer certificate validation will always set the
    /// `G_TLS_CERTIFICATE_UNKNOWN_CA` error (meaning
    /// `GDtlsConnection::accept-certificate` will always be emitted on
    /// client-side connections, unless that bit is not set in
    /// `GDtlsClientConnection:validation-flags`).
    /// 
    /// There are nonintuitive security implications when using a non-default
    /// database. See `GDtlsConnection:database` for details.
    @inlinable func set(database: TLSDatabaseRef? = nil) {
            
        g_dtls_connection_set_database(dtls_connection_ptr, database?.tls_database_ptr)
            
    }
    /// Sets the certificate database that is used to verify peer certificates.
    /// This is set to the default database by default. See
    /// `g_tls_backend_get_default_database()`. If set to `nil`, then
    /// peer certificate validation will always set the
    /// `G_TLS_CERTIFICATE_UNKNOWN_CA` error (meaning
    /// `GDtlsConnection::accept-certificate` will always be emitted on
    /// client-side connections, unless that bit is not set in
    /// `GDtlsClientConnection:validation-flags`).
    /// 
    /// There are nonintuitive security implications when using a non-default
    /// database. See `GDtlsConnection:database` for details.
    @inlinable func set<TLSDatabaseT: TLSDatabaseProtocol>(database: TLSDatabaseT?) {
        
        g_dtls_connection_set_database(dtls_connection_ptr, database?.tls_database_ptr)
        
    }

    /// Set the object that will be used to interact with the user. It will be used
    /// for things like prompting the user for passwords.
    /// 
    /// The `interaction` argument will normally be a derived subclass of
    /// `GTlsInteraction`. `nil` can also be provided if no user interaction
    /// should occur for this connection.
    @inlinable func set(interaction: TLSInteractionRef? = nil) {
            
        g_dtls_connection_set_interaction(dtls_connection_ptr, interaction?.tls_interaction_ptr)
            
    }
    /// Set the object that will be used to interact with the user. It will be used
    /// for things like prompting the user for passwords.
    /// 
    /// The `interaction` argument will normally be a derived subclass of
    /// `GTlsInteraction`. `nil` can also be provided if no user interaction
    /// should occur for this connection.
    @inlinable func set<TLSInteractionT: TLSInteractionProtocol>(interaction: TLSInteractionT?) {
        
        g_dtls_connection_set_interaction(dtls_connection_ptr, interaction?.tls_interaction_ptr)
        
    }

    /// Since GLib 2.64, changing the rehandshake mode is no longer supported
    /// and will have no effect. With TLS 1.3, rehandshaking has been removed from
    /// the TLS protocol, replaced by separate post-handshake authentication and
    /// rekey operations.
    ///
    /// **set_rehandshake_mode is deprecated:**
    /// Changing the rehandshake mode is no longer
    ///   required for compatibility. Also, rehandshaking has been removed
    ///   from the TLS protocol in TLS 1.3.
    @available(*, deprecated) @inlinable func setRehandshake(mode: GTlsRehandshakeMode) {
        
        g_dtls_connection_set_rehandshake_mode(dtls_connection_ptr, mode)
        
    }

    /// Sets whether or not `conn` expects a proper TLS close notification
    /// before the connection is closed. If this is `true` (the default),
    /// then `conn` will expect to receive a TLS close notification from its
    /// peer before the connection is closed, and will return a
    /// `G_TLS_ERROR_EOF` error if the connection is closed without proper
    /// notification (since this may indicate a network error, or
    /// man-in-the-middle attack).
    /// 
    /// In some protocols, the application will know whether or not the
    /// connection was closed cleanly based on application-level data
    /// (because the application-level data includes a length field, or is
    /// somehow self-delimiting); in this case, the close notify is
    /// redundant and may be omitted. You
    /// can use `g_dtls_connection_set_require_close_notify()` to tell `conn`
    /// to allow an "unannounced" connection close, in which case the close
    /// will show up as a 0-length read, as in a non-TLS
    /// `GDatagramBased`, and it is up to the application to check that
    /// the data has been fully received.
    /// 
    /// Note that this only affects the behavior when the peer closes the
    /// connection; when the application calls `g_dtls_connection_close_async()` on
    /// `conn` itself, this will send a close notification regardless of the
    /// setting of this property. If you explicitly want to do an unclean
    /// close, you can close `conn`'s `GDtlsConnection:base-socket` rather
    /// than closing `conn` itself.
    @inlinable func set(requireCloseNotify: Bool) {
        
        g_dtls_connection_set_require_close_notify(dtls_connection_ptr, gboolean((requireCloseNotify) ? 1 : 0))
        
    }

    /// Shut down part or all of a DTLS connection.
    /// 
    /// If `shutdown_read` is `true` then the receiving side of the connection is shut
    /// down, and further reading is disallowed. Subsequent calls to
    /// `g_datagram_based_receive_messages()` will return `G_IO_ERROR_CLOSED`.
    /// 
    /// If `shutdown_write` is `true` then the sending side of the connection is shut
    /// down, and further writing is disallowed. Subsequent calls to
    /// `g_datagram_based_send_messages()` will return `G_IO_ERROR_CLOSED`.
    /// 
    /// It is allowed for both `shutdown_read` and `shutdown_write` to be TRUE  this
    /// is equivalent to calling `g_dtls_connection_close()`.
    /// 
    /// If `cancellable` is cancelled, the `GDtlsConnection` may be left
    /// partially-closed and any pending untransmitted data may be lost. Call
    /// `g_dtls_connection_shutdown()` again to complete closing the `GDtlsConnection`.
    @inlinable func shutdown(shutdownRead: Bool, shutdownWrite: Bool, cancellable: CancellableRef? = nil) throws -> Bool {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dtls_connection_shutdown(dtls_connection_ptr, gboolean((shutdownRead) ? 1 : 0), gboolean((shutdownWrite) ? 1 : 0), cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
            return rv
    }
    /// Shut down part or all of a DTLS connection.
    /// 
    /// If `shutdown_read` is `true` then the receiving side of the connection is shut
    /// down, and further reading is disallowed. Subsequent calls to
    /// `g_datagram_based_receive_messages()` will return `G_IO_ERROR_CLOSED`.
    /// 
    /// If `shutdown_write` is `true` then the sending side of the connection is shut
    /// down, and further writing is disallowed. Subsequent calls to
    /// `g_datagram_based_send_messages()` will return `G_IO_ERROR_CLOSED`.
    /// 
    /// It is allowed for both `shutdown_read` and `shutdown_write` to be TRUE  this
    /// is equivalent to calling `g_dtls_connection_close()`.
    /// 
    /// If `cancellable` is cancelled, the `GDtlsConnection` may be left
    /// partially-closed and any pending untransmitted data may be lost. Call
    /// `g_dtls_connection_shutdown()` again to complete closing the `GDtlsConnection`.
    @inlinable func shutdown<CancellableT: CancellableProtocol>(shutdownRead: Bool, shutdownWrite: Bool, cancellable: CancellableT?) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dtls_connection_shutdown(dtls_connection_ptr, gboolean((shutdownRead) ? 1 : 0), gboolean((shutdownWrite) ? 1 : 0), cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Asynchronously shut down part or all of the DTLS connection. See
    /// `g_dtls_connection_shutdown()` for more information.
    @inlinable func shutdownAsync(shutdownRead: Bool, shutdownWrite: Bool, ioPriority: Int, cancellable: CancellableRef? = nil, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
            
        g_dtls_connection_shutdown_async(dtls_connection_ptr, gboolean((shutdownRead) ? 1 : 0), gboolean((shutdownWrite) ? 1 : 0), gint(ioPriority), cancellable?.cancellable_ptr, callback, userData)
            
    }
    /// Asynchronously shut down part or all of the DTLS connection. See
    /// `g_dtls_connection_shutdown()` for more information.
    @inlinable func shutdownAsync<CancellableT: CancellableProtocol>(shutdownRead: Bool, shutdownWrite: Bool, ioPriority: Int, cancellable: CancellableT?, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
        
        g_dtls_connection_shutdown_async(dtls_connection_ptr, gboolean((shutdownRead) ? 1 : 0), gboolean((shutdownWrite) ? 1 : 0), gint(ioPriority), cancellable?.cancellable_ptr, callback, userData)
        
    }

    /// Finish an asynchronous TLS shutdown operation. See
    /// `g_dtls_connection_shutdown()` for more information.
    @inlinable func shutdownFinish<AsyncResultT: AsyncResultProtocol>(result: AsyncResultT) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dtls_connection_shutdown_finish(dtls_connection_ptr, result.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }
    /// The connection's certificate; see
    /// `g_dtls_connection_set_certificate()`.
    @inlinable var certificate: GIO.TLSCertificateRef! {
        /// Gets `conn`'s certificate, as set by
        /// `g_dtls_connection_set_certificate()`.
        get {
            let result = g_dtls_connection_get_certificate(dtls_connection_ptr)
        let rv = TLSCertificateRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// This sets the certificate that `conn` will present to its peer
        /// during the TLS handshake. For a `GDtlsServerConnection`, it is
        /// mandatory to set this, and that will normally be done at construct
        /// time.
        /// 
        /// For a `GDtlsClientConnection`, this is optional. If a handshake fails
        /// with `G_TLS_ERROR_CERTIFICATE_REQUIRED`, that means that the server
        /// requires a certificate, and if you try connecting again, you should
        /// call this method first. You can call
        /// `g_dtls_client_connection_get_accepted_cas()` on the failed connection
        /// to get a list of Certificate Authorities that the server will
        /// accept certificates from.
        /// 
        /// (It is also possible that a server will allow the connection with
        /// or without a certificate; in that case, if you don't provide a
        /// certificate, you can tell that the server requested one by the fact
        /// that `g_dtls_client_connection_get_accepted_cas()` will return
        /// non-`nil`.)
        nonmutating set {
            g_dtls_connection_set_certificate(dtls_connection_ptr, UnsafeMutablePointer<GTlsCertificate>(newValue?.tls_certificate_ptr))
        }
    }

    /// Returns the name of the current DTLS ciphersuite, or `nil` if the
    /// connection has not handshaked or has been closed. Beware that the TLS
    /// backend may use any of multiple different naming conventions, because
    /// OpenSSL and GnuTLS have their own ciphersuite naming conventions that
    /// are different from each other and different from the standard, IANA-
    /// registered ciphersuite names. The ciphersuite name is intended to be
    /// displayed to the user for informative purposes only, and parsing it
    /// is not recommended.
    @inlinable var ciphersuiteName: String! {
        /// Returns the name of the current DTLS ciphersuite, or `nil` if the
        /// connection has not handshaked or has been closed. Beware that the TLS
        /// backend may use any of multiple different naming conventions, because
        /// OpenSSL and GnuTLS have their own ciphersuite naming conventions that
        /// are different from each other and different from the standard, IANA-
        /// registered ciphersuite names. The ciphersuite name is intended to be
        /// displayed to the user for informative purposes only, and parsing it
        /// is not recommended.
        get {
            let result = g_dtls_connection_get_ciphersuite_name(dtls_connection_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// The certificate database to use when verifying this TLS connection.
    /// If no certificate database is set, then the default database will be
    /// used. See `g_tls_backend_get_default_database()`.
    /// 
    /// When using a non-default database, `GDtlsConnection` must fall back to using
    /// the `GTlsDatabase` to perform certificate verification using
    /// `g_tls_database_verify_chain()`, which means certificate verification will
    /// not be able to make use of TLS session context. This may be less secure.
    /// For example, if you create your own `GTlsDatabase` that just wraps the
    /// default `GTlsDatabase`, you might expect that you have not changed anything,
    /// but this is not true because you may have altered the behavior of
    /// `GDtlsConnection` by causing it to use `g_tls_database_verify_chain()`. See the
    /// documentation of `g_tls_database_verify_chain()` for more details on specific
    /// security checks that may not be performed. Accordingly, setting a
    /// non-default database is discouraged except for specialty applications with
    /// unusual security requirements.
    @inlinable var database: GIO.TLSDatabaseRef! {
        /// Gets the certificate database that `conn` uses to verify
        /// peer certificates. See `g_dtls_connection_set_database()`.
        get {
            let result = g_dtls_connection_get_database(dtls_connection_ptr)
        let rv = TLSDatabaseRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets the certificate database that is used to verify peer certificates.
        /// This is set to the default database by default. See
        /// `g_tls_backend_get_default_database()`. If set to `nil`, then
        /// peer certificate validation will always set the
        /// `G_TLS_CERTIFICATE_UNKNOWN_CA` error (meaning
        /// `GDtlsConnection::accept-certificate` will always be emitted on
        /// client-side connections, unless that bit is not set in
        /// `GDtlsClientConnection:validation-flags`).
        /// 
        /// There are nonintuitive security implications when using a non-default
        /// database. See `GDtlsConnection:database` for details.
        nonmutating set {
            g_dtls_connection_set_database(dtls_connection_ptr, UnsafeMutablePointer<GTlsDatabase>(newValue?.tls_database_ptr))
        }
    }

    /// A `GTlsInteraction` object to be used when the connection or certificate
    /// database need to interact with the user. This will be used to prompt the
    /// user for passwords where necessary.
    @inlinable var interaction: GIO.TLSInteractionRef! {
        /// Get the object that will be used to interact with the user. It will be used
        /// for things like prompting the user for passwords. If `nil` is returned, then
        /// no user interaction will occur for this connection.
        get {
            let result = g_dtls_connection_get_interaction(dtls_connection_ptr)
        let rv = TLSInteractionRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Set the object that will be used to interact with the user. It will be used
        /// for things like prompting the user for passwords.
        /// 
        /// The `interaction` argument will normally be a derived subclass of
        /// `GTlsInteraction`. `nil` can also be provided if no user interaction
        /// should occur for this connection.
        nonmutating set {
            g_dtls_connection_set_interaction(dtls_connection_ptr, UnsafeMutablePointer<GTlsInteraction>(newValue?.tls_interaction_ptr))
        }
    }

    /// Gets the name of the application-layer protocol negotiated during
    /// the handshake.
    /// 
    /// If the peer did not use the ALPN extension, or did not advertise a
    /// protocol that matched one of `conn`'s protocols, or the TLS backend
    /// does not support ALPN, then this will be `nil`. See
    /// `g_dtls_connection_set_advertised_protocols()`.
    @inlinable var negotiatedProtocol: String! {
        /// Gets the name of the application-layer protocol negotiated during
        /// the handshake.
        /// 
        /// If the peer did not use the ALPN extension, or did not advertise a
        /// protocol that matched one of `conn`'s protocols, or the TLS backend
        /// does not support ALPN, then this will be `nil`. See
        /// `g_dtls_connection_set_advertised_protocols()`.
        get {
            let result = g_dtls_connection_get_negotiated_protocol(dtls_connection_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// Gets `conn`'s peer's certificate after the handshake has completed
    /// or failed. (It is not set during the emission of
    /// `GDtlsConnection::accept-certificate`.)
    @inlinable var peerCertificate: GIO.TLSCertificateRef! {
        /// Gets `conn`'s peer's certificate after the handshake has completed
        /// or failed. (It is not set during the emission of
        /// `GDtlsConnection::accept-certificate`.)
        get {
            let result = g_dtls_connection_get_peer_certificate(dtls_connection_ptr)
        let rv = TLSCertificateRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Gets the errors associated with validating `conn`'s peer's
    /// certificate, after the handshake has completed or failed. (It is
    /// not set during the emission of `GDtlsConnection::accept-certificate`.)
    @inlinable var peerCertificateErrors: GIO.TLSCertificateFlags {
        /// Gets the errors associated with validating `conn`'s peer's
        /// certificate, after the handshake has completed or failed. (It is
        /// not set during the emission of `GDtlsConnection::accept-certificate`.)
        get {
            let result = g_dtls_connection_get_peer_certificate_errors(dtls_connection_ptr)
        let rv = TLSCertificateFlags(result)
            return rv
        }
    }

    /// Returns the current DTLS protocol version, which may be
    /// `G_TLS_PROTOCOL_VERSION_UNKNOWN` if the connection has not handshaked, or
    /// has been closed, or if the TLS backend has implemented a protocol version
    /// that is not a recognized `GTlsProtocolVersion`.
    @inlinable var protocolVersion: GTlsProtocolVersion {
        /// Returns the current DTLS protocol version, which may be
        /// `G_TLS_PROTOCOL_VERSION_UNKNOWN` if the connection has not handshaked, or
        /// has been closed, or if the TLS backend has implemented a protocol version
        /// that is not a recognized `GTlsProtocolVersion`.
        get {
            let result = g_dtls_connection_get_protocol_version(dtls_connection_ptr)
        let rv = result
            return rv
        }
    }

    /// Gets `conn` rehandshaking mode. See
    /// `g_dtls_connection_set_rehandshake_mode()` for details.
    ///
    /// **get_rehandshake_mode is deprecated:**
    /// Changing the rehandshake mode is no longer
    ///   required for compatibility. Also, rehandshaking has been removed
    ///   from the TLS protocol in TLS 1.3.
    @inlinable var rehandshakeMode: GTlsRehandshakeMode {
        /// Gets `conn` rehandshaking mode. See
        /// `g_dtls_connection_set_rehandshake_mode()` for details.
        ///
        /// **get_rehandshake_mode is deprecated:**
        /// Changing the rehandshake mode is no longer
        ///   required for compatibility. Also, rehandshaking has been removed
        ///   from the TLS protocol in TLS 1.3.
        @available(*, deprecated) get {
            let result = g_dtls_connection_get_rehandshake_mode(dtls_connection_ptr)
        let rv = result
            return rv
        }
        /// Since GLib 2.64, changing the rehandshake mode is no longer supported
        /// and will have no effect. With TLS 1.3, rehandshaking has been removed from
        /// the TLS protocol, replaced by separate post-handshake authentication and
        /// rekey operations.
        ///
        /// **set_rehandshake_mode is deprecated:**
        /// Changing the rehandshake mode is no longer
        ///   required for compatibility. Also, rehandshaking has been removed
        ///   from the TLS protocol in TLS 1.3.
        @available(*, deprecated) nonmutating set {
            g_dtls_connection_set_rehandshake_mode(dtls_connection_ptr, newValue)
        }
    }

    /// Tests whether or not `conn` expects a proper TLS close notification
    /// when the connection is closed. See
    /// `g_dtls_connection_set_require_close_notify()` for details.
    @inlinable var requireCloseNotify: Bool {
        /// Tests whether or not `conn` expects a proper TLS close notification
        /// when the connection is closed. See
        /// `g_dtls_connection_set_require_close_notify()` for details.
        get {
            let result = g_dtls_connection_get_require_close_notify(dtls_connection_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether or not `conn` expects a proper TLS close notification
        /// before the connection is closed. If this is `true` (the default),
        /// then `conn` will expect to receive a TLS close notification from its
        /// peer before the connection is closed, and will return a
        /// `G_TLS_ERROR_EOF` error if the connection is closed without proper
        /// notification (since this may indicate a network error, or
        /// man-in-the-middle attack).
        /// 
        /// In some protocols, the application will know whether or not the
        /// connection was closed cleanly based on application-level data
        /// (because the application-level data includes a length field, or is
        /// somehow self-delimiting); in this case, the close notify is
        /// redundant and may be omitted. You
        /// can use `g_dtls_connection_set_require_close_notify()` to tell `conn`
        /// to allow an "unannounced" connection close, in which case the close
        /// will show up as a 0-length read, as in a non-TLS
        /// `GDatagramBased`, and it is up to the application to check that
        /// the data has been fully received.
        /// 
        /// Note that this only affects the behavior when the peer closes the
        /// connection; when the application calls `g_dtls_connection_close_async()` on
        /// `conn` itself, this will send a close notification regardless of the
        /// setting of this property. If you explicitly want to do an unclean
        /// close, you can close `conn`'s `GDtlsConnection:base-socket` rather
        /// than closing `conn` itself.
        nonmutating set {
            g_dtls_connection_set_require_close_notify(dtls_connection_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - DtlsServerConnection Interface

/// `GDtlsServerConnection` is the server-side subclass of `GDtlsConnection`,
/// representing a server-side DTLS connection.
///
/// The `DtlsServerConnectionProtocol` protocol exposes the methods and properties of an underlying `GDtlsServerConnection` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DtlsServerConnection`.
/// Alternatively, use `DtlsServerConnectionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DtlsServerConnectionProtocol: DatagramBasedProtocol {
        /// Untyped pointer to the underlying `GDtlsServerConnection` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDtlsServerConnection` instance.
    var dtls_server_connection_ptr: UnsafeMutablePointer<GDtlsServerConnection>! { get }

    /// Required Initialiser for types conforming to `DtlsServerConnectionProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GDtlsServerConnection` is the server-side subclass of `GDtlsConnection`,
/// representing a server-side DTLS connection.
///
/// The `DtlsServerConnectionRef` type acts as a lightweight Swift reference to an underlying `GDtlsServerConnection` instance.
/// It exposes methods that can operate on this data type through `DtlsServerConnectionProtocol` conformance.
/// Use `DtlsServerConnectionRef` only as an `unowned` reference to an existing `GDtlsServerConnection` instance.
///
public struct DtlsServerConnectionRef: DtlsServerConnectionProtocol {
        /// Untyped pointer to the underlying `GDtlsServerConnection` instance.
    /// For type-safe access, use the generated, typed pointer `dtls_server_connection_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DtlsServerConnectionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDtlsServerConnection>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDtlsServerConnection>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDtlsServerConnection>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDtlsServerConnection>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DtlsServerConnectionProtocol`
    @inlinable init<T: DtlsServerConnectionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsServerConnectionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsServerConnectionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsServerConnectionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsServerConnectionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsServerConnectionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// `GDtlsServerConnection` is the server-side subclass of `GDtlsConnection`,
/// representing a server-side DTLS connection.
///
/// The `DtlsServerConnection` type acts as an owner of an underlying `GDtlsServerConnection` instance.
/// It provides the methods that can operate on this data type through `DtlsServerConnectionProtocol` conformance.
/// Use `DtlsServerConnection` as a strong reference or owner of a `GDtlsServerConnection` instance.
///
open class DtlsServerConnection: DatagramBased, DtlsServerConnectionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DtlsServerConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDtlsServerConnection>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DtlsServerConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDtlsServerConnection>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DtlsServerConnection` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DtlsServerConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DtlsServerConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDtlsServerConnection>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DtlsServerConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDtlsServerConnection>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GDtlsServerConnection` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `DtlsServerConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDtlsServerConnection>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DtlsServerConnectionProtocol`
    /// `GDtlsServerConnection` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `DtlsServerConnectionProtocol`
    @inlinable public init<T: DtlsServerConnectionProtocol>(dtlsServerConnection other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsServerConnectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsServerConnectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsServerConnectionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsServerConnectionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsServerConnectionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsServerConnectionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsServerConnectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DtlsServerConnectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum DtlsServerConnectionPropertyName: String, PropertyNameProtocol {
    /// The `GTlsAuthenticationMode` for the server. This can be changed
    /// before calling `g_dtls_connection_handshake()` if you want to
    /// rehandshake with a different mode from the initial handshake.
    case authenticationMode = "authentication-mode"
}

public extension DtlsServerConnectionProtocol {
    /// Bind a `DtlsServerConnectionPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: DtlsServerConnectionPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a DtlsServerConnection property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: DtlsServerConnectionPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a DtlsServerConnection property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: DtlsServerConnectionPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum DtlsServerConnectionSignalName: String, SignalNameProtocol {

    /// The `GTlsAuthenticationMode` for the server. This can be changed
    /// before calling `g_dtls_connection_handshake()` if you want to
    /// rehandshake with a different mode from the initial handshake.
    case notifyAuthenticationMode = "notify::authentication-mode"
}

// MARK: DtlsServerConnection has no signals
// MARK: DtlsServerConnection Interface: DtlsServerConnectionProtocol extension (methods and fields)
public extension DtlsServerConnectionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDtlsServerConnection` instance.
    @inlinable var dtls_server_connection_ptr: UnsafeMutablePointer<GDtlsServerConnection>! { return ptr?.assumingMemoryBound(to: GDtlsServerConnection.self) }



}



// MARK: - DBusAuthObserver Class

/// The `GDBusAuthObserver` type provides a mechanism for participating
/// in how a `GDBusServer` (or a `GDBusConnection`) authenticates remote
/// peers. Simply instantiate a `GDBusAuthObserver` and connect to the
/// signals you are interested in. Note that new signals may be added
/// in the future
/// 
/// ## Controlling Authentication Mechanisms
/// 
/// By default, a `GDBusServer` or server-side `GDBusConnection` will allow
/// any authentication mechanism to be used. If you only
/// want to allow D-Bus connections with the `EXTERNAL` mechanism,
/// which makes use of credentials passing and is the recommended
/// mechanism for modern Unix platforms such as Linux and the BSD family,
/// you would use a signal handler like this:
/// 
/// (C Language Example):
/// ```C
/// static gboolean
/// on_allow_mechanism (GDBusAuthObserver *observer,
///                     const gchar       *mechanism,
///                     gpointer           user_data)
/// {
///   if (g_strcmp0 (mechanism, "EXTERNAL") == 0)
///     {
///       return TRUE;
///     }
/// 
///   return FALSE;
/// }
/// ```
/// 
/// ## Controlling Authorization # <a name="auth-observer"></a>
/// 
/// By default, a `GDBusServer` or server-side `GDBusConnection` will accept
/// connections from any successfully authenticated user (but not from
/// anonymous connections using the `ANONYMOUS` mechanism). If you only
/// want to allow D-Bus connections from processes owned by the same uid
/// as the server, since GLib 2.68, you should use the
/// `G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flag. Its equivalent
/// to the following signal handler:
/// 
/// (C Language Example):
/// ```C
/// static gboolean
/// on_authorize_authenticated_peer (GDBusAuthObserver *observer,
///                                  GIOStream         *stream,
///                                  GCredentials      *credentials,
///                                  gpointer           user_data)
/// {
///   gboolean authorized;
/// 
///   authorized = FALSE;
///   if (credentials != NULL)
///     {
///       GCredentials *own_credentials;
///       own_credentials = g_credentials_new ();
///       if (g_credentials_is_same_user (credentials, own_credentials, NULL))
///         authorized = TRUE;
///       g_object_unref (own_credentials);
///     }
/// 
///   return authorized;
/// }
/// ```
/// 
///
/// The `DBusAuthObserverProtocol` protocol exposes the methods and properties of an underlying `GDBusAuthObserver` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusAuthObserver`.
/// Alternatively, use `DBusAuthObserverRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusAuthObserverProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GDBusAuthObserver` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusAuthObserver` instance.
    var dbus_auth_observer_ptr: UnsafeMutablePointer<GDBusAuthObserver>! { get }

    /// Required Initialiser for types conforming to `DBusAuthObserverProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `GDBusAuthObserver` type provides a mechanism for participating
/// in how a `GDBusServer` (or a `GDBusConnection`) authenticates remote
/// peers. Simply instantiate a `GDBusAuthObserver` and connect to the
/// signals you are interested in. Note that new signals may be added
/// in the future
/// 
/// ## Controlling Authentication Mechanisms
/// 
/// By default, a `GDBusServer` or server-side `GDBusConnection` will allow
/// any authentication mechanism to be used. If you only
/// want to allow D-Bus connections with the `EXTERNAL` mechanism,
/// which makes use of credentials passing and is the recommended
/// mechanism for modern Unix platforms such as Linux and the BSD family,
/// you would use a signal handler like this:
/// 
/// (C Language Example):
/// ```C
/// static gboolean
/// on_allow_mechanism (GDBusAuthObserver *observer,
///                     const gchar       *mechanism,
///                     gpointer           user_data)
/// {
///   if (g_strcmp0 (mechanism, "EXTERNAL") == 0)
///     {
///       return TRUE;
///     }
/// 
///   return FALSE;
/// }
/// ```
/// 
/// ## Controlling Authorization # <a name="auth-observer"></a>
/// 
/// By default, a `GDBusServer` or server-side `GDBusConnection` will accept
/// connections from any successfully authenticated user (but not from
/// anonymous connections using the `ANONYMOUS` mechanism). If you only
/// want to allow D-Bus connections from processes owned by the same uid
/// as the server, since GLib 2.68, you should use the
/// `G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flag. Its equivalent
/// to the following signal handler:
/// 
/// (C Language Example):
/// ```C
/// static gboolean
/// on_authorize_authenticated_peer (GDBusAuthObserver *observer,
///                                  GIOStream         *stream,
///                                  GCredentials      *credentials,
///                                  gpointer           user_data)
/// {
///   gboolean authorized;
/// 
///   authorized = FALSE;
///   if (credentials != NULL)
///     {
///       GCredentials *own_credentials;
///       own_credentials = g_credentials_new ();
///       if (g_credentials_is_same_user (credentials, own_credentials, NULL))
///         authorized = TRUE;
///       g_object_unref (own_credentials);
///     }
/// 
///   return authorized;
/// }
/// ```
/// 
///
/// The `DBusAuthObserverRef` type acts as a lightweight Swift reference to an underlying `GDBusAuthObserver` instance.
/// It exposes methods that can operate on this data type through `DBusAuthObserverProtocol` conformance.
/// Use `DBusAuthObserverRef` only as an `unowned` reference to an existing `GDBusAuthObserver` instance.
///
public struct DBusAuthObserverRef: DBusAuthObserverProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GDBusAuthObserver` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_auth_observer_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusAuthObserverRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusAuthObserver>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusAuthObserver>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusAuthObserver>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusAuthObserver>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusAuthObserverProtocol`
    @inlinable init<T: DBusAuthObserverProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: DBusAuthObserverProtocol>(_ other: T) -> DBusAuthObserverRef { DBusAuthObserverRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAuthObserverProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAuthObserverProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAuthObserverProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAuthObserverProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAuthObserverProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GDBusAuthObserver` object.
    @inlinable init() {
            let result = g_dbus_auth_observer_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `GDBusAuthObserver` type provides a mechanism for participating
/// in how a `GDBusServer` (or a `GDBusConnection`) authenticates remote
/// peers. Simply instantiate a `GDBusAuthObserver` and connect to the
/// signals you are interested in. Note that new signals may be added
/// in the future
/// 
/// ## Controlling Authentication Mechanisms
/// 
/// By default, a `GDBusServer` or server-side `GDBusConnection` will allow
/// any authentication mechanism to be used. If you only
/// want to allow D-Bus connections with the `EXTERNAL` mechanism,
/// which makes use of credentials passing and is the recommended
/// mechanism for modern Unix platforms such as Linux and the BSD family,
/// you would use a signal handler like this:
/// 
/// (C Language Example):
/// ```C
/// static gboolean
/// on_allow_mechanism (GDBusAuthObserver *observer,
///                     const gchar       *mechanism,
///                     gpointer           user_data)
/// {
///   if (g_strcmp0 (mechanism, "EXTERNAL") == 0)
///     {
///       return TRUE;
///     }
/// 
///   return FALSE;
/// }
/// ```
/// 
/// ## Controlling Authorization # <a name="auth-observer"></a>
/// 
/// By default, a `GDBusServer` or server-side `GDBusConnection` will accept
/// connections from any successfully authenticated user (but not from
/// anonymous connections using the `ANONYMOUS` mechanism). If you only
/// want to allow D-Bus connections from processes owned by the same uid
/// as the server, since GLib 2.68, you should use the
/// `G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flag. Its equivalent
/// to the following signal handler:
/// 
/// (C Language Example):
/// ```C
/// static gboolean
/// on_authorize_authenticated_peer (GDBusAuthObserver *observer,
///                                  GIOStream         *stream,
///                                  GCredentials      *credentials,
///                                  gpointer           user_data)
/// {
///   gboolean authorized;
/// 
///   authorized = FALSE;
///   if (credentials != NULL)
///     {
///       GCredentials *own_credentials;
///       own_credentials = g_credentials_new ();
///       if (g_credentials_is_same_user (credentials, own_credentials, NULL))
///         authorized = TRUE;
///       g_object_unref (own_credentials);
///     }
/// 
///   return authorized;
/// }
/// ```
/// 
///
/// The `DBusAuthObserver` type acts as a reference-counted owner of an underlying `GDBusAuthObserver` instance.
/// It provides the methods that can operate on this data type through `DBusAuthObserverProtocol` conformance.
/// Use `DBusAuthObserver` as a strong reference or owner of a `GDBusAuthObserver` instance.
///
open class DBusAuthObserver: GLibObject.Object, DBusAuthObserverProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusAuthObserver` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusAuthObserver>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusAuthObserver` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusAuthObserver>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusAuthObserver` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusAuthObserver` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusAuthObserver` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusAuthObserver>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusAuthObserver` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusAuthObserver>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDBusAuthObserver`.
    /// i.e., ownership is transferred to the `DBusAuthObserver` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusAuthObserver>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DBusAuthObserverProtocol`
    /// Will retain `GDBusAuthObserver`.
    /// - Parameter other: an instance of a related type that implements `DBusAuthObserverProtocol`
    @inlinable public init<T: DBusAuthObserverProtocol>(dBusAuthObserver other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAuthObserverProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAuthObserverProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAuthObserverProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAuthObserverProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAuthObserverProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAuthObserverProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAuthObserverProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusAuthObserverProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GDBusAuthObserver` object.
    @inlinable public init() {
            let result = g_dbus_auth_observer_new()
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no DBusAuthObserver properties

public enum DBusAuthObserverSignalName: String, SignalNameProtocol {
    /// Emitted to check if `mechanism` is allowed to be used.
    case allowMechanism = "allow-mechanism"
    /// Emitted to check if a peer that is successfully authenticated
    /// is authorized.
    case authorizeAuthenticatedPeer = "authorize-authenticated-peer"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: DBusAuthObserver signals
public extension DBusAuthObserverProtocol {
    /// Connect a Swift signal handler to the given, typed `DBusAuthObserverSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DBusAuthObserverSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `DBusAuthObserverSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DBusAuthObserverSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted to check if `mechanism` is allowed to be used.
    /// - Note: This represents the underlying `allow-mechanism` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter mechanism: The name of the mechanism, e.g. `DBUS_COOKIE_SHA1`.
    /// - Parameter handler: `true` if `mechanism` can be used to authenticate the other peer, `false` if not.
    /// Run the given callback whenever the `allowMechanism` signal is emitted
    @discardableResult @inlinable func onAllowMechanism(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusAuthObserverRef, _ mechanism: String) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusAuthObserverRef, String), Bool>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> gboolean = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call((DBusAuthObserverRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .allowMechanism,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `allow-mechanism` signal for using the `connect(signal:)` methods
    static var allowMechanismSignal: DBusAuthObserverSignalName { .allowMechanism }
    
    /// Emitted to check if a peer that is successfully authenticated
    /// is authorized.
    /// - Note: This represents the underlying `authorize-authenticated-peer` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter stream: A `GIOStream` for the `GDBusConnection`.
    /// - Parameter credentials: Credentials received from the peer or `nil`.
    /// - Parameter handler: `true` if the peer is authorized, `false` if not.
    /// Run the given callback whenever the `authorizeAuthenticatedPeer` signal is emitted
    @discardableResult @inlinable func onAuthorizeAuthenticatedPeer(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusAuthObserverRef, _ stream: IOStreamRef, _ credentials: CredentialsRef?) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusAuthObserverRef, IOStreamRef, CredentialsRef?), Bool>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer?, gpointer) -> gboolean = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call((DBusAuthObserverRef(raw: unownedSelf), IOStreamRef(raw: arg1), arg2.flatMap(CredentialsRef.init(raw:))))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .authorizeAuthenticatedPeer,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `authorize-authenticated-peer` signal for using the `connect(signal:)` methods
    static var authorizeAuthenticatedPeerSignal: DBusAuthObserverSignalName { .authorizeAuthenticatedPeer }
    
    
}

// MARK: DBusAuthObserver Class: DBusAuthObserverProtocol extension (methods and fields)
public extension DBusAuthObserverProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusAuthObserver` instance.
    @inlinable var dbus_auth_observer_ptr: UnsafeMutablePointer<GDBusAuthObserver>! { return ptr?.assumingMemoryBound(to: GDBusAuthObserver.self) }

    /// Emits the `GDBusAuthObserver::allow-mechanism` signal on `observer`.
    @inlinable func allow(mechanism: UnsafePointer<gchar>!) -> Bool {
        let result = g_dbus_auth_observer_allow_mechanism(dbus_auth_observer_ptr, mechanism)
        let rv = ((result) != 0)
        return rv
    }

    /// Emits the `GDBusAuthObserver::authorize-authenticated-peer` signal on `observer`.
    @inlinable func authorizeAuthenticatedPeer<IOStreamT: IOStreamProtocol>(stream: IOStreamT, credentials: CredentialsRef? = nil) -> Bool {
            let result = g_dbus_auth_observer_authorize_authenticated_peer(dbus_auth_observer_ptr, stream.io_stream_ptr, credentials?.credentials_ptr)
        let rv = ((result) != 0)
            return rv
    }
    /// Emits the `GDBusAuthObserver::authorize-authenticated-peer` signal on `observer`.
    @inlinable func authorizeAuthenticatedPeer<CredentialsT: CredentialsProtocol, IOStreamT: IOStreamProtocol>(stream: IOStreamT, credentials: CredentialsT?) -> Bool {
        let result = g_dbus_auth_observer_authorize_authenticated_peer(dbus_auth_observer_ptr, stream.io_stream_ptr, credentials?.credentials_ptr)
        let rv = ((result) != 0)
        return rv
    }


}



// MARK: - DBusConnection Class

/// The `GDBusConnection` type is used for D-Bus connections to remote
/// peers such as a message buses. It is a low-level API that offers a
/// lot of flexibility. For instance, it lets you establish a connection
/// over any transport that can by represented as a `GIOStream`.
/// 
/// This class is rarely used directly in D-Bus clients. If you are writing
/// a D-Bus client, it is often easier to use the `g_bus_own_name()`,
/// `g_bus_watch_name()` or `g_dbus_proxy_new_for_bus()` APIs.
/// 
/// As an exception to the usual GLib rule that a particular object must not
/// be used by two threads at the same time, `GDBusConnection`'s methods may be
/// called from any thread. This is so that `g_bus_get()` and `g_bus_get_sync()`
/// can safely return the same `GDBusConnection` when called from any thread.
/// 
/// Most of the ways to obtain a `GDBusConnection` automatically initialize it
/// (i.e. connect to D-Bus): for instance, `g_dbus_connection_new()` and
/// `g_bus_get()`, and the synchronous versions of those methods, give you an
/// initialized connection. Language bindings for GIO should use
/// `g_initable_new()` or `g_async_initable_new_async()`, which also initialize the
/// connection.
/// 
/// If you construct an uninitialized `GDBusConnection`, such as via
/// `g_object_new()`, you must initialize it via `g_initable_init()` or
/// `g_async_initable_init_async()` before using its methods or properties.
/// Calling methods or accessing properties on a `GDBusConnection` that has not
/// completed initialization successfully is considered to be invalid, and leads
/// to undefined behaviour. In particular, if initialization fails with a
/// `GError`, the only valid thing you can do with that `GDBusConnection` is to
/// free it with `g_object_unref()`.
/// 
/// ## An example D-Bus server # <a name="gdbus-server"></a>
/// 
/// Here is an example for a D-Bus server:
/// [gdbus-example-server.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-server.c)
/// 
/// ## An example for exporting a subtree # <a name="gdbus-subtree-server"></a>
/// 
/// Here is an example for exporting a subtree:
/// [gdbus-example-subtree.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-subtree.c)
/// 
/// ## An example for file descriptor passing # <a name="gdbus-unix-fd-client"></a>
/// 
/// Here is an example for passing UNIX file descriptors:
/// [gdbus-unix-fd-client.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-unix-fd-client.c)
/// 
/// ## An example for exporting a GObject # <a name="gdbus-export"></a>
/// 
/// Here is an example for exporting a `GObject:`
/// [gdbus-example-export.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-export.c)
///
/// The `DBusConnectionProtocol` protocol exposes the methods and properties of an underlying `GDBusConnection` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusConnection`.
/// Alternatively, use `DBusConnectionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusConnectionProtocol: GLibObject.ObjectProtocol, AsyncInitableProtocol, InitableProtocol {
        /// Untyped pointer to the underlying `GDBusConnection` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusConnection` instance.
    var dbus_connection_ptr: UnsafeMutablePointer<GDBusConnection>! { get }

    /// Required Initialiser for types conforming to `DBusConnectionProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `GDBusConnection` type is used for D-Bus connections to remote
/// peers such as a message buses. It is a low-level API that offers a
/// lot of flexibility. For instance, it lets you establish a connection
/// over any transport that can by represented as a `GIOStream`.
/// 
/// This class is rarely used directly in D-Bus clients. If you are writing
/// a D-Bus client, it is often easier to use the `g_bus_own_name()`,
/// `g_bus_watch_name()` or `g_dbus_proxy_new_for_bus()` APIs.
/// 
/// As an exception to the usual GLib rule that a particular object must not
/// be used by two threads at the same time, `GDBusConnection`'s methods may be
/// called from any thread. This is so that `g_bus_get()` and `g_bus_get_sync()`
/// can safely return the same `GDBusConnection` when called from any thread.
/// 
/// Most of the ways to obtain a `GDBusConnection` automatically initialize it
/// (i.e. connect to D-Bus): for instance, `g_dbus_connection_new()` and
/// `g_bus_get()`, and the synchronous versions of those methods, give you an
/// initialized connection. Language bindings for GIO should use
/// `g_initable_new()` or `g_async_initable_new_async()`, which also initialize the
/// connection.
/// 
/// If you construct an uninitialized `GDBusConnection`, such as via
/// `g_object_new()`, you must initialize it via `g_initable_init()` or
/// `g_async_initable_init_async()` before using its methods or properties.
/// Calling methods or accessing properties on a `GDBusConnection` that has not
/// completed initialization successfully is considered to be invalid, and leads
/// to undefined behaviour. In particular, if initialization fails with a
/// `GError`, the only valid thing you can do with that `GDBusConnection` is to
/// free it with `g_object_unref()`.
/// 
/// ## An example D-Bus server # <a name="gdbus-server"></a>
/// 
/// Here is an example for a D-Bus server:
/// [gdbus-example-server.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-server.c)
/// 
/// ## An example for exporting a subtree # <a name="gdbus-subtree-server"></a>
/// 
/// Here is an example for exporting a subtree:
/// [gdbus-example-subtree.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-subtree.c)
/// 
/// ## An example for file descriptor passing # <a name="gdbus-unix-fd-client"></a>
/// 
/// Here is an example for passing UNIX file descriptors:
/// [gdbus-unix-fd-client.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-unix-fd-client.c)
/// 
/// ## An example for exporting a GObject # <a name="gdbus-export"></a>
/// 
/// Here is an example for exporting a `GObject:`
/// [gdbus-example-export.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-export.c)
///
/// The `DBusConnectionRef` type acts as a lightweight Swift reference to an underlying `GDBusConnection` instance.
/// It exposes methods that can operate on this data type through `DBusConnectionProtocol` conformance.
/// Use `DBusConnectionRef` only as an `unowned` reference to an existing `GDBusConnection` instance.
///
public struct DBusConnectionRef: DBusConnectionProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GDBusConnection` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_connection_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusConnectionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusConnection>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusConnection>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusConnection>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusConnection>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusConnectionProtocol`
    @inlinable init<T: DBusConnectionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: DBusConnectionProtocol>(_ other: T) -> DBusConnectionRef { DBusConnectionRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusConnectionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusConnectionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusConnectionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusConnectionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusConnectionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Finishes an operation started with `g_dbus_connection_new()`.
    @inlinable init<AsyncResultT: AsyncResultProtocol>(finish res: AsyncResultT) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_new_finish(res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Finishes an operation started with `g_dbus_connection_new_for_address()`.
    @inlinable init<AsyncResultT: AsyncResultProtocol>(addressFinish res: AsyncResultT) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_new_for_address_finish(res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Synchronously connects and sets up a D-Bus client connection for
    /// exchanging D-Bus messages with an endpoint specified by `address`
    /// which must be in the
    /// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html`addresses`).
    /// 
    /// This constructor can only be used to initiate client-side
    /// connections - use `g_dbus_connection_new_sync()` if you need to act
    /// as the server. In particular, `flags` cannot contain the
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER`,
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS` or
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flags.
    /// 
    /// This is a synchronous failable constructor. See
    /// `g_dbus_connection_new_for_address()` for the asynchronous version.
    /// 
    /// If `observer` is not `nil` it may be used to control the
    /// authentication process.
    @inlinable init<CancellableT: CancellableProtocol, DBusAuthObserverT: DBusAuthObserverProtocol>(addressSync address: UnsafePointer<gchar>!, flags: DBusConnectionFlags, observer: DBusAuthObserverT?, cancellable: CancellableT?) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_new_for_address_sync(address, flags.value, observer?.dbus_auth_observer_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Synchronously sets up a D-Bus connection for exchanging D-Bus messages
    /// with the end represented by `stream`.
    /// 
    /// If `stream` is a `GSocketConnection`, then the corresponding `GSocket`
    /// will be put into non-blocking mode.
    /// 
    /// The D-Bus connection will interact with `stream` from a worker thread.
    /// As a result, the caller should not interact with `stream` after this
    /// method has been called, except by calling `g_object_unref()` on it.
    /// 
    /// If `observer` is not `nil` it may be used to control the
    /// authentication process.
    /// 
    /// This is a synchronous failable constructor. See
    /// `g_dbus_connection_new()` for the asynchronous version.
    @inlinable init<CancellableT: CancellableProtocol, DBusAuthObserverT: DBusAuthObserverProtocol, IOStreamT: IOStreamProtocol>(sync stream: IOStreamT, guid: UnsafePointer<gchar>? = nil, flags: DBusConnectionFlags, observer: DBusAuthObserverT?, cancellable: CancellableT?) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_new_sync(stream.io_stream_ptr, guid, flags.value, observer?.dbus_auth_observer_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
    /// Finishes an operation started with `g_dbus_connection_new()`.
    @inlinable static func new<AsyncResultT: AsyncResultProtocol>(finish res: AsyncResultT) throws -> GIO.DBusConnectionRef! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_new_finish(res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusConnectionRef(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
        return rv
    }

    /// Finishes an operation started with `g_dbus_connection_new_for_address()`.
    @inlinable static func newFor<AsyncResultT: AsyncResultProtocol>(addressFinish res: AsyncResultT) throws -> GIO.DBusConnectionRef! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_new_for_address_finish(res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusConnectionRef(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
        return rv
    }

    /// Synchronously connects and sets up a D-Bus client connection for
    /// exchanging D-Bus messages with an endpoint specified by `address`
    /// which must be in the
    /// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html`addresses`).
    /// 
    /// This constructor can only be used to initiate client-side
    /// connections - use `g_dbus_connection_new_sync()` if you need to act
    /// as the server. In particular, `flags` cannot contain the
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER`,
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS` or
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flags.
    /// 
    /// This is a synchronous failable constructor. See
    /// `g_dbus_connection_new_for_address()` for the asynchronous version.
    /// 
    /// If `observer` is not `nil` it may be used to control the
    /// authentication process.
    @inlinable static func newFor<CancellableT: CancellableProtocol, DBusAuthObserverT: DBusAuthObserverProtocol>(addressSync address: UnsafePointer<gchar>!, flags: DBusConnectionFlags, observer: DBusAuthObserverT?, cancellable: CancellableT?) throws -> GIO.DBusConnectionRef! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_new_for_address_sync(address, flags.value, observer?.dbus_auth_observer_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusConnectionRef(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
        return rv
    }

    /// Synchronously sets up a D-Bus connection for exchanging D-Bus messages
    /// with the end represented by `stream`.
    /// 
    /// If `stream` is a `GSocketConnection`, then the corresponding `GSocket`
    /// will be put into non-blocking mode.
    /// 
    /// The D-Bus connection will interact with `stream` from a worker thread.
    /// As a result, the caller should not interact with `stream` after this
    /// method has been called, except by calling `g_object_unref()` on it.
    /// 
    /// If `observer` is not `nil` it may be used to control the
    /// authentication process.
    /// 
    /// This is a synchronous failable constructor. See
    /// `g_dbus_connection_new()` for the asynchronous version.
    @inlinable static func new<CancellableT: CancellableProtocol, DBusAuthObserverT: DBusAuthObserverProtocol, IOStreamT: IOStreamProtocol>(sync stream: IOStreamT, guid: UnsafePointer<gchar>? = nil, flags: DBusConnectionFlags, observer: DBusAuthObserverT?, cancellable: CancellableT?) throws -> GIO.DBusConnectionRef! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_new_sync(stream.io_stream_ptr, guid, flags.value, observer?.dbus_auth_observer_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusConnectionRef(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
        return rv
    }
}

/// The `GDBusConnection` type is used for D-Bus connections to remote
/// peers such as a message buses. It is a low-level API that offers a
/// lot of flexibility. For instance, it lets you establish a connection
/// over any transport that can by represented as a `GIOStream`.
/// 
/// This class is rarely used directly in D-Bus clients. If you are writing
/// a D-Bus client, it is often easier to use the `g_bus_own_name()`,
/// `g_bus_watch_name()` or `g_dbus_proxy_new_for_bus()` APIs.
/// 
/// As an exception to the usual GLib rule that a particular object must not
/// be used by two threads at the same time, `GDBusConnection`'s methods may be
/// called from any thread. This is so that `g_bus_get()` and `g_bus_get_sync()`
/// can safely return the same `GDBusConnection` when called from any thread.
/// 
/// Most of the ways to obtain a `GDBusConnection` automatically initialize it
/// (i.e. connect to D-Bus): for instance, `g_dbus_connection_new()` and
/// `g_bus_get()`, and the synchronous versions of those methods, give you an
/// initialized connection. Language bindings for GIO should use
/// `g_initable_new()` or `g_async_initable_new_async()`, which also initialize the
/// connection.
/// 
/// If you construct an uninitialized `GDBusConnection`, such as via
/// `g_object_new()`, you must initialize it via `g_initable_init()` or
/// `g_async_initable_init_async()` before using its methods or properties.
/// Calling methods or accessing properties on a `GDBusConnection` that has not
/// completed initialization successfully is considered to be invalid, and leads
/// to undefined behaviour. In particular, if initialization fails with a
/// `GError`, the only valid thing you can do with that `GDBusConnection` is to
/// free it with `g_object_unref()`.
/// 
/// ## An example D-Bus server # <a name="gdbus-server"></a>
/// 
/// Here is an example for a D-Bus server:
/// [gdbus-example-server.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-server.c)
/// 
/// ## An example for exporting a subtree # <a name="gdbus-subtree-server"></a>
/// 
/// Here is an example for exporting a subtree:
/// [gdbus-example-subtree.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-subtree.c)
/// 
/// ## An example for file descriptor passing # <a name="gdbus-unix-fd-client"></a>
/// 
/// Here is an example for passing UNIX file descriptors:
/// [gdbus-unix-fd-client.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-unix-fd-client.c)
/// 
/// ## An example for exporting a GObject # <a name="gdbus-export"></a>
/// 
/// Here is an example for exporting a `GObject:`
/// [gdbus-example-export.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-export.c)
///
/// The `DBusConnection` type acts as a reference-counted owner of an underlying `GDBusConnection` instance.
/// It provides the methods that can operate on this data type through `DBusConnectionProtocol` conformance.
/// Use `DBusConnection` as a strong reference or owner of a `GDBusConnection` instance.
///
open class DBusConnection: GLibObject.Object, DBusConnectionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusConnection>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusConnection>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusConnection` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusConnection>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusConnection>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDBusConnection`.
    /// i.e., ownership is transferred to the `DBusConnection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusConnection>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DBusConnectionProtocol`
    /// Will retain `GDBusConnection`.
    /// - Parameter other: an instance of a related type that implements `DBusConnectionProtocol`
    @inlinable public init<T: DBusConnectionProtocol>(dBusConnection other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusConnectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusConnectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusConnectionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusConnectionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusConnectionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusConnectionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusConnectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusConnectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Finishes an operation started with `g_dbus_connection_new()`.
    @inlinable public init<AsyncResultT: AsyncResultProtocol>(finish res: AsyncResultT) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_new_finish(res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Finishes an operation started with `g_dbus_connection_new_for_address()`.
    @inlinable public init<AsyncResultT: AsyncResultProtocol>(addressFinish res: AsyncResultT) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_new_for_address_finish(res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Synchronously connects and sets up a D-Bus client connection for
    /// exchanging D-Bus messages with an endpoint specified by `address`
    /// which must be in the
    /// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html`addresses`).
    /// 
    /// This constructor can only be used to initiate client-side
    /// connections - use `g_dbus_connection_new_sync()` if you need to act
    /// as the server. In particular, `flags` cannot contain the
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER`,
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS` or
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flags.
    /// 
    /// This is a synchronous failable constructor. See
    /// `g_dbus_connection_new_for_address()` for the asynchronous version.
    /// 
    /// If `observer` is not `nil` it may be used to control the
    /// authentication process.
    @inlinable public init<CancellableT: CancellableProtocol, DBusAuthObserverT: DBusAuthObserverProtocol>(addressSync address: UnsafePointer<gchar>!, flags: DBusConnectionFlags, observer: DBusAuthObserverT?, cancellable: CancellableT?) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_new_for_address_sync(address, flags.value, observer?.dbus_auth_observer_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Synchronously sets up a D-Bus connection for exchanging D-Bus messages
    /// with the end represented by `stream`.
    /// 
    /// If `stream` is a `GSocketConnection`, then the corresponding `GSocket`
    /// will be put into non-blocking mode.
    /// 
    /// The D-Bus connection will interact with `stream` from a worker thread.
    /// As a result, the caller should not interact with `stream` after this
    /// method has been called, except by calling `g_object_unref()` on it.
    /// 
    /// If `observer` is not `nil` it may be used to control the
    /// authentication process.
    /// 
    /// This is a synchronous failable constructor. See
    /// `g_dbus_connection_new()` for the asynchronous version.
    @inlinable public init<CancellableT: CancellableProtocol, DBusAuthObserverT: DBusAuthObserverProtocol, IOStreamT: IOStreamProtocol>(sync stream: IOStreamT, guid: UnsafePointer<gchar>? = nil, flags: DBusConnectionFlags, observer: DBusAuthObserverT?, cancellable: CancellableT?) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_new_sync(stream.io_stream_ptr, guid, flags.value, observer?.dbus_auth_observer_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Finishes an operation started with `g_dbus_connection_new()`.
    @inlinable public static func new<AsyncResultT: AsyncResultProtocol>(finish res: AsyncResultT) throws -> GIO.DBusConnection! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_new_finish(res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusConnection(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

    /// Finishes an operation started with `g_dbus_connection_new_for_address()`.
    @inlinable public static func newFor<AsyncResultT: AsyncResultProtocol>(addressFinish res: AsyncResultT) throws -> GIO.DBusConnection! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_new_for_address_finish(res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusConnection(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

    /// Synchronously connects and sets up a D-Bus client connection for
    /// exchanging D-Bus messages with an endpoint specified by `address`
    /// which must be in the
    /// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html`addresses`).
    /// 
    /// This constructor can only be used to initiate client-side
    /// connections - use `g_dbus_connection_new_sync()` if you need to act
    /// as the server. In particular, `flags` cannot contain the
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER`,
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS` or
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flags.
    /// 
    /// This is a synchronous failable constructor. See
    /// `g_dbus_connection_new_for_address()` for the asynchronous version.
    /// 
    /// If `observer` is not `nil` it may be used to control the
    /// authentication process.
    @inlinable public static func newFor<CancellableT: CancellableProtocol, DBusAuthObserverT: DBusAuthObserverProtocol>(addressSync address: UnsafePointer<gchar>!, flags: DBusConnectionFlags, observer: DBusAuthObserverT?, cancellable: CancellableT?) throws -> GIO.DBusConnection! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_new_for_address_sync(address, flags.value, observer?.dbus_auth_observer_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusConnection(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

    /// Synchronously sets up a D-Bus connection for exchanging D-Bus messages
    /// with the end represented by `stream`.
    /// 
    /// If `stream` is a `GSocketConnection`, then the corresponding `GSocket`
    /// will be put into non-blocking mode.
    /// 
    /// The D-Bus connection will interact with `stream` from a worker thread.
    /// As a result, the caller should not interact with `stream` after this
    /// method has been called, except by calling `g_object_unref()` on it.
    /// 
    /// If `observer` is not `nil` it may be used to control the
    /// authentication process.
    /// 
    /// This is a synchronous failable constructor. See
    /// `g_dbus_connection_new()` for the asynchronous version.
    @inlinable public static func new<CancellableT: CancellableProtocol, DBusAuthObserverT: DBusAuthObserverProtocol, IOStreamT: IOStreamProtocol>(sync stream: IOStreamT, guid: UnsafePointer<gchar>? = nil, flags: DBusConnectionFlags, observer: DBusAuthObserverT?, cancellable: CancellableT?) throws -> GIO.DBusConnection! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_new_sync(stream.io_stream_ptr, guid, flags.value, observer?.dbus_auth_observer_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusConnection(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

}

public enum DBusConnectionPropertyName: String, PropertyNameProtocol {
    /// A D-Bus address specifying potential endpoints that can be used
    /// when establishing the connection.
    case address = "address"
    /// A `GDBusAuthObserver` object to assist in the authentication process or `nil`.
    case authenticationObserver = "authentication-observer"
    /// Flags from the `GDBusCapabilityFlags` enumeration
    /// representing connection features negotiated with the other peer.
    case capabilities = "capabilities"
    /// A boolean specifying whether the connection has been closed.
    case closed = "closed"
    /// A boolean specifying whether the process will be terminated (by
    /// calling ``raise(SIGTERM)``) if the connection is closed by the
    /// remote peer.
    /// 
    /// Note that `GDBusConnection` objects returned by `g_bus_get_finish()`
    /// and `g_bus_get_sync()` will (usually) have this property set to `true`.
    case exitOnClose = "exit-on-close"
    /// Flags from the `GDBusConnectionFlags` enumeration.
    case flags = "flags"
    /// The GUID of the peer performing the role of server when
    /// authenticating.
    /// 
    /// If you are constructing a `GDBusConnection` and pass
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER` in the
    /// `GDBusConnection:flags` property then you **must** also set this
    /// property to a valid guid.
    /// 
    /// If you are constructing a `GDBusConnection` and pass
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT` in the
    /// `GDBusConnection:flags` property you will be able to read the GUID
    /// of the other peer here after the connection has been successfully
    /// initialized.
    /// 
    /// Note that the
    /// [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html`addresses`)
    /// uses the term UUID to refer to this, whereas GLib consistently uses the
    /// term GUID for historical reasons.
    /// 
    /// Despite its name, the format of `GDBusConnection:guid` does not follow
    /// [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122) or the Microsoft
    /// GUID format.
    case guid = "guid"
    /// The underlying `GIOStream` used for I/O.
    /// 
    /// If this is passed on construction and is a `GSocketConnection`,
    /// then the corresponding `GSocket` will be put into non-blocking mode.
    /// 
    /// While the `GDBusConnection` is active, it will interact with this
    /// stream from a worker thread, so it is not safe to interact with
    /// the stream directly.
    case stream = "stream"
    /// The unique name as assigned by the message bus or `nil` if the
    /// connection is not open or not a message bus connection.
    case uniqueName = "unique-name"
}

public extension DBusConnectionProtocol {
    /// Bind a `DBusConnectionPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: DBusConnectionPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a DBusConnection property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: DBusConnectionPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a DBusConnection property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: DBusConnectionPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum DBusConnectionSignalName: String, SignalNameProtocol {
    /// Emitted when the connection is closed.
    /// 
    /// The cause of this event can be
    /// 
    /// - If `g_dbus_connection_close()` is called. In this case
    ///   `remote_peer_vanished` is set to `false` and `error` is `nil`.
    /// 
    /// - If the remote peer closes the connection. In this case
    ///   `remote_peer_vanished` is set to `true` and `error` is set.
    /// 
    /// - If the remote peer sends invalid or malformed data. In this
    ///   case `remote_peer_vanished` is set to `false` and `error` is set.
    /// 
    /// Upon receiving this signal, you should give up your reference to
    /// `connection`. You are guaranteed that this signal is emitted only
    /// once.
    case closed = "closed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// A D-Bus address specifying potential endpoints that can be used
    /// when establishing the connection.
    case notifyAddress = "notify::address"
    /// A `GDBusAuthObserver` object to assist in the authentication process or `nil`.
    case notifyAuthenticationObserver = "notify::authentication-observer"
    /// Flags from the `GDBusCapabilityFlags` enumeration
    /// representing connection features negotiated with the other peer.
    case notifyCapabilities = "notify::capabilities"
    /// A boolean specifying whether the connection has been closed.
    case notifyClosed = "notify::closed"
    /// A boolean specifying whether the process will be terminated (by
    /// calling ``raise(SIGTERM)``) if the connection is closed by the
    /// remote peer.
    /// 
    /// Note that `GDBusConnection` objects returned by `g_bus_get_finish()`
    /// and `g_bus_get_sync()` will (usually) have this property set to `true`.
    case notifyExitOnClose = "notify::exit-on-close"
    /// Flags from the `GDBusConnectionFlags` enumeration.
    case notifyFlags = "notify::flags"
    /// The GUID of the peer performing the role of server when
    /// authenticating.
    /// 
    /// If you are constructing a `GDBusConnection` and pass
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER` in the
    /// `GDBusConnection:flags` property then you **must** also set this
    /// property to a valid guid.
    /// 
    /// If you are constructing a `GDBusConnection` and pass
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT` in the
    /// `GDBusConnection:flags` property you will be able to read the GUID
    /// of the other peer here after the connection has been successfully
    /// initialized.
    /// 
    /// Note that the
    /// [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html`addresses`)
    /// uses the term UUID to refer to this, whereas GLib consistently uses the
    /// term GUID for historical reasons.
    /// 
    /// Despite its name, the format of `GDBusConnection:guid` does not follow
    /// [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122) or the Microsoft
    /// GUID format.
    case notifyGuid = "notify::guid"
    /// The underlying `GIOStream` used for I/O.
    /// 
    /// If this is passed on construction and is a `GSocketConnection`,
    /// then the corresponding `GSocket` will be put into non-blocking mode.
    /// 
    /// While the `GDBusConnection` is active, it will interact with this
    /// stream from a worker thread, so it is not safe to interact with
    /// the stream directly.
    case notifyStream = "notify::stream"
    /// The unique name as assigned by the message bus or `nil` if the
    /// connection is not open or not a message bus connection.
    case notifyUniqueName = "notify::unique-name"
}

// MARK: DBusConnection signals
public extension DBusConnectionProtocol {
    /// Connect a Swift signal handler to the given, typed `DBusConnectionSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DBusConnectionSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `DBusConnectionSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DBusConnectionSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when the connection is closed.
    /// 
    /// The cause of this event can be
    /// 
    /// - If `g_dbus_connection_close()` is called. In this case
    ///   `remote_peer_vanished` is set to `false` and `error` is `nil`.
    /// 
    /// - If the remote peer closes the connection. In this case
    ///   `remote_peer_vanished` is set to `true` and `error` is set.
    /// 
    /// - If the remote peer sends invalid or malformed data. In this
    ///   case `remote_peer_vanished` is set to `false` and `error` is set.
    /// 
    /// Upon receiving this signal, you should give up your reference to
    /// `connection`. You are guaranteed that this signal is emitted only
    /// once.
    /// - Note: This represents the underlying `closed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter remotePeerVanished: `true` if `connection` is closed because the     remote peer closed its end of the connection
    /// - Parameter error: a `GError` with more details about the event or `nil`
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `closed` signal is emitted
    @discardableResult @inlinable func onClosed(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusConnectionRef, _ remotePeerVanished: Bool, _ error: GLib.ErrorRef?) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusConnectionRef, Bool, GLib.ErrorRef?), Void>
        let cCallback: @convention(c) (gpointer, gboolean, gpointer?, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusConnectionRef(raw: unownedSelf), ((arg1) != 0), arg2.flatMap(GLib.ErrorRef.init(raw:))))
            return output
        }
        return connect(
            signal: .closed,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `closed` signal for using the `connect(signal:)` methods
    static var closedSignal: DBusConnectionSignalName { .closed }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::address` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAddress` signal is emitted
    @discardableResult @inlinable func onNotifyAddress(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyAddress,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::address` signal for using the `connect(signal:)` methods
    static var notifyAddressSignal: DBusConnectionSignalName { .notifyAddress }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::authentication-observer` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAuthenticationObserver` signal is emitted
    @discardableResult @inlinable func onNotifyAuthenticationObserver(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyAuthenticationObserver,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::authentication-observer` signal for using the `connect(signal:)` methods
    static var notifyAuthenticationObserverSignal: DBusConnectionSignalName { .notifyAuthenticationObserver }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::capabilities` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyCapabilities` signal is emitted
    @discardableResult @inlinable func onNotifyCapabilities(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyCapabilities,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::capabilities` signal for using the `connect(signal:)` methods
    static var notifyCapabilitiesSignal: DBusConnectionSignalName { .notifyCapabilities }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::closed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyClosed` signal is emitted
    @discardableResult @inlinable func onNotifyClosed(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyClosed,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::closed` signal for using the `connect(signal:)` methods
    static var notifyClosedSignal: DBusConnectionSignalName { .notifyClosed }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::exit-on-close` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyExitOnClose` signal is emitted
    @discardableResult @inlinable func onNotifyExitOnClose(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyExitOnClose,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::exit-on-close` signal for using the `connect(signal:)` methods
    static var notifyExitOnCloseSignal: DBusConnectionSignalName { .notifyExitOnClose }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::flags` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFlags` signal is emitted
    @discardableResult @inlinable func onNotifyFlags(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyFlags,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::flags` signal for using the `connect(signal:)` methods
    static var notifyFlagsSignal: DBusConnectionSignalName { .notifyFlags }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::guid` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyGuid` signal is emitted
    @discardableResult @inlinable func onNotifyGuid(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyGuid,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::guid` signal for using the `connect(signal:)` methods
    static var notifyGuidSignal: DBusConnectionSignalName { .notifyGuid }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::stream` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStream` signal is emitted
    @discardableResult @inlinable func onNotifyStream(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyStream,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::stream` signal for using the `connect(signal:)` methods
    static var notifyStreamSignal: DBusConnectionSignalName { .notifyStream }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::unique-name` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyUniqueName` signal is emitted
    @discardableResult @inlinable func onNotifyUniqueName(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusConnectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusConnectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusConnectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyUniqueName,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::unique-name` signal for using the `connect(signal:)` methods
    static var notifyUniqueNameSignal: DBusConnectionSignalName { .notifyUniqueName }
    
}

// MARK: DBusConnection Class: DBusConnectionProtocol extension (methods and fields)
public extension DBusConnectionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusConnection` instance.
    @inlinable var dbus_connection_ptr: UnsafeMutablePointer<GDBusConnection>! { return ptr?.assumingMemoryBound(to: GDBusConnection.self) }

    /// Adds a message filter. Filters are handlers that are run on all
    /// incoming and outgoing messages, prior to standard dispatch. Filters
    /// are run in the order that they were added.  The same handler can be
    /// added as a filter more than once, in which case it will be run more
    /// than once.  Filters added during a filter callback won't be run on
    /// the message being processed. Filter functions are allowed to modify
    /// and even drop messages.
    /// 
    /// Note that filters are run in a dedicated message handling thread so
    /// they can't block and, generally, can't do anything but signal a
    /// worker thread. Also note that filters are rarely needed - use API
    /// such as `g_dbus_connection_send_message_with_reply()`,
    /// `g_dbus_connection_signal_subscribe()` or `g_dbus_connection_call()` instead.
    /// 
    /// If a filter consumes an incoming message the message is not
    /// dispatched anywhere else - not even the standard dispatch machinery
    /// (that API such as `g_dbus_connection_signal_subscribe()` and
    /// `g_dbus_connection_send_message_with_reply()` relies on) will see the
    /// message. Similarly, if a filter consumes an outgoing message, the
    /// message will not be sent to the other peer.
    /// 
    /// If `user_data_free_func` is non-`nil`, it will be called (in the
    /// thread-default main context of the thread you are calling this
    /// method from) at some point after `user_data` is no longer
    /// needed. (It is not guaranteed to be called synchronously when the
    /// filter is removed, and may be called after `connection` has been
    /// destroyed.)
    @inlinable func addFilter(filterFunction: @escaping GDBusMessageFilterFunction, userData: gpointer? = nil, userDataFreeFunc: GDestroyNotify?) -> Int {
        let result = g_dbus_connection_add_filter(dbus_connection_ptr, filterFunction, userData, userDataFreeFunc)
        let rv = Int(result)
        return rv
    }

    /// Asynchronously invokes the `method_name` method on the
    /// `interface_name` D-Bus interface on the remote object at
    /// `object_path` owned by `bus_name`.
    /// 
    /// If `connection` is closed then the operation will fail with
    /// `G_IO_ERROR_CLOSED`. If `cancellable` is canceled, the operation will
    /// fail with `G_IO_ERROR_CANCELLED`. If `parameters` contains a value
    /// not compatible with the D-Bus protocol, the operation fails with
    /// `G_IO_ERROR_INVALID_ARGUMENT`.
    /// 
    /// If `reply_type` is non-`nil` then the reply will be checked for having this type and an
    /// error will be raised if it does not match.  Said another way, if you give a `reply_type`
    /// then any non-`nil` return value will be of this type. Unless its
    /// `G_VARIANT_TYPE_UNIT`, the `reply_type` will be a tuple containing one or more
    /// values.
    /// 
    /// If the `parameters` `GVariant` is floating, it is consumed. This allows
    /// convenient 'inline' use of `g_variant_new()`, e.g.:
    /// (C Language Example):
    /// ```C
    ///  g_dbus_connection_call (connection,
    ///                          "org.freedesktop.StringThings",
    ///                          "/org/freedesktop/StringThings",
    ///                          "org.freedesktop.StringThings",
    ///                          "TwoStrings",
    ///                          g_variant_new ("(ss)",
    ///                                         "Thing One",
    ///                                         "Thing Two"),
    ///                          NULL,
    ///                          G_DBUS_CALL_FLAGS_NONE,
    ///                          -1,
    ///                          NULL,
    ///                          (GAsyncReadyCallback) two_strings_done,
    ///                          NULL);
    /// ```
    /// 
    /// This is an asynchronous method. When the operation is finished,
    /// `callback` will be invoked in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// of the thread you are calling this method from. You can then call
    /// `g_dbus_connection_call_finish()` to get the result of the operation.
    /// See `g_dbus_connection_call_sync()` for the synchronous version of this
    /// function.
    /// 
    /// If `callback` is `nil` then the D-Bus method call message will be sent with
    /// the `G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED` flag set.
    @inlinable func call(busName: UnsafePointer<gchar>? = nil, objectPath: UnsafePointer<gchar>!, interfaceName: UnsafePointer<gchar>!, methodName: UnsafePointer<gchar>!, parameters: GLib.VariantRef? = nil, replyType: GLib.VariantTypeRef? = nil, flags: DBusCallFlags, timeoutMsec: Int, cancellable: CancellableRef? = nil, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
            
        g_dbus_connection_call(dbus_connection_ptr, busName, objectPath, interfaceName, methodName, parameters?.variant_ptr, replyType?.variant_type_ptr, flags.value, gint(timeoutMsec), cancellable?.cancellable_ptr, callback, userData)
            
    }
    /// Asynchronously invokes the `method_name` method on the
    /// `interface_name` D-Bus interface on the remote object at
    /// `object_path` owned by `bus_name`.
    /// 
    /// If `connection` is closed then the operation will fail with
    /// `G_IO_ERROR_CLOSED`. If `cancellable` is canceled, the operation will
    /// fail with `G_IO_ERROR_CANCELLED`. If `parameters` contains a value
    /// not compatible with the D-Bus protocol, the operation fails with
    /// `G_IO_ERROR_INVALID_ARGUMENT`.
    /// 
    /// If `reply_type` is non-`nil` then the reply will be checked for having this type and an
    /// error will be raised if it does not match.  Said another way, if you give a `reply_type`
    /// then any non-`nil` return value will be of this type. Unless its
    /// `G_VARIANT_TYPE_UNIT`, the `reply_type` will be a tuple containing one or more
    /// values.
    /// 
    /// If the `parameters` `GVariant` is floating, it is consumed. This allows
    /// convenient 'inline' use of `g_variant_new()`, e.g.:
    /// (C Language Example):
    /// ```C
    ///  g_dbus_connection_call (connection,
    ///                          "org.freedesktop.StringThings",
    ///                          "/org/freedesktop/StringThings",
    ///                          "org.freedesktop.StringThings",
    ///                          "TwoStrings",
    ///                          g_variant_new ("(ss)",
    ///                                         "Thing One",
    ///                                         "Thing Two"),
    ///                          NULL,
    ///                          G_DBUS_CALL_FLAGS_NONE,
    ///                          -1,
    ///                          NULL,
    ///                          (GAsyncReadyCallback) two_strings_done,
    ///                          NULL);
    /// ```
    /// 
    /// This is an asynchronous method. When the operation is finished,
    /// `callback` will be invoked in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// of the thread you are calling this method from. You can then call
    /// `g_dbus_connection_call_finish()` to get the result of the operation.
    /// See `g_dbus_connection_call_sync()` for the synchronous version of this
    /// function.
    /// 
    /// If `callback` is `nil` then the D-Bus method call message will be sent with
    /// the `G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED` flag set.
    @inlinable func call<CancellableT: CancellableProtocol, GLibVariantT: GLib.VariantProtocol, GLibVariantTypeT: GLib.VariantTypeProtocol>(busName: UnsafePointer<gchar>? = nil, objectPath: UnsafePointer<gchar>!, interfaceName: UnsafePointer<gchar>!, methodName: UnsafePointer<gchar>!, parameters: GLibVariantT?, replyType: GLibVariantTypeT?, flags: DBusCallFlags, timeoutMsec: Int, cancellable: CancellableT?, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
        
        g_dbus_connection_call(dbus_connection_ptr, busName, objectPath, interfaceName, methodName, parameters?.variant_ptr, replyType?.variant_type_ptr, flags.value, gint(timeoutMsec), cancellable?.cancellable_ptr, callback, userData)
        
    }

    /// Finishes an operation started with `g_dbus_connection_call()`.
    @inlinable func callFinish<AsyncResultT: AsyncResultProtocol>(res: AsyncResultT) throws -> GLib.VariantRef! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_call_finish(dbus_connection_ptr, res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = GLib.VariantRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Synchronously invokes the `method_name` method on the
    /// `interface_name` D-Bus interface on the remote object at
    /// `object_path` owned by `bus_name`.
    /// 
    /// If `connection` is closed then the operation will fail with
    /// `G_IO_ERROR_CLOSED`. If `cancellable` is canceled, the
    /// operation will fail with `G_IO_ERROR_CANCELLED`. If `parameters`
    /// contains a value not compatible with the D-Bus protocol, the operation
    /// fails with `G_IO_ERROR_INVALID_ARGUMENT`.
    /// 
    /// If `reply_type` is non-`nil` then the reply will be checked for having
    /// this type and an error will be raised if it does not match.  Said
    /// another way, if you give a `reply_type` then any non-`nil` return
    /// value will be of this type.
    /// 
    /// If the `parameters` `GVariant` is floating, it is consumed.
    /// This allows convenient 'inline' use of `g_variant_new()`, e.g.:
    /// (C Language Example):
    /// ```C
    ///  g_dbus_connection_call_sync (connection,
    ///                               "org.freedesktop.StringThings",
    ///                               "/org/freedesktop/StringThings",
    ///                               "org.freedesktop.StringThings",
    ///                               "TwoStrings",
    ///                               g_variant_new ("(ss)",
    ///                                              "Thing One",
    ///                                              "Thing Two"),
    ///                               NULL,
    ///                               G_DBUS_CALL_FLAGS_NONE,
    ///                               -1,
    ///                               NULL,
    ///                               &error);
    /// ```
    /// 
    /// The calling thread is blocked until a reply is received. See
    /// `g_dbus_connection_call()` for the asynchronous version of
    /// this method.
    @inlinable func callSync(busName: UnsafePointer<gchar>? = nil, objectPath: UnsafePointer<gchar>!, interfaceName: UnsafePointer<gchar>!, methodName: UnsafePointer<gchar>!, parameters: GLib.VariantRef? = nil, replyType: GLib.VariantTypeRef? = nil, flags: DBusCallFlags, timeoutMsec: Int, cancellable: CancellableRef? = nil) throws -> GLib.VariantRef! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_call_sync(dbus_connection_ptr, busName, objectPath, interfaceName, methodName, parameters?.variant_ptr, replyType?.variant_type_ptr, flags.value, gint(timeoutMsec), cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = GLib.VariantRef(gconstpointer: gconstpointer(result))
            return rv
    }
    /// Synchronously invokes the `method_name` method on the
    /// `interface_name` D-Bus interface on the remote object at
    /// `object_path` owned by `bus_name`.
    /// 
    /// If `connection` is closed then the operation will fail with
    /// `G_IO_ERROR_CLOSED`. If `cancellable` is canceled, the
    /// operation will fail with `G_IO_ERROR_CANCELLED`. If `parameters`
    /// contains a value not compatible with the D-Bus protocol, the operation
    /// fails with `G_IO_ERROR_INVALID_ARGUMENT`.
    /// 
    /// If `reply_type` is non-`nil` then the reply will be checked for having
    /// this type and an error will be raised if it does not match.  Said
    /// another way, if you give a `reply_type` then any non-`nil` return
    /// value will be of this type.
    /// 
    /// If the `parameters` `GVariant` is floating, it is consumed.
    /// This allows convenient 'inline' use of `g_variant_new()`, e.g.:
    /// (C Language Example):
    /// ```C
    ///  g_dbus_connection_call_sync (connection,
    ///                               "org.freedesktop.StringThings",
    ///                               "/org/freedesktop/StringThings",
    ///                               "org.freedesktop.StringThings",
    ///                               "TwoStrings",
    ///                               g_variant_new ("(ss)",
    ///                                              "Thing One",
    ///                                              "Thing Two"),
    ///                               NULL,
    ///                               G_DBUS_CALL_FLAGS_NONE,
    ///                               -1,
    ///                               NULL,
    ///                               &error);
    /// ```
    /// 
    /// The calling thread is blocked until a reply is received. See
    /// `g_dbus_connection_call()` for the asynchronous version of
    /// this method.
    @inlinable func callSync<CancellableT: CancellableProtocol, GLibVariantT: GLib.VariantProtocol, GLibVariantTypeT: GLib.VariantTypeProtocol>(busName: UnsafePointer<gchar>? = nil, objectPath: UnsafePointer<gchar>!, interfaceName: UnsafePointer<gchar>!, methodName: UnsafePointer<gchar>!, parameters: GLibVariantT?, replyType: GLibVariantTypeT?, flags: DBusCallFlags, timeoutMsec: Int, cancellable: CancellableT?) throws -> GLib.VariantRef! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_call_sync(dbus_connection_ptr, busName, objectPath, interfaceName, methodName, parameters?.variant_ptr, replyType?.variant_type_ptr, flags.value, gint(timeoutMsec), cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = GLib.VariantRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Like `g_dbus_connection_call()` but also takes a `GUnixFDList` object.
    /// 
    /// The file descriptors normally correspond to `G_VARIANT_TYPE_HANDLE`
    /// values in the body of the message. For example, if a message contains
    /// two file descriptors, `fd_list` would have length 2, and
    /// `g_variant_new_handle (0)` and `g_variant_new_handle (1)` would appear
    /// somewhere in the body of the message (not necessarily in that order!)
    /// to represent the file descriptors at indexes 0 and 1 respectively.
    /// 
    /// When designing D-Bus APIs that are intended to be interoperable,
    /// please note that non-GDBus implementations of D-Bus can usually only
    /// access file descriptors if they are referenced in this way by a
    /// value of type `G_VARIANT_TYPE_HANDLE` in the body of the message.
    /// 
    /// This method is only available on UNIX.
    @inlinable func callWithUnixFdList(busName: UnsafePointer<gchar>? = nil, objectPath: UnsafePointer<gchar>!, interfaceName: UnsafePointer<gchar>!, methodName: UnsafePointer<gchar>!, parameters: GLib.VariantRef? = nil, replyType: GLib.VariantTypeRef? = nil, flags: DBusCallFlags, timeoutMsec: Int, fdList: UnixFDListRef? = nil, cancellable: CancellableRef? = nil, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
            
        g_dbus_connection_call_with_unix_fd_list(dbus_connection_ptr, busName, objectPath, interfaceName, methodName, parameters?.variant_ptr, replyType?.variant_type_ptr, flags.value, gint(timeoutMsec), fdList?.unix_fd_list_ptr, cancellable?.cancellable_ptr, callback, userData)
            
    }
    /// Like `g_dbus_connection_call()` but also takes a `GUnixFDList` object.
    /// 
    /// The file descriptors normally correspond to `G_VARIANT_TYPE_HANDLE`
    /// values in the body of the message. For example, if a message contains
    /// two file descriptors, `fd_list` would have length 2, and
    /// `g_variant_new_handle (0)` and `g_variant_new_handle (1)` would appear
    /// somewhere in the body of the message (not necessarily in that order!)
    /// to represent the file descriptors at indexes 0 and 1 respectively.
    /// 
    /// When designing D-Bus APIs that are intended to be interoperable,
    /// please note that non-GDBus implementations of D-Bus can usually only
    /// access file descriptors if they are referenced in this way by a
    /// value of type `G_VARIANT_TYPE_HANDLE` in the body of the message.
    /// 
    /// This method is only available on UNIX.
    @inlinable func callWithUnixFdList<CancellableT: CancellableProtocol, GLibVariantT: GLib.VariantProtocol, GLibVariantTypeT: GLib.VariantTypeProtocol, UnixFDListT: UnixFDListProtocol>(busName: UnsafePointer<gchar>? = nil, objectPath: UnsafePointer<gchar>!, interfaceName: UnsafePointer<gchar>!, methodName: UnsafePointer<gchar>!, parameters: GLibVariantT?, replyType: GLibVariantTypeT?, flags: DBusCallFlags, timeoutMsec: Int, fdList: UnixFDListT?, cancellable: CancellableT?, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
        
        g_dbus_connection_call_with_unix_fd_list(dbus_connection_ptr, busName, objectPath, interfaceName, methodName, parameters?.variant_ptr, replyType?.variant_type_ptr, flags.value, gint(timeoutMsec), fdList?.unix_fd_list_ptr, cancellable?.cancellable_ptr, callback, userData)
        
    }

    /// Finishes an operation started with `g_dbus_connection_call_with_unix_fd_list()`.
    /// 
    /// The file descriptors normally correspond to `G_VARIANT_TYPE_HANDLE`
    /// values in the body of the message. For example,
    /// if `g_variant_get_handle()` returns 5, that is intended to be a reference
    /// to the file descriptor that can be accessed by
    /// `g_unix_fd_list_get (*out_fd_list, 5, ...)`.
    /// 
    /// When designing D-Bus APIs that are intended to be interoperable,
    /// please note that non-GDBus implementations of D-Bus can usually only
    /// access file descriptors if they are referenced in this way by a
    /// value of type `G_VARIANT_TYPE_HANDLE` in the body of the message.
    @inlinable func callWithUnixFdListFinish<AsyncResultT: AsyncResultProtocol>(outFdList: UnsafeMutablePointer<UnsafeMutablePointer<GUnixFDList>?>! = nil, res: AsyncResultT) throws -> GLib.VariantRef! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_call_with_unix_fd_list_finish(dbus_connection_ptr, outFdList, res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = GLib.VariantRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Like `g_dbus_connection_call_sync()` but also takes and returns `GUnixFDList` objects.
    /// See `g_dbus_connection_call_with_unix_fd_list()` and
    /// `g_dbus_connection_call_with_unix_fd_list_finish()` for more details.
    /// 
    /// This method is only available on UNIX.
    @inlinable func callWithUnixFdListSync(busName: UnsafePointer<gchar>? = nil, objectPath: UnsafePointer<gchar>!, interfaceName: UnsafePointer<gchar>!, methodName: UnsafePointer<gchar>!, parameters: GLib.VariantRef? = nil, replyType: GLib.VariantTypeRef? = nil, flags: DBusCallFlags, timeoutMsec: Int, fdList: UnixFDListRef? = nil, outFdList: UnsafeMutablePointer<UnsafeMutablePointer<GUnixFDList>?>! = nil, cancellable: CancellableRef? = nil) throws -> GLib.VariantRef! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_call_with_unix_fd_list_sync(dbus_connection_ptr, busName, objectPath, interfaceName, methodName, parameters?.variant_ptr, replyType?.variant_type_ptr, flags.value, gint(timeoutMsec), fdList?.unix_fd_list_ptr, outFdList, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = GLib.VariantRef(gconstpointer: gconstpointer(result))
            return rv
    }
    /// Like `g_dbus_connection_call_sync()` but also takes and returns `GUnixFDList` objects.
    /// See `g_dbus_connection_call_with_unix_fd_list()` and
    /// `g_dbus_connection_call_with_unix_fd_list_finish()` for more details.
    /// 
    /// This method is only available on UNIX.
    @inlinable func callWithUnixFdListSync<CancellableT: CancellableProtocol, GLibVariantT: GLib.VariantProtocol, GLibVariantTypeT: GLib.VariantTypeProtocol, UnixFDListT: UnixFDListProtocol>(busName: UnsafePointer<gchar>? = nil, objectPath: UnsafePointer<gchar>!, interfaceName: UnsafePointer<gchar>!, methodName: UnsafePointer<gchar>!, parameters: GLibVariantT?, replyType: GLibVariantTypeT?, flags: DBusCallFlags, timeoutMsec: Int, fdList: UnixFDListT?, outFdList: UnsafeMutablePointer<UnsafeMutablePointer<GUnixFDList>?>! = nil, cancellable: CancellableT?) throws -> GLib.VariantRef! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_call_with_unix_fd_list_sync(dbus_connection_ptr, busName, objectPath, interfaceName, methodName, parameters?.variant_ptr, replyType?.variant_type_ptr, flags.value, gint(timeoutMsec), fdList?.unix_fd_list_ptr, outFdList, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = GLib.VariantRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Closes `connection`. Note that this never causes the process to
    /// exit (this might only happen if the other end of a shared message
    /// bus connection disconnects, see `GDBusConnection:exit-on-close`).
    /// 
    /// Once the connection is closed, operations such as sending a message
    /// will return with the error `G_IO_ERROR_CLOSED`. Closing a connection
    /// will not automatically flush the connection so queued messages may
    /// be lost. Use `g_dbus_connection_flush()` if you need such guarantees.
    /// 
    /// If `connection` is already closed, this method fails with
    /// `G_IO_ERROR_CLOSED`.
    /// 
    /// When `connection` has been closed, the `GDBusConnection::closed`
    /// signal is emitted in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// of the thread that `connection` was constructed in.
    /// 
    /// This is an asynchronous method. When the operation is finished,
    /// `callback` will be invoked in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// of the thread you are calling this method from. You can
    /// then call `g_dbus_connection_close_finish()` to get the result of the
    /// operation. See `g_dbus_connection_close_sync()` for the synchronous
    /// version.
    @inlinable func close(cancellable: CancellableRef? = nil, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
            
        g_dbus_connection_close(dbus_connection_ptr, cancellable?.cancellable_ptr, callback, userData)
            
    }
    /// Closes `connection`. Note that this never causes the process to
    /// exit (this might only happen if the other end of a shared message
    /// bus connection disconnects, see `GDBusConnection:exit-on-close`).
    /// 
    /// Once the connection is closed, operations such as sending a message
    /// will return with the error `G_IO_ERROR_CLOSED`. Closing a connection
    /// will not automatically flush the connection so queued messages may
    /// be lost. Use `g_dbus_connection_flush()` if you need such guarantees.
    /// 
    /// If `connection` is already closed, this method fails with
    /// `G_IO_ERROR_CLOSED`.
    /// 
    /// When `connection` has been closed, the `GDBusConnection::closed`
    /// signal is emitted in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// of the thread that `connection` was constructed in.
    /// 
    /// This is an asynchronous method. When the operation is finished,
    /// `callback` will be invoked in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// of the thread you are calling this method from. You can
    /// then call `g_dbus_connection_close_finish()` to get the result of the
    /// operation. See `g_dbus_connection_close_sync()` for the synchronous
    /// version.
    @inlinable func close<CancellableT: CancellableProtocol>(cancellable: CancellableT?, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
        
        g_dbus_connection_close(dbus_connection_ptr, cancellable?.cancellable_ptr, callback, userData)
        
    }

    /// Finishes an operation started with `g_dbus_connection_close()`.
    @inlinable func closeFinish<AsyncResultT: AsyncResultProtocol>(res: AsyncResultT) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_close_finish(dbus_connection_ptr, res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Synchronously closes `connection`. The calling thread is blocked
    /// until this is done. See `g_dbus_connection_close()` for the
    /// asynchronous version of this method and more details about what it
    /// does.
    @inlinable func closeSync(cancellable: CancellableRef? = nil) throws -> Bool {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_close_sync(dbus_connection_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
            return rv
    }
    /// Synchronously closes `connection`. The calling thread is blocked
    /// until this is done. See `g_dbus_connection_close()` for the
    /// asynchronous version of this method and more details about what it
    /// does.
    @inlinable func closeSync<CancellableT: CancellableProtocol>(cancellable: CancellableT?) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_close_sync(dbus_connection_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Emits a signal.
    /// 
    /// If the parameters GVariant is floating, it is consumed.
    /// 
    /// This can only fail if `parameters` is not compatible with the D-Bus protocol
    /// (`G_IO_ERROR_INVALID_ARGUMENT`), or if `connection` has been closed
    /// (`G_IO_ERROR_CLOSED`).
    @inlinable func emitSignal(destinationBusName: UnsafePointer<gchar>? = nil, objectPath: UnsafePointer<gchar>!, interfaceName: UnsafePointer<gchar>!, signalName: UnsafePointer<gchar>!, parameters: GLib.VariantRef? = nil) throws -> Bool {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_emit_signal(dbus_connection_ptr, destinationBusName, objectPath, interfaceName, signalName, parameters?.variant_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
            return rv
    }
    /// Emits a signal.
    /// 
    /// If the parameters GVariant is floating, it is consumed.
    /// 
    /// This can only fail if `parameters` is not compatible with the D-Bus protocol
    /// (`G_IO_ERROR_INVALID_ARGUMENT`), or if `connection` has been closed
    /// (`G_IO_ERROR_CLOSED`).
    @inlinable func emitSignal<GLibVariantT: GLib.VariantProtocol>(destinationBusName: UnsafePointer<gchar>? = nil, objectPath: UnsafePointer<gchar>!, interfaceName: UnsafePointer<gchar>!, signalName: UnsafePointer<gchar>!, parameters: GLibVariantT?) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_emit_signal(dbus_connection_ptr, destinationBusName, objectPath, interfaceName, signalName, parameters?.variant_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Exports `action_group` on `connection` at `object_path`.
    /// 
    /// The implemented D-Bus API should be considered private.  It is
    /// subject to change in the future.
    /// 
    /// A given object path can only have one action group exported on it.
    /// If this constraint is violated, the export will fail and 0 will be
    /// returned (with `error` set accordingly).
    /// 
    /// You can unexport the action group using
    /// `g_dbus_connection_unexport_action_group()` with the return value of
    /// this function.
    /// 
    /// The thread default main context is taken at the time of this call.
    /// All incoming action activations and state change requests are
    /// reported from this context.  Any changes on the action group that
    /// cause it to emit signals must also come from this same context.
    /// Since incoming action activations and state change requests are
    /// rather likely to cause changes on the action group, this effectively
    /// limits a given action group to being exported from only one main
    /// context.
    @inlinable func exportActionGroup<ActionGroupT: ActionGroupProtocol>(objectPath: UnsafePointer<gchar>!, actionGroup: ActionGroupT) throws -> Int {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_export_action_group(dbus_connection_ptr, objectPath, actionGroup.action_group_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = Int(result)
        return rv
    }

    /// Exports `menu` on `connection` at `object_path`.
    /// 
    /// The implemented D-Bus API should be considered private.
    /// It is subject to change in the future.
    /// 
    /// An object path can only have one menu model exported on it. If this
    /// constraint is violated, the export will fail and 0 will be
    /// returned (with `error` set accordingly).
    /// 
    /// You can unexport the menu model using
    /// `g_dbus_connection_unexport_menu_model()` with the return value of
    /// this function.
    @inlinable func exportMenuModel<MenuModelT: MenuModelProtocol>(objectPath: UnsafePointer<gchar>!, menu: MenuModelT) throws -> Int {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_export_menu_model(dbus_connection_ptr, objectPath, menu.menu_model_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = Int(result)
        return rv
    }

    /// Asynchronously flushes `connection`, that is, writes all queued
    /// outgoing message to the transport and then flushes the transport
    /// (using `g_output_stream_flush_async()`). This is useful in programs
    /// that wants to emit a D-Bus signal and then exit immediately. Without
    /// flushing the connection, there is no guaranteed that the message has
    /// been sent to the networking buffers in the OS kernel.
    /// 
    /// This is an asynchronous method. When the operation is finished,
    /// `callback` will be invoked in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// of the thread you are calling this method from. You can
    /// then call `g_dbus_connection_flush_finish()` to get the result of the
    /// operation. See `g_dbus_connection_flush_sync()` for the synchronous
    /// version.
    @inlinable func flush(cancellable: CancellableRef? = nil, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
            
        g_dbus_connection_flush(dbus_connection_ptr, cancellable?.cancellable_ptr, callback, userData)
            
    }
    /// Asynchronously flushes `connection`, that is, writes all queued
    /// outgoing message to the transport and then flushes the transport
    /// (using `g_output_stream_flush_async()`). This is useful in programs
    /// that wants to emit a D-Bus signal and then exit immediately. Without
    /// flushing the connection, there is no guaranteed that the message has
    /// been sent to the networking buffers in the OS kernel.
    /// 
    /// This is an asynchronous method. When the operation is finished,
    /// `callback` will be invoked in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// of the thread you are calling this method from. You can
    /// then call `g_dbus_connection_flush_finish()` to get the result of the
    /// operation. See `g_dbus_connection_flush_sync()` for the synchronous
    /// version.
    @inlinable func flush<CancellableT: CancellableProtocol>(cancellable: CancellableT?, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
        
        g_dbus_connection_flush(dbus_connection_ptr, cancellable?.cancellable_ptr, callback, userData)
        
    }

    /// Finishes an operation started with `g_dbus_connection_flush()`.
    @inlinable func flushFinish<AsyncResultT: AsyncResultProtocol>(res: AsyncResultT) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_flush_finish(dbus_connection_ptr, res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Synchronously flushes `connection`. The calling thread is blocked
    /// until this is done. See `g_dbus_connection_flush()` for the
    /// asynchronous version of this method and more details about what it
    /// does.
    @inlinable func flushSync(cancellable: CancellableRef? = nil) throws -> Bool {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_flush_sync(dbus_connection_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
            return rv
    }
    /// Synchronously flushes `connection`. The calling thread is blocked
    /// until this is done. See `g_dbus_connection_flush()` for the
    /// asynchronous version of this method and more details about what it
    /// does.
    @inlinable func flushSync<CancellableT: CancellableProtocol>(cancellable: CancellableT?) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_flush_sync(dbus_connection_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the capabilities negotiated with the remote peer
    @inlinable func getCapabilities() -> GIO.DBusCapabilityFlags {
        let result = g_dbus_connection_get_capabilities(dbus_connection_ptr)
        let rv = DBusCapabilityFlags(result)
        return rv
    }

    /// Gets whether the process is terminated when `connection` is
    /// closed by the remote peer. See
    /// `GDBusConnection:exit-on-close` for more details.
    @inlinable func getExitOnClose() -> Bool {
        let result = g_dbus_connection_get_exit_on_close(dbus_connection_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the flags used to construct this connection
    @inlinable func getFlags() -> GIO.DBusConnectionFlags {
        let result = g_dbus_connection_get_flags(dbus_connection_ptr)
        let rv = DBusConnectionFlags(result)
        return rv
    }

    /// The GUID of the peer performing the role of server when
    /// authenticating. See `GDBusConnection:guid` for more details.
    @inlinable func getGuid() -> String! {
        let result = g_dbus_connection_get_guid(dbus_connection_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Retrieves the last serial number assigned to a `GDBusMessage` on
    /// the current thread. This includes messages sent via both low-level
    /// API such as `g_dbus_connection_send_message()` as well as
    /// high-level API such as `g_dbus_connection_emit_signal()`,
    /// `g_dbus_connection_call()` or `g_dbus_proxy_call()`.
    @inlinable func getLastSerial() -> guint32 {
        let result = g_dbus_connection_get_last_serial(dbus_connection_ptr)
        let rv = result
        return rv
    }

    /// Gets the credentials of the authenticated peer. This will always
    /// return `nil` unless `connection` acted as a server
    /// (e.g. `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER` was passed)
    /// when set up and the client passed credentials as part of the
    /// authentication process.
    /// 
    /// In a message bus setup, the message bus is always the server and
    /// each application is a client. So this method will always return
    /// `nil` for message bus clients.
    @inlinable func getPeerCredentials() -> GIO.CredentialsRef! {
        let result = g_dbus_connection_get_peer_credentials(dbus_connection_ptr)
        let rv = CredentialsRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the underlying stream used for IO.
    /// 
    /// While the `GDBusConnection` is active, it will interact with this
    /// stream from a worker thread, so it is not safe to interact with
    /// the stream directly.
    @inlinable func getStream() -> GIO.IOStreamRef! {
        let result = g_dbus_connection_get_stream(dbus_connection_ptr)
        let rv = IOStreamRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the unique name of `connection` as assigned by the message
    /// bus. This can also be used to figure out if `connection` is a
    /// message bus connection.
    @inlinable func getUniqueName() -> String! {
        let result = g_dbus_connection_get_unique_name(dbus_connection_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Registers callbacks for exported objects at `object_path` with the
    /// D-Bus interface that is described in `interface_info`.
    /// 
    /// Calls to functions in `vtable` (and `user_data_free_func`) will happen
    /// in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// of the thread you are calling this method from.
    /// 
    /// Note that all `GVariant` values passed to functions in `vtable` will match
    /// the signature given in `interface_info` - if a remote caller passes
    /// incorrect values, the `org.freedesktop.DBus.Error.InvalidArgs`
    /// is returned to the remote caller.
    /// 
    /// Additionally, if the remote caller attempts to invoke methods or
    /// access properties not mentioned in `interface_info` the
    /// `org.freedesktop.DBus.Error.UnknownMethod` resp.
    /// `org.freedesktop.DBus.Error.InvalidArgs` errors
    /// are returned to the caller.
    /// 
    /// It is considered a programming error if the
    /// `GDBusInterfaceGetPropertyFunc` function in `vtable` returns a
    /// `GVariant` of incorrect type.
    /// 
    /// If an existing callback is already registered at `object_path` and
    /// `interface_name`, then `error` is set to `G_IO_ERROR_EXISTS`.
    /// 
    /// GDBus automatically implements the standard D-Bus interfaces
    /// org.freedesktop.DBus.Properties, org.freedesktop.DBus.Introspectable
    /// and org.freedesktop.Peer, so you don't have to implement those for the
    /// objects you export. You can implement org.freedesktop.DBus.Properties
    /// yourself, e.g. to handle getting and setting of properties asynchronously.
    /// 
    /// Note that the reference count on `interface_info` will be
    /// incremented by 1 (unless allocated statically, e.g. if the
    /// reference count is -1, see `g_dbus_interface_info_ref()`) for as long
    /// as the object is exported. Also note that `vtable` will be copied.
    /// 
    /// See this [server](#gdbus-server) for an example of how to use this method.
    @inlinable func registerObject<DBusInterfaceInfoT: DBusInterfaceInfoProtocol>(objectPath: UnsafePointer<gchar>!, interfaceInfo: DBusInterfaceInfoT, vtable: DBusInterfaceVTableRef? = nil, userData: gpointer? = nil, userDataFreeFunc: GDestroyNotify?) throws -> Int {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_register_object(dbus_connection_ptr, objectPath, interfaceInfo.dbus_interface_info_ptr, vtable?._ptr, userData, userDataFreeFunc, &error)
        if let error = error { throw GLibError(error) }
        let rv = Int(result)
            return rv
    }
    /// Registers callbacks for exported objects at `object_path` with the
    /// D-Bus interface that is described in `interface_info`.
    /// 
    /// Calls to functions in `vtable` (and `user_data_free_func`) will happen
    /// in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// of the thread you are calling this method from.
    /// 
    /// Note that all `GVariant` values passed to functions in `vtable` will match
    /// the signature given in `interface_info` - if a remote caller passes
    /// incorrect values, the `org.freedesktop.DBus.Error.InvalidArgs`
    /// is returned to the remote caller.
    /// 
    /// Additionally, if the remote caller attempts to invoke methods or
    /// access properties not mentioned in `interface_info` the
    /// `org.freedesktop.DBus.Error.UnknownMethod` resp.
    /// `org.freedesktop.DBus.Error.InvalidArgs` errors
    /// are returned to the caller.
    /// 
    /// It is considered a programming error if the
    /// `GDBusInterfaceGetPropertyFunc` function in `vtable` returns a
    /// `GVariant` of incorrect type.
    /// 
    /// If an existing callback is already registered at `object_path` and
    /// `interface_name`, then `error` is set to `G_IO_ERROR_EXISTS`.
    /// 
    /// GDBus automatically implements the standard D-Bus interfaces
    /// org.freedesktop.DBus.Properties, org.freedesktop.DBus.Introspectable
    /// and org.freedesktop.Peer, so you don't have to implement those for the
    /// objects you export. You can implement org.freedesktop.DBus.Properties
    /// yourself, e.g. to handle getting and setting of properties asynchronously.
    /// 
    /// Note that the reference count on `interface_info` will be
    /// incremented by 1 (unless allocated statically, e.g. if the
    /// reference count is -1, see `g_dbus_interface_info_ref()`) for as long
    /// as the object is exported. Also note that `vtable` will be copied.
    /// 
    /// See this [server](#gdbus-server) for an example of how to use this method.
    @inlinable func registerObject<DBusInterfaceInfoT: DBusInterfaceInfoProtocol, DBusInterfaceVTableT: DBusInterfaceVTableProtocol>(objectPath: UnsafePointer<gchar>!, interfaceInfo: DBusInterfaceInfoT, vtable: DBusInterfaceVTableT?, userData: gpointer? = nil, userDataFreeFunc: GDestroyNotify?) throws -> Int {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_register_object(dbus_connection_ptr, objectPath, interfaceInfo.dbus_interface_info_ptr, vtable?._ptr, userData, userDataFreeFunc, &error)
        if let error = error { throw GLibError(error) }
        let rv = Int(result)
        return rv
    }

    /// Version of `g_dbus_connection_register_object()` using closures instead of a
    /// `GDBusInterfaceVTable` for easier binding in other languages.
    @inlinable func registerObjectWithClosures<DBusInterfaceInfoT: DBusInterfaceInfoProtocol>(objectPath: UnsafePointer<gchar>!, interfaceInfo: DBusInterfaceInfoT, methodCallClosure: GLibObject.ClosureRef? = nil, getPropertyClosure: GLibObject.ClosureRef? = nil, setPropertyClosure: GLibObject.ClosureRef? = nil) throws -> Int {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_register_object_with_closures(dbus_connection_ptr, objectPath, interfaceInfo.dbus_interface_info_ptr, methodCallClosure?.closure_ptr, getPropertyClosure?.closure_ptr, setPropertyClosure?.closure_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = Int(result)
            return rv
    }
    /// Version of `g_dbus_connection_register_object()` using closures instead of a
    /// `GDBusInterfaceVTable` for easier binding in other languages.
    @inlinable func registerObjectWithClosures<DBusInterfaceInfoT: DBusInterfaceInfoProtocol, GObjectClosureT: GLibObject.ClosureProtocol>(objectPath: UnsafePointer<gchar>!, interfaceInfo: DBusInterfaceInfoT, methodCallClosure: GObjectClosureT?, getPropertyClosure: GObjectClosureT?, setPropertyClosure: GObjectClosureT?) throws -> Int {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_register_object_with_closures(dbus_connection_ptr, objectPath, interfaceInfo.dbus_interface_info_ptr, methodCallClosure?.closure_ptr, getPropertyClosure?.closure_ptr, setPropertyClosure?.closure_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = Int(result)
        return rv
    }

    /// Registers a whole subtree of dynamic objects.
    /// 
    /// The `enumerate` and `introspection` functions in `vtable` are used to
    /// convey, to remote callers, what nodes exist in the subtree rooted
    /// by `object_path`.
    /// 
    /// When handling remote calls into any node in the subtree, first the
    /// `enumerate` function is used to check if the node exists. If the node exists
    /// or the `G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES` flag is set
    /// the `introspection` function is used to check if the node supports the
    /// requested method. If so, the `dispatch` function is used to determine
    /// where to dispatch the call. The collected `GDBusInterfaceVTable` and
    /// `gpointer` will be used to call into the interface vtable for processing
    /// the request.
    /// 
    /// All calls into user-provided code will be invoked in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// of the thread you are calling this method from.
    /// 
    /// If an existing subtree is already registered at `object_path` or
    /// then `error` is set to `G_IO_ERROR_EXISTS`.
    /// 
    /// Note that it is valid to register regular objects (using
    /// `g_dbus_connection_register_object()`) in a subtree registered with
    /// `g_dbus_connection_register_subtree()` - if so, the subtree handler
    /// is tried as the last resort. One way to think about a subtree
    /// handler is to consider it a fallback handler for object paths not
    /// registered via `g_dbus_connection_register_object()` or other bindings.
    /// 
    /// Note that `vtable` will be copied so you cannot change it after
    /// registration.
    /// 
    /// See this [server](#gdbus-subtree-server) for an example of how to use
    /// this method.
    @inlinable func registerSubtree<DBusSubtreeVTableT: DBusSubtreeVTableProtocol>(objectPath: UnsafePointer<gchar>!, vtable: DBusSubtreeVTableT, flags: DBusSubtreeFlags, userData: gpointer? = nil, userDataFreeFunc: GDestroyNotify?) throws -> Int {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_register_subtree(dbus_connection_ptr, objectPath, vtable._ptr, flags.value, userData, userDataFreeFunc, &error)
        if let error = error { throw GLibError(error) }
        let rv = Int(result)
        return rv
    }

    /// Removes a filter.
    /// 
    /// Note that since filters run in a different thread, there is a race
    /// condition where it is possible that the filter will be running even
    /// after calling `g_dbus_connection_remove_filter()`, so you cannot just
    /// free data that the filter might be using. Instead, you should pass
    /// a `GDestroyNotify` to `g_dbus_connection_add_filter()`, which will be
    /// called when it is guaranteed that the data is no longer needed.
    @inlinable func removeFilter(filterID: Int) {
        
        g_dbus_connection_remove_filter(dbus_connection_ptr, guint(filterID))
        
    }

    /// Asynchronously sends `message` to the peer represented by `connection`.
    /// 
    /// Unless `flags` contain the
    /// `G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL` flag, the serial number
    /// will be assigned by `connection` and set on `message` via
    /// `g_dbus_message_set_serial()`. If `out_serial` is not `nil`, then the
    /// serial number used will be written to this location prior to
    /// submitting the message to the underlying transport. While it has a `volatile`
    /// qualifier, this is a historical artifact and the argument passed to it should
    /// not be `volatile`.
    /// 
    /// If `connection` is closed then the operation will fail with
    /// `G_IO_ERROR_CLOSED`. If `message` is not well-formed,
    /// the operation fails with `G_IO_ERROR_INVALID_ARGUMENT`.
    /// 
    /// See this [server](#gdbus-server) and [client](#gdbus-unix-fd-client)
    /// for an example of how to use this low-level API to send and receive
    /// UNIX file descriptors.
    /// 
    /// Note that `message` must be unlocked, unless `flags` contain the
    /// `G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL` flag.
    @inlinable func send<DBusMessageT: DBusMessageProtocol>(message: DBusMessageT, flags: DBusSendMessageFlags, outSerial: UnsafeMutablePointer<guint32>! = nil) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_send_message(dbus_connection_ptr, message.dbus_message_ptr, flags.value, outSerial, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Asynchronously sends `message` to the peer represented by `connection`.
    /// 
    /// Unless `flags` contain the
    /// `G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL` flag, the serial number
    /// will be assigned by `connection` and set on `message` via
    /// `g_dbus_message_set_serial()`. If `out_serial` is not `nil`, then the
    /// serial number used will be written to this location prior to
    /// submitting the message to the underlying transport. While it has a `volatile`
    /// qualifier, this is a historical artifact and the argument passed to it should
    /// not be `volatile`.
    /// 
    /// If `connection` is closed then the operation will fail with
    /// `G_IO_ERROR_CLOSED`. If `cancellable` is canceled, the operation will
    /// fail with `G_IO_ERROR_CANCELLED`. If `message` is not well-formed,
    /// the operation fails with `G_IO_ERROR_INVALID_ARGUMENT`.
    /// 
    /// This is an asynchronous method. When the operation is finished, `callback`
    /// will be invoked in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// of the thread you are calling this method from. You can then call
    /// `g_dbus_connection_send_message_with_reply_finish()` to get the result of the operation.
    /// See `g_dbus_connection_send_message_with_reply_sync()` for the synchronous version.
    /// 
    /// Note that `message` must be unlocked, unless `flags` contain the
    /// `G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL` flag.
    /// 
    /// See this [server](#gdbus-server) and [client](#gdbus-unix-fd-client)
    /// for an example of how to use this low-level API to send and receive
    /// UNIX file descriptors.
    @inlinable func sendMessageWithReply<DBusMessageT: DBusMessageProtocol>(message: DBusMessageT, flags: DBusSendMessageFlags, timeoutMsec: Int, outSerial: UnsafeMutablePointer<guint32>! = nil, cancellable: CancellableRef? = nil, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
            
        g_dbus_connection_send_message_with_reply(dbus_connection_ptr, message.dbus_message_ptr, flags.value, gint(timeoutMsec), outSerial, cancellable?.cancellable_ptr, callback, userData)
            
    }
    /// Asynchronously sends `message` to the peer represented by `connection`.
    /// 
    /// Unless `flags` contain the
    /// `G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL` flag, the serial number
    /// will be assigned by `connection` and set on `message` via
    /// `g_dbus_message_set_serial()`. If `out_serial` is not `nil`, then the
    /// serial number used will be written to this location prior to
    /// submitting the message to the underlying transport. While it has a `volatile`
    /// qualifier, this is a historical artifact and the argument passed to it should
    /// not be `volatile`.
    /// 
    /// If `connection` is closed then the operation will fail with
    /// `G_IO_ERROR_CLOSED`. If `cancellable` is canceled, the operation will
    /// fail with `G_IO_ERROR_CANCELLED`. If `message` is not well-formed,
    /// the operation fails with `G_IO_ERROR_INVALID_ARGUMENT`.
    /// 
    /// This is an asynchronous method. When the operation is finished, `callback`
    /// will be invoked in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// of the thread you are calling this method from. You can then call
    /// `g_dbus_connection_send_message_with_reply_finish()` to get the result of the operation.
    /// See `g_dbus_connection_send_message_with_reply_sync()` for the synchronous version.
    /// 
    /// Note that `message` must be unlocked, unless `flags` contain the
    /// `G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL` flag.
    /// 
    /// See this [server](#gdbus-server) and [client](#gdbus-unix-fd-client)
    /// for an example of how to use this low-level API to send and receive
    /// UNIX file descriptors.
    @inlinable func sendMessageWithReply<CancellableT: CancellableProtocol, DBusMessageT: DBusMessageProtocol>(message: DBusMessageT, flags: DBusSendMessageFlags, timeoutMsec: Int, outSerial: UnsafeMutablePointer<guint32>! = nil, cancellable: CancellableT?, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
        
        g_dbus_connection_send_message_with_reply(dbus_connection_ptr, message.dbus_message_ptr, flags.value, gint(timeoutMsec), outSerial, cancellable?.cancellable_ptr, callback, userData)
        
    }

    /// Finishes an operation started with `g_dbus_connection_send_message_with_reply()`.
    /// 
    /// Note that `error` is only set if a local in-process error
    /// occurred. That is to say that the returned `GDBusMessage` object may
    /// be of type `G_DBUS_MESSAGE_TYPE_ERROR`. Use
    /// `g_dbus_message_to_gerror()` to transcode this to a `GError`.
    /// 
    /// See this [server](#gdbus-server) and [client](#gdbus-unix-fd-client)
    /// for an example of how to use this low-level API to send and receive
    /// UNIX file descriptors.
    @inlinable func sendMessageWithReplyFinish<AsyncResultT: AsyncResultProtocol>(res: AsyncResultT) throws -> GIO.DBusMessageRef! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_send_message_with_reply_finish(dbus_connection_ptr, res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = DBusMessageRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Synchronously sends `message` to the peer represented by `connection`
    /// and blocks the calling thread until a reply is received or the
    /// timeout is reached. See `g_dbus_connection_send_message_with_reply()`
    /// for the asynchronous version of this method.
    /// 
    /// Unless `flags` contain the
    /// `G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL` flag, the serial number
    /// will be assigned by `connection` and set on `message` via
    /// `g_dbus_message_set_serial()`. If `out_serial` is not `nil`, then the
    /// serial number used will be written to this location prior to
    /// submitting the message to the underlying transport. While it has a `volatile`
    /// qualifier, this is a historical artifact and the argument passed to it should
    /// not be `volatile`.
    /// 
    /// If `connection` is closed then the operation will fail with
    /// `G_IO_ERROR_CLOSED`. If `cancellable` is canceled, the operation will
    /// fail with `G_IO_ERROR_CANCELLED`. If `message` is not well-formed,
    /// the operation fails with `G_IO_ERROR_INVALID_ARGUMENT`.
    /// 
    /// Note that `error` is only set if a local in-process error
    /// occurred. That is to say that the returned `GDBusMessage` object may
    /// be of type `G_DBUS_MESSAGE_TYPE_ERROR`. Use
    /// `g_dbus_message_to_gerror()` to transcode this to a `GError`.
    /// 
    /// See this [server](#gdbus-server) and [client](#gdbus-unix-fd-client)
    /// for an example of how to use this low-level API to send and receive
    /// UNIX file descriptors.
    /// 
    /// Note that `message` must be unlocked, unless `flags` contain the
    /// `G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL` flag.
    @inlinable func sendMessageWithReplySync<DBusMessageT: DBusMessageProtocol>(message: DBusMessageT, flags: DBusSendMessageFlags, timeoutMsec: Int, outSerial: UnsafeMutablePointer<guint32>! = nil, cancellable: CancellableRef? = nil) throws -> GIO.DBusMessageRef! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_send_message_with_reply_sync(dbus_connection_ptr, message.dbus_message_ptr, flags.value, gint(timeoutMsec), outSerial, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = DBusMessageRef(gconstpointer: gconstpointer(result))
            return rv
    }
    /// Synchronously sends `message` to the peer represented by `connection`
    /// and blocks the calling thread until a reply is received or the
    /// timeout is reached. See `g_dbus_connection_send_message_with_reply()`
    /// for the asynchronous version of this method.
    /// 
    /// Unless `flags` contain the
    /// `G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL` flag, the serial number
    /// will be assigned by `connection` and set on `message` via
    /// `g_dbus_message_set_serial()`. If `out_serial` is not `nil`, then the
    /// serial number used will be written to this location prior to
    /// submitting the message to the underlying transport. While it has a `volatile`
    /// qualifier, this is a historical artifact and the argument passed to it should
    /// not be `volatile`.
    /// 
    /// If `connection` is closed then the operation will fail with
    /// `G_IO_ERROR_CLOSED`. If `cancellable` is canceled, the operation will
    /// fail with `G_IO_ERROR_CANCELLED`. If `message` is not well-formed,
    /// the operation fails with `G_IO_ERROR_INVALID_ARGUMENT`.
    /// 
    /// Note that `error` is only set if a local in-process error
    /// occurred. That is to say that the returned `GDBusMessage` object may
    /// be of type `G_DBUS_MESSAGE_TYPE_ERROR`. Use
    /// `g_dbus_message_to_gerror()` to transcode this to a `GError`.
    /// 
    /// See this [server](#gdbus-server) and [client](#gdbus-unix-fd-client)
    /// for an example of how to use this low-level API to send and receive
    /// UNIX file descriptors.
    /// 
    /// Note that `message` must be unlocked, unless `flags` contain the
    /// `G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL` flag.
    @inlinable func sendMessageWithReplySync<CancellableT: CancellableProtocol, DBusMessageT: DBusMessageProtocol>(message: DBusMessageT, flags: DBusSendMessageFlags, timeoutMsec: Int, outSerial: UnsafeMutablePointer<guint32>! = nil, cancellable: CancellableT?) throws -> GIO.DBusMessageRef! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_connection_send_message_with_reply_sync(dbus_connection_ptr, message.dbus_message_ptr, flags.value, gint(timeoutMsec), outSerial, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = DBusMessageRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Sets whether the process should be terminated when `connection` is
    /// closed by the remote peer. See `GDBusConnection:exit-on-close` for
    /// more details.
    /// 
    /// Note that this function should be used with care. Most modern UNIX
    /// desktops tie the notion of a user session with the session bus, and expect
    /// all of a user's applications to quit when their bus connection goes away.
    /// If you are setting `exit_on_close` to `false` for the shared session
    /// bus connection, you should make sure that your application exits
    /// when the user session ends.
    @inlinable func set(exitOnClose: Bool) {
        
        g_dbus_connection_set_exit_on_close(dbus_connection_ptr, gboolean((exitOnClose) ? 1 : 0))
        
    }

    /// Subscribes to signals on `connection` and invokes `callback` with a whenever
    /// the signal is received. Note that `callback` will be invoked in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// of the thread you are calling this method from.
    /// 
    /// If `connection` is not a message bus connection, `sender` must be
    /// `nil`.
    /// 
    /// If `sender` is a well-known name note that `callback` is invoked with
    /// the unique name for the owner of `sender`, not the well-known name
    /// as one would expect. This is because the message bus rewrites the
    /// name. As such, to avoid certain race conditions, users should be
    /// tracking the name owner of the well-known name and use that when
    /// processing the received signal.
    /// 
    /// If one of `G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE` or
    /// `G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH` are given, `arg0` is
    /// interpreted as part of a namespace or path.  The first argument
    /// of a signal is matched against that part as specified by D-Bus.
    /// 
    /// If `user_data_free_func` is non-`nil`, it will be called (in the
    /// thread-default main context of the thread you are calling this
    /// method from) at some point after `user_data` is no longer
    /// needed. (It is not guaranteed to be called synchronously when the
    /// signal is unsubscribed from, and may be called after `connection`
    /// has been destroyed.)
    /// 
    /// As `callback` is potentially invoked in a different thread from where its
    /// emitted, its possible for this to happen after
    /// `g_dbus_connection_signal_unsubscribe()` has been called in another thread.
    /// Due to this, `user_data` should have a strong reference which is freed with
    /// `user_data_free_func`, rather than pointing to data whose lifecycle is tied
    /// to the signal subscription. For example, if a `GObject` is used to store the
    /// subscription ID from `g_dbus_connection_signal_subscribe()`, a strong reference
    /// to that `GObject` must be passed to `user_data`, and `g_object_unref()` passed to
    /// `user_data_free_func`. You are responsible for breaking the resulting
    /// reference count cycle by explicitly unsubscribing from the signal when
    /// dropping the last external reference to the `GObject`. Alternatively, a weak
    /// reference may be used.
    /// 
    /// It is guaranteed that if you unsubscribe from a signal using
    /// `g_dbus_connection_signal_unsubscribe()` from the same thread which made the
    /// corresponding `g_dbus_connection_signal_subscribe()` call, `callback` will not
    /// be invoked after `g_dbus_connection_signal_unsubscribe()` returns.
    /// 
    /// The returned subscription identifier is an opaque value which is guaranteed
    /// to never be zero.
    /// 
    /// This function can never fail.
    @inlinable func signalSubscribe(sender: UnsafePointer<gchar>? = nil, interfaceName: UnsafePointer<gchar>? = nil, member: UnsafePointer<gchar>? = nil, objectPath: UnsafePointer<gchar>? = nil, arg0: UnsafePointer<gchar>? = nil, flags: DBusSignalFlags, callback: GDBusSignalCallback?, userData: gpointer? = nil, userDataFreeFunc: GDestroyNotify? = nil) -> Int {
        let result = g_dbus_connection_signal_subscribe(dbus_connection_ptr, sender, interfaceName, member, objectPath, arg0, flags.value, callback, userData, userDataFreeFunc)
        let rv = Int(result)
        return rv
    }

    /// Unsubscribes from signals.
    /// 
    /// Note that there may still be D-Bus traffic to process (relating to this
    /// signal subscription) in the current thread-default `GMainContext` after this
    /// function has returned. You should continue to iterate the `GMainContext`
    /// until the `GDestroyNotify` function passed to
    /// `g_dbus_connection_signal_subscribe()` is called, in order to avoid memory
    /// leaks through callbacks queued on the `GMainContext` after its stopped being
    /// iterated.
    /// Alternatively, any idle source with a priority lower than `G_PRIORITY_DEFAULT`
    /// that was scheduled after unsubscription, also indicates that all resources
    /// of this subscription are released.
    @inlinable func signalUnsubscribe(subscriptionID: Int) {
        
        g_dbus_connection_signal_unsubscribe(dbus_connection_ptr, guint(subscriptionID))
        
    }

    /// If `connection` was created with
    /// `G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING`, this method
    /// starts processing messages. Does nothing on if `connection` wasn't
    /// created with this flag or if the method has already been called.
    @inlinable func startMessageProcessing() {
        
        g_dbus_connection_start_message_processing(dbus_connection_ptr)
        
    }

    /// Reverses the effect of a previous call to
    /// `g_dbus_connection_export_action_group()`.
    /// 
    /// It is an error to call this function with an ID that wasn't returned
    /// from `g_dbus_connection_export_action_group()` or to call it with the
    /// same ID more than once.
    @inlinable func unexportActionGroup(exportID: Int) {
        
        g_dbus_connection_unexport_action_group(dbus_connection_ptr, guint(exportID))
        
    }

    /// Reverses the effect of a previous call to
    /// `g_dbus_connection_export_menu_model()`.
    /// 
    /// It is an error to call this function with an ID that wasn't returned
    /// from `g_dbus_connection_export_menu_model()` or to call it with the
    /// same ID more than once.
    @inlinable func unexportMenuModel(exportID: Int) {
        
        g_dbus_connection_unexport_menu_model(dbus_connection_ptr, guint(exportID))
        
    }

    /// Unregisters an object.
    @inlinable func unregisterObject(registrationID: Int) -> Bool {
        let result = g_dbus_connection_unregister_object(dbus_connection_ptr, guint(registrationID))
        let rv = ((result) != 0)
        return rv
    }

    /// Unregisters a subtree.
    @inlinable func unregisterSubtree(registrationID: Int) -> Bool {
        let result = g_dbus_connection_unregister_subtree(dbus_connection_ptr, guint(registrationID))
        let rv = ((result) != 0)
        return rv
    }

    /// Like `g_bus_own_name()` but takes a `GDBusConnection` instead of a
    /// `GBusType`.
    @inlinable func busOwnNameOnConnection(name: UnsafePointer<gchar>!, flags: BusNameOwnerFlags, nameAcquiredHandler: GBusNameAcquiredCallback? = nil, nameLostHandler: GBusNameLostCallback? = nil, userData: gpointer? = nil, userDataFreeFunc: GDestroyNotify? = nil) -> Int {
        let result = g_bus_own_name_on_connection(dbus_connection_ptr, name, flags.value, nameAcquiredHandler, nameLostHandler, userData, userDataFreeFunc)
        let rv = Int(result)
        return rv
    }

    /// Version of `g_bus_own_name_on_connection()` using closures instead of
    /// callbacks for easier binding in other languages.
    @inlinable func busOwnNameOnConnectionWithClosures(name: UnsafePointer<gchar>!, flags: BusNameOwnerFlags, nameAcquiredClosure: GLibObject.ClosureRef? = nil, nameLostClosure: GLibObject.ClosureRef? = nil) -> Int {
            let result = g_bus_own_name_on_connection_with_closures(dbus_connection_ptr, name, flags.value, nameAcquiredClosure?.closure_ptr, nameLostClosure?.closure_ptr)
        let rv = Int(result)
            return rv
    }
    /// Version of `g_bus_own_name_on_connection()` using closures instead of
    /// callbacks for easier binding in other languages.
    @inlinable func busOwnNameOnConnectionWithClosures<GObjectClosureT: GLibObject.ClosureProtocol>(name: UnsafePointer<gchar>!, flags: BusNameOwnerFlags, nameAcquiredClosure: GObjectClosureT?, nameLostClosure: GObjectClosureT?) -> Int {
        let result = g_bus_own_name_on_connection_with_closures(dbus_connection_ptr, name, flags.value, nameAcquiredClosure?.closure_ptr, nameLostClosure?.closure_ptr)
        let rv = Int(result)
        return rv
    }

    /// Like `g_bus_watch_name()` but takes a `GDBusConnection` instead of a
    /// `GBusType`.
    @inlinable func busWatchNameOnConnection(name: UnsafePointer<gchar>!, flags: BusNameWatcherFlags, nameAppearedHandler: GBusNameAppearedCallback? = nil, nameVanishedHandler: GBusNameVanishedCallback? = nil, userData: gpointer? = nil, userDataFreeFunc: GDestroyNotify? = nil) -> Int {
        let result = g_bus_watch_name_on_connection(dbus_connection_ptr, name, flags.value, nameAppearedHandler, nameVanishedHandler, userData, userDataFreeFunc)
        let rv = Int(result)
        return rv
    }

    /// Version of `g_bus_watch_name_on_connection()` using closures instead of callbacks for
    /// easier binding in other languages.
    @inlinable func busWatchNameOnConnectionWithClosures(name: UnsafePointer<gchar>!, flags: BusNameWatcherFlags, nameAppearedClosure: GLibObject.ClosureRef? = nil, nameVanishedClosure: GLibObject.ClosureRef? = nil) -> Int {
            let result = g_bus_watch_name_on_connection_with_closures(dbus_connection_ptr, name, flags.value, nameAppearedClosure?.closure_ptr, nameVanishedClosure?.closure_ptr)
        let rv = Int(result)
            return rv
    }
    /// Version of `g_bus_watch_name_on_connection()` using closures instead of callbacks for
    /// easier binding in other languages.
    @inlinable func busWatchNameOnConnectionWithClosures<GObjectClosureT: GLibObject.ClosureProtocol>(name: UnsafePointer<gchar>!, flags: BusNameWatcherFlags, nameAppearedClosure: GObjectClosureT?, nameVanishedClosure: GObjectClosureT?) -> Int {
        let result = g_bus_watch_name_on_connection_with_closures(dbus_connection_ptr, name, flags.value, nameAppearedClosure?.closure_ptr, nameVanishedClosure?.closure_ptr)
        let rv = Int(result)
        return rv
    }
    /// Flags from the `GDBusCapabilityFlags` enumeration
    /// representing connection features negotiated with the other peer.
    @inlinable var capabilities: GIO.DBusCapabilityFlags {
        /// Gets the capabilities negotiated with the remote peer
        get {
            let result = g_dbus_connection_get_capabilities(dbus_connection_ptr)
        let rv = DBusCapabilityFlags(result)
            return rv
        }
    }

    /// Gets whether the process is terminated when `connection` is
    /// closed by the remote peer. See
    /// `GDBusConnection:exit-on-close` for more details.
    @inlinable var exitOnClose: Bool {
        /// Gets whether the process is terminated when `connection` is
        /// closed by the remote peer. See
        /// `GDBusConnection:exit-on-close` for more details.
        get {
            let result = g_dbus_connection_get_exit_on_close(dbus_connection_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether the process should be terminated when `connection` is
        /// closed by the remote peer. See `GDBusConnection:exit-on-close` for
        /// more details.
        /// 
        /// Note that this function should be used with care. Most modern UNIX
        /// desktops tie the notion of a user session with the session bus, and expect
        /// all of a user's applications to quit when their bus connection goes away.
        /// If you are setting `exit_on_close` to `false` for the shared session
        /// bus connection, you should make sure that your application exits
        /// when the user session ends.
        nonmutating set {
            g_dbus_connection_set_exit_on_close(dbus_connection_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Flags from the `GDBusConnectionFlags` enumeration.
    @inlinable var flags: GIO.DBusConnectionFlags {
        /// Gets the flags used to construct this connection
        get {
            let result = g_dbus_connection_get_flags(dbus_connection_ptr)
        let rv = DBusConnectionFlags(result)
            return rv
        }
    }

    /// The GUID of the peer performing the role of server when
    /// authenticating.
    /// 
    /// If you are constructing a `GDBusConnection` and pass
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER` in the
    /// `GDBusConnection:flags` property then you **must** also set this
    /// property to a valid guid.
    /// 
    /// If you are constructing a `GDBusConnection` and pass
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT` in the
    /// `GDBusConnection:flags` property you will be able to read the GUID
    /// of the other peer here after the connection has been successfully
    /// initialized.
    /// 
    /// Note that the
    /// [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html`addresses`)
    /// uses the term UUID to refer to this, whereas GLib consistently uses the
    /// term GUID for historical reasons.
    /// 
    /// Despite its name, the format of `GDBusConnection:guid` does not follow
    /// [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122) or the Microsoft
    /// GUID format.
    @inlinable var guid: String! {
        /// The GUID of the peer performing the role of server when
        /// authenticating. See `GDBusConnection:guid` for more details.
        get {
            let result = g_dbus_connection_get_guid(dbus_connection_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// Gets whether `connection` is closed.
    @inlinable var isClosed: Bool {
        /// Gets whether `connection` is closed.
        get {
            let result = g_dbus_connection_is_closed(dbus_connection_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// Retrieves the last serial number assigned to a `GDBusMessage` on
    /// the current thread. This includes messages sent via both low-level
    /// API such as `g_dbus_connection_send_message()` as well as
    /// high-level API such as `g_dbus_connection_emit_signal()`,
    /// `g_dbus_connection_call()` or `g_dbus_proxy_call()`.
    @inlinable var lastSerial: guint32 {
        /// Retrieves the last serial number assigned to a `GDBusMessage` on
        /// the current thread. This includes messages sent via both low-level
        /// API such as `g_dbus_connection_send_message()` as well as
        /// high-level API such as `g_dbus_connection_emit_signal()`,
        /// `g_dbus_connection_call()` or `g_dbus_proxy_call()`.
        get {
            let result = g_dbus_connection_get_last_serial(dbus_connection_ptr)
        let rv = result
            return rv
        }
    }

    /// Gets the credentials of the authenticated peer. This will always
    /// return `nil` unless `connection` acted as a server
    /// (e.g. `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER` was passed)
    /// when set up and the client passed credentials as part of the
    /// authentication process.
    /// 
    /// In a message bus setup, the message bus is always the server and
    /// each application is a client. So this method will always return
    /// `nil` for message bus clients.
    @inlinable var peerCredentials: GIO.CredentialsRef! {
        /// Gets the credentials of the authenticated peer. This will always
        /// return `nil` unless `connection` acted as a server
        /// (e.g. `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER` was passed)
        /// when set up and the client passed credentials as part of the
        /// authentication process.
        /// 
        /// In a message bus setup, the message bus is always the server and
        /// each application is a client. So this method will always return
        /// `nil` for message bus clients.
        get {
            let result = g_dbus_connection_get_peer_credentials(dbus_connection_ptr)
        let rv = CredentialsRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// The underlying `GIOStream` used for I/O.
    /// 
    /// If this is passed on construction and is a `GSocketConnection`,
    /// then the corresponding `GSocket` will be put into non-blocking mode.
    /// 
    /// While the `GDBusConnection` is active, it will interact with this
    /// stream from a worker thread, so it is not safe to interact with
    /// the stream directly.
    @inlinable var stream: GIO.IOStreamRef! {
        /// Gets the underlying stream used for IO.
        /// 
        /// While the `GDBusConnection` is active, it will interact with this
        /// stream from a worker thread, so it is not safe to interact with
        /// the stream directly.
        get {
            let result = g_dbus_connection_get_stream(dbus_connection_ptr)
        let rv = IOStreamRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Gets the unique name of `connection` as assigned by the message
    /// bus. This can also be used to figure out if `connection` is a
    /// message bus connection.
    @inlinable var uniqueName: String! {
        /// Gets the unique name of `connection` as assigned by the message
        /// bus. This can also be used to figure out if `connection` is a
        /// message bus connection.
        get {
            let result = g_dbus_connection_get_unique_name(dbus_connection_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }


}



// MARK: - DBusInterfaceSkeleton Class

/// Abstract base class for D-Bus interfaces on the service side.
///
/// The `DBusInterfaceSkeletonProtocol` protocol exposes the methods and properties of an underlying `GDBusInterfaceSkeleton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusInterfaceSkeleton`.
/// Alternatively, use `DBusInterfaceSkeletonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusInterfaceSkeletonProtocol: GLibObject.ObjectProtocol, DBusInterfaceProtocol {
        /// Untyped pointer to the underlying `GDBusInterfaceSkeleton` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusInterfaceSkeleton` instance.
    var dbus_interface_skeleton_ptr: UnsafeMutablePointer<GDBusInterfaceSkeleton>! { get }

    /// Required Initialiser for types conforming to `DBusInterfaceSkeletonProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Abstract base class for D-Bus interfaces on the service side.
///
/// The `DBusInterfaceSkeletonRef` type acts as a lightweight Swift reference to an underlying `GDBusInterfaceSkeleton` instance.
/// It exposes methods that can operate on this data type through `DBusInterfaceSkeletonProtocol` conformance.
/// Use `DBusInterfaceSkeletonRef` only as an `unowned` reference to an existing `GDBusInterfaceSkeleton` instance.
///
public struct DBusInterfaceSkeletonRef: DBusInterfaceSkeletonProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GDBusInterfaceSkeleton` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_interface_skeleton_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusInterfaceSkeletonRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusInterfaceSkeleton>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusInterfaceSkeleton>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusInterfaceSkeleton>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusInterfaceSkeleton>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusInterfaceSkeletonProtocol`
    @inlinable init<T: DBusInterfaceSkeletonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: DBusInterfaceSkeletonProtocol>(_ other: T) -> DBusInterfaceSkeletonRef { DBusInterfaceSkeletonRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceSkeletonProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceSkeletonProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceSkeletonProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceSkeletonProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceSkeletonProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// Abstract base class for D-Bus interfaces on the service side.
///
/// The `DBusInterfaceSkeleton` type acts as a reference-counted owner of an underlying `GDBusInterfaceSkeleton` instance.
/// It provides the methods that can operate on this data type through `DBusInterfaceSkeletonProtocol` conformance.
/// Use `DBusInterfaceSkeleton` as a strong reference or owner of a `GDBusInterfaceSkeleton` instance.
///
open class DBusInterfaceSkeleton: GLibObject.Object, DBusInterfaceSkeletonProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterfaceSkeleton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusInterfaceSkeleton>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterfaceSkeleton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusInterfaceSkeleton>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterfaceSkeleton` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterfaceSkeleton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterfaceSkeleton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusInterfaceSkeleton>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusInterfaceSkeleton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusInterfaceSkeleton>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDBusInterfaceSkeleton`.
    /// i.e., ownership is transferred to the `DBusInterfaceSkeleton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusInterfaceSkeleton>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DBusInterfaceSkeletonProtocol`
    /// Will retain `GDBusInterfaceSkeleton`.
    /// - Parameter other: an instance of a related type that implements `DBusInterfaceSkeletonProtocol`
    @inlinable public init<T: DBusInterfaceSkeletonProtocol>(dBusInterfaceSkeleton other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceSkeletonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceSkeletonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceSkeletonProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceSkeletonProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceSkeletonProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceSkeletonProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceSkeletonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusInterfaceSkeletonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum DBusInterfaceSkeletonPropertyName: String, PropertyNameProtocol {
    /// Flags from the `GDBusInterfaceSkeletonFlags` enumeration.
    case gFlags = "g-flags"
}

public extension DBusInterfaceSkeletonProtocol {
    /// Bind a `DBusInterfaceSkeletonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: DBusInterfaceSkeletonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a DBusInterfaceSkeleton property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: DBusInterfaceSkeletonPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a DBusInterfaceSkeleton property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: DBusInterfaceSkeletonPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum DBusInterfaceSkeletonSignalName: String, SignalNameProtocol {
    /// Emitted when a method is invoked by a remote caller and used to
    /// determine if the method call is authorized.
    /// 
    /// Note that this signal is emitted in a thread dedicated to
    /// handling the method call so handlers are allowed to perform
    /// blocking IO. This means that it is appropriate to call e.g.
    /// [`polkit_authority_check_authorization_sync()`](http://hal.freedesktop.org/docs/polkit/PolkitAuthority.html`polkit-authority-check-authorization-sync`)
    /// with the
    /// [POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION](http://hal.freedesktop.org/docs/polkit/PolkitAuthority.html`POLKIT-CHECK-AUTHORIZATION-FLAGS-ALLOW-USER-INTERACTION:CAPS`)
    /// flag set.
    /// 
    /// If `false` is returned then no further handlers are run and the
    /// signal handler must take a reference to `invocation` and finish
    /// handling the call (e.g. return an error via
    /// `g_dbus_method_invocation_return_error()`).
    /// 
    /// Otherwise, if `true` is returned, signal emission continues. If no
    /// handlers return `false`, then the method is dispatched. If
    /// `interface` has an enclosing `GDBusObjectSkeleton`, then the
    /// `GDBusObjectSkeleton::authorize-method` signal handlers run before
    /// the handlers for this signal.
    /// 
    /// The default class handler just returns `true`.
    /// 
    /// Please note that the common case is optimized: if no signals
    /// handlers are connected and the default class handler isn't
    /// overridden (for both `interface` and the enclosing
    /// `GDBusObjectSkeleton`, if any) and `GDBusInterfaceSkeleton:g-flags` does
    /// not have the
    /// `G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD`
    /// flags set, no dedicated thread is ever used and the call will be
    /// handled in the same thread as the object that `interface` belongs
    /// to was exported in.
    case gAuthorizeMethod = "g-authorize-method"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Flags from the `GDBusInterfaceSkeletonFlags` enumeration.
    case notifyGFlags = "notify::g-flags"
}

// MARK: DBusInterfaceSkeleton signals
public extension DBusInterfaceSkeletonProtocol {
    /// Connect a Swift signal handler to the given, typed `DBusInterfaceSkeletonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DBusInterfaceSkeletonSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `DBusInterfaceSkeletonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DBusInterfaceSkeletonSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when a method is invoked by a remote caller and used to
    /// determine if the method call is authorized.
    /// 
    /// Note that this signal is emitted in a thread dedicated to
    /// handling the method call so handlers are allowed to perform
    /// blocking IO. This means that it is appropriate to call e.g.
    /// [`polkit_authority_check_authorization_sync()`](http://hal.freedesktop.org/docs/polkit/PolkitAuthority.html`polkit-authority-check-authorization-sync`)
    /// with the
    /// [POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION](http://hal.freedesktop.org/docs/polkit/PolkitAuthority.html`POLKIT-CHECK-AUTHORIZATION-FLAGS-ALLOW-USER-INTERACTION:CAPS`)
    /// flag set.
    /// 
    /// If `false` is returned then no further handlers are run and the
    /// signal handler must take a reference to `invocation` and finish
    /// handling the call (e.g. return an error via
    /// `g_dbus_method_invocation_return_error()`).
    /// 
    /// Otherwise, if `true` is returned, signal emission continues. If no
    /// handlers return `false`, then the method is dispatched. If
    /// `interface` has an enclosing `GDBusObjectSkeleton`, then the
    /// `GDBusObjectSkeleton::authorize-method` signal handlers run before
    /// the handlers for this signal.
    /// 
    /// The default class handler just returns `true`.
    /// 
    /// Please note that the common case is optimized: if no signals
    /// handlers are connected and the default class handler isn't
    /// overridden (for both `interface` and the enclosing
    /// `GDBusObjectSkeleton`, if any) and `GDBusInterfaceSkeleton:g-flags` does
    /// not have the
    /// `G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD`
    /// flags set, no dedicated thread is ever used and the call will be
    /// handled in the same thread as the object that `interface` belongs
    /// to was exported in.
    /// - Note: This represents the underlying `g-authorize-method` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter invocation: A `GDBusMethodInvocation`.
    /// - Parameter handler: `true` if the call is authorized, `false` otherwise.
    /// Run the given callback whenever the `gAuthorizeMethod` signal is emitted
    @discardableResult @inlinable func onGAuthorizeMethod(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusInterfaceSkeletonRef, _ invocation: DBusMethodInvocationRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusInterfaceSkeletonRef, DBusMethodInvocationRef), Bool>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> gboolean = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call((DBusInterfaceSkeletonRef(raw: unownedSelf), DBusMethodInvocationRef(raw: arg1)))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .gAuthorizeMethod,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `g-authorize-method` signal for using the `connect(signal:)` methods
    static var gAuthorizeMethodSignal: DBusInterfaceSkeletonSignalName { .gAuthorizeMethod }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::g-flags` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyGFlags` signal is emitted
    @discardableResult @inlinable func onNotifyGFlags(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusInterfaceSkeletonRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusInterfaceSkeletonRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusInterfaceSkeletonRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyGFlags,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::g-flags` signal for using the `connect(signal:)` methods
    static var notifyGFlagsSignal: DBusInterfaceSkeletonSignalName { .notifyGFlags }
    
}

// MARK: DBusInterfaceSkeleton Class: DBusInterfaceSkeletonProtocol extension (methods and fields)
public extension DBusInterfaceSkeletonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusInterfaceSkeleton` instance.
    @inlinable var dbus_interface_skeleton_ptr: UnsafeMutablePointer<GDBusInterfaceSkeleton>! { return ptr?.assumingMemoryBound(to: GDBusInterfaceSkeleton.self) }

    /// Exports `interface_` at `object_path` on `connection`.
    /// 
    /// This can be called multiple times to export the same `interface_`
    /// onto multiple connections however the `object_path` provided must be
    /// the same for all connections.
    /// 
    /// Use `g_dbus_interface_skeleton_unexport()` to unexport the object.
    @inlinable func export<DBusConnectionT: DBusConnectionProtocol>(connection: DBusConnectionT, objectPath: UnsafePointer<gchar>!) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_interface_skeleton_export(dbus_interface_skeleton_ptr, connection.dbus_connection_ptr, objectPath, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// If `interface_` has outstanding changes, request for these changes to be
    /// emitted immediately.
    /// 
    /// For example, an exported D-Bus interface may queue up property
    /// changes and emit the
    /// `org.freedesktop.DBus.Properties.PropertiesChanged`
    /// signal later (e.g. in an idle handler). This technique is useful
    /// for collapsing multiple property changes into one.
    @inlinable func flush() {
        
        g_dbus_interface_skeleton_flush(dbus_interface_skeleton_ptr)
        
    }

    /// Gets the first connection that `interface_` is exported on, if any.
    @inlinable func getConnection() -> GIO.DBusConnectionRef! {
        let result = g_dbus_interface_skeleton_get_connection(dbus_interface_skeleton_ptr)
        let rv = DBusConnectionRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets a list of the connections that `interface_` is exported on.
    @inlinable func getConnections() -> GLib.ListRef! {
        let result = g_dbus_interface_skeleton_get_connections(dbus_interface_skeleton_ptr)
        let rv = GLib.ListRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the `GDBusInterfaceSkeletonFlags` that describes what the behavior
    /// of `interface_`
    @inlinable func getFlags() -> GIO.DBusInterfaceSkeletonFlags {
        let result = g_dbus_interface_skeleton_get_flags(dbus_interface_skeleton_ptr)
        let rv = DBusInterfaceSkeletonFlags(result)
        return rv
    }

    /// Gets D-Bus introspection information for the D-Bus interface
    /// implemented by `interface_`.
    @inlinable func getInfo() -> GIO.DBusInterfaceInfoRef! {
        let result = g_dbus_interface_skeleton_get_info(dbus_interface_skeleton_ptr)
        let rv = DBusInterfaceInfoRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the object path that `interface_` is exported on, if any.
    @inlinable func getObjectPath() -> String! {
        let result = g_dbus_interface_skeleton_get_object_path(dbus_interface_skeleton_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets all D-Bus properties for `interface_`.
    @inlinable func getProperties() -> GLib.VariantRef! {
        let result = g_dbus_interface_skeleton_get_properties(dbus_interface_skeleton_ptr)
        let rv = GLib.VariantRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the interface vtable for the D-Bus interface implemented by
    /// `interface_`. The returned function pointers should expect `interface_`
    /// itself to be passed as `user_data`.
    @inlinable func getVtable() -> GIO.DBusInterfaceVTableRef! {
        let result = g_dbus_interface_skeleton_get_vtable(dbus_interface_skeleton_ptr)
        let rv = DBusInterfaceVTableRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Checks if `interface_` is exported on `connection`.
    @inlinable func has<DBusConnectionT: DBusConnectionProtocol>(connection: DBusConnectionT) -> Bool {
        let result = g_dbus_interface_skeleton_has_connection(dbus_interface_skeleton_ptr, connection.dbus_connection_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Sets flags describing what the behavior of `skeleton` should be.
    @inlinable func set(flags: DBusInterfaceSkeletonFlags) {
        
        g_dbus_interface_skeleton_set_flags(dbus_interface_skeleton_ptr, flags.value)
        
    }

    /// Stops exporting `interface_` on all connections it is exported on.
    /// 
    /// To unexport `interface_` from only a single connection, use
    /// `g_dbus_interface_skeleton_unexport_from_connection()`
    @inlinable func unexport() {
        
        g_dbus_interface_skeleton_unexport(dbus_interface_skeleton_ptr)
        
    }

    /// Stops exporting `interface_` on `connection`.
    /// 
    /// To stop exporting on all connections the interface is exported on,
    /// use `g_dbus_interface_skeleton_unexport()`.
    @inlinable func unexportFrom<DBusConnectionT: DBusConnectionProtocol>(connection: DBusConnectionT) {
        
        g_dbus_interface_skeleton_unexport_from_connection(dbus_interface_skeleton_ptr, connection.dbus_connection_ptr)
        
    }
    /// Gets the first connection that `interface_` is exported on, if any.
    @inlinable var connection: GIO.DBusConnectionRef! {
        /// Gets the first connection that `interface_` is exported on, if any.
        get {
            let result = g_dbus_interface_skeleton_get_connection(dbus_interface_skeleton_ptr)
        let rv = DBusConnectionRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Gets a list of the connections that `interface_` is exported on.
    @inlinable var connections: GLib.ListRef! {
        /// Gets a list of the connections that `interface_` is exported on.
        get {
            let result = g_dbus_interface_skeleton_get_connections(dbus_interface_skeleton_ptr)
        let rv = GLib.ListRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Gets the `GDBusInterfaceSkeletonFlags` that describes what the behavior
    /// of `interface_`
    @inlinable var flags: GIO.DBusInterfaceSkeletonFlags {
        /// Gets the `GDBusInterfaceSkeletonFlags` that describes what the behavior
        /// of `interface_`
        get {
            let result = g_dbus_interface_skeleton_get_flags(dbus_interface_skeleton_ptr)
        let rv = DBusInterfaceSkeletonFlags(result)
            return rv
        }
        /// Sets flags describing what the behavior of `skeleton` should be.
        nonmutating set {
            g_dbus_interface_skeleton_set_flags(dbus_interface_skeleton_ptr, newValue.value)
        }
    }

    /// Gets D-Bus introspection information for the D-Bus interface
    /// implemented by `interface_`.
    @inlinable var info: GIO.DBusInterfaceInfoRef! {
        /// Gets D-Bus introspection information for the D-Bus interface
        /// implemented by `interface_`.
        get {
            let result = g_dbus_interface_skeleton_get_info(dbus_interface_skeleton_ptr)
        let rv = DBusInterfaceInfoRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Gets the object path that `interface_` is exported on, if any.
    @inlinable var objectPath: String! {
        /// Gets the object path that `interface_` is exported on, if any.
        get {
            let result = g_dbus_interface_skeleton_get_object_path(dbus_interface_skeleton_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// Gets all D-Bus properties for `interface_`.
    @inlinable var properties: GLib.VariantRef! {
        /// Gets all D-Bus properties for `interface_`.
        get {
            let result = g_dbus_interface_skeleton_get_properties(dbus_interface_skeleton_ptr)
        let rv = GLib.VariantRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Gets the interface vtable for the D-Bus interface implemented by
    /// `interface_`. The returned function pointers should expect `interface_`
    /// itself to be passed as `user_data`.
    @inlinable var vtable: GIO.DBusInterfaceVTableRef! {
        /// Gets the interface vtable for the D-Bus interface implemented by
        /// `interface_`. The returned function pointers should expect `interface_`
        /// itself to be passed as `user_data`.
        get {
            let result = g_dbus_interface_skeleton_get_vtable(dbus_interface_skeleton_ptr)
        let rv = DBusInterfaceVTableRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    // var parentInstance is unavailable because parent_instance is private

    // var priv is unavailable because priv is private

}



// MARK: - DBusMenuModel Class

/// `GDBusMenuModel` is an implementation of `GMenuModel` that can be used
/// as a proxy for a menu model that is exported over D-Bus with
/// `g_dbus_connection_export_menu_model()`.
///
/// The `DBusMenuModelProtocol` protocol exposes the methods and properties of an underlying `GDBusMenuModel` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusMenuModel`.
/// Alternatively, use `DBusMenuModelRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusMenuModelProtocol: MenuModelProtocol {
        /// Untyped pointer to the underlying `GDBusMenuModel` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusMenuModel` instance.
    var dbus_menu_model_ptr: UnsafeMutablePointer<GDBusMenuModel>! { get }

    /// Required Initialiser for types conforming to `DBusMenuModelProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GDBusMenuModel` is an implementation of `GMenuModel` that can be used
/// as a proxy for a menu model that is exported over D-Bus with
/// `g_dbus_connection_export_menu_model()`.
///
/// The `DBusMenuModelRef` type acts as a lightweight Swift reference to an underlying `GDBusMenuModel` instance.
/// It exposes methods that can operate on this data type through `DBusMenuModelProtocol` conformance.
/// Use `DBusMenuModelRef` only as an `unowned` reference to an existing `GDBusMenuModel` instance.
///
public struct DBusMenuModelRef: DBusMenuModelProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GDBusMenuModel` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_menu_model_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusMenuModelRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusMenuModel>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusMenuModel>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusMenuModel>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusMenuModel>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusMenuModelProtocol`
    @inlinable init<T: DBusMenuModelProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: DBusMenuModelProtocol>(_ other: T) -> DBusMenuModelRef { DBusMenuModelRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMenuModelProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMenuModelProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMenuModelProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMenuModelProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMenuModelProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Obtains a `GDBusMenuModel` for the menu model which is exported
    /// at the given `bus_name` and `object_path`.
    /// 
    /// The thread default main context is taken at the time of this call.
    /// All signals on the menu model (and any linked models) are reported
    /// with respect to this context.  All calls on the returned menu model
    /// (and linked models) must also originate from this same context, with
    /// the thread default main context unchanged.
    @inlinable static func dbusMenuModelGet<DBusConnectionT: DBusConnectionProtocol>(connection: DBusConnectionT, busName: UnsafePointer<gchar>? = nil, objectPath: UnsafePointer<gchar>!) -> GIO.DBusMenuModelRef! {
            let result = g_dbus_menu_model_get(connection.dbus_connection_ptr, busName, objectPath)
        guard let rv = DBusMenuModelRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }
}

/// `GDBusMenuModel` is an implementation of `GMenuModel` that can be used
/// as a proxy for a menu model that is exported over D-Bus with
/// `g_dbus_connection_export_menu_model()`.
///
/// The `DBusMenuModel` type acts as a reference-counted owner of an underlying `GDBusMenuModel` instance.
/// It provides the methods that can operate on this data type through `DBusMenuModelProtocol` conformance.
/// Use `DBusMenuModel` as a strong reference or owner of a `GDBusMenuModel` instance.
///
open class DBusMenuModel: MenuModel, DBusMenuModelProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMenuModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusMenuModel>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMenuModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusMenuModel>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMenuModel` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMenuModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMenuModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusMenuModel>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMenuModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusMenuModel>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDBusMenuModel`.
    /// i.e., ownership is transferred to the `DBusMenuModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusMenuModel>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DBusMenuModelProtocol`
    /// Will retain `GDBusMenuModel`.
    /// - Parameter other: an instance of a related type that implements `DBusMenuModelProtocol`
    @inlinable public init<T: DBusMenuModelProtocol>(dBusMenuModel other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMenuModelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMenuModelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMenuModelProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMenuModelProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMenuModelProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMenuModelProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMenuModelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMenuModelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }


    /// Obtains a `GDBusMenuModel` for the menu model which is exported
    /// at the given `bus_name` and `object_path`.
    /// 
    /// The thread default main context is taken at the time of this call.
    /// All signals on the menu model (and any linked models) are reported
    /// with respect to this context.  All calls on the returned menu model
    /// (and linked models) must also originate from this same context, with
    /// the thread default main context unchanged.
    @inlinable public static func dbusMenuModelGet<DBusConnectionT: DBusConnectionProtocol>(connection: DBusConnectionT, busName: UnsafePointer<gchar>? = nil, objectPath: UnsafePointer<gchar>!) -> GIO.DBusMenuModel! {
            let result = g_dbus_menu_model_get(connection.dbus_connection_ptr, busName, objectPath)
        guard let rv = DBusMenuModel(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

}

// MARK: no DBusMenuModel properties

public enum DBusMenuModelSignalName: String, SignalNameProtocol {
    /// Emitted when a change has occurred to the menu.
    /// 
    /// The only changes that can occur to a menu is that items are removed
    /// or added.  Items may not change (except by being removed and added
    /// back in the same location).  This signal is capable of describing
    /// both of those changes (at the same time).
    /// 
    /// The signal means that starting at the index `position`, `removed`
    /// items were removed and `added` items were added in their place.  If
    /// `removed` is zero then only items were added.  If `added` is zero
    /// then only items were removed.
    /// 
    /// As an example, if the menu contains items a, b, c, d (in that
    /// order) and the signal (2, 1, 3) occurs then the new composition of
    /// the menu will be a, b, _, _, _, d (with each _ representing some
    /// new item).
    /// 
    /// Signal handlers may query the model (particularly the added items)
    /// and expect to see the results of the modification that is being
    /// reported.  The signal is emitted after the modification.
    case itemsChanged = "items-changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: DBusMenuModel has no signals
// MARK: DBusMenuModel Class: DBusMenuModelProtocol extension (methods and fields)
public extension DBusMenuModelProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusMenuModel` instance.
    @inlinable var dbus_menu_model_ptr: UnsafeMutablePointer<GDBusMenuModel>! { return ptr?.assumingMemoryBound(to: GDBusMenuModel.self) }



}



// MARK: - DBusMessage Class

/// A type for representing D-Bus messages that can be sent or received
/// on a `GDBusConnection`.
///
/// The `DBusMessageProtocol` protocol exposes the methods and properties of an underlying `GDBusMessage` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusMessage`.
/// Alternatively, use `DBusMessageRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusMessageProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GDBusMessage` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusMessage` instance.
    var dbus_message_ptr: UnsafeMutablePointer<GDBusMessage>! { get }

    /// Required Initialiser for types conforming to `DBusMessageProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A type for representing D-Bus messages that can be sent or received
/// on a `GDBusConnection`.
///
/// The `DBusMessageRef` type acts as a lightweight Swift reference to an underlying `GDBusMessage` instance.
/// It exposes methods that can operate on this data type through `DBusMessageProtocol` conformance.
/// Use `DBusMessageRef` only as an `unowned` reference to an existing `GDBusMessage` instance.
///
public struct DBusMessageRef: DBusMessageProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GDBusMessage` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_message_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusMessageRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusMessage>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusMessage>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusMessage>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusMessage>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusMessageProtocol`
    @inlinable init<T: DBusMessageProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: DBusMessageProtocol>(_ other: T) -> DBusMessageRef { DBusMessageRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMessageProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMessageProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMessageProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMessageProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMessageProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new empty `GDBusMessage`.
    @inlinable init() {
            let result = g_dbus_message_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GDBusMessage` from the data stored at `blob`. The byte
    /// order that the message was in can be retrieved using
    /// `g_dbus_message_get_byte_order()`.
    /// 
    /// If the `blob` cannot be parsed, contains invalid fields, or contains invalid
    /// headers, `G_IO_ERROR_INVALID_ARGUMENT` will be returned.
    @inlinable init(blob: UnsafeMutablePointer<guchar>!, blobLen: Int, capabilities: DBusCapabilityFlags) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_message_new_from_blob(blob, gsize(blobLen), capabilities.value, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GDBusMessage` for a method call.
    @inlinable init(method_call name: UnsafePointer<gchar>? = nil, path: UnsafePointer<gchar>!, interface: UnsafePointer<gchar>? = nil, method: UnsafePointer<gchar>!) {
            let result = g_dbus_message_new_method_call(name, path, interface, method)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GDBusMessage` for a signal emission.
    @inlinable init(signal path: UnsafePointer<gchar>!, interface: UnsafePointer<gchar>!, signal: UnsafePointer<gchar>!) {
            let result = g_dbus_message_new_signal(path, interface, signal)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GDBusMessage` from the data stored at `blob`. The byte
    /// order that the message was in can be retrieved using
    /// `g_dbus_message_get_byte_order()`.
    /// 
    /// If the `blob` cannot be parsed, contains invalid fields, or contains invalid
    /// headers, `G_IO_ERROR_INVALID_ARGUMENT` will be returned.
    @inlinable static func newFrom(blob: UnsafeMutablePointer<guchar>!, blobLen: Int, capabilities: DBusCapabilityFlags) throws -> GIO.DBusMessageRef! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_message_new_from_blob(blob, gsize(blobLen), capabilities.value, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusMessageRef(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
        return rv
    }

    /// Creates a new `GDBusMessage` for a method call.
    @inlinable static func newMethodCall(method_call name: UnsafePointer<gchar>? = nil, path: UnsafePointer<gchar>!, interface: UnsafePointer<gchar>? = nil, method: UnsafePointer<gchar>!) -> GIO.DBusMessageRef! {
            let result = g_dbus_message_new_method_call(name, path, interface, method)
        guard let rv = DBusMessageRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Creates a new `GDBusMessage` for a signal emission.
    @inlinable static func new(signal path: UnsafePointer<gchar>!, interface: UnsafePointer<gchar>!, signal: UnsafePointer<gchar>!) -> GIO.DBusMessageRef! {
            let result = g_dbus_message_new_signal(path, interface, signal)
        guard let rv = DBusMessageRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }
}

/// A type for representing D-Bus messages that can be sent or received
/// on a `GDBusConnection`.
///
/// The `DBusMessage` type acts as a reference-counted owner of an underlying `GDBusMessage` instance.
/// It provides the methods that can operate on this data type through `DBusMessageProtocol` conformance.
/// Use `DBusMessage` as a strong reference or owner of a `GDBusMessage` instance.
///
open class DBusMessage: GLibObject.Object, DBusMessageProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMessage` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusMessage>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMessage` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusMessage>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMessage` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMessage` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMessage` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusMessage>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMessage` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusMessage>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDBusMessage`.
    /// i.e., ownership is transferred to the `DBusMessage` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusMessage>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DBusMessageProtocol`
    /// Will retain `GDBusMessage`.
    /// - Parameter other: an instance of a related type that implements `DBusMessageProtocol`
    @inlinable public init<T: DBusMessageProtocol>(dBusMessage other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMessageProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMessageProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMessageProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMessageProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMessageProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMessageProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMessageProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMessageProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new empty `GDBusMessage`.
    @inlinable public init() {
            let result = g_dbus_message_new()
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GDBusMessage` from the data stored at `blob`. The byte
    /// order that the message was in can be retrieved using
    /// `g_dbus_message_get_byte_order()`.
    /// 
    /// If the `blob` cannot be parsed, contains invalid fields, or contains invalid
    /// headers, `G_IO_ERROR_INVALID_ARGUMENT` will be returned.
    @inlinable public init(blob: UnsafeMutablePointer<guchar>!, blobLen: Int, capabilities: DBusCapabilityFlags) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_message_new_from_blob(blob, gsize(blobLen), capabilities.value, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GDBusMessage` for a method call.
    @inlinable public init(method_call name: UnsafePointer<gchar>? = nil, path: UnsafePointer<gchar>!, interface: UnsafePointer<gchar>? = nil, method: UnsafePointer<gchar>!) {
            let result = g_dbus_message_new_method_call(name, path, interface, method)
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GDBusMessage` for a signal emission.
    @inlinable public init(signal path: UnsafePointer<gchar>!, interface: UnsafePointer<gchar>!, signal: UnsafePointer<gchar>!) {
            let result = g_dbus_message_new_signal(path, interface, signal)
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GDBusMessage` from the data stored at `blob`. The byte
    /// order that the message was in can be retrieved using
    /// `g_dbus_message_get_byte_order()`.
    /// 
    /// If the `blob` cannot be parsed, contains invalid fields, or contains invalid
    /// headers, `G_IO_ERROR_INVALID_ARGUMENT` will be returned.
    @inlinable public static func newFrom(blob: UnsafeMutablePointer<guchar>!, blobLen: Int, capabilities: DBusCapabilityFlags) throws -> GIO.DBusMessage! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_message_new_from_blob(blob, gsize(blobLen), capabilities.value, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusMessage(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

    /// Creates a new `GDBusMessage` for a method call.
    @inlinable public static func newMethodCall(method_call name: UnsafePointer<gchar>? = nil, path: UnsafePointer<gchar>!, interface: UnsafePointer<gchar>? = nil, method: UnsafePointer<gchar>!) -> GIO.DBusMessage! {
            let result = g_dbus_message_new_method_call(name, path, interface, method)
        guard let rv = DBusMessage(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

    /// Creates a new `GDBusMessage` for a signal emission.
    @inlinable public static func new(signal path: UnsafePointer<gchar>!, interface: UnsafePointer<gchar>!, signal: UnsafePointer<gchar>!) -> GIO.DBusMessage! {
            let result = g_dbus_message_new_signal(path, interface, signal)
        guard let rv = DBusMessage(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

}

public enum DBusMessagePropertyName: String, PropertyNameProtocol {
    case locked = "locked"
}

public extension DBusMessageProtocol {
    /// Bind a `DBusMessagePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: DBusMessagePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a DBusMessage property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: DBusMessagePropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a DBusMessage property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: DBusMessagePropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum DBusMessageSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyLocked = "notify::locked"
}

// MARK: DBusMessage has no signals
// MARK: DBusMessage Class: DBusMessageProtocol extension (methods and fields)
public extension DBusMessageProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusMessage` instance.
    @inlinable var dbus_message_ptr: UnsafeMutablePointer<GDBusMessage>! { return ptr?.assumingMemoryBound(to: GDBusMessage.self) }

    /// Copies `message`. The copy is a deep copy and the returned
    /// `GDBusMessage` is completely identical except that it is guaranteed
    /// to not be locked.
    /// 
    /// This operation can fail if e.g. `message` contains file descriptors
    /// and the per-process or system-wide open files limit is reached.
    @inlinable func copy() throws -> GIO.DBusMessageRef! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_message_copy(dbus_message_ptr, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusMessageRef(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
        return rv
    }

    /// Convenience to get the first item in the body of `message`.
    @inlinable func getArg0() -> String! {
        let result = g_dbus_message_get_arg0(dbus_message_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets the body of a message.
    @inlinable func getBody() -> GLib.VariantRef! {
        let result = g_dbus_message_get_body(dbus_message_ptr)
        let rv = GLib.VariantRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the byte order of `message`.
    @inlinable func getByteOrder() -> GDBusMessageByteOrder {
        let result = g_dbus_message_get_byte_order(dbus_message_ptr)
        let rv = result
        return rv
    }

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION` header field.
    @inlinable func getDestination() -> String! {
        let result = g_dbus_message_get_destination(dbus_message_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME` header field.
    @inlinable func getErrorName() -> String! {
        let result = g_dbus_message_get_error_name(dbus_message_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets the flags for `message`.
    @inlinable func getFlags() -> GIO.DBusMessageFlags {
        let result = g_dbus_message_get_flags(dbus_message_ptr)
        let rv = DBusMessageFlags(result)
        return rv
    }

    /// Gets a header field on `message`.
    /// 
    /// The caller is responsible for checking the type of the returned `GVariant`
    /// matches what is expected.
    @inlinable func getHeader(headerField: GDBusMessageHeaderField) -> GLib.VariantRef! {
        let result = g_dbus_message_get_header(dbus_message_ptr, headerField)
        let rv = GLib.VariantRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets an array of all header fields on `message` that are set.
    @inlinable func getHeaderFields() -> String! {
        let result = g_dbus_message_get_header_fields(dbus_message_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE` header field.
    @inlinable func getInterface() -> String! {
        let result = g_dbus_message_get_interface(dbus_message_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Checks whether `message` is locked. To monitor changes to this
    /// value, conncet to the `GObject::notify` signal to listen for changes
    /// on the `GDBusMessage:locked` property.
    @inlinable func getLocked() -> Bool {
        let result = g_dbus_message_get_locked(dbus_message_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_MEMBER` header field.
    @inlinable func getMember() -> String! {
        let result = g_dbus_message_get_member(dbus_message_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets the type of `message`.
    @inlinable func getMessageType() -> GDBusMessageType {
        let result = g_dbus_message_get_message_type(dbus_message_ptr)
        let rv = result
        return rv
    }

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS` header field.
    @inlinable func getNumUnixFds() -> guint32 {
        let result = g_dbus_message_get_num_unix_fds(dbus_message_ptr)
        let rv = result
        return rv
    }

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_PATH` header field.
    @inlinable func getPath() -> String! {
        let result = g_dbus_message_get_path(dbus_message_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL` header field.
    @inlinable func getReplySerial() -> guint32 {
        let result = g_dbus_message_get_reply_serial(dbus_message_ptr)
        let rv = result
        return rv
    }

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_SENDER` header field.
    @inlinable func getSender() -> String! {
        let result = g_dbus_message_get_sender(dbus_message_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets the serial for `message`.
    @inlinable func getSerial() -> guint32 {
        let result = g_dbus_message_get_serial(dbus_message_ptr)
        let rv = result
        return rv
    }

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE` header field.
    /// 
    /// This will always be non-`nil`, but may be an empty string.
    @inlinable func getSignature() -> String! {
        let result = g_dbus_message_get_signature(dbus_message_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets the UNIX file descriptors associated with `message`, if any.
    /// 
    /// This method is only available on UNIX.
    /// 
    /// The file descriptors normally correspond to `G_VARIANT_TYPE_HANDLE`
    /// values in the body of the message. For example,
    /// if `g_variant_get_handle()` returns 5, that is intended to be a reference
    /// to the file descriptor that can be accessed by
    /// `g_unix_fd_list_get (list, 5, ...)`.
    @inlinable func getUnixFdList() -> GIO.UnixFDListRef! {
        let result = g_dbus_message_get_unix_fd_list(dbus_message_ptr)
        let rv = UnixFDListRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// If `message` is locked, does nothing. Otherwise locks the message.
    @inlinable func lock() {
        
        g_dbus_message_lock(dbus_message_ptr)
        
    }


    // *** newMethodError() is not available because it has a varargs (...) parameter!


    /// Creates a new `GDBusMessage` that is an error reply to `method_call_message`.
    @inlinable func newMethodErrorLiteral(errorName: UnsafePointer<gchar>!, errorMessage: UnsafePointer<gchar>!) -> GIO.DBusMessageRef! {
        let result = g_dbus_message_new_method_error_literal(dbus_message_ptr, errorName, errorMessage)
        guard let rv = DBusMessageRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Like `g_dbus_message_new_method_error()` but intended for language bindings.
    @inlinable func newMethodErrorValist(errorName: UnsafePointer<gchar>!, errorMessageFormat: UnsafePointer<gchar>!, varArgs: CVaListPointer) -> GIO.DBusMessageRef! {
        let result = g_dbus_message_new_method_error_valist(dbus_message_ptr, errorName, errorMessageFormat, varArgs)
        guard let rv = DBusMessageRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Creates a new `GDBusMessage` that is a reply to `method_call_message`.
    @inlinable func newMethodReply() -> GIO.DBusMessageRef! {
        let result = g_dbus_message_new_method_reply(dbus_message_ptr)
        guard let rv = DBusMessageRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Produces a human-readable multi-line description of `message`.
    /// 
    /// The contents of the description has no ABI guarantees, the contents
    /// and formatting is subject to change at any time. Typical output
    /// looks something like this:
    /// ```
    /// Flags:   none
    /// Version: 0
    /// Serial:  4
    /// Headers:
    ///   path -> objectpath '/org/gtk/GDBus/TestObject'
    ///   interface -> 'org.gtk.GDBus.TestInterface'
    ///   member -> 'GimmeStdout'
    ///   destination -> ':1.146'
    /// Body: ()
    /// UNIX File Descriptors:
    ///   (none)
    /// ```
    /// or
    /// ```
    /// Flags:   no-reply-expected
    /// Version: 0
    /// Serial:  477
    /// Headers:
    ///   reply-serial -> uint32 4
    ///   destination -> ':1.159'
    ///   sender -> ':1.146'
    ///   num-unix-fds -> uint32 1
    /// Body: ()
    /// UNIX File Descriptors:
    ///   fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
    /// ```
    /// 
    @inlinable func print(indent: Int) -> String! {
        let result = g_dbus_message_print(dbus_message_ptr, guint(indent))
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Sets the body `message`. As a side-effect the
    /// `G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE` header field is set to the
    /// type string of `body` (or cleared if `body` is `nil`).
    /// 
    /// If `body` is floating, `message` assumes ownership of `body`.
    @inlinable func set<GLibVariantT: GLib.VariantProtocol>(body: GLibVariantT) {
        
        g_dbus_message_set_body(dbus_message_ptr, body.variant_ptr)
        
    }

    /// Sets the byte order of `message`.
    @inlinable func set(byteOrder: GDBusMessageByteOrder) {
        
        g_dbus_message_set_byte_order(dbus_message_ptr, byteOrder)
        
    }

    /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION` header field.
    @inlinable func setDestination(value: UnsafePointer<gchar>? = nil) {
        
        g_dbus_message_set_destination(dbus_message_ptr, value)
        
    }

    /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME` header field.
    @inlinable func setErrorName(value: UnsafePointer<gchar>!) {
        
        g_dbus_message_set_error_name(dbus_message_ptr, value)
        
    }

    /// Sets the flags to set on `message`.
    @inlinable func set(flags: DBusMessageFlags) {
        
        g_dbus_message_set_flags(dbus_message_ptr, flags.value)
        
    }

    /// Sets a header field on `message`.
    /// 
    /// If `value` is floating, `message` assumes ownership of `value`.
    @inlinable func setHeader(headerField: GDBusMessageHeaderField, value: GLib.VariantRef? = nil) {
            
        g_dbus_message_set_header(dbus_message_ptr, headerField, value?.variant_ptr)
            
    }
    /// Sets a header field on `message`.
    /// 
    /// If `value` is floating, `message` assumes ownership of `value`.
    @inlinable func setHeader<GLibVariantT: GLib.VariantProtocol>(headerField: GDBusMessageHeaderField, value: GLibVariantT?) {
        
        g_dbus_message_set_header(dbus_message_ptr, headerField, value?.variant_ptr)
        
    }

    /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE` header field.
    @inlinable func setInterface(value: UnsafePointer<gchar>? = nil) {
        
        g_dbus_message_set_interface(dbus_message_ptr, value)
        
    }

    /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_MEMBER` header field.
    @inlinable func setMember(value: UnsafePointer<gchar>? = nil) {
        
        g_dbus_message_set_member(dbus_message_ptr, value)
        
    }

    /// Sets `message` to be of `type`.
    @inlinable func setMessage(type: GDBusMessageType) {
        
        g_dbus_message_set_message_type(dbus_message_ptr, type)
        
    }

    /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS` header field.
    @inlinable func setNumUnixFds(value: guint32) {
        
        g_dbus_message_set_num_unix_fds(dbus_message_ptr, value)
        
    }

    /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_PATH` header field.
    @inlinable func setPath(value: UnsafePointer<gchar>? = nil) {
        
        g_dbus_message_set_path(dbus_message_ptr, value)
        
    }

    /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL` header field.
    @inlinable func setReplySerial(value: guint32) {
        
        g_dbus_message_set_reply_serial(dbus_message_ptr, value)
        
    }

    /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_SENDER` header field.
    @inlinable func setSender(value: UnsafePointer<gchar>? = nil) {
        
        g_dbus_message_set_sender(dbus_message_ptr, value)
        
    }

    /// Sets the serial for `message`.
    @inlinable func set(serial: guint32) {
        
        g_dbus_message_set_serial(dbus_message_ptr, serial)
        
    }

    /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE` header field.
    @inlinable func setSignature(value: UnsafePointer<gchar>? = nil) {
        
        g_dbus_message_set_signature(dbus_message_ptr, value)
        
    }

    /// Sets the UNIX file descriptors associated with `message`. As a
    /// side-effect the `G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS` header
    /// field is set to the number of fds in `fd_list` (or cleared if
    /// `fd_list` is `nil`).
    /// 
    /// This method is only available on UNIX.
    /// 
    /// When designing D-Bus APIs that are intended to be interoperable,
    /// please note that non-GDBus implementations of D-Bus can usually only
    /// access file descriptors if they are referenced by a value of type
    /// `G_VARIANT_TYPE_HANDLE` in the body of the message.
    @inlinable func setUnix(fdList: UnixFDListRef? = nil) {
            
        g_dbus_message_set_unix_fd_list(dbus_message_ptr, fdList?.unix_fd_list_ptr)
            
    }
    /// Sets the UNIX file descriptors associated with `message`. As a
    /// side-effect the `G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS` header
    /// field is set to the number of fds in `fd_list` (or cleared if
    /// `fd_list` is `nil`).
    /// 
    /// This method is only available on UNIX.
    /// 
    /// When designing D-Bus APIs that are intended to be interoperable,
    /// please note that non-GDBus implementations of D-Bus can usually only
    /// access file descriptors if they are referenced by a value of type
    /// `G_VARIANT_TYPE_HANDLE` in the body of the message.
    @inlinable func setUnix<UnixFDListT: UnixFDListProtocol>(fdList: UnixFDListT?) {
        
        g_dbus_message_set_unix_fd_list(dbus_message_ptr, fdList?.unix_fd_list_ptr)
        
    }

    /// Serializes `message` to a blob. The byte order returned by
    /// `g_dbus_message_get_byte_order()` will be used.
    @inlinable func toBlob(outSize: UnsafeMutablePointer<gsize>!, capabilities: DBusCapabilityFlags) throws -> String! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_message_to_blob(dbus_message_ptr, outSize, capabilities.value, &error)
        if let error = error { throw GLibError(error) }
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// If `message` is not of type `G_DBUS_MESSAGE_TYPE_ERROR` does
    /// nothing and returns `false`.
    /// 
    /// Otherwise this method encodes the error in `message` as a `GError`
    /// using `g_dbus_error_set_dbus_error()` using the information in the
    /// `G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME` header field of `message` as
    /// well as the first string item in `message`'s body.
    @inlinable func toGerror() throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_message_to_gerror(dbus_message_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }
    /// Convenience to get the first item in the body of `message`.
    @inlinable var arg0: String! {
        /// Convenience to get the first item in the body of `message`.
        get {
            let result = g_dbus_message_get_arg0(dbus_message_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// Gets the body of a message.
    @inlinable var body: GLib.VariantRef! {
        /// Gets the body of a message.
        get {
            let result = g_dbus_message_get_body(dbus_message_ptr)
        let rv = GLib.VariantRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets the body `message`. As a side-effect the
        /// `G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE` header field is set to the
        /// type string of `body` (or cleared if `body` is `nil`).
        /// 
        /// If `body` is floating, `message` assumes ownership of `body`.
        nonmutating set {
            g_dbus_message_set_body(dbus_message_ptr, UnsafeMutablePointer<GVariant>(newValue?.variant_ptr))
        }
    }

    /// Gets the byte order of `message`.
    @inlinable var byteOrder: GDBusMessageByteOrder {
        /// Gets the byte order of `message`.
        get {
            let result = g_dbus_message_get_byte_order(dbus_message_ptr)
        let rv = result
            return rv
        }
        /// Sets the byte order of `message`.
        nonmutating set {
            g_dbus_message_set_byte_order(dbus_message_ptr, newValue)
        }
    }

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION` header field.
    @inlinable var destination: String! {
        /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION` header field.
        get {
            let result = g_dbus_message_get_destination(dbus_message_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
        /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION` header field.
        nonmutating set {
            g_dbus_message_set_destination(dbus_message_ptr, newValue)
        }
    }

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME` header field.
    @inlinable var errorName: String! {
        /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME` header field.
        get {
            let result = g_dbus_message_get_error_name(dbus_message_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
        /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME` header field.
        nonmutating set {
            g_dbus_message_set_error_name(dbus_message_ptr, newValue)
        }
    }

    /// Gets the flags for `message`.
    @inlinable var flags: GIO.DBusMessageFlags {
        /// Gets the flags for `message`.
        get {
            let result = g_dbus_message_get_flags(dbus_message_ptr)
        let rv = DBusMessageFlags(result)
            return rv
        }
        /// Sets the flags to set on `message`.
        nonmutating set {
            g_dbus_message_set_flags(dbus_message_ptr, newValue.value)
        }
    }

    /// Gets an array of all header fields on `message` that are set.
    @inlinable var headerFields: String! {
        /// Gets an array of all header fields on `message` that are set.
        get {
            let result = g_dbus_message_get_header_fields(dbus_message_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE` header field.
    @inlinable var interface: String! {
        /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE` header field.
        get {
            let result = g_dbus_message_get_interface(dbus_message_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
        /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE` header field.
        nonmutating set {
            g_dbus_message_set_interface(dbus_message_ptr, newValue)
        }
    }

    @inlinable var locked: Bool {
        /// Checks whether `message` is locked. To monitor changes to this
        /// value, conncet to the `GObject::notify` signal to listen for changes
        /// on the `GDBusMessage:locked` property.
        get {
            let result = g_dbus_message_get_locked(dbus_message_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_MEMBER` header field.
    @inlinable var member: String! {
        /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_MEMBER` header field.
        get {
            let result = g_dbus_message_get_member(dbus_message_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
        /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_MEMBER` header field.
        nonmutating set {
            g_dbus_message_set_member(dbus_message_ptr, newValue)
        }
    }

    /// Gets the type of `message`.
    @inlinable var messageType: GDBusMessageType {
        /// Gets the type of `message`.
        get {
            let result = g_dbus_message_get_message_type(dbus_message_ptr)
        let rv = result
            return rv
        }
        /// Sets `message` to be of `type`.
        nonmutating set {
            g_dbus_message_set_message_type(dbus_message_ptr, newValue)
        }
    }

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS` header field.
    @inlinable var numUnixFds: guint32 {
        /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS` header field.
        get {
            let result = g_dbus_message_get_num_unix_fds(dbus_message_ptr)
        let rv = result
            return rv
        }
        /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS` header field.
        nonmutating set {
            g_dbus_message_set_num_unix_fds(dbus_message_ptr, newValue)
        }
    }

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_PATH` header field.
    @inlinable var path: String! {
        /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_PATH` header field.
        get {
            let result = g_dbus_message_get_path(dbus_message_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
        /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_PATH` header field.
        nonmutating set {
            g_dbus_message_set_path(dbus_message_ptr, newValue)
        }
    }

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL` header field.
    @inlinable var replySerial: guint32 {
        /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL` header field.
        get {
            let result = g_dbus_message_get_reply_serial(dbus_message_ptr)
        let rv = result
            return rv
        }
        /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL` header field.
        nonmutating set {
            g_dbus_message_set_reply_serial(dbus_message_ptr, newValue)
        }
    }

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_SENDER` header field.
    @inlinable var sender: String! {
        /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_SENDER` header field.
        get {
            let result = g_dbus_message_get_sender(dbus_message_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
        /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_SENDER` header field.
        nonmutating set {
            g_dbus_message_set_sender(dbus_message_ptr, newValue)
        }
    }

    /// Gets the serial for `message`.
    @inlinable var serial: guint32 {
        /// Gets the serial for `message`.
        get {
            let result = g_dbus_message_get_serial(dbus_message_ptr)
        let rv = result
            return rv
        }
        /// Sets the serial for `message`.
        nonmutating set {
            g_dbus_message_set_serial(dbus_message_ptr, newValue)
        }
    }

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE` header field.
    /// 
    /// This will always be non-`nil`, but may be an empty string.
    @inlinable var signature: String! {
        /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE` header field.
        /// 
        /// This will always be non-`nil`, but may be an empty string.
        get {
            let result = g_dbus_message_get_signature(dbus_message_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
        /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE` header field.
        nonmutating set {
            g_dbus_message_set_signature(dbus_message_ptr, newValue)
        }
    }

    /// Gets the UNIX file descriptors associated with `message`, if any.
    /// 
    /// This method is only available on UNIX.
    /// 
    /// The file descriptors normally correspond to `G_VARIANT_TYPE_HANDLE`
    /// values in the body of the message. For example,
    /// if `g_variant_get_handle()` returns 5, that is intended to be a reference
    /// to the file descriptor that can be accessed by
    /// `g_unix_fd_list_get (list, 5, ...)`.
    @inlinable var unixFdList: GIO.UnixFDListRef! {
        /// Gets the UNIX file descriptors associated with `message`, if any.
        /// 
        /// This method is only available on UNIX.
        /// 
        /// The file descriptors normally correspond to `G_VARIANT_TYPE_HANDLE`
        /// values in the body of the message. For example,
        /// if `g_variant_get_handle()` returns 5, that is intended to be a reference
        /// to the file descriptor that can be accessed by
        /// `g_unix_fd_list_get (list, 5, ...)`.
        get {
            let result = g_dbus_message_get_unix_fd_list(dbus_message_ptr)
        let rv = UnixFDListRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets the UNIX file descriptors associated with `message`. As a
        /// side-effect the `G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS` header
        /// field is set to the number of fds in `fd_list` (or cleared if
        /// `fd_list` is `nil`).
        /// 
        /// This method is only available on UNIX.
        /// 
        /// When designing D-Bus APIs that are intended to be interoperable,
        /// please note that non-GDBus implementations of D-Bus can usually only
        /// access file descriptors if they are referenced by a value of type
        /// `G_VARIANT_TYPE_HANDLE` in the body of the message.
        nonmutating set {
            g_dbus_message_set_unix_fd_list(dbus_message_ptr, UnsafeMutablePointer<GUnixFDList>(newValue?.unix_fd_list_ptr))
        }
    }


}



// MARK: - DBusMethodInvocation Class

/// Instances of the `GDBusMethodInvocation` class are used when
/// handling D-Bus method calls. It provides a way to asynchronously
/// return results and errors.
/// 
/// The normal way to obtain a `GDBusMethodInvocation` object is to receive
/// it as an argument to the `handle_method_call()` function in a
/// `GDBusInterfaceVTable` that was passed to `g_dbus_connection_register_object()`.
///
/// The `DBusMethodInvocationProtocol` protocol exposes the methods and properties of an underlying `GDBusMethodInvocation` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusMethodInvocation`.
/// Alternatively, use `DBusMethodInvocationRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusMethodInvocationProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GDBusMethodInvocation` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusMethodInvocation` instance.
    var dbus_method_invocation_ptr: UnsafeMutablePointer<GDBusMethodInvocation>! { get }

    /// Required Initialiser for types conforming to `DBusMethodInvocationProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Instances of the `GDBusMethodInvocation` class are used when
/// handling D-Bus method calls. It provides a way to asynchronously
/// return results and errors.
/// 
/// The normal way to obtain a `GDBusMethodInvocation` object is to receive
/// it as an argument to the `handle_method_call()` function in a
/// `GDBusInterfaceVTable` that was passed to `g_dbus_connection_register_object()`.
///
/// The `DBusMethodInvocationRef` type acts as a lightweight Swift reference to an underlying `GDBusMethodInvocation` instance.
/// It exposes methods that can operate on this data type through `DBusMethodInvocationProtocol` conformance.
/// Use `DBusMethodInvocationRef` only as an `unowned` reference to an existing `GDBusMethodInvocation` instance.
///
public struct DBusMethodInvocationRef: DBusMethodInvocationProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GDBusMethodInvocation` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_method_invocation_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusMethodInvocationRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusMethodInvocation>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusMethodInvocation>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusMethodInvocation>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusMethodInvocation>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusMethodInvocationProtocol`
    @inlinable init<T: DBusMethodInvocationProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: DBusMethodInvocationProtocol>(_ other: T) -> DBusMethodInvocationRef { DBusMethodInvocationRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInvocationProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInvocationProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInvocationProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInvocationProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInvocationProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// Instances of the `GDBusMethodInvocation` class are used when
/// handling D-Bus method calls. It provides a way to asynchronously
/// return results and errors.
/// 
/// The normal way to obtain a `GDBusMethodInvocation` object is to receive
/// it as an argument to the `handle_method_call()` function in a
/// `GDBusInterfaceVTable` that was passed to `g_dbus_connection_register_object()`.
///
/// The `DBusMethodInvocation` type acts as a reference-counted owner of an underlying `GDBusMethodInvocation` instance.
/// It provides the methods that can operate on this data type through `DBusMethodInvocationProtocol` conformance.
/// Use `DBusMethodInvocation` as a strong reference or owner of a `GDBusMethodInvocation` instance.
///
open class DBusMethodInvocation: GLibObject.Object, DBusMethodInvocationProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMethodInvocation` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusMethodInvocation>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMethodInvocation` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusMethodInvocation>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMethodInvocation` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMethodInvocation` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMethodInvocation` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusMethodInvocation>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusMethodInvocation` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusMethodInvocation>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDBusMethodInvocation`.
    /// i.e., ownership is transferred to the `DBusMethodInvocation` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusMethodInvocation>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DBusMethodInvocationProtocol`
    /// Will retain `GDBusMethodInvocation`.
    /// - Parameter other: an instance of a related type that implements `DBusMethodInvocationProtocol`
    @inlinable public init<T: DBusMethodInvocationProtocol>(dBusMethodInvocation other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInvocationProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInvocationProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInvocationProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInvocationProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInvocationProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInvocationProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInvocationProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusMethodInvocationProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

// MARK: no DBusMethodInvocation properties

public enum DBusMethodInvocationSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: DBusMethodInvocation has no signals
// MARK: DBusMethodInvocation Class: DBusMethodInvocationProtocol extension (methods and fields)
public extension DBusMethodInvocationProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusMethodInvocation` instance.
    @inlinable var dbus_method_invocation_ptr: UnsafeMutablePointer<GDBusMethodInvocation>! { return ptr?.assumingMemoryBound(to: GDBusMethodInvocation.self) }

    /// Gets the `GDBusConnection` the method was invoked on.
    @inlinable func getConnection() -> GIO.DBusConnectionRef! {
        let result = g_dbus_method_invocation_get_connection(dbus_method_invocation_ptr)
        let rv = DBusConnectionRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the name of the D-Bus interface the method was invoked on.
    /// 
    /// If this method call is a property Get, Set or GetAll call that has
    /// been redirected to the method call handler then
    /// "org.freedesktop.DBus.Properties" will be returned.  See
    /// `GDBusInterfaceVTable` for more information.
    @inlinable func getInterfaceName() -> String! {
        let result = g_dbus_method_invocation_get_interface_name(dbus_method_invocation_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets the `GDBusMessage` for the method invocation. This is useful if
    /// you need to use low-level protocol features, such as UNIX file
    /// descriptor passing, that cannot be properly expressed in the
    /// `GVariant` API.
    /// 
    /// See this [server](#gdbus-server) and [client](#gdbus-unix-fd-client)
    /// for an example of how to use this low-level API to send and receive
    /// UNIX file descriptors.
    @inlinable func getMessage() -> GIO.DBusMessageRef! {
        let result = g_dbus_method_invocation_get_message(dbus_method_invocation_ptr)
        let rv = DBusMessageRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets information about the method call, if any.
    /// 
    /// If this method invocation is a property Get, Set or GetAll call that
    /// has been redirected to the method call handler then `nil` will be
    /// returned.  See `g_dbus_method_invocation_get_property_info()` and
    /// `GDBusInterfaceVTable` for more information.
    @inlinable func getMethodInfo() -> GIO.DBusMethodInfoRef! {
        let result = g_dbus_method_invocation_get_method_info(dbus_method_invocation_ptr)
        let rv = DBusMethodInfoRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the name of the method that was invoked.
    @inlinable func getMethodName() -> String! {
        let result = g_dbus_method_invocation_get_method_name(dbus_method_invocation_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets the object path the method was invoked on.
    @inlinable func getObjectPath() -> String! {
        let result = g_dbus_method_invocation_get_object_path(dbus_method_invocation_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets the parameters of the method invocation. If there are no input
    /// parameters then this will return a GVariant with 0 children rather than NULL.
    @inlinable func getParameters() -> GLib.VariantRef! {
        let result = g_dbus_method_invocation_get_parameters(dbus_method_invocation_ptr)
        let rv = GLib.VariantRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets information about the property that this method call is for, if
    /// any.
    /// 
    /// This will only be set in the case of an invocation in response to a
    /// property Get or Set call that has been directed to the method call
    /// handler for an object on account of its `property_get()` or
    /// `property_set()` vtable pointers being unset.
    /// 
    /// See `GDBusInterfaceVTable` for more information.
    /// 
    /// If the call was GetAll, `nil` will be returned.
    @inlinable func getPropertyInfo() -> GIO.DBusPropertyInfoRef! {
        let result = g_dbus_method_invocation_get_property_info(dbus_method_invocation_ptr)
        let rv = DBusPropertyInfoRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the bus name that invoked the method.
    @inlinable func getSender() -> String! {
        let result = g_dbus_method_invocation_get_sender(dbus_method_invocation_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets the `user_data` `gpointer` passed to `g_dbus_connection_register_object()`.
    @inlinable func getUserData() -> gpointer? {
        let result = g_dbus_method_invocation_get_user_data(dbus_method_invocation_ptr)
        let rv = result
        return rv
    }

    /// Finishes handling a D-Bus method call by returning an error.
    /// 
    /// This method will take ownership of `invocation`. See
    /// `GDBusInterfaceVTable` for more information about the ownership of
    /// `invocation`.
    @inlinable func returnDbusError(errorName: UnsafePointer<gchar>!, errorMessage: UnsafePointer<gchar>!) {
        
        g_dbus_method_invocation_return_dbus_error(dbus_method_invocation_ptr, errorName, errorMessage)
        
    }


    // *** returnError() is not available because it has a varargs (...) parameter!


    /// Like `g_dbus_method_invocation_return_error()` but without `printf()`-style formatting.
    /// 
    /// This method will take ownership of `invocation`. See
    /// `GDBusInterfaceVTable` for more information about the ownership of
    /// `invocation`.
    @inlinable func returnErrorLiteral(domain: GQuark, code: Int, message: UnsafePointer<gchar>!) {
        
        g_dbus_method_invocation_return_error_literal(dbus_method_invocation_ptr, domain, gint(code), message)
        
    }

    /// Like `g_dbus_method_invocation_return_error()` but intended for
    /// language bindings.
    /// 
    /// This method will take ownership of `invocation`. See
    /// `GDBusInterfaceVTable` for more information about the ownership of
    /// `invocation`.
    @inlinable func returnErrorValist(domain: GQuark, code: Int, format: UnsafePointer<gchar>!, varArgs: CVaListPointer) {
        
        g_dbus_method_invocation_return_error_valist(dbus_method_invocation_ptr, domain, gint(code), format, varArgs)
        
    }

    /// Like `g_dbus_method_invocation_return_error()` but takes a `GError`
    /// instead of the error domain, error code and message.
    /// 
    /// This method will take ownership of `invocation`. See
    /// `GDBusInterfaceVTable` for more information about the ownership of
    /// `invocation`.
    @inlinable func returnGerror<GLibGLibErrorT: GLib.ErrorProtocol>(error: GLibGLibErrorT) {
        
        g_dbus_method_invocation_return_gerror(dbus_method_invocation_ptr, error.error_ptr)
        
    }

    /// Finishes handling a D-Bus method call by returning `parameters`.
    /// If the `parameters` GVariant is floating, it is consumed.
    /// 
    /// It is an error if `parameters` is not of the right format: it must be a tuple
    /// containing the out-parameters of the D-Bus method. Even if the method has a
    /// single out-parameter, it must be contained in a tuple. If the method has no
    /// out-parameters, `parameters` may be `nil` or an empty tuple.
    /// 
    /// (C Language Example):
    /// ```C
    /// GDBusMethodInvocation *invocation = some_invocation;
    /// g_autofree gchar *result_string = NULL;
    /// g_autoptr (GError) error = NULL;
    /// 
    /// result_string = calculate_result (&error);
    /// 
    /// if (error != NULL)
    ///   g_dbus_method_invocation_return_gerror (invocation, error);
    /// else
    ///   g_dbus_method_invocation_return_value (invocation,
    ///                                          g_variant_new ("(s)", result_string));
    /// 
    /// // Do not free @invocation here; returning a value does that
    /// ```
    /// 
    /// This method will take ownership of `invocation`. See
    /// `GDBusInterfaceVTable` for more information about the ownership of
    /// `invocation`.
    /// 
    /// Since 2.48, if the method call requested for a reply not to be sent
    /// then this call will sink `parameters` and free `invocation`, but
    /// otherwise do nothing (as per the recommendations of the D-Bus
    /// specification).
    @inlinable func returnValue(parameters: GLib.VariantRef? = nil) {
            
        g_dbus_method_invocation_return_value(dbus_method_invocation_ptr, parameters?.variant_ptr)
            
    }
    /// Finishes handling a D-Bus method call by returning `parameters`.
    /// If the `parameters` GVariant is floating, it is consumed.
    /// 
    /// It is an error if `parameters` is not of the right format: it must be a tuple
    /// containing the out-parameters of the D-Bus method. Even if the method has a
    /// single out-parameter, it must be contained in a tuple. If the method has no
    /// out-parameters, `parameters` may be `nil` or an empty tuple.
    /// 
    /// (C Language Example):
    /// ```C
    /// GDBusMethodInvocation *invocation = some_invocation;
    /// g_autofree gchar *result_string = NULL;
    /// g_autoptr (GError) error = NULL;
    /// 
    /// result_string = calculate_result (&error);
    /// 
    /// if (error != NULL)
    ///   g_dbus_method_invocation_return_gerror (invocation, error);
    /// else
    ///   g_dbus_method_invocation_return_value (invocation,
    ///                                          g_variant_new ("(s)", result_string));
    /// 
    /// // Do not free @invocation here; returning a value does that
    /// ```
    /// 
    /// This method will take ownership of `invocation`. See
    /// `GDBusInterfaceVTable` for more information about the ownership of
    /// `invocation`.
    /// 
    /// Since 2.48, if the method call requested for a reply not to be sent
    /// then this call will sink `parameters` and free `invocation`, but
    /// otherwise do nothing (as per the recommendations of the D-Bus
    /// specification).
    @inlinable func returnValue<GLibVariantT: GLib.VariantProtocol>(parameters: GLibVariantT?) {
        
        g_dbus_method_invocation_return_value(dbus_method_invocation_ptr, parameters?.variant_ptr)
        
    }

    /// Like `g_dbus_method_invocation_return_value()` but also takes a `GUnixFDList`.
    /// 
    /// This method is only available on UNIX.
    /// 
    /// This method will take ownership of `invocation`. See
    /// `GDBusInterfaceVTable` for more information about the ownership of
    /// `invocation`.
    @inlinable func returnValueWithUnixFdList(parameters: GLib.VariantRef? = nil, fdList: UnixFDListRef? = nil) {
            
        g_dbus_method_invocation_return_value_with_unix_fd_list(dbus_method_invocation_ptr, parameters?.variant_ptr, fdList?.unix_fd_list_ptr)
            
    }
    /// Like `g_dbus_method_invocation_return_value()` but also takes a `GUnixFDList`.
    /// 
    /// This method is only available on UNIX.
    /// 
    /// This method will take ownership of `invocation`. See
    /// `GDBusInterfaceVTable` for more information about the ownership of
    /// `invocation`.
    @inlinable func returnValueWithUnixFdList<GLibVariantT: GLib.VariantProtocol, UnixFDListT: UnixFDListProtocol>(parameters: GLibVariantT?, fdList: UnixFDListT?) {
        
        g_dbus_method_invocation_return_value_with_unix_fd_list(dbus_method_invocation_ptr, parameters?.variant_ptr, fdList?.unix_fd_list_ptr)
        
    }

    /// Like `g_dbus_method_invocation_return_gerror()` but takes ownership
    /// of `error` so the caller does not need to free it.
    /// 
    /// This method will take ownership of `invocation`. See
    /// `GDBusInterfaceVTable` for more information about the ownership of
    /// `invocation`.
    @inlinable func take<GLibGLibErrorT: GLib.ErrorProtocol>(error: GLibGLibErrorT) {
        
        g_dbus_method_invocation_take_error(dbus_method_invocation_ptr, error.error_ptr)
        
    }
    /// Gets the `GDBusConnection` the method was invoked on.
    @inlinable var connection: GIO.DBusConnectionRef! {
        /// Gets the `GDBusConnection` the method was invoked on.
        get {
            let result = g_dbus_method_invocation_get_connection(dbus_method_invocation_ptr)
        let rv = DBusConnectionRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Gets the name of the D-Bus interface the method was invoked on.
    /// 
    /// If this method call is a property Get, Set or GetAll call that has
    /// been redirected to the method call handler then
    /// "org.freedesktop.DBus.Properties" will be returned.  See
    /// `GDBusInterfaceVTable` for more information.
    @inlinable var interfaceName: String! {
        /// Gets the name of the D-Bus interface the method was invoked on.
        /// 
        /// If this method call is a property Get, Set or GetAll call that has
        /// been redirected to the method call handler then
        /// "org.freedesktop.DBus.Properties" will be returned.  See
        /// `GDBusInterfaceVTable` for more information.
        get {
            let result = g_dbus_method_invocation_get_interface_name(dbus_method_invocation_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// Gets the `GDBusMessage` for the method invocation. This is useful if
    /// you need to use low-level protocol features, such as UNIX file
    /// descriptor passing, that cannot be properly expressed in the
    /// `GVariant` API.
    /// 
    /// See this [server](#gdbus-server) and [client](#gdbus-unix-fd-client)
    /// for an example of how to use this low-level API to send and receive
    /// UNIX file descriptors.
    @inlinable var message: GIO.DBusMessageRef! {
        /// Gets the `GDBusMessage` for the method invocation. This is useful if
        /// you need to use low-level protocol features, such as UNIX file
        /// descriptor passing, that cannot be properly expressed in the
        /// `GVariant` API.
        /// 
        /// See this [server](#gdbus-server) and [client](#gdbus-unix-fd-client)
        /// for an example of how to use this low-level API to send and receive
        /// UNIX file descriptors.
        get {
            let result = g_dbus_method_invocation_get_message(dbus_method_invocation_ptr)
        let rv = DBusMessageRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Gets information about the method call, if any.
    /// 
    /// If this method invocation is a property Get, Set or GetAll call that
    /// has been redirected to the method call handler then `nil` will be
    /// returned.  See `g_dbus_method_invocation_get_property_info()` and
    /// `GDBusInterfaceVTable` for more information.
    @inlinable var methodInfo: GIO.DBusMethodInfoRef! {
        /// Gets information about the method call, if any.
        /// 
        /// If this method invocation is a property Get, Set or GetAll call that
        /// has been redirected to the method call handler then `nil` will be
        /// returned.  See `g_dbus_method_invocation_get_property_info()` and
        /// `GDBusInterfaceVTable` for more information.
        get {
            let result = g_dbus_method_invocation_get_method_info(dbus_method_invocation_ptr)
        let rv = DBusMethodInfoRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Gets the name of the method that was invoked.
    @inlinable var methodName: String! {
        /// Gets the name of the method that was invoked.
        get {
            let result = g_dbus_method_invocation_get_method_name(dbus_method_invocation_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// Gets the object path the method was invoked on.
    @inlinable var objectPath: String! {
        /// Gets the object path the method was invoked on.
        get {
            let result = g_dbus_method_invocation_get_object_path(dbus_method_invocation_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// Gets the parameters of the method invocation. If there are no input
    /// parameters then this will return a GVariant with 0 children rather than NULL.
    @inlinable var parameters: GLib.VariantRef! {
        /// Gets the parameters of the method invocation. If there are no input
        /// parameters then this will return a GVariant with 0 children rather than NULL.
        get {
            let result = g_dbus_method_invocation_get_parameters(dbus_method_invocation_ptr)
        let rv = GLib.VariantRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Gets information about the property that this method call is for, if
    /// any.
    /// 
    /// This will only be set in the case of an invocation in response to a
    /// property Get or Set call that has been directed to the method call
    /// handler for an object on account of its `property_get()` or
    /// `property_set()` vtable pointers being unset.
    /// 
    /// See `GDBusInterfaceVTable` for more information.
    /// 
    /// If the call was GetAll, `nil` will be returned.
    @inlinable var propertyInfo: GIO.DBusPropertyInfoRef! {
        /// Gets information about the property that this method call is for, if
        /// any.
        /// 
        /// This will only be set in the case of an invocation in response to a
        /// property Get or Set call that has been directed to the method call
        /// handler for an object on account of its `property_get()` or
        /// `property_set()` vtable pointers being unset.
        /// 
        /// See `GDBusInterfaceVTable` for more information.
        /// 
        /// If the call was GetAll, `nil` will be returned.
        get {
            let result = g_dbus_method_invocation_get_property_info(dbus_method_invocation_ptr)
        let rv = DBusPropertyInfoRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Gets the bus name that invoked the method.
    @inlinable var sender: String! {
        /// Gets the bus name that invoked the method.
        get {
            let result = g_dbus_method_invocation_get_sender(dbus_method_invocation_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// Gets the `user_data` `gpointer` passed to `g_dbus_connection_register_object()`.
    @inlinable var userData: gpointer? {
        /// Gets the `user_data` `gpointer` passed to `g_dbus_connection_register_object()`.
        get {
            let result = g_dbus_method_invocation_get_user_data(dbus_method_invocation_ptr)
        let rv = result
            return rv
        }
    }


}



// MARK: - DBusObjectManagerClient Class

/// `GDBusObjectManagerClient` is used to create, monitor and delete object
/// proxies for remote objects exported by a `GDBusObjectManagerServer` (or any
/// code implementing the
/// [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html`standard-interfaces-objectmanager`)
/// interface).
/// 
/// Once an instance of this type has been created, you can connect to
/// the `GDBusObjectManager::object-added` and
/// `GDBusObjectManager::object-removed` signals and inspect the
/// `GDBusObjectProxy` objects returned by
/// `g_dbus_object_manager_get_objects()`.
/// 
/// If the name for a `GDBusObjectManagerClient` is not owned by anyone at
/// object construction time, the default behavior is to request the
/// message bus to launch an owner for the name. This behavior can be
/// disabled using the `G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START`
/// flag. It's also worth noting that this only works if the name of
/// interest is activatable in the first place. E.g. in some cases it
/// is not possible to launch an owner for the requested name. In this
/// case, `GDBusObjectManagerClient` object construction still succeeds but
/// there will be no object proxies
/// (e.g. `g_dbus_object_manager_get_objects()` returns the empty list) and
/// the `GDBusObjectManagerClient:name-owner` property is `nil`.
/// 
/// The owner of the requested name can come and go (for example
/// consider a system service being restarted)  `GDBusObjectManagerClient`
/// handles this case too; simply connect to the `GObject::notify`
/// signal to watch for changes on the `GDBusObjectManagerClient:name-owner`
/// property. When the name owner vanishes, the behavior is that
/// `GDBusObjectManagerClient:name-owner` is set to `nil` (this includes
/// emission of the `GObject::notify` signal) and then
/// `GDBusObjectManager::object-removed` signals are synthesized
/// for all currently existing object proxies. Since
/// `GDBusObjectManagerClient:name-owner` is `nil` when this happens, you can
/// use this information to disambiguate a synthesized signal from a
/// genuine signal caused by object removal on the remote
/// `GDBusObjectManager`. Similarly, when a new name owner appears,
/// `GDBusObjectManager::object-added` signals are synthesized
/// while `GDBusObjectManagerClient:name-owner` is still `nil`. Only when all
/// object proxies have been added, the `GDBusObjectManagerClient:name-owner`
/// is set to the new name owner (this includes emission of the
/// `GObject::notify` signal).  Furthermore, you are guaranteed that
/// `GDBusObjectManagerClient:name-owner` will alternate between a name owner
/// (e.g. `:1.42`) and `nil` even in the case where
/// the name of interest is atomically replaced
/// 
/// Ultimately, `GDBusObjectManagerClient` is used to obtain `GDBusProxy`
/// instances. All signals (including the
/// org.freedesktop.DBus.Properties`PropertiesChanged` signal)
/// delivered to `GDBusProxy` instances are guaranteed to originate
/// from the name owner. This guarantee along with the behavior
/// described above, means that certain race conditions including the
/// "half the proxy is from the old owner and the other half is from
/// the new owner" problem cannot happen.
/// 
/// To avoid having the application connect to signals on the returned
/// `GDBusObjectProxy` and `GDBusProxy` objects, the
/// `GDBusObject::interface-added`,
/// `GDBusObject::interface-removed`,
/// `GDBusProxy::g-properties-changed` and
/// `GDBusProxy::g-signal` signals
/// are also emitted on the `GDBusObjectManagerClient` instance managing these
/// objects. The signals emitted are
/// `GDBusObjectManager::interface-added`,
/// `GDBusObjectManager::interface-removed`,
/// `GDBusObjectManagerClient::interface-proxy-properties-changed` and
/// `GDBusObjectManagerClient::interface-proxy-signal`.
/// 
/// Note that all callbacks and signals are emitted in the
/// [thread-default main context](#g-main-context-push-thread-default)
/// that the `GDBusObjectManagerClient` object was constructed
/// in. Additionally, the `GDBusObjectProxy` and `GDBusProxy` objects
/// originating from the `GDBusObjectManagerClient` object will be created in
/// the same context and, consequently, will deliver signals in the
/// same main loop.
///
/// The `DBusObjectManagerClientProtocol` protocol exposes the methods and properties of an underlying `GDBusObjectManagerClient` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusObjectManagerClient`.
/// Alternatively, use `DBusObjectManagerClientRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusObjectManagerClientProtocol: GLibObject.ObjectProtocol, AsyncInitableProtocol, DBusObjectManagerProtocol, InitableProtocol {
        /// Untyped pointer to the underlying `GDBusObjectManagerClient` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusObjectManagerClient` instance.
    var dbus_object_manager_client_ptr: UnsafeMutablePointer<GDBusObjectManagerClient>! { get }

    /// Required Initialiser for types conforming to `DBusObjectManagerClientProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GDBusObjectManagerClient` is used to create, monitor and delete object
/// proxies for remote objects exported by a `GDBusObjectManagerServer` (or any
/// code implementing the
/// [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html`standard-interfaces-objectmanager`)
/// interface).
/// 
/// Once an instance of this type has been created, you can connect to
/// the `GDBusObjectManager::object-added` and
/// `GDBusObjectManager::object-removed` signals and inspect the
/// `GDBusObjectProxy` objects returned by
/// `g_dbus_object_manager_get_objects()`.
/// 
/// If the name for a `GDBusObjectManagerClient` is not owned by anyone at
/// object construction time, the default behavior is to request the
/// message bus to launch an owner for the name. This behavior can be
/// disabled using the `G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START`
/// flag. It's also worth noting that this only works if the name of
/// interest is activatable in the first place. E.g. in some cases it
/// is not possible to launch an owner for the requested name. In this
/// case, `GDBusObjectManagerClient` object construction still succeeds but
/// there will be no object proxies
/// (e.g. `g_dbus_object_manager_get_objects()` returns the empty list) and
/// the `GDBusObjectManagerClient:name-owner` property is `nil`.
/// 
/// The owner of the requested name can come and go (for example
/// consider a system service being restarted)  `GDBusObjectManagerClient`
/// handles this case too; simply connect to the `GObject::notify`
/// signal to watch for changes on the `GDBusObjectManagerClient:name-owner`
/// property. When the name owner vanishes, the behavior is that
/// `GDBusObjectManagerClient:name-owner` is set to `nil` (this includes
/// emission of the `GObject::notify` signal) and then
/// `GDBusObjectManager::object-removed` signals are synthesized
/// for all currently existing object proxies. Since
/// `GDBusObjectManagerClient:name-owner` is `nil` when this happens, you can
/// use this information to disambiguate a synthesized signal from a
/// genuine signal caused by object removal on the remote
/// `GDBusObjectManager`. Similarly, when a new name owner appears,
/// `GDBusObjectManager::object-added` signals are synthesized
/// while `GDBusObjectManagerClient:name-owner` is still `nil`. Only when all
/// object proxies have been added, the `GDBusObjectManagerClient:name-owner`
/// is set to the new name owner (this includes emission of the
/// `GObject::notify` signal).  Furthermore, you are guaranteed that
/// `GDBusObjectManagerClient:name-owner` will alternate between a name owner
/// (e.g. `:1.42`) and `nil` even in the case where
/// the name of interest is atomically replaced
/// 
/// Ultimately, `GDBusObjectManagerClient` is used to obtain `GDBusProxy`
/// instances. All signals (including the
/// org.freedesktop.DBus.Properties`PropertiesChanged` signal)
/// delivered to `GDBusProxy` instances are guaranteed to originate
/// from the name owner. This guarantee along with the behavior
/// described above, means that certain race conditions including the
/// "half the proxy is from the old owner and the other half is from
/// the new owner" problem cannot happen.
/// 
/// To avoid having the application connect to signals on the returned
/// `GDBusObjectProxy` and `GDBusProxy` objects, the
/// `GDBusObject::interface-added`,
/// `GDBusObject::interface-removed`,
/// `GDBusProxy::g-properties-changed` and
/// `GDBusProxy::g-signal` signals
/// are also emitted on the `GDBusObjectManagerClient` instance managing these
/// objects. The signals emitted are
/// `GDBusObjectManager::interface-added`,
/// `GDBusObjectManager::interface-removed`,
/// `GDBusObjectManagerClient::interface-proxy-properties-changed` and
/// `GDBusObjectManagerClient::interface-proxy-signal`.
/// 
/// Note that all callbacks and signals are emitted in the
/// [thread-default main context](#g-main-context-push-thread-default)
/// that the `GDBusObjectManagerClient` object was constructed
/// in. Additionally, the `GDBusObjectProxy` and `GDBusProxy` objects
/// originating from the `GDBusObjectManagerClient` object will be created in
/// the same context and, consequently, will deliver signals in the
/// same main loop.
///
/// The `DBusObjectManagerClientRef` type acts as a lightweight Swift reference to an underlying `GDBusObjectManagerClient` instance.
/// It exposes methods that can operate on this data type through `DBusObjectManagerClientProtocol` conformance.
/// Use `DBusObjectManagerClientRef` only as an `unowned` reference to an existing `GDBusObjectManagerClient` instance.
///
public struct DBusObjectManagerClientRef: DBusObjectManagerClientProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GDBusObjectManagerClient` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_object_manager_client_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusObjectManagerClientRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusObjectManagerClient>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusObjectManagerClient>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusObjectManagerClient>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusObjectManagerClient>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusObjectManagerClientProtocol`
    @inlinable init<T: DBusObjectManagerClientProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: DBusObjectManagerClientProtocol>(_ other: T) -> DBusObjectManagerClientRef { DBusObjectManagerClientRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerClientProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerClientProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerClientProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerClientProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerClientProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// `GDBusObjectManagerClient` is used to create, monitor and delete object
/// proxies for remote objects exported by a `GDBusObjectManagerServer` (or any
/// code implementing the
/// [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html`standard-interfaces-objectmanager`)
/// interface).
/// 
/// Once an instance of this type has been created, you can connect to
/// the `GDBusObjectManager::object-added` and
/// `GDBusObjectManager::object-removed` signals and inspect the
/// `GDBusObjectProxy` objects returned by
/// `g_dbus_object_manager_get_objects()`.
/// 
/// If the name for a `GDBusObjectManagerClient` is not owned by anyone at
/// object construction time, the default behavior is to request the
/// message bus to launch an owner for the name. This behavior can be
/// disabled using the `G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START`
/// flag. It's also worth noting that this only works if the name of
/// interest is activatable in the first place. E.g. in some cases it
/// is not possible to launch an owner for the requested name. In this
/// case, `GDBusObjectManagerClient` object construction still succeeds but
/// there will be no object proxies
/// (e.g. `g_dbus_object_manager_get_objects()` returns the empty list) and
/// the `GDBusObjectManagerClient:name-owner` property is `nil`.
/// 
/// The owner of the requested name can come and go (for example
/// consider a system service being restarted)  `GDBusObjectManagerClient`
/// handles this case too; simply connect to the `GObject::notify`
/// signal to watch for changes on the `GDBusObjectManagerClient:name-owner`
/// property. When the name owner vanishes, the behavior is that
/// `GDBusObjectManagerClient:name-owner` is set to `nil` (this includes
/// emission of the `GObject::notify` signal) and then
/// `GDBusObjectManager::object-removed` signals are synthesized
/// for all currently existing object proxies. Since
/// `GDBusObjectManagerClient:name-owner` is `nil` when this happens, you can
/// use this information to disambiguate a synthesized signal from a
/// genuine signal caused by object removal on the remote
/// `GDBusObjectManager`. Similarly, when a new name owner appears,
/// `GDBusObjectManager::object-added` signals are synthesized
/// while `GDBusObjectManagerClient:name-owner` is still `nil`. Only when all
/// object proxies have been added, the `GDBusObjectManagerClient:name-owner`
/// is set to the new name owner (this includes emission of the
/// `GObject::notify` signal).  Furthermore, you are guaranteed that
/// `GDBusObjectManagerClient:name-owner` will alternate between a name owner
/// (e.g. `:1.42`) and `nil` even in the case where
/// the name of interest is atomically replaced
/// 
/// Ultimately, `GDBusObjectManagerClient` is used to obtain `GDBusProxy`
/// instances. All signals (including the
/// org.freedesktop.DBus.Properties`PropertiesChanged` signal)
/// delivered to `GDBusProxy` instances are guaranteed to originate
/// from the name owner. This guarantee along with the behavior
/// described above, means that certain race conditions including the
/// "half the proxy is from the old owner and the other half is from
/// the new owner" problem cannot happen.
/// 
/// To avoid having the application connect to signals on the returned
/// `GDBusObjectProxy` and `GDBusProxy` objects, the
/// `GDBusObject::interface-added`,
/// `GDBusObject::interface-removed`,
/// `GDBusProxy::g-properties-changed` and
/// `GDBusProxy::g-signal` signals
/// are also emitted on the `GDBusObjectManagerClient` instance managing these
/// objects. The signals emitted are
/// `GDBusObjectManager::interface-added`,
/// `GDBusObjectManager::interface-removed`,
/// `GDBusObjectManagerClient::interface-proxy-properties-changed` and
/// `GDBusObjectManagerClient::interface-proxy-signal`.
/// 
/// Note that all callbacks and signals are emitted in the
/// [thread-default main context](#g-main-context-push-thread-default)
/// that the `GDBusObjectManagerClient` object was constructed
/// in. Additionally, the `GDBusObjectProxy` and `GDBusProxy` objects
/// originating from the `GDBusObjectManagerClient` object will be created in
/// the same context and, consequently, will deliver signals in the
/// same main loop.
///
/// The `DBusObjectManagerClient` type acts as a reference-counted owner of an underlying `GDBusObjectManagerClient` instance.
/// It provides the methods that can operate on this data type through `DBusObjectManagerClientProtocol` conformance.
/// Use `DBusObjectManagerClient` as a strong reference or owner of a `GDBusObjectManagerClient` instance.
///
open class DBusObjectManagerClient: GLibObject.Object, DBusObjectManagerClientProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectManagerClient` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusObjectManagerClient>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectManagerClient` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusObjectManagerClient>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectManagerClient` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectManagerClient` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectManagerClient` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusObjectManagerClient>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectManagerClient` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusObjectManagerClient>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDBusObjectManagerClient`.
    /// i.e., ownership is transferred to the `DBusObjectManagerClient` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusObjectManagerClient>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DBusObjectManagerClientProtocol`
    /// Will retain `GDBusObjectManagerClient`.
    /// - Parameter other: an instance of a related type that implements `DBusObjectManagerClientProtocol`
    @inlinable public init<T: DBusObjectManagerClientProtocol>(dBusObjectManagerClient other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerClientProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerClientProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerClientProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerClientProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerClientProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerClientProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerClientProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerClientProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum DBusObjectManagerClientPropertyName: String, PropertyNameProtocol {
    /// If this property is not `G_BUS_TYPE_NONE`, then
    /// `GDBusObjectManagerClient:connection` must be `nil` and will be set to the
    /// `GDBusConnection` obtained by calling `g_bus_get()` with the value
    /// of this property.
    case busType = "bus-type"
    /// The `GDBusConnection` to use.
    case connection = "connection"
    /// Flags from the `GDBusObjectManagerClientFlags` enumeration.
    case flags = "flags"
    /// A `GDestroyNotify` for the `gpointer` user_data in `GDBusObjectManagerClient:get-proxy-type-user-data`.
    case getProxyTypeDestroyNotify = "get-proxy-type-destroy-notify"
    /// The `GDBusProxyTypeFunc` to use when determining what `GType` to
    /// use for interface proxies or `nil`.
    case getProxyTypeFunc = "get-proxy-type-func"
    /// The `gpointer` user_data to pass to `GDBusObjectManagerClient:get-proxy-type-func`.
    case getProxyTypeUserData = "get-proxy-type-user-data"
    /// The well-known name or unique name that the manager is for.
    case name = "name"
    /// The unique name that owns `GDBusObjectManagerClient:name` or `nil` if
    /// no-one is currently owning the name. Connect to the
    /// `GObject::notify` signal to track changes to this property.
    case nameOwner = "name-owner"
    /// The object path the manager is for.
    case objectPath = "object-path"
}

public extension DBusObjectManagerClientProtocol {
    /// Bind a `DBusObjectManagerClientPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: DBusObjectManagerClientPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a DBusObjectManagerClient property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: DBusObjectManagerClientPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a DBusObjectManagerClient property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: DBusObjectManagerClientPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum DBusObjectManagerClientSignalName: String, SignalNameProtocol {
    /// Emitted when one or more D-Bus properties on proxy changes. The
    /// local cache has already been updated when this signal fires. Note
    /// that both `changed_properties` and `invalidated_properties` are
    /// guaranteed to never be `nil` (either may be empty though).
    /// 
    /// This signal exists purely as a convenience to avoid having to
    /// connect signals to all interface proxies managed by `manager`.
    /// 
    /// This signal is emitted in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// that `manager` was constructed in.
    case interfaceProxyPropertiesChanged = "interface-proxy-properties-changed"
    /// Emitted when a D-Bus signal is received on `interface_proxy`.
    /// 
    /// This signal exists purely as a convenience to avoid having to
    /// connect signals to all interface proxies managed by `manager`.
    /// 
    /// This signal is emitted in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// that `manager` was constructed in.
    case interfaceProxySignal = "interface-proxy-signal"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// If this property is not `G_BUS_TYPE_NONE`, then
    /// `GDBusObjectManagerClient:connection` must be `nil` and will be set to the
    /// `GDBusConnection` obtained by calling `g_bus_get()` with the value
    /// of this property.
    case notifyBusType = "notify::bus-type"
    /// The `GDBusConnection` to use.
    case notifyConnection = "notify::connection"
    /// Flags from the `GDBusObjectManagerClientFlags` enumeration.
    case notifyFlags = "notify::flags"
    /// A `GDestroyNotify` for the `gpointer` user_data in `GDBusObjectManagerClient:get-proxy-type-user-data`.
    case notifyGetProxyTypeDestroyNotify = "notify::get-proxy-type-destroy-notify"
    /// The `GDBusProxyTypeFunc` to use when determining what `GType` to
    /// use for interface proxies or `nil`.
    case notifyGetProxyTypeFunc = "notify::get-proxy-type-func"
    /// The `gpointer` user_data to pass to `GDBusObjectManagerClient:get-proxy-type-func`.
    case notifyGetProxyTypeUserData = "notify::get-proxy-type-user-data"
    /// The well-known name or unique name that the manager is for.
    case notifyName = "notify::name"
    /// The unique name that owns `GDBusObjectManagerClient:name` or `nil` if
    /// no-one is currently owning the name. Connect to the
    /// `GObject::notify` signal to track changes to this property.
    case notifyNameOwner = "notify::name-owner"
    /// The object path the manager is for.
    case notifyObjectPath = "notify::object-path"
}

// MARK: DBusObjectManagerClient signals
public extension DBusObjectManagerClientProtocol {
    /// Connect a Swift signal handler to the given, typed `DBusObjectManagerClientSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DBusObjectManagerClientSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `DBusObjectManagerClientSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DBusObjectManagerClientSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when one or more D-Bus properties on proxy changes. The
    /// local cache has already been updated when this signal fires. Note
    /// that both `changed_properties` and `invalidated_properties` are
    /// guaranteed to never be `nil` (either may be empty though).
    /// 
    /// This signal exists purely as a convenience to avoid having to
    /// connect signals to all interface proxies managed by `manager`.
    /// 
    /// This signal is emitted in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// that `manager` was constructed in.
    /// - Note: This represents the underlying `interface-proxy-properties-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter objectProxy: The `GDBusObjectProxy` on which an interface has properties that are changing.
    /// - Parameter interfaceProxy: The `GDBusProxy` that has properties that are changing.
    /// - Parameter changedProperties: A `GVariant` containing the properties that changed (type: `a{sv}`).
    /// - Parameter invalidatedProperties: A `nil` terminated   array of properties that were invalidated.
    /// - Parameter handler: The signal handler to call
    /// - Warning: a `onInterfaceProxyPropertiesChanged` wrapper for this signal could not be generated because it contains unimplemented features: { (3)  Void argument is not yet supported, (7)  array argument or return type is not allowed }
    /// - Note: Instead, you can connect `interfaceProxyPropertiesChangedSignal` using the `connect(signal:)` methods
    static var interfaceProxyPropertiesChangedSignal: DBusObjectManagerClientSignalName { .interfaceProxyPropertiesChanged }
    /// Emitted when a D-Bus signal is received on `interface_proxy`.
    /// 
    /// This signal exists purely as a convenience to avoid having to
    /// connect signals to all interface proxies managed by `manager`.
    /// 
    /// This signal is emitted in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// that `manager` was constructed in.
    /// - Note: This represents the underlying `interface-proxy-signal` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter objectProxy: The `GDBusObjectProxy` on which an interface is emitting a D-Bus signal.
    /// - Parameter interfaceProxy: The `GDBusProxy` that is emitting a D-Bus signal.
    /// - Parameter senderName: The sender of the signal or NULL if the connection is not a bus connection.
    /// - Parameter signalName: The signal name.
    /// - Parameter parameters: A `GVariant` tuple with parameters for the signal.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `interfaceProxySignal` signal is emitted
    @discardableResult @inlinable func onInterfaceProxySignal(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusObjectManagerClientRef, _ objectProxy: DBusObjectProxyRef, _ interfaceProxy: DBusProxyRef, _ senderName: String, _ signalName: String, _ parameters: GLib.VariantRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusObjectManagerClientRef, DBusObjectProxyRef, DBusProxyRef, String, String, GLib.VariantRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, UnsafeMutablePointer<gchar>?, UnsafeMutablePointer<gchar>?, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, arg3, arg4, arg5, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusObjectManagerClientRef(raw: unownedSelf), DBusObjectProxyRef(raw: arg1), DBusProxyRef(raw: arg2), arg3.map({ String(cString: $0) })!, arg4.map({ String(cString: $0) })!, GLib.VariantRef(raw: arg5)))
            return output
        }
        return connect(
            signal: .interfaceProxySignal,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `interface-proxy-signal` signal for using the `connect(signal:)` methods
    static var interfaceProxySignalSignal: DBusObjectManagerClientSignalName { .interfaceProxySignal }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::bus-type` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyBusType` signal is emitted
    @discardableResult @inlinable func onNotifyBusType(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusObjectManagerClientRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusObjectManagerClientRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusObjectManagerClientRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyBusType,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::bus-type` signal for using the `connect(signal:)` methods
    static var notifyBusTypeSignal: DBusObjectManagerClientSignalName { .notifyBusType }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::connection` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyConnection` signal is emitted
    @discardableResult @inlinable func onNotifyConnection(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusObjectManagerClientRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusObjectManagerClientRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusObjectManagerClientRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyConnection,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::connection` signal for using the `connect(signal:)` methods
    static var notifyConnectionSignal: DBusObjectManagerClientSignalName { .notifyConnection }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::flags` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFlags` signal is emitted
    @discardableResult @inlinable func onNotifyFlags(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusObjectManagerClientRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusObjectManagerClientRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusObjectManagerClientRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyFlags,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::flags` signal for using the `connect(signal:)` methods
    static var notifyFlagsSignal: DBusObjectManagerClientSignalName { .notifyFlags }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::get-proxy-type-destroy-notify` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyGetProxyTypeDestroyNotify` signal is emitted
    @discardableResult @inlinable func onNotifyGetProxyTypeDestroyNotify(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusObjectManagerClientRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusObjectManagerClientRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusObjectManagerClientRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyGetProxyTypeDestroyNotify,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::get-proxy-type-destroy-notify` signal for using the `connect(signal:)` methods
    static var notifyGetProxyTypeDestroyNotifySignal: DBusObjectManagerClientSignalName { .notifyGetProxyTypeDestroyNotify }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::get-proxy-type-func` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyGetProxyTypeFunc` signal is emitted
    @discardableResult @inlinable func onNotifyGetProxyTypeFunc(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusObjectManagerClientRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusObjectManagerClientRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusObjectManagerClientRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyGetProxyTypeFunc,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::get-proxy-type-func` signal for using the `connect(signal:)` methods
    static var notifyGetProxyTypeFuncSignal: DBusObjectManagerClientSignalName { .notifyGetProxyTypeFunc }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::get-proxy-type-user-data` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyGetProxyTypeUserData` signal is emitted
    @discardableResult @inlinable func onNotifyGetProxyTypeUserData(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusObjectManagerClientRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusObjectManagerClientRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusObjectManagerClientRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyGetProxyTypeUserData,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::get-proxy-type-user-data` signal for using the `connect(signal:)` methods
    static var notifyGetProxyTypeUserDataSignal: DBusObjectManagerClientSignalName { .notifyGetProxyTypeUserData }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::name` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyName` signal is emitted
    @discardableResult @inlinable func onNotifyName(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusObjectManagerClientRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusObjectManagerClientRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusObjectManagerClientRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyName,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::name` signal for using the `connect(signal:)` methods
    static var notifyNameSignal: DBusObjectManagerClientSignalName { .notifyName }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::name-owner` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyNameOwner` signal is emitted
    @discardableResult @inlinable func onNotifyNameOwner(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusObjectManagerClientRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusObjectManagerClientRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusObjectManagerClientRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyNameOwner,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::name-owner` signal for using the `connect(signal:)` methods
    static var notifyNameOwnerSignal: DBusObjectManagerClientSignalName { .notifyNameOwner }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::object-path` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyObjectPath` signal is emitted
    @discardableResult @inlinable func onNotifyObjectPath(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusObjectManagerClientRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusObjectManagerClientRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusObjectManagerClientRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyObjectPath,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::object-path` signal for using the `connect(signal:)` methods
    static var notifyObjectPathSignal: DBusObjectManagerClientSignalName { .notifyObjectPath }
    
}

// MARK: DBusObjectManagerClient Class: DBusObjectManagerClientProtocol extension (methods and fields)
public extension DBusObjectManagerClientProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusObjectManagerClient` instance.
    @inlinable var dbus_object_manager_client_ptr: UnsafeMutablePointer<GDBusObjectManagerClient>! { return ptr?.assumingMemoryBound(to: GDBusObjectManagerClient.self) }

    /// Gets the `GDBusConnection` used by `manager`.
    @inlinable func getConnection() -> GIO.DBusConnectionRef! {
        let result = g_dbus_object_manager_client_get_connection(dbus_object_manager_client_ptr)
        let rv = DBusConnectionRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the flags that `manager` was constructed with.
    @inlinable func getFlags() -> GIO.DBusObjectManagerClientFlags {
        let result = g_dbus_object_manager_client_get_flags(dbus_object_manager_client_ptr)
        let rv = DBusObjectManagerClientFlags(result)
        return rv
    }

    /// Gets the name that `manager` is for, or `nil` if not a message bus
    /// connection.
    @inlinable func getName() -> String! {
        let result = g_dbus_object_manager_client_get_name(dbus_object_manager_client_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// The unique name that owns the name that `manager` is for or `nil` if
    /// no-one currently owns that name. You can connect to the
    /// `GObject::notify` signal to track changes to the
    /// `GDBusObjectManagerClient:name-owner` property.
    @inlinable func getNameOwner() -> String! {
        let result = g_dbus_object_manager_client_get_name_owner(dbus_object_manager_client_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }
    /// The `GDBusConnection` to use.
    @inlinable var connection: GIO.DBusConnectionRef! {
        /// Gets the `GDBusConnection` used by `manager`.
        get {
            let result = g_dbus_object_manager_client_get_connection(dbus_object_manager_client_ptr)
        let rv = DBusConnectionRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Flags from the `GDBusObjectManagerClientFlags` enumeration.
    @inlinable var flags: GIO.DBusObjectManagerClientFlags {
        /// Gets the flags that `manager` was constructed with.
        get {
            let result = g_dbus_object_manager_client_get_flags(dbus_object_manager_client_ptr)
        let rv = DBusObjectManagerClientFlags(result)
            return rv
        }
    }

    /// The well-known name or unique name that the manager is for.
    @inlinable var name: String! {
        /// Gets the name that `manager` is for, or `nil` if not a message bus
        /// connection.
        get {
            let result = g_dbus_object_manager_client_get_name(dbus_object_manager_client_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// The unique name that owns the name that `manager` is for or `nil` if
    /// no-one currently owns that name. You can connect to the
    /// `GObject::notify` signal to track changes to the
    /// `GDBusObjectManagerClient:name-owner` property.
    @inlinable var nameOwner: String! {
        /// The unique name that owns the name that `manager` is for or `nil` if
        /// no-one currently owns that name. You can connect to the
        /// `GObject::notify` signal to track changes to the
        /// `GDBusObjectManagerClient:name-owner` property.
        get {
            let result = g_dbus_object_manager_client_get_name_owner(dbus_object_manager_client_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    // var parentInstance is unavailable because parent_instance is private

    // var priv is unavailable because priv is private

}



// MARK: - DBusObjectManagerServer Class

/// `GDBusObjectManagerServer` is used to export `GDBusObject` instances using
/// the standardized
/// [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html`standard-interfaces-objectmanager`)
/// interface. For example, remote D-Bus clients can get all objects
/// and properties in a single call. Additionally, any change in the
/// object hierarchy is broadcast using signals. This means that D-Bus
/// clients can keep caches up to date by only listening to D-Bus
/// signals.
/// 
/// The recommended path to export an object manager at is the path form of the
/// well-known name of a D-Bus service, or below. For example, if a D-Bus service
/// is available at the well-known name `net.example.ExampleService1`, the object
/// manager should typically be exported at `/net/example/ExampleService1`, or
/// below (to allow for multiple object managers in a service).
/// 
/// It is supported, but not recommended, to export an object manager at the root
/// path, `/`.
/// 
/// See `GDBusObjectManagerClient` for the client-side code that is
/// intended to be used with `GDBusObjectManagerServer` or any D-Bus
/// object implementing the org.freedesktop.DBus.ObjectManager
/// interface.
///
/// The `DBusObjectManagerServerProtocol` protocol exposes the methods and properties of an underlying `GDBusObjectManagerServer` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusObjectManagerServer`.
/// Alternatively, use `DBusObjectManagerServerRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusObjectManagerServerProtocol: GLibObject.ObjectProtocol, DBusObjectManagerProtocol {
        /// Untyped pointer to the underlying `GDBusObjectManagerServer` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusObjectManagerServer` instance.
    var dbus_object_manager_server_ptr: UnsafeMutablePointer<GDBusObjectManagerServer>! { get }

    /// Required Initialiser for types conforming to `DBusObjectManagerServerProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GDBusObjectManagerServer` is used to export `GDBusObject` instances using
/// the standardized
/// [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html`standard-interfaces-objectmanager`)
/// interface. For example, remote D-Bus clients can get all objects
/// and properties in a single call. Additionally, any change in the
/// object hierarchy is broadcast using signals. This means that D-Bus
/// clients can keep caches up to date by only listening to D-Bus
/// signals.
/// 
/// The recommended path to export an object manager at is the path form of the
/// well-known name of a D-Bus service, or below. For example, if a D-Bus service
/// is available at the well-known name `net.example.ExampleService1`, the object
/// manager should typically be exported at `/net/example/ExampleService1`, or
/// below (to allow for multiple object managers in a service).
/// 
/// It is supported, but not recommended, to export an object manager at the root
/// path, `/`.
/// 
/// See `GDBusObjectManagerClient` for the client-side code that is
/// intended to be used with `GDBusObjectManagerServer` or any D-Bus
/// object implementing the org.freedesktop.DBus.ObjectManager
/// interface.
///
/// The `DBusObjectManagerServerRef` type acts as a lightweight Swift reference to an underlying `GDBusObjectManagerServer` instance.
/// It exposes methods that can operate on this data type through `DBusObjectManagerServerProtocol` conformance.
/// Use `DBusObjectManagerServerRef` only as an `unowned` reference to an existing `GDBusObjectManagerServer` instance.
///
public struct DBusObjectManagerServerRef: DBusObjectManagerServerProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GDBusObjectManagerServer` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_object_manager_server_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusObjectManagerServerRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusObjectManagerServer>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusObjectManagerServer>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusObjectManagerServer>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusObjectManagerServer>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusObjectManagerServerProtocol`
    @inlinable init<T: DBusObjectManagerServerProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: DBusObjectManagerServerProtocol>(_ other: T) -> DBusObjectManagerServerRef { DBusObjectManagerServerRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerServerProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerServerProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerServerProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerServerProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerServerProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GDBusObjectManagerServer` object.
    /// 
    /// The returned server isn't yet exported on any connection. To do so,
    /// use `g_dbus_object_manager_server_set_connection()`. Normally you
    /// want to export all of your objects before doing so to avoid
    /// [InterfacesAdded](http://dbus.freedesktop.org/doc/dbus-specification.html`standard-interfaces-objectmanager`)
    /// signals being emitted.
    @inlinable init( objectPath: UnsafePointer<gchar>!) {
            let result = g_dbus_object_manager_server_new(objectPath)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GDBusObjectManagerServer` is used to export `GDBusObject` instances using
/// the standardized
/// [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html`standard-interfaces-objectmanager`)
/// interface. For example, remote D-Bus clients can get all objects
/// and properties in a single call. Additionally, any change in the
/// object hierarchy is broadcast using signals. This means that D-Bus
/// clients can keep caches up to date by only listening to D-Bus
/// signals.
/// 
/// The recommended path to export an object manager at is the path form of the
/// well-known name of a D-Bus service, or below. For example, if a D-Bus service
/// is available at the well-known name `net.example.ExampleService1`, the object
/// manager should typically be exported at `/net/example/ExampleService1`, or
/// below (to allow for multiple object managers in a service).
/// 
/// It is supported, but not recommended, to export an object manager at the root
/// path, `/`.
/// 
/// See `GDBusObjectManagerClient` for the client-side code that is
/// intended to be used with `GDBusObjectManagerServer` or any D-Bus
/// object implementing the org.freedesktop.DBus.ObjectManager
/// interface.
///
/// The `DBusObjectManagerServer` type acts as a reference-counted owner of an underlying `GDBusObjectManagerServer` instance.
/// It provides the methods that can operate on this data type through `DBusObjectManagerServerProtocol` conformance.
/// Use `DBusObjectManagerServer` as a strong reference or owner of a `GDBusObjectManagerServer` instance.
///
open class DBusObjectManagerServer: GLibObject.Object, DBusObjectManagerServerProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectManagerServer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusObjectManagerServer>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectManagerServer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusObjectManagerServer>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectManagerServer` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectManagerServer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectManagerServer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusObjectManagerServer>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectManagerServer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusObjectManagerServer>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDBusObjectManagerServer`.
    /// i.e., ownership is transferred to the `DBusObjectManagerServer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusObjectManagerServer>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DBusObjectManagerServerProtocol`
    /// Will retain `GDBusObjectManagerServer`.
    /// - Parameter other: an instance of a related type that implements `DBusObjectManagerServerProtocol`
    @inlinable public init<T: DBusObjectManagerServerProtocol>(dBusObjectManagerServer other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerServerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerServerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerServerProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerServerProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerServerProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerServerProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerServerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectManagerServerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GDBusObjectManagerServer` object.
    /// 
    /// The returned server isn't yet exported on any connection. To do so,
    /// use `g_dbus_object_manager_server_set_connection()`. Normally you
    /// want to export all of your objects before doing so to avoid
    /// [InterfacesAdded](http://dbus.freedesktop.org/doc/dbus-specification.html`standard-interfaces-objectmanager`)
    /// signals being emitted.
    @inlinable public init( objectPath: UnsafePointer<gchar>!) {
            let result = g_dbus_object_manager_server_new(objectPath)
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum DBusObjectManagerServerPropertyName: String, PropertyNameProtocol {
    /// The `GDBusConnection` to export objects on.
    case connection = "connection"
    /// The object path to register the manager object at.
    case objectPath = "object-path"
}

public extension DBusObjectManagerServerProtocol {
    /// Bind a `DBusObjectManagerServerPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: DBusObjectManagerServerPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a DBusObjectManagerServer property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: DBusObjectManagerServerPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a DBusObjectManagerServer property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: DBusObjectManagerServerPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum DBusObjectManagerServerSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `GDBusConnection` to export objects on.
    case notifyConnection = "notify::connection"
    /// The object path to register the manager object at.
    case notifyObjectPath = "notify::object-path"
}

// MARK: DBusObjectManagerServer has no signals
// MARK: DBusObjectManagerServer Class: DBusObjectManagerServerProtocol extension (methods and fields)
public extension DBusObjectManagerServerProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusObjectManagerServer` instance.
    @inlinable var dbus_object_manager_server_ptr: UnsafeMutablePointer<GDBusObjectManagerServer>! { return ptr?.assumingMemoryBound(to: GDBusObjectManagerServer.self) }

    /// Exports `object` on `manager`.
    /// 
    /// If there is already a `GDBusObject` exported at the object path,
    /// then the old object is removed.
    /// 
    /// The object path for `object` must be in the hierarchy rooted by the
    /// object path for `manager`.
    /// 
    /// Note that `manager` will take a reference on `object` for as long as
    /// it is exported.
    @inlinable func export<DBusObjectSkeletonT: DBusObjectSkeletonProtocol>(object: DBusObjectSkeletonT) {
        
        g_dbus_object_manager_server_export(dbus_object_manager_server_ptr, object.dbus_object_skeleton_ptr)
        
    }

    /// Like `g_dbus_object_manager_server_export()` but appends a string of
    /// the form _N (with N being a natural number) to `object`'s object path
    /// if an object with the given path already exists. As such, the
    /// `GDBusObjectProxy:g-object-path` property of `object` may be modified.
    @inlinable func exportUniquely<DBusObjectSkeletonT: DBusObjectSkeletonProtocol>(object: DBusObjectSkeletonT) {
        
        g_dbus_object_manager_server_export_uniquely(dbus_object_manager_server_ptr, object.dbus_object_skeleton_ptr)
        
    }

    /// Gets the `GDBusConnection` used by `manager`.
    @inlinable func getConnection() -> GIO.DBusConnectionRef! {
        let result = g_dbus_object_manager_server_get_connection(dbus_object_manager_server_ptr)
        let rv = DBusConnectionRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns whether `object` is currently exported on `manager`.
    @inlinable func isExported<DBusObjectSkeletonT: DBusObjectSkeletonProtocol>(object: DBusObjectSkeletonT) -> Bool {
        let result = g_dbus_object_manager_server_is_exported(dbus_object_manager_server_ptr, object.dbus_object_skeleton_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Exports all objects managed by `manager` on `connection`. If
    /// `connection` is `nil`, stops exporting objects.
    @inlinable func set(connection: DBusConnectionRef? = nil) {
            
        g_dbus_object_manager_server_set_connection(dbus_object_manager_server_ptr, connection?.dbus_connection_ptr)
            
    }
    /// Exports all objects managed by `manager` on `connection`. If
    /// `connection` is `nil`, stops exporting objects.
    @inlinable func set<DBusConnectionT: DBusConnectionProtocol>(connection: DBusConnectionT?) {
        
        g_dbus_object_manager_server_set_connection(dbus_object_manager_server_ptr, connection?.dbus_connection_ptr)
        
    }

    /// If `manager` has an object at `path`, removes the object. Otherwise
    /// does nothing.
    /// 
    /// Note that `object_path` must be in the hierarchy rooted by the
    /// object path for `manager`.
    @inlinable func unexport(objectPath: UnsafePointer<gchar>!) -> Bool {
        let result = g_dbus_object_manager_server_unexport(dbus_object_manager_server_ptr, objectPath)
        let rv = ((result) != 0)
        return rv
    }
    /// The `GDBusConnection` to export objects on.
    @inlinable var connection: GIO.DBusConnectionRef! {
        /// Gets the `GDBusConnection` used by `manager`.
        get {
            let result = g_dbus_object_manager_server_get_connection(dbus_object_manager_server_ptr)
        let rv = DBusConnectionRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Exports all objects managed by `manager` on `connection`. If
        /// `connection` is `nil`, stops exporting objects.
        nonmutating set {
            g_dbus_object_manager_server_set_connection(dbus_object_manager_server_ptr, UnsafeMutablePointer<GDBusConnection>(newValue?.dbus_connection_ptr))
        }
    }

    // var parentInstance is unavailable because parent_instance is private

    // var priv is unavailable because priv is private

}



// MARK: - DBusObjectProxy Class

/// A `GDBusObjectProxy` is an object used to represent a remote object
/// with one or more D-Bus interfaces. Normally, you don't instantiate
/// a `GDBusObjectProxy` yourself - typically `GDBusObjectManagerClient`
/// is used to obtain it.
///
/// The `DBusObjectProxyProtocol` protocol exposes the methods and properties of an underlying `GDBusObjectProxy` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusObjectProxy`.
/// Alternatively, use `DBusObjectProxyRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusObjectProxyProtocol: GLibObject.ObjectProtocol, DBusObjectProtocol {
        /// Untyped pointer to the underlying `GDBusObjectProxy` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusObjectProxy` instance.
    var dbus_object_proxy_ptr: UnsafeMutablePointer<GDBusObjectProxy>! { get }

    /// Required Initialiser for types conforming to `DBusObjectProxyProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GDBusObjectProxy` is an object used to represent a remote object
/// with one or more D-Bus interfaces. Normally, you don't instantiate
/// a `GDBusObjectProxy` yourself - typically `GDBusObjectManagerClient`
/// is used to obtain it.
///
/// The `DBusObjectProxyRef` type acts as a lightweight Swift reference to an underlying `GDBusObjectProxy` instance.
/// It exposes methods that can operate on this data type through `DBusObjectProxyProtocol` conformance.
/// Use `DBusObjectProxyRef` only as an `unowned` reference to an existing `GDBusObjectProxy` instance.
///
public struct DBusObjectProxyRef: DBusObjectProxyProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GDBusObjectProxy` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_object_proxy_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusObjectProxyRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusObjectProxy>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusObjectProxy>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusObjectProxy>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusObjectProxy>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusObjectProxyProtocol`
    @inlinable init<T: DBusObjectProxyProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: DBusObjectProxyProtocol>(_ other: T) -> DBusObjectProxyRef { DBusObjectProxyRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProxyProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProxyProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProxyProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProxyProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProxyProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GDBusObjectProxy` for the given connection and
    /// object path.
    @inlinable init<DBusConnectionT: DBusConnectionProtocol>( connection: DBusConnectionT, objectPath: UnsafePointer<gchar>!) {
            let result = g_dbus_object_proxy_new(connection.dbus_connection_ptr, objectPath)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// A `GDBusObjectProxy` is an object used to represent a remote object
/// with one or more D-Bus interfaces. Normally, you don't instantiate
/// a `GDBusObjectProxy` yourself - typically `GDBusObjectManagerClient`
/// is used to obtain it.
///
/// The `DBusObjectProxy` type acts as a reference-counted owner of an underlying `GDBusObjectProxy` instance.
/// It provides the methods that can operate on this data type through `DBusObjectProxyProtocol` conformance.
/// Use `DBusObjectProxy` as a strong reference or owner of a `GDBusObjectProxy` instance.
///
open class DBusObjectProxy: GLibObject.Object, DBusObjectProxyProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectProxy` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusObjectProxy>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectProxy` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusObjectProxy>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectProxy` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectProxy` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectProxy` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusObjectProxy>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectProxy` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusObjectProxy>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDBusObjectProxy`.
    /// i.e., ownership is transferred to the `DBusObjectProxy` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusObjectProxy>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DBusObjectProxyProtocol`
    /// Will retain `GDBusObjectProxy`.
    /// - Parameter other: an instance of a related type that implements `DBusObjectProxyProtocol`
    @inlinable public init<T: DBusObjectProxyProtocol>(dBusObjectProxy other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProxyProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProxyProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProxyProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProxyProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProxyProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProxyProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProxyProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectProxyProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GDBusObjectProxy` for the given connection and
    /// object path.
    @inlinable public init<DBusConnectionT: DBusConnectionProtocol>( connection: DBusConnectionT, objectPath: UnsafePointer<gchar>!) {
            let result = g_dbus_object_proxy_new(connection.dbus_connection_ptr, objectPath)
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum DBusObjectProxyPropertyName: String, PropertyNameProtocol {
    /// The connection of the proxy.
    case gConnection = "g-connection"
    /// The object path of the proxy.
    case gObjectPath = "g-object-path"
}

public extension DBusObjectProxyProtocol {
    /// Bind a `DBusObjectProxyPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: DBusObjectProxyPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a DBusObjectProxy property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: DBusObjectProxyPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a DBusObjectProxy property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: DBusObjectProxyPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum DBusObjectProxySignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The connection of the proxy.
    case notifyGConnection = "notify::g-connection"
    /// The object path of the proxy.
    case notifyGObjectPath = "notify::g-object-path"
}

// MARK: DBusObjectProxy has no signals
// MARK: DBusObjectProxy Class: DBusObjectProxyProtocol extension (methods and fields)
public extension DBusObjectProxyProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusObjectProxy` instance.
    @inlinable var dbus_object_proxy_ptr: UnsafeMutablePointer<GDBusObjectProxy>! { return ptr?.assumingMemoryBound(to: GDBusObjectProxy.self) }

    /// Gets the connection that `proxy` is for.
    @inlinable func getConnection() -> GIO.DBusConnectionRef! {
        let result = g_dbus_object_proxy_get_connection(dbus_object_proxy_ptr)
        let rv = DBusConnectionRef(gconstpointer: gconstpointer(result))
        return rv
    }
    /// Gets the connection that `proxy` is for.
    @inlinable var connection: GIO.DBusConnectionRef! {
        /// Gets the connection that `proxy` is for.
        get {
            let result = g_dbus_object_proxy_get_connection(dbus_object_proxy_ptr)
        let rv = DBusConnectionRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    // var parentInstance is unavailable because parent_instance is private

    // var priv is unavailable because priv is private

}



// MARK: - DBusObjectSkeleton Class

/// A `GDBusObjectSkeleton` instance is essentially a group of D-Bus
/// interfaces. The set of exported interfaces on the object may be
/// dynamic and change at runtime.
/// 
/// This type is intended to be used with `GDBusObjectManager`.
///
/// The `DBusObjectSkeletonProtocol` protocol exposes the methods and properties of an underlying `GDBusObjectSkeleton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusObjectSkeleton`.
/// Alternatively, use `DBusObjectSkeletonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusObjectSkeletonProtocol: GLibObject.ObjectProtocol, DBusObjectProtocol {
        /// Untyped pointer to the underlying `GDBusObjectSkeleton` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusObjectSkeleton` instance.
    var dbus_object_skeleton_ptr: UnsafeMutablePointer<GDBusObjectSkeleton>! { get }

    /// Required Initialiser for types conforming to `DBusObjectSkeletonProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GDBusObjectSkeleton` instance is essentially a group of D-Bus
/// interfaces. The set of exported interfaces on the object may be
/// dynamic and change at runtime.
/// 
/// This type is intended to be used with `GDBusObjectManager`.
///
/// The `DBusObjectSkeletonRef` type acts as a lightweight Swift reference to an underlying `GDBusObjectSkeleton` instance.
/// It exposes methods that can operate on this data type through `DBusObjectSkeletonProtocol` conformance.
/// Use `DBusObjectSkeletonRef` only as an `unowned` reference to an existing `GDBusObjectSkeleton` instance.
///
public struct DBusObjectSkeletonRef: DBusObjectSkeletonProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GDBusObjectSkeleton` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_object_skeleton_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusObjectSkeletonRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusObjectSkeleton>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusObjectSkeleton>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusObjectSkeleton>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusObjectSkeleton>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusObjectSkeletonProtocol`
    @inlinable init<T: DBusObjectSkeletonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: DBusObjectSkeletonProtocol>(_ other: T) -> DBusObjectSkeletonRef { DBusObjectSkeletonRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectSkeletonProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectSkeletonProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectSkeletonProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectSkeletonProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectSkeletonProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GDBusObjectSkeleton`.
    @inlinable init( objectPath: UnsafePointer<gchar>!) {
            let result = g_dbus_object_skeleton_new(objectPath)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// A `GDBusObjectSkeleton` instance is essentially a group of D-Bus
/// interfaces. The set of exported interfaces on the object may be
/// dynamic and change at runtime.
/// 
/// This type is intended to be used with `GDBusObjectManager`.
///
/// The `DBusObjectSkeleton` type acts as a reference-counted owner of an underlying `GDBusObjectSkeleton` instance.
/// It provides the methods that can operate on this data type through `DBusObjectSkeletonProtocol` conformance.
/// Use `DBusObjectSkeleton` as a strong reference or owner of a `GDBusObjectSkeleton` instance.
///
open class DBusObjectSkeleton: GLibObject.Object, DBusObjectSkeletonProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectSkeleton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusObjectSkeleton>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectSkeleton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusObjectSkeleton>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectSkeleton` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectSkeleton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectSkeleton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusObjectSkeleton>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusObjectSkeleton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusObjectSkeleton>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDBusObjectSkeleton`.
    /// i.e., ownership is transferred to the `DBusObjectSkeleton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusObjectSkeleton>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DBusObjectSkeletonProtocol`
    /// Will retain `GDBusObjectSkeleton`.
    /// - Parameter other: an instance of a related type that implements `DBusObjectSkeletonProtocol`
    @inlinable public init<T: DBusObjectSkeletonProtocol>(dBusObjectSkeleton other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectSkeletonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectSkeletonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectSkeletonProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectSkeletonProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectSkeletonProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectSkeletonProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectSkeletonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusObjectSkeletonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GDBusObjectSkeleton`.
    @inlinable public init( objectPath: UnsafePointer<gchar>!) {
            let result = g_dbus_object_skeleton_new(objectPath)
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum DBusObjectSkeletonPropertyName: String, PropertyNameProtocol {
    /// The object path where the object is exported.
    case gObjectPath = "g-object-path"
}

public extension DBusObjectSkeletonProtocol {
    /// Bind a `DBusObjectSkeletonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: DBusObjectSkeletonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a DBusObjectSkeleton property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: DBusObjectSkeletonPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a DBusObjectSkeleton property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: DBusObjectSkeletonPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum DBusObjectSkeletonSignalName: String, SignalNameProtocol {
    /// Emitted when a method is invoked by a remote caller and used to
    /// determine if the method call is authorized.
    /// 
    /// This signal is like `GDBusInterfaceSkeleton`'s
    /// `GDBusInterfaceSkeleton::g-authorize-method` signal,
    /// except that it is for the enclosing object.
    /// 
    /// The default class handler just returns `true`.
    case authorizeMethod = "authorize-method"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The object path where the object is exported.
    case notifyGObjectPath = "notify::g-object-path"
}

// MARK: DBusObjectSkeleton signals
public extension DBusObjectSkeletonProtocol {
    /// Connect a Swift signal handler to the given, typed `DBusObjectSkeletonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DBusObjectSkeletonSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `DBusObjectSkeletonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DBusObjectSkeletonSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when a method is invoked by a remote caller and used to
    /// determine if the method call is authorized.
    /// 
    /// This signal is like `GDBusInterfaceSkeleton`'s
    /// `GDBusInterfaceSkeleton::g-authorize-method` signal,
    /// except that it is for the enclosing object.
    /// 
    /// The default class handler just returns `true`.
    /// - Note: This represents the underlying `authorize-method` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter interface: The `GDBusInterfaceSkeleton` that `invocation` is for.
    /// - Parameter invocation: A `GDBusMethodInvocation`.
    /// - Parameter handler: `true` if the call is authorized, `false` otherwise.
    /// Run the given callback whenever the `authorizeMethod` signal is emitted
    @discardableResult @inlinable func onAuthorizeMethod(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusObjectSkeletonRef, _ interface: DBusInterfaceSkeletonRef, _ invocation: DBusMethodInvocationRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusObjectSkeletonRef, DBusInterfaceSkeletonRef, DBusMethodInvocationRef), Bool>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> gboolean = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call((DBusObjectSkeletonRef(raw: unownedSelf), DBusInterfaceSkeletonRef(raw: arg1), DBusMethodInvocationRef(raw: arg2)))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .authorizeMethod,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `authorize-method` signal for using the `connect(signal:)` methods
    static var authorizeMethodSignal: DBusObjectSkeletonSignalName { .authorizeMethod }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::g-object-path` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyGObjectPath` signal is emitted
    @discardableResult @inlinable func onNotifyGObjectPath(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusObjectSkeletonRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusObjectSkeletonRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusObjectSkeletonRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyGObjectPath,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::g-object-path` signal for using the `connect(signal:)` methods
    static var notifyGObjectPathSignal: DBusObjectSkeletonSignalName { .notifyGObjectPath }
    
}

// MARK: DBusObjectSkeleton Class: DBusObjectSkeletonProtocol extension (methods and fields)
public extension DBusObjectSkeletonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusObjectSkeleton` instance.
    @inlinable var dbus_object_skeleton_ptr: UnsafeMutablePointer<GDBusObjectSkeleton>! { return ptr?.assumingMemoryBound(to: GDBusObjectSkeleton.self) }

    /// Adds `interface_` to `object`.
    /// 
    /// If `object` already contains a `GDBusInterfaceSkeleton` with the same
    /// interface name, it is removed before `interface_` is added.
    /// 
    /// Note that `object` takes its own reference on `interface_` and holds
    /// it until removed.
    @inlinable func add<DBusInterfaceSkeletonT: DBusInterfaceSkeletonProtocol>(interface: DBusInterfaceSkeletonT) {
        
        g_dbus_object_skeleton_add_interface(dbus_object_skeleton_ptr, interface.dbus_interface_skeleton_ptr)
        
    }

    /// This method simply calls `g_dbus_interface_skeleton_flush()` on all
    /// interfaces belonging to `object`. See that method for when flushing
    /// is useful.
    @inlinable func flush() {
        
        g_dbus_object_skeleton_flush(dbus_object_skeleton_ptr)
        
    }

    /// Removes `interface_` from `object`.
    @inlinable func remove<DBusInterfaceSkeletonT: DBusInterfaceSkeletonProtocol>(interface: DBusInterfaceSkeletonT) {
        
        g_dbus_object_skeleton_remove_interface(dbus_object_skeleton_ptr, interface.dbus_interface_skeleton_ptr)
        
    }

    /// Removes the `GDBusInterface` with `interface_name` from `object`.
    /// 
    /// If no D-Bus interface of the given interface exists, this function
    /// does nothing.
    @inlinable func removeInterfaceByName(interfaceName: UnsafePointer<gchar>!) {
        
        g_dbus_object_skeleton_remove_interface_by_name(dbus_object_skeleton_ptr, interfaceName)
        
    }

    /// Sets the object path for `object`.
    @inlinable func set(objectPath: UnsafePointer<gchar>!) {
        
        g_dbus_object_skeleton_set_object_path(dbus_object_skeleton_ptr, objectPath)
        
    }

    // var parentInstance is unavailable because parent_instance is private

    // var priv is unavailable because priv is private

}



// MARK: - DBusProxy Class

/// `GDBusProxy` is a base class used for proxies to access a D-Bus
/// interface on a remote object. A `GDBusProxy` can be constructed for
/// both well-known and unique names.
/// 
/// By default, `GDBusProxy` will cache all properties (and listen to
/// changes) of the remote object, and proxy all signals that get
/// emitted. This behaviour can be changed by passing suitable
/// `GDBusProxyFlags` when the proxy is created. If the proxy is for a
/// well-known name, the property cache is flushed when the name owner
/// vanishes and reloaded when a name owner appears.
/// 
/// The unique name owner of the proxy's name is tracked and can be read from
/// `GDBusProxy:g-name-owner`. Connect to the `GObject::notify` signal to
/// get notified of changes. Additionally, only signals and property
/// changes emitted from the current name owner are considered and
/// calls are always sent to the current name owner. This avoids a
/// number of race conditions when the name is lost by one owner and
/// claimed by another. However, if no name owner currently exists,
/// then calls will be sent to the well-known name which may result in
/// the message bus launching an owner (unless
/// `G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START` is set).
/// 
/// If the proxy is for a stateless D-Bus service, where the name owner may
/// be started and stopped between calls, the `GDBusProxy:g-name-owner` tracking
/// of `GDBusProxy` will cause the proxy to drop signal and property changes from
/// the service after it has restarted for the first time. When interacting
/// with a stateless D-Bus service, do not use `GDBusProxy`  use direct D-Bus
/// method calls and signal connections.
/// 
/// The generic `GDBusProxy::g-properties-changed` and
/// `GDBusProxy::g-signal` signals are not very convenient to work with.
/// Therefore, the recommended way of working with proxies is to subclass
/// `GDBusProxy`, and have more natural properties and signals in your derived
/// class. This [example](#gdbus-example-gdbus-codegen) shows how this can
/// easily be done using the [gdbus-codegen](#gdbus-codegen) tool.
/// 
/// A `GDBusProxy` instance can be used from multiple threads but note
/// that all signals (e.g. `GDBusProxy::g-signal`, `GDBusProxy::g-properties-changed`
/// and `GObject::notify`) are emitted in the
/// [thread-default main context](#g-main-context-push-thread-default)
/// of the thread where the instance was constructed.
/// 
/// An example using a proxy for a well-known name can be found in
/// [gdbus-example-watch-proxy.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-watch-proxy.c)
///
/// The `DBusProxyProtocol` protocol exposes the methods and properties of an underlying `GDBusProxy` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusProxy`.
/// Alternatively, use `DBusProxyRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusProxyProtocol: GLibObject.ObjectProtocol, AsyncInitableProtocol, DBusInterfaceProtocol, InitableProtocol {
        /// Untyped pointer to the underlying `GDBusProxy` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusProxy` instance.
    var dbus_proxy_ptr: UnsafeMutablePointer<GDBusProxy>! { get }

    /// Required Initialiser for types conforming to `DBusProxyProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GDBusProxy` is a base class used for proxies to access a D-Bus
/// interface on a remote object. A `GDBusProxy` can be constructed for
/// both well-known and unique names.
/// 
/// By default, `GDBusProxy` will cache all properties (and listen to
/// changes) of the remote object, and proxy all signals that get
/// emitted. This behaviour can be changed by passing suitable
/// `GDBusProxyFlags` when the proxy is created. If the proxy is for a
/// well-known name, the property cache is flushed when the name owner
/// vanishes and reloaded when a name owner appears.
/// 
/// The unique name owner of the proxy's name is tracked and can be read from
/// `GDBusProxy:g-name-owner`. Connect to the `GObject::notify` signal to
/// get notified of changes. Additionally, only signals and property
/// changes emitted from the current name owner are considered and
/// calls are always sent to the current name owner. This avoids a
/// number of race conditions when the name is lost by one owner and
/// claimed by another. However, if no name owner currently exists,
/// then calls will be sent to the well-known name which may result in
/// the message bus launching an owner (unless
/// `G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START` is set).
/// 
/// If the proxy is for a stateless D-Bus service, where the name owner may
/// be started and stopped between calls, the `GDBusProxy:g-name-owner` tracking
/// of `GDBusProxy` will cause the proxy to drop signal and property changes from
/// the service after it has restarted for the first time. When interacting
/// with a stateless D-Bus service, do not use `GDBusProxy`  use direct D-Bus
/// method calls and signal connections.
/// 
/// The generic `GDBusProxy::g-properties-changed` and
/// `GDBusProxy::g-signal` signals are not very convenient to work with.
/// Therefore, the recommended way of working with proxies is to subclass
/// `GDBusProxy`, and have more natural properties and signals in your derived
/// class. This [example](#gdbus-example-gdbus-codegen) shows how this can
/// easily be done using the [gdbus-codegen](#gdbus-codegen) tool.
/// 
/// A `GDBusProxy` instance can be used from multiple threads but note
/// that all signals (e.g. `GDBusProxy::g-signal`, `GDBusProxy::g-properties-changed`
/// and `GObject::notify`) are emitted in the
/// [thread-default main context](#g-main-context-push-thread-default)
/// of the thread where the instance was constructed.
/// 
/// An example using a proxy for a well-known name can be found in
/// [gdbus-example-watch-proxy.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-watch-proxy.c)
///
/// The `DBusProxyRef` type acts as a lightweight Swift reference to an underlying `GDBusProxy` instance.
/// It exposes methods that can operate on this data type through `DBusProxyProtocol` conformance.
/// Use `DBusProxyRef` only as an `unowned` reference to an existing `GDBusProxy` instance.
///
public struct DBusProxyRef: DBusProxyProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GDBusProxy` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_proxy_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusProxyRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusProxy>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusProxy>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusProxy>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusProxy>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusProxyProtocol`
    @inlinable init<T: DBusProxyProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: DBusProxyProtocol>(_ other: T) -> DBusProxyRef { DBusProxyRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusProxyProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusProxyProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusProxyProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusProxyProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusProxyProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Finishes creating a `GDBusProxy`.
    @inlinable init<AsyncResultT: AsyncResultProtocol>(finish res: AsyncResultT) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_new_finish(res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Finishes creating a `GDBusProxy`.
    @inlinable init<AsyncResultT: AsyncResultProtocol>(busFinish res: AsyncResultT) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_new_for_bus_finish(res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Like `g_dbus_proxy_new_sync()` but takes a `GBusType` instead of a `GDBusConnection`.
    /// 
    /// `GDBusProxy` is used in this [example](#gdbus-wellknown-proxy).
    @inlinable init<CancellableT: CancellableProtocol, DBusInterfaceInfoT: DBusInterfaceInfoProtocol>(busSync busType: GBusType, flags: DBusProxyFlags, info: DBusInterfaceInfoT?, name: UnsafePointer<gchar>!, objectPath: UnsafePointer<gchar>!, interfaceName: UnsafePointer<gchar>!, cancellable: CancellableT?) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_new_for_bus_sync(busType, flags.value, info?.dbus_interface_info_ptr, name, objectPath, interfaceName, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a proxy for accessing `interface_name` on the remote object
    /// at `object_path` owned by `name` at `connection` and synchronously
    /// loads D-Bus properties unless the
    /// `G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES` flag is used.
    /// 
    /// If the `G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS` flag is not set, also sets up
    /// match rules for signals. Connect to the `GDBusProxy::g-signal` signal
    /// to handle signals from the remote object.
    /// 
    /// If both `G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES` and
    /// `G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS` are set, this constructor is
    /// guaranteed to return immediately without blocking.
    /// 
    /// If `name` is a well-known name and the
    /// `G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START` and `G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION`
    /// flags aren't set and no name owner currently exists, the message bus
    /// will be requested to launch a name owner for the name.
    /// 
    /// This is a synchronous failable constructor. See `g_dbus_proxy_new()`
    /// and `g_dbus_proxy_new_finish()` for the asynchronous version.
    /// 
    /// `GDBusProxy` is used in this [example](#gdbus-wellknown-proxy).
    @inlinable init<CancellableT: CancellableProtocol, DBusConnectionT: DBusConnectionProtocol, DBusInterfaceInfoT: DBusInterfaceInfoProtocol>(sync connection: DBusConnectionT, flags: DBusProxyFlags, info: DBusInterfaceInfoT?, name: UnsafePointer<gchar>? = nil, objectPath: UnsafePointer<gchar>!, interfaceName: UnsafePointer<gchar>!, cancellable: CancellableT?) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_new_sync(connection.dbus_connection_ptr, flags.value, info?.dbus_interface_info_ptr, name, objectPath, interfaceName, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
    /// Finishes creating a `GDBusProxy`.
    @inlinable static func new<AsyncResultT: AsyncResultProtocol>(finish res: AsyncResultT) throws -> GIO.DBusProxyRef! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_new_finish(res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusProxyRef(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
        return rv
    }

    /// Finishes creating a `GDBusProxy`.
    @inlinable static func newFor<AsyncResultT: AsyncResultProtocol>(busFinish res: AsyncResultT) throws -> GIO.DBusProxyRef! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_new_for_bus_finish(res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusProxyRef(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
        return rv
    }

    /// Like `g_dbus_proxy_new_sync()` but takes a `GBusType` instead of a `GDBusConnection`.
    /// 
    /// `GDBusProxy` is used in this [example](#gdbus-wellknown-proxy).
    @inlinable static func newFor<CancellableT: CancellableProtocol, DBusInterfaceInfoT: DBusInterfaceInfoProtocol>(busSync busType: GBusType, flags: DBusProxyFlags, info: DBusInterfaceInfoT?, name: UnsafePointer<gchar>!, objectPath: UnsafePointer<gchar>!, interfaceName: UnsafePointer<gchar>!, cancellable: CancellableT?) throws -> GIO.DBusProxyRef! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_new_for_bus_sync(busType, flags.value, info?.dbus_interface_info_ptr, name, objectPath, interfaceName, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusProxyRef(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
        return rv
    }

    /// Creates a proxy for accessing `interface_name` on the remote object
    /// at `object_path` owned by `name` at `connection` and synchronously
    /// loads D-Bus properties unless the
    /// `G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES` flag is used.
    /// 
    /// If the `G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS` flag is not set, also sets up
    /// match rules for signals. Connect to the `GDBusProxy::g-signal` signal
    /// to handle signals from the remote object.
    /// 
    /// If both `G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES` and
    /// `G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS` are set, this constructor is
    /// guaranteed to return immediately without blocking.
    /// 
    /// If `name` is a well-known name and the
    /// `G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START` and `G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION`
    /// flags aren't set and no name owner currently exists, the message bus
    /// will be requested to launch a name owner for the name.
    /// 
    /// This is a synchronous failable constructor. See `g_dbus_proxy_new()`
    /// and `g_dbus_proxy_new_finish()` for the asynchronous version.
    /// 
    /// `GDBusProxy` is used in this [example](#gdbus-wellknown-proxy).
    @inlinable static func new<CancellableT: CancellableProtocol, DBusConnectionT: DBusConnectionProtocol, DBusInterfaceInfoT: DBusInterfaceInfoProtocol>(sync connection: DBusConnectionT, flags: DBusProxyFlags, info: DBusInterfaceInfoT?, name: UnsafePointer<gchar>? = nil, objectPath: UnsafePointer<gchar>!, interfaceName: UnsafePointer<gchar>!, cancellable: CancellableT?) throws -> GIO.DBusProxyRef! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_new_sync(connection.dbus_connection_ptr, flags.value, info?.dbus_interface_info_ptr, name, objectPath, interfaceName, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusProxyRef(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
        return rv
    }
}

/// `GDBusProxy` is a base class used for proxies to access a D-Bus
/// interface on a remote object. A `GDBusProxy` can be constructed for
/// both well-known and unique names.
/// 
/// By default, `GDBusProxy` will cache all properties (and listen to
/// changes) of the remote object, and proxy all signals that get
/// emitted. This behaviour can be changed by passing suitable
/// `GDBusProxyFlags` when the proxy is created. If the proxy is for a
/// well-known name, the property cache is flushed when the name owner
/// vanishes and reloaded when a name owner appears.
/// 
/// The unique name owner of the proxy's name is tracked and can be read from
/// `GDBusProxy:g-name-owner`. Connect to the `GObject::notify` signal to
/// get notified of changes. Additionally, only signals and property
/// changes emitted from the current name owner are considered and
/// calls are always sent to the current name owner. This avoids a
/// number of race conditions when the name is lost by one owner and
/// claimed by another. However, if no name owner currently exists,
/// then calls will be sent to the well-known name which may result in
/// the message bus launching an owner (unless
/// `G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START` is set).
/// 
/// If the proxy is for a stateless D-Bus service, where the name owner may
/// be started and stopped between calls, the `GDBusProxy:g-name-owner` tracking
/// of `GDBusProxy` will cause the proxy to drop signal and property changes from
/// the service after it has restarted for the first time. When interacting
/// with a stateless D-Bus service, do not use `GDBusProxy`  use direct D-Bus
/// method calls and signal connections.
/// 
/// The generic `GDBusProxy::g-properties-changed` and
/// `GDBusProxy::g-signal` signals are not very convenient to work with.
/// Therefore, the recommended way of working with proxies is to subclass
/// `GDBusProxy`, and have more natural properties and signals in your derived
/// class. This [example](#gdbus-example-gdbus-codegen) shows how this can
/// easily be done using the [gdbus-codegen](#gdbus-codegen) tool.
/// 
/// A `GDBusProxy` instance can be used from multiple threads but note
/// that all signals (e.g. `GDBusProxy::g-signal`, `GDBusProxy::g-properties-changed`
/// and `GObject::notify`) are emitted in the
/// [thread-default main context](#g-main-context-push-thread-default)
/// of the thread where the instance was constructed.
/// 
/// An example using a proxy for a well-known name can be found in
/// [gdbus-example-watch-proxy.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-watch-proxy.c)
///
/// The `DBusProxy` type acts as a reference-counted owner of an underlying `GDBusProxy` instance.
/// It provides the methods that can operate on this data type through `DBusProxyProtocol` conformance.
/// Use `DBusProxy` as a strong reference or owner of a `GDBusProxy` instance.
///
open class DBusProxy: GLibObject.Object, DBusProxyProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusProxy` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusProxy>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusProxy` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusProxy>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusProxy` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusProxy` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusProxy` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusProxy>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusProxy` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusProxy>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDBusProxy`.
    /// i.e., ownership is transferred to the `DBusProxy` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusProxy>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DBusProxyProtocol`
    /// Will retain `GDBusProxy`.
    /// - Parameter other: an instance of a related type that implements `DBusProxyProtocol`
    @inlinable public init<T: DBusProxyProtocol>(dBusProxy other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusProxyProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusProxyProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusProxyProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusProxyProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusProxyProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusProxyProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusProxyProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusProxyProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Finishes creating a `GDBusProxy`.
    @inlinable public init<AsyncResultT: AsyncResultProtocol>(finish res: AsyncResultT) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_new_finish(res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Finishes creating a `GDBusProxy`.
    @inlinable public init<AsyncResultT: AsyncResultProtocol>(busFinish res: AsyncResultT) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_new_for_bus_finish(res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Like `g_dbus_proxy_new_sync()` but takes a `GBusType` instead of a `GDBusConnection`.
    /// 
    /// `GDBusProxy` is used in this [example](#gdbus-wellknown-proxy).
    @inlinable public init<CancellableT: CancellableProtocol, DBusInterfaceInfoT: DBusInterfaceInfoProtocol>(busSync busType: GBusType, flags: DBusProxyFlags, info: DBusInterfaceInfoT?, name: UnsafePointer<gchar>!, objectPath: UnsafePointer<gchar>!, interfaceName: UnsafePointer<gchar>!, cancellable: CancellableT?) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_new_for_bus_sync(busType, flags.value, info?.dbus_interface_info_ptr, name, objectPath, interfaceName, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a proxy for accessing `interface_name` on the remote object
    /// at `object_path` owned by `name` at `connection` and synchronously
    /// loads D-Bus properties unless the
    /// `G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES` flag is used.
    /// 
    /// If the `G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS` flag is not set, also sets up
    /// match rules for signals. Connect to the `GDBusProxy::g-signal` signal
    /// to handle signals from the remote object.
    /// 
    /// If both `G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES` and
    /// `G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS` are set, this constructor is
    /// guaranteed to return immediately without blocking.
    /// 
    /// If `name` is a well-known name and the
    /// `G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START` and `G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION`
    /// flags aren't set and no name owner currently exists, the message bus
    /// will be requested to launch a name owner for the name.
    /// 
    /// This is a synchronous failable constructor. See `g_dbus_proxy_new()`
    /// and `g_dbus_proxy_new_finish()` for the asynchronous version.
    /// 
    /// `GDBusProxy` is used in this [example](#gdbus-wellknown-proxy).
    @inlinable public init<CancellableT: CancellableProtocol, DBusConnectionT: DBusConnectionProtocol, DBusInterfaceInfoT: DBusInterfaceInfoProtocol>(sync connection: DBusConnectionT, flags: DBusProxyFlags, info: DBusInterfaceInfoT?, name: UnsafePointer<gchar>? = nil, objectPath: UnsafePointer<gchar>!, interfaceName: UnsafePointer<gchar>!, cancellable: CancellableT?) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_new_sync(connection.dbus_connection_ptr, flags.value, info?.dbus_interface_info_ptr, name, objectPath, interfaceName, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Finishes creating a `GDBusProxy`.
    @inlinable public static func new<AsyncResultT: AsyncResultProtocol>(finish res: AsyncResultT) throws -> GIO.DBusProxy! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_new_finish(res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusProxy(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

    /// Finishes creating a `GDBusProxy`.
    @inlinable public static func newFor<AsyncResultT: AsyncResultProtocol>(busFinish res: AsyncResultT) throws -> GIO.DBusProxy! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_new_for_bus_finish(res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusProxy(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

    /// Like `g_dbus_proxy_new_sync()` but takes a `GBusType` instead of a `GDBusConnection`.
    /// 
    /// `GDBusProxy` is used in this [example](#gdbus-wellknown-proxy).
    @inlinable public static func newFor<CancellableT: CancellableProtocol, DBusInterfaceInfoT: DBusInterfaceInfoProtocol>(busSync busType: GBusType, flags: DBusProxyFlags, info: DBusInterfaceInfoT?, name: UnsafePointer<gchar>!, objectPath: UnsafePointer<gchar>!, interfaceName: UnsafePointer<gchar>!, cancellable: CancellableT?) throws -> GIO.DBusProxy! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_new_for_bus_sync(busType, flags.value, info?.dbus_interface_info_ptr, name, objectPath, interfaceName, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusProxy(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

    /// Creates a proxy for accessing `interface_name` on the remote object
    /// at `object_path` owned by `name` at `connection` and synchronously
    /// loads D-Bus properties unless the
    /// `G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES` flag is used.
    /// 
    /// If the `G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS` flag is not set, also sets up
    /// match rules for signals. Connect to the `GDBusProxy::g-signal` signal
    /// to handle signals from the remote object.
    /// 
    /// If both `G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES` and
    /// `G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS` are set, this constructor is
    /// guaranteed to return immediately without blocking.
    /// 
    /// If `name` is a well-known name and the
    /// `G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START` and `G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION`
    /// flags aren't set and no name owner currently exists, the message bus
    /// will be requested to launch a name owner for the name.
    /// 
    /// This is a synchronous failable constructor. See `g_dbus_proxy_new()`
    /// and `g_dbus_proxy_new_finish()` for the asynchronous version.
    /// 
    /// `GDBusProxy` is used in this [example](#gdbus-wellknown-proxy).
    @inlinable public static func new<CancellableT: CancellableProtocol, DBusConnectionT: DBusConnectionProtocol, DBusInterfaceInfoT: DBusInterfaceInfoProtocol>(sync connection: DBusConnectionT, flags: DBusProxyFlags, info: DBusInterfaceInfoT?, name: UnsafePointer<gchar>? = nil, objectPath: UnsafePointer<gchar>!, interfaceName: UnsafePointer<gchar>!, cancellable: CancellableT?) throws -> GIO.DBusProxy! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_new_sync(connection.dbus_connection_ptr, flags.value, info?.dbus_interface_info_ptr, name, objectPath, interfaceName, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusProxy(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

}

public enum DBusProxyPropertyName: String, PropertyNameProtocol {
    /// If this property is not `G_BUS_TYPE_NONE`, then
    /// `GDBusProxy:g-connection` must be `nil` and will be set to the
    /// `GDBusConnection` obtained by calling `g_bus_get()` with the value
    /// of this property.
    case gBusType = "g-bus-type"
    /// The `GDBusConnection` the proxy is for.
    case gConnection = "g-connection"
    /// The timeout to use if -1 (specifying default timeout) is passed
    /// as `timeout_msec` in the `g_dbus_proxy_call()` and
    /// `g_dbus_proxy_call_sync()` functions.
    /// 
    /// This allows applications to set a proxy-wide timeout for all
    /// remote method invocations on the proxy. If this property is -1,
    /// the default timeout (typically 25 seconds) is used. If set to
    /// `G_MAXINT`, then no timeout is used.
    case gDefaultTimeout = "g-default-timeout"
    /// Flags from the `GDBusProxyFlags` enumeration.
    case gFlags = "g-flags"
    /// Ensure that interactions with this proxy conform to the given
    /// interface. This is mainly to ensure that malformed data received
    /// from the other peer is ignored. The given `GDBusInterfaceInfo` is
    /// said to be the "expected interface".
    /// 
    /// The checks performed are:
    /// - When completing a method call, if the type signature of
    ///   the reply message isn't what's expected, the reply is
    ///   discarded and the `GError` is set to `G_IO_ERROR_INVALID_ARGUMENT`.
    /// 
    /// - Received signals that have a type signature mismatch are dropped and
    ///   a warning is logged via `g_warning()`.
    /// 
    /// - Properties received via the initial ``GetAll()`` call or via the
    ///   ``PropertiesChanged`` signal (on the
    ///   [org.freedesktop.DBus.Properties](http://dbus.freedesktop.org/doc/dbus-specification.html`standard-interfaces-properties`)
    ///   interface) or set using `g_dbus_proxy_set_cached_property()`
    ///   with a type signature mismatch are ignored and a warning is
    ///   logged via `g_warning()`.
    /// 
    /// Note that these checks are never done on methods, signals and
    /// properties that are not referenced in the given
    /// `GDBusInterfaceInfo`, since extending a D-Bus interface on the
    /// service-side is not considered an ABI break.
    case gInterfaceInfo = "g-interface-info"
    /// The D-Bus interface name the proxy is for.
    case gInterfaceName = "g-interface-name"
    /// The well-known or unique name that the proxy is for.
    case gName = "g-name"
    /// The unique name that owns `GDBusProxy:g-name` or `nil` if no-one
    /// currently owns that name. You may connect to `GObject::notify` signal to
    /// track changes to this property.
    case gNameOwner = "g-name-owner"
    /// The object path the proxy is for.
    case gObjectPath = "g-object-path"
}

public extension DBusProxyProtocol {
    /// Bind a `DBusProxyPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: DBusProxyPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a DBusProxy property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: DBusProxyPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a DBusProxy property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: DBusProxyPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum DBusProxySignalName: String, SignalNameProtocol {
    /// Emitted when one or more D-Bus properties on `proxy` changes. The
    /// local cache has already been updated when this signal fires. Note
    /// that both `changed_properties` and `invalidated_properties` are
    /// guaranteed to never be `nil` (either may be empty though).
    /// 
    /// If the proxy has the flag
    /// `G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES` set, then
    /// `invalidated_properties` will always be empty.
    /// 
    /// This signal corresponds to the
    /// `PropertiesChanged` D-Bus signal on the
    /// `org.freedesktop.DBus.Properties` interface.
    case gPropertiesChanged = "g-properties-changed"
    /// Emitted when a signal from the remote object and interface that `proxy` is for, has been received.
    /// 
    /// Since 2.72 this signal supports detailed connections. You can connect to
    /// the detailed signal `g-signal`x`` in order to receive callbacks only when
    /// signal `x` is received from the remote object.
    case gSignal = "g-signal"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// If this property is not `G_BUS_TYPE_NONE`, then
    /// `GDBusProxy:g-connection` must be `nil` and will be set to the
    /// `GDBusConnection` obtained by calling `g_bus_get()` with the value
    /// of this property.
    case notifyGBusType = "notify::g-bus-type"
    /// The `GDBusConnection` the proxy is for.
    case notifyGConnection = "notify::g-connection"
    /// The timeout to use if -1 (specifying default timeout) is passed
    /// as `timeout_msec` in the `g_dbus_proxy_call()` and
    /// `g_dbus_proxy_call_sync()` functions.
    /// 
    /// This allows applications to set a proxy-wide timeout for all
    /// remote method invocations on the proxy. If this property is -1,
    /// the default timeout (typically 25 seconds) is used. If set to
    /// `G_MAXINT`, then no timeout is used.
    case notifyGDefaultTimeout = "notify::g-default-timeout"
    /// Flags from the `GDBusProxyFlags` enumeration.
    case notifyGFlags = "notify::g-flags"
    /// Ensure that interactions with this proxy conform to the given
    /// interface. This is mainly to ensure that malformed data received
    /// from the other peer is ignored. The given `GDBusInterfaceInfo` is
    /// said to be the "expected interface".
    /// 
    /// The checks performed are:
    /// - When completing a method call, if the type signature of
    ///   the reply message isn't what's expected, the reply is
    ///   discarded and the `GError` is set to `G_IO_ERROR_INVALID_ARGUMENT`.
    /// 
    /// - Received signals that have a type signature mismatch are dropped and
    ///   a warning is logged via `g_warning()`.
    /// 
    /// - Properties received via the initial ``GetAll()`` call or via the
    ///   ``PropertiesChanged`` signal (on the
    ///   [org.freedesktop.DBus.Properties](http://dbus.freedesktop.org/doc/dbus-specification.html`standard-interfaces-properties`)
    ///   interface) or set using `g_dbus_proxy_set_cached_property()`
    ///   with a type signature mismatch are ignored and a warning is
    ///   logged via `g_warning()`.
    /// 
    /// Note that these checks are never done on methods, signals and
    /// properties that are not referenced in the given
    /// `GDBusInterfaceInfo`, since extending a D-Bus interface on the
    /// service-side is not considered an ABI break.
    case notifyGInterfaceInfo = "notify::g-interface-info"
    /// The D-Bus interface name the proxy is for.
    case notifyGInterfaceName = "notify::g-interface-name"
    /// The well-known or unique name that the proxy is for.
    case notifyGName = "notify::g-name"
    /// The unique name that owns `GDBusProxy:g-name` or `nil` if no-one
    /// currently owns that name. You may connect to `GObject::notify` signal to
    /// track changes to this property.
    case notifyGNameOwner = "notify::g-name-owner"
    /// The object path the proxy is for.
    case notifyGObjectPath = "notify::g-object-path"
}

// MARK: DBusProxy signals
public extension DBusProxyProtocol {
    /// Connect a Swift signal handler to the given, typed `DBusProxySignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DBusProxySignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `DBusProxySignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DBusProxySignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when one or more D-Bus properties on `proxy` changes. The
    /// local cache has already been updated when this signal fires. Note
    /// that both `changed_properties` and `invalidated_properties` are
    /// guaranteed to never be `nil` (either may be empty though).
    /// 
    /// If the proxy has the flag
    /// `G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES` set, then
    /// `invalidated_properties` will always be empty.
    /// 
    /// This signal corresponds to the
    /// `PropertiesChanged` D-Bus signal on the
    /// `org.freedesktop.DBus.Properties` interface.
    /// - Note: This represents the underlying `g-properties-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter changedProperties: A `GVariant` containing the properties that changed (type: `a{sv}`)
    /// - Parameter invalidatedProperties: A `nil` terminated array of properties that was invalidated
    /// - Parameter handler: The signal handler to call
    /// - Warning: a `onGPropertiesChanged` wrapper for this signal could not be generated because it contains unimplemented features: { (3)  Void argument is not yet supported, (7)  array argument or return type is not allowed }
    /// - Note: Instead, you can connect `gPropertiesChangedSignal` using the `connect(signal:)` methods
    static var gPropertiesChangedSignal: DBusProxySignalName { .gPropertiesChanged }
    /// Emitted when a signal from the remote object and interface that `proxy` is for, has been received.
    /// 
    /// Since 2.72 this signal supports detailed connections. You can connect to
    /// the detailed signal `g-signal`x`` in order to receive callbacks only when
    /// signal `x` is received from the remote object.
    /// - Note: This represents the underlying `g-signal` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter senderName: The sender of the signal or `nil` if the connection is not a bus connection.
    /// - Parameter signalName: The name of the signal.
    /// - Parameter parameters: A `GVariant` tuple with parameters for the signal.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `gSignal` signal is emitted
    @discardableResult @inlinable func onGSignal(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusProxyRef, _ senderName: String?, _ signalName: String, _ parameters: GLib.VariantRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusProxyRef, String?, String, GLib.VariantRef), Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, UnsafeMutablePointer<gchar>?, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, arg3, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusProxyRef(raw: unownedSelf), arg1.map({ String(cString: $0) }), arg2.map({ String(cString: $0) })!, GLib.VariantRef(raw: arg3)))
            return output
        }
        return connect(
            signal: .gSignal,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `g-signal` signal for using the `connect(signal:)` methods
    static var gSignalSignal: DBusProxySignalName { .gSignal }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::g-bus-type` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyGBusType` signal is emitted
    @discardableResult @inlinable func onNotifyGBusType(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusProxyRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusProxyRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusProxyRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyGBusType,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::g-bus-type` signal for using the `connect(signal:)` methods
    static var notifyGBusTypeSignal: DBusProxySignalName { .notifyGBusType }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::g-connection` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyGConnection` signal is emitted
    @discardableResult @inlinable func onNotifyGConnection(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusProxyRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusProxyRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusProxyRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyGConnection,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::g-connection` signal for using the `connect(signal:)` methods
    static var notifyGConnectionSignal: DBusProxySignalName { .notifyGConnection }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::g-default-timeout` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyGDefaultTimeout` signal is emitted
    @discardableResult @inlinable func onNotifyGDefaultTimeout(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusProxyRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusProxyRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusProxyRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyGDefaultTimeout,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::g-default-timeout` signal for using the `connect(signal:)` methods
    static var notifyGDefaultTimeoutSignal: DBusProxySignalName { .notifyGDefaultTimeout }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::g-flags` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyGFlags` signal is emitted
    @discardableResult @inlinable func onNotifyGFlags(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusProxyRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusProxyRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusProxyRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyGFlags,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::g-flags` signal for using the `connect(signal:)` methods
    static var notifyGFlagsSignal: DBusProxySignalName { .notifyGFlags }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::g-interface-info` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyGInterfaceInfo` signal is emitted
    @discardableResult @inlinable func onNotifyGInterfaceInfo(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusProxyRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusProxyRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusProxyRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyGInterfaceInfo,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::g-interface-info` signal for using the `connect(signal:)` methods
    static var notifyGInterfaceInfoSignal: DBusProxySignalName { .notifyGInterfaceInfo }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::g-interface-name` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyGInterfaceName` signal is emitted
    @discardableResult @inlinable func onNotifyGInterfaceName(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusProxyRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusProxyRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusProxyRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyGInterfaceName,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::g-interface-name` signal for using the `connect(signal:)` methods
    static var notifyGInterfaceNameSignal: DBusProxySignalName { .notifyGInterfaceName }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::g-name` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyGName` signal is emitted
    @discardableResult @inlinable func onNotifyGName(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusProxyRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusProxyRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusProxyRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyGName,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::g-name` signal for using the `connect(signal:)` methods
    static var notifyGNameSignal: DBusProxySignalName { .notifyGName }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::g-name-owner` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyGNameOwner` signal is emitted
    @discardableResult @inlinable func onNotifyGNameOwner(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusProxyRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusProxyRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusProxyRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyGNameOwner,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::g-name-owner` signal for using the `connect(signal:)` methods
    static var notifyGNameOwnerSignal: DBusProxySignalName { .notifyGNameOwner }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::g-object-path` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyGObjectPath` signal is emitted
    @discardableResult @inlinable func onNotifyGObjectPath(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusProxyRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusProxyRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusProxyRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyGObjectPath,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::g-object-path` signal for using the `connect(signal:)` methods
    static var notifyGObjectPathSignal: DBusProxySignalName { .notifyGObjectPath }
    
}

// MARK: DBusProxy Class: DBusProxyProtocol extension (methods and fields)
public extension DBusProxyProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusProxy` instance.
    @inlinable var dbus_proxy_ptr: UnsafeMutablePointer<GDBusProxy>! { return ptr?.assumingMemoryBound(to: GDBusProxy.self) }

    /// Asynchronously invokes the `method_name` method on `proxy`.
    /// 
    /// If `method_name` contains any dots, then `name` is split into interface and
    /// method name parts. This allows using `proxy` for invoking methods on
    /// other interfaces.
    /// 
    /// If the `GDBusConnection` associated with `proxy` is closed then
    /// the operation will fail with `G_IO_ERROR_CLOSED`. If
    /// `cancellable` is canceled, the operation will fail with
    /// `G_IO_ERROR_CANCELLED`. If `parameters` contains a value not
    /// compatible with the D-Bus protocol, the operation fails with
    /// `G_IO_ERROR_INVALID_ARGUMENT`.
    /// 
    /// If the `parameters` `GVariant` is floating, it is consumed. This allows
    /// convenient 'inline' use of `g_variant_new()`, e.g.:
    /// (C Language Example):
    /// ```C
    ///  g_dbus_proxy_call (proxy,
    ///                     "TwoStrings",
    ///                     g_variant_new ("(ss)",
    ///                                    "Thing One",
    ///                                    "Thing Two"),
    ///                     G_DBUS_CALL_FLAGS_NONE,
    ///                     -1,
    ///                     NULL,
    ///                     (GAsyncReadyCallback) two_strings_done,
    ///                     &data);
    /// ```
    /// 
    /// If `proxy` has an expected interface (see
    /// `GDBusProxy:g-interface-info`) and `method_name` is referenced by it,
    /// then the return value is checked against the return type.
    /// 
    /// This is an asynchronous method. When the operation is finished,
    /// `callback` will be invoked in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// of the thread you are calling this method from.
    /// You can then call `g_dbus_proxy_call_finish()` to get the result of
    /// the operation. See `g_dbus_proxy_call_sync()` for the synchronous
    /// version of this method.
    /// 
    /// If `callback` is `nil` then the D-Bus method call message will be sent with
    /// the `G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED` flag set.
    @inlinable func call(methodName: UnsafePointer<gchar>!, parameters: GLib.VariantRef? = nil, flags: DBusCallFlags, timeoutMsec: Int, cancellable: CancellableRef? = nil, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
            
        g_dbus_proxy_call(dbus_proxy_ptr, methodName, parameters?.variant_ptr, flags.value, gint(timeoutMsec), cancellable?.cancellable_ptr, callback, userData)
            
    }
    /// Asynchronously invokes the `method_name` method on `proxy`.
    /// 
    /// If `method_name` contains any dots, then `name` is split into interface and
    /// method name parts. This allows using `proxy` for invoking methods on
    /// other interfaces.
    /// 
    /// If the `GDBusConnection` associated with `proxy` is closed then
    /// the operation will fail with `G_IO_ERROR_CLOSED`. If
    /// `cancellable` is canceled, the operation will fail with
    /// `G_IO_ERROR_CANCELLED`. If `parameters` contains a value not
    /// compatible with the D-Bus protocol, the operation fails with
    /// `G_IO_ERROR_INVALID_ARGUMENT`.
    /// 
    /// If the `parameters` `GVariant` is floating, it is consumed. This allows
    /// convenient 'inline' use of `g_variant_new()`, e.g.:
    /// (C Language Example):
    /// ```C
    ///  g_dbus_proxy_call (proxy,
    ///                     "TwoStrings",
    ///                     g_variant_new ("(ss)",
    ///                                    "Thing One",
    ///                                    "Thing Two"),
    ///                     G_DBUS_CALL_FLAGS_NONE,
    ///                     -1,
    ///                     NULL,
    ///                     (GAsyncReadyCallback) two_strings_done,
    ///                     &data);
    /// ```
    /// 
    /// If `proxy` has an expected interface (see
    /// `GDBusProxy:g-interface-info`) and `method_name` is referenced by it,
    /// then the return value is checked against the return type.
    /// 
    /// This is an asynchronous method. When the operation is finished,
    /// `callback` will be invoked in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// of the thread you are calling this method from.
    /// You can then call `g_dbus_proxy_call_finish()` to get the result of
    /// the operation. See `g_dbus_proxy_call_sync()` for the synchronous
    /// version of this method.
    /// 
    /// If `callback` is `nil` then the D-Bus method call message will be sent with
    /// the `G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED` flag set.
    @inlinable func call<CancellableT: CancellableProtocol, GLibVariantT: GLib.VariantProtocol>(methodName: UnsafePointer<gchar>!, parameters: GLibVariantT?, flags: DBusCallFlags, timeoutMsec: Int, cancellable: CancellableT?, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
        
        g_dbus_proxy_call(dbus_proxy_ptr, methodName, parameters?.variant_ptr, flags.value, gint(timeoutMsec), cancellable?.cancellable_ptr, callback, userData)
        
    }

    /// Finishes an operation started with `g_dbus_proxy_call()`.
    @inlinable func callFinish<AsyncResultT: AsyncResultProtocol>(res: AsyncResultT) throws -> GLib.VariantRef! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_call_finish(dbus_proxy_ptr, res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = GLib.VariantRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Synchronously invokes the `method_name` method on `proxy`.
    /// 
    /// If `method_name` contains any dots, then `name` is split into interface and
    /// method name parts. This allows using `proxy` for invoking methods on
    /// other interfaces.
    /// 
    /// If the `GDBusConnection` associated with `proxy` is disconnected then
    /// the operation will fail with `G_IO_ERROR_CLOSED`. If
    /// `cancellable` is canceled, the operation will fail with
    /// `G_IO_ERROR_CANCELLED`. If `parameters` contains a value not
    /// compatible with the D-Bus protocol, the operation fails with
    /// `G_IO_ERROR_INVALID_ARGUMENT`.
    /// 
    /// If the `parameters` `GVariant` is floating, it is consumed. This allows
    /// convenient 'inline' use of `g_variant_new()`, e.g.:
    /// (C Language Example):
    /// ```C
    ///  g_dbus_proxy_call_sync (proxy,
    ///                          "TwoStrings",
    ///                          g_variant_new ("(ss)",
    ///                                         "Thing One",
    ///                                         "Thing Two"),
    ///                          G_DBUS_CALL_FLAGS_NONE,
    ///                          -1,
    ///                          NULL,
    ///                          &error);
    /// ```
    /// 
    /// The calling thread is blocked until a reply is received. See
    /// `g_dbus_proxy_call()` for the asynchronous version of this
    /// method.
    /// 
    /// If `proxy` has an expected interface (see
    /// `GDBusProxy:g-interface-info`) and `method_name` is referenced by it,
    /// then the return value is checked against the return type.
    @inlinable func callSync(methodName: UnsafePointer<gchar>!, parameters: GLib.VariantRef? = nil, flags: DBusCallFlags, timeoutMsec: Int, cancellable: CancellableRef? = nil) throws -> GLib.VariantRef! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_call_sync(dbus_proxy_ptr, methodName, parameters?.variant_ptr, flags.value, gint(timeoutMsec), cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = GLib.VariantRef(gconstpointer: gconstpointer(result))
            return rv
    }
    /// Synchronously invokes the `method_name` method on `proxy`.
    /// 
    /// If `method_name` contains any dots, then `name` is split into interface and
    /// method name parts. This allows using `proxy` for invoking methods on
    /// other interfaces.
    /// 
    /// If the `GDBusConnection` associated with `proxy` is disconnected then
    /// the operation will fail with `G_IO_ERROR_CLOSED`. If
    /// `cancellable` is canceled, the operation will fail with
    /// `G_IO_ERROR_CANCELLED`. If `parameters` contains a value not
    /// compatible with the D-Bus protocol, the operation fails with
    /// `G_IO_ERROR_INVALID_ARGUMENT`.
    /// 
    /// If the `parameters` `GVariant` is floating, it is consumed. This allows
    /// convenient 'inline' use of `g_variant_new()`, e.g.:
    /// (C Language Example):
    /// ```C
    ///  g_dbus_proxy_call_sync (proxy,
    ///                          "TwoStrings",
    ///                          g_variant_new ("(ss)",
    ///                                         "Thing One",
    ///                                         "Thing Two"),
    ///                          G_DBUS_CALL_FLAGS_NONE,
    ///                          -1,
    ///                          NULL,
    ///                          &error);
    /// ```
    /// 
    /// The calling thread is blocked until a reply is received. See
    /// `g_dbus_proxy_call()` for the asynchronous version of this
    /// method.
    /// 
    /// If `proxy` has an expected interface (see
    /// `GDBusProxy:g-interface-info`) and `method_name` is referenced by it,
    /// then the return value is checked against the return type.
    @inlinable func callSync<CancellableT: CancellableProtocol, GLibVariantT: GLib.VariantProtocol>(methodName: UnsafePointer<gchar>!, parameters: GLibVariantT?, flags: DBusCallFlags, timeoutMsec: Int, cancellable: CancellableT?) throws -> GLib.VariantRef! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_call_sync(dbus_proxy_ptr, methodName, parameters?.variant_ptr, flags.value, gint(timeoutMsec), cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = GLib.VariantRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Like `g_dbus_proxy_call()` but also takes a `GUnixFDList` object.
    /// 
    /// This method is only available on UNIX.
    @inlinable func callWithUnixFdList(methodName: UnsafePointer<gchar>!, parameters: GLib.VariantRef? = nil, flags: DBusCallFlags, timeoutMsec: Int, fdList: UnixFDListRef? = nil, cancellable: CancellableRef? = nil, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
            
        g_dbus_proxy_call_with_unix_fd_list(dbus_proxy_ptr, methodName, parameters?.variant_ptr, flags.value, gint(timeoutMsec), fdList?.unix_fd_list_ptr, cancellable?.cancellable_ptr, callback, userData)
            
    }
    /// Like `g_dbus_proxy_call()` but also takes a `GUnixFDList` object.
    /// 
    /// This method is only available on UNIX.
    @inlinable func callWithUnixFdList<CancellableT: CancellableProtocol, GLibVariantT: GLib.VariantProtocol, UnixFDListT: UnixFDListProtocol>(methodName: UnsafePointer<gchar>!, parameters: GLibVariantT?, flags: DBusCallFlags, timeoutMsec: Int, fdList: UnixFDListT?, cancellable: CancellableT?, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
        
        g_dbus_proxy_call_with_unix_fd_list(dbus_proxy_ptr, methodName, parameters?.variant_ptr, flags.value, gint(timeoutMsec), fdList?.unix_fd_list_ptr, cancellable?.cancellable_ptr, callback, userData)
        
    }

    /// Finishes an operation started with `g_dbus_proxy_call_with_unix_fd_list()`.
    @inlinable func callWithUnixFdListFinish<AsyncResultT: AsyncResultProtocol>(outFdList: UnsafeMutablePointer<UnsafeMutablePointer<GUnixFDList>?>! = nil, res: AsyncResultT) throws -> GLib.VariantRef! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_call_with_unix_fd_list_finish(dbus_proxy_ptr, outFdList, res.async_result_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = GLib.VariantRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Like `g_dbus_proxy_call_sync()` but also takes and returns `GUnixFDList` objects.
    /// 
    /// This method is only available on UNIX.
    @inlinable func callWithUnixFdListSync(methodName: UnsafePointer<gchar>!, parameters: GLib.VariantRef? = nil, flags: DBusCallFlags, timeoutMsec: Int, fdList: UnixFDListRef? = nil, outFdList: UnsafeMutablePointer<UnsafeMutablePointer<GUnixFDList>?>! = nil, cancellable: CancellableRef? = nil) throws -> GLib.VariantRef! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_call_with_unix_fd_list_sync(dbus_proxy_ptr, methodName, parameters?.variant_ptr, flags.value, gint(timeoutMsec), fdList?.unix_fd_list_ptr, outFdList, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = GLib.VariantRef(gconstpointer: gconstpointer(result))
            return rv
    }
    /// Like `g_dbus_proxy_call_sync()` but also takes and returns `GUnixFDList` objects.
    /// 
    /// This method is only available on UNIX.
    @inlinable func callWithUnixFdListSync<CancellableT: CancellableProtocol, GLibVariantT: GLib.VariantProtocol, UnixFDListT: UnixFDListProtocol>(methodName: UnsafePointer<gchar>!, parameters: GLibVariantT?, flags: DBusCallFlags, timeoutMsec: Int, fdList: UnixFDListT?, outFdList: UnsafeMutablePointer<UnsafeMutablePointer<GUnixFDList>?>! = nil, cancellable: CancellableT?) throws -> GLib.VariantRef! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_proxy_call_with_unix_fd_list_sync(dbus_proxy_ptr, methodName, parameters?.variant_ptr, flags.value, gint(timeoutMsec), fdList?.unix_fd_list_ptr, outFdList, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = GLib.VariantRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Looks up the value for a property from the cache. This call does no
    /// blocking IO.
    /// 
    /// If `proxy` has an expected interface (see
    /// `GDBusProxy:g-interface-info`) and `property_name` is referenced by
    /// it, then `value` is checked against the type of the property.
    @inlinable func getCachedProperty(propertyName: UnsafePointer<gchar>!) -> GLib.VariantRef! {
        let result = g_dbus_proxy_get_cached_property(dbus_proxy_ptr, propertyName)
        let rv = GLib.VariantRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the names of all cached properties on `proxy`.
    @inlinable func getCachedPropertyNames() -> UnsafeMutablePointer<UnsafeMutablePointer<gchar>?>! {
        let result = g_dbus_proxy_get_cached_property_names(dbus_proxy_ptr)
        let rv = result
        return rv
    }

    /// Gets the connection `proxy` is for.
    @inlinable func getConnection() -> GIO.DBusConnectionRef! {
        let result = g_dbus_proxy_get_connection(dbus_proxy_ptr)
        let rv = DBusConnectionRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the timeout to use if -1 (specifying default timeout) is
    /// passed as `timeout_msec` in the `g_dbus_proxy_call()` and
    /// `g_dbus_proxy_call_sync()` functions.
    /// 
    /// See the `GDBusProxy:g-default-timeout` property for more details.
    @inlinable func getDefaultTimeout() -> Int {
        let result = g_dbus_proxy_get_default_timeout(dbus_proxy_ptr)
        let rv = Int(result)
        return rv
    }

    /// Gets the flags that `proxy` was constructed with.
    @inlinable func getFlags() -> GIO.DBusProxyFlags {
        let result = g_dbus_proxy_get_flags(dbus_proxy_ptr)
        let rv = DBusProxyFlags(result)
        return rv
    }

    /// Returns the `GDBusInterfaceInfo`, if any, specifying the interface
    /// that `proxy` conforms to. See the `GDBusProxy:g-interface-info`
    /// property for more details.
    @inlinable func getInterfaceInfo() -> GIO.DBusInterfaceInfoRef! {
        let result = g_dbus_proxy_get_interface_info(dbus_proxy_ptr)
        let rv = DBusInterfaceInfoRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the D-Bus interface name `proxy` is for.
    @inlinable func getInterfaceName() -> String! {
        let result = g_dbus_proxy_get_interface_name(dbus_proxy_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets the name that `proxy` was constructed for.
    /// 
    /// When connected to a message bus, this will usually be non-`nil`.
    /// However, it may be `nil` for a proxy that communicates using a peer-to-peer
    /// pattern.
    @inlinable func getName() -> String! {
        let result = g_dbus_proxy_get_name(dbus_proxy_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// The unique name that owns the name that `proxy` is for or `nil` if
    /// no-one currently owns that name. You may connect to the
    /// `GObject::notify` signal to track changes to the
    /// `GDBusProxy:g-name-owner` property.
    @inlinable func getNameOwner() -> String! {
        let result = g_dbus_proxy_get_name_owner(dbus_proxy_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets the object path `proxy` is for.
    @inlinable func getObjectPath() -> String! {
        let result = g_dbus_proxy_get_object_path(dbus_proxy_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// If `value` is not `nil`, sets the cached value for the property with
    /// name `property_name` to the value in `value`.
    /// 
    /// If `value` is `nil`, then the cached value is removed from the
    /// property cache.
    /// 
    /// If `proxy` has an expected interface (see
    /// `GDBusProxy:g-interface-info`) and `property_name` is referenced by
    /// it, then `value` is checked against the type of the property.
    /// 
    /// If the `value` `GVariant` is floating, it is consumed. This allows
    /// convenient 'inline' use of `g_variant_new()`, e.g.
    /// (C Language Example):
    /// ```C
    ///  g_dbus_proxy_set_cached_property (proxy,
    ///                                    "SomeProperty",
    ///                                    g_variant_new ("(si)",
    ///                                                  "A String",
    ///                                                  42));
    /// ```
    /// 
    /// Normally you will not need to use this method since `proxy`
    /// is tracking changes using the
    /// `org.freedesktop.DBus.Properties.PropertiesChanged`
    /// D-Bus signal. However, for performance reasons an object may
    /// decide to not use this signal for some properties and instead
    /// use a proprietary out-of-band mechanism to transmit changes.
    /// 
    /// As a concrete example, consider an object with a property
    /// `ChatroomParticipants` which is an array of strings. Instead of
    /// transmitting the same (long) array every time the property changes,
    /// it is more efficient to only transmit the delta using e.g. signals
    /// ``ChatroomParticipantJoined(String name)`` and
    /// ``ChatroomParticipantParted(String name)``.
    @inlinable func setCachedProperty(propertyName: UnsafePointer<gchar>!, value: GLib.VariantRef? = nil) {
            
        g_dbus_proxy_set_cached_property(dbus_proxy_ptr, propertyName, value?.variant_ptr)
            
    }
    /// If `value` is not `nil`, sets the cached value for the property with
    /// name `property_name` to the value in `value`.
    /// 
    /// If `value` is `nil`, then the cached value is removed from the
    /// property cache.
    /// 
    /// If `proxy` has an expected interface (see
    /// `GDBusProxy:g-interface-info`) and `property_name` is referenced by
    /// it, then `value` is checked against the type of the property.
    /// 
    /// If the `value` `GVariant` is floating, it is consumed. This allows
    /// convenient 'inline' use of `g_variant_new()`, e.g.
    /// (C Language Example):
    /// ```C
    ///  g_dbus_proxy_set_cached_property (proxy,
    ///                                    "SomeProperty",
    ///                                    g_variant_new ("(si)",
    ///                                                  "A String",
    ///                                                  42));
    /// ```
    /// 
    /// Normally you will not need to use this method since `proxy`
    /// is tracking changes using the
    /// `org.freedesktop.DBus.Properties.PropertiesChanged`
    /// D-Bus signal. However, for performance reasons an object may
    /// decide to not use this signal for some properties and instead
    /// use a proprietary out-of-band mechanism to transmit changes.
    /// 
    /// As a concrete example, consider an object with a property
    /// `ChatroomParticipants` which is an array of strings. Instead of
    /// transmitting the same (long) array every time the property changes,
    /// it is more efficient to only transmit the delta using e.g. signals
    /// ``ChatroomParticipantJoined(String name)`` and
    /// ``ChatroomParticipantParted(String name)``.
    @inlinable func setCachedProperty<GLibVariantT: GLib.VariantProtocol>(propertyName: UnsafePointer<gchar>!, value: GLibVariantT?) {
        
        g_dbus_proxy_set_cached_property(dbus_proxy_ptr, propertyName, value?.variant_ptr)
        
    }

    /// Sets the timeout to use if -1 (specifying default timeout) is
    /// passed as `timeout_msec` in the `g_dbus_proxy_call()` and
    /// `g_dbus_proxy_call_sync()` functions.
    /// 
    /// See the `GDBusProxy:g-default-timeout` property for more details.
    @inlinable func setDefaultTimeout(timeoutMsec: Int) {
        
        g_dbus_proxy_set_default_timeout(dbus_proxy_ptr, gint(timeoutMsec))
        
    }

    /// Ensure that interactions with `proxy` conform to the given
    /// interface. See the `GDBusProxy:g-interface-info` property for more
    /// details.
    @inlinable func setInterface(info: DBusInterfaceInfoRef? = nil) {
            
        g_dbus_proxy_set_interface_info(dbus_proxy_ptr, info?.dbus_interface_info_ptr)
            
    }
    /// Ensure that interactions with `proxy` conform to the given
    /// interface. See the `GDBusProxy:g-interface-info` property for more
    /// details.
    @inlinable func setInterface<DBusInterfaceInfoT: DBusInterfaceInfoProtocol>(info: DBusInterfaceInfoT?) {
        
        g_dbus_proxy_set_interface_info(dbus_proxy_ptr, info?.dbus_interface_info_ptr)
        
    }
    /// Gets the names of all cached properties on `proxy`.
    @inlinable var cachedPropertyNames: UnsafeMutablePointer<UnsafeMutablePointer<gchar>?>! {
        /// Gets the names of all cached properties on `proxy`.
        get {
            let result = g_dbus_proxy_get_cached_property_names(dbus_proxy_ptr)
        let rv = result
            return rv
        }
    }

    /// Gets the connection `proxy` is for.
    @inlinable var connection: GIO.DBusConnectionRef! {
        /// Gets the connection `proxy` is for.
        get {
            let result = g_dbus_proxy_get_connection(dbus_proxy_ptr)
        let rv = DBusConnectionRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Gets the timeout to use if -1 (specifying default timeout) is
    /// passed as `timeout_msec` in the `g_dbus_proxy_call()` and
    /// `g_dbus_proxy_call_sync()` functions.
    /// 
    /// See the `GDBusProxy:g-default-timeout` property for more details.
    @inlinable var defaultTimeout: Int {
        /// Gets the timeout to use if -1 (specifying default timeout) is
        /// passed as `timeout_msec` in the `g_dbus_proxy_call()` and
        /// `g_dbus_proxy_call_sync()` functions.
        /// 
        /// See the `GDBusProxy:g-default-timeout` property for more details.
        get {
            let result = g_dbus_proxy_get_default_timeout(dbus_proxy_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the timeout to use if -1 (specifying default timeout) is
        /// passed as `timeout_msec` in the `g_dbus_proxy_call()` and
        /// `g_dbus_proxy_call_sync()` functions.
        /// 
        /// See the `GDBusProxy:g-default-timeout` property for more details.
        nonmutating set {
            g_dbus_proxy_set_default_timeout(dbus_proxy_ptr, gint(newValue))
        }
    }

    /// Gets the flags that `proxy` was constructed with.
    @inlinable var flags: GIO.DBusProxyFlags {
        /// Gets the flags that `proxy` was constructed with.
        get {
            let result = g_dbus_proxy_get_flags(dbus_proxy_ptr)
        let rv = DBusProxyFlags(result)
            return rv
        }
    }

    /// Returns the `GDBusInterfaceInfo`, if any, specifying the interface
    /// that `proxy` conforms to. See the `GDBusProxy:g-interface-info`
    /// property for more details.
    @inlinable var interfaceInfo: GIO.DBusInterfaceInfoRef! {
        /// Returns the `GDBusInterfaceInfo`, if any, specifying the interface
        /// that `proxy` conforms to. See the `GDBusProxy:g-interface-info`
        /// property for more details.
        get {
            let result = g_dbus_proxy_get_interface_info(dbus_proxy_ptr)
        let rv = DBusInterfaceInfoRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Ensure that interactions with `proxy` conform to the given
        /// interface. See the `GDBusProxy:g-interface-info` property for more
        /// details.
        nonmutating set {
            g_dbus_proxy_set_interface_info(dbus_proxy_ptr, UnsafeMutablePointer<GDBusInterfaceInfo>(newValue?.dbus_interface_info_ptr))
        }
    }

    /// Gets the D-Bus interface name `proxy` is for.
    @inlinable var interfaceName: String! {
        /// Gets the D-Bus interface name `proxy` is for.
        get {
            let result = g_dbus_proxy_get_interface_name(dbus_proxy_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// Gets the name that `proxy` was constructed for.
    /// 
    /// When connected to a message bus, this will usually be non-`nil`.
    /// However, it may be `nil` for a proxy that communicates using a peer-to-peer
    /// pattern.
    @inlinable var name: String! {
        /// Gets the name that `proxy` was constructed for.
        /// 
        /// When connected to a message bus, this will usually be non-`nil`.
        /// However, it may be `nil` for a proxy that communicates using a peer-to-peer
        /// pattern.
        get {
            let result = g_dbus_proxy_get_name(dbus_proxy_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// The unique name that owns the name that `proxy` is for or `nil` if
    /// no-one currently owns that name. You may connect to the
    /// `GObject::notify` signal to track changes to the
    /// `GDBusProxy:g-name-owner` property.
    @inlinable var nameOwner: String! {
        /// The unique name that owns the name that `proxy` is for or `nil` if
        /// no-one currently owns that name. You may connect to the
        /// `GObject::notify` signal to track changes to the
        /// `GDBusProxy:g-name-owner` property.
        get {
            let result = g_dbus_proxy_get_name_owner(dbus_proxy_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// Gets the object path `proxy` is for.
    @inlinable var objectPath: String! {
        /// Gets the object path `proxy` is for.
        get {
            let result = g_dbus_proxy_get_object_path(dbus_proxy_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    // var parentInstance is unavailable because parent_instance is private

    // var priv is unavailable because priv is private

}



// MARK: - DBusServer Class

/// `GDBusServer` is a helper for listening to and accepting D-Bus
/// connections. This can be used to create a new D-Bus server, allowing two
/// peers to use the D-Bus protocol for their own specialized communication.
/// A server instance provided in this way will not perform message routing or
/// implement the org.freedesktop.DBus interface.
/// 
/// To just export an object on a well-known name on a message bus, such as the
/// session or system bus, you should instead use `g_bus_own_name()`.
/// 
/// An example of peer-to-peer communication with GDBus can be found
/// in [gdbus-example-peer.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-peer.c).
/// 
/// Note that a minimal `GDBusServer` will accept connections from any
/// peer. In many use-cases it will be necessary to add a `GDBusAuthObserver`
/// that only accepts connections that have successfully authenticated
/// as the same user that is running the `GDBusServer`. Since GLib 2.68 this can
/// be achieved more simply by passing the
/// `G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flag to the server.
///
/// The `DBusServerProtocol` protocol exposes the methods and properties of an underlying `GDBusServer` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DBusServer`.
/// Alternatively, use `DBusServerRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DBusServerProtocol: GLibObject.ObjectProtocol, InitableProtocol {
        /// Untyped pointer to the underlying `GDBusServer` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDBusServer` instance.
    var dbus_server_ptr: UnsafeMutablePointer<GDBusServer>! { get }

    /// Required Initialiser for types conforming to `DBusServerProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GDBusServer` is a helper for listening to and accepting D-Bus
/// connections. This can be used to create a new D-Bus server, allowing two
/// peers to use the D-Bus protocol for their own specialized communication.
/// A server instance provided in this way will not perform message routing or
/// implement the org.freedesktop.DBus interface.
/// 
/// To just export an object on a well-known name on a message bus, such as the
/// session or system bus, you should instead use `g_bus_own_name()`.
/// 
/// An example of peer-to-peer communication with GDBus can be found
/// in [gdbus-example-peer.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-peer.c).
/// 
/// Note that a minimal `GDBusServer` will accept connections from any
/// peer. In many use-cases it will be necessary to add a `GDBusAuthObserver`
/// that only accepts connections that have successfully authenticated
/// as the same user that is running the `GDBusServer`. Since GLib 2.68 this can
/// be achieved more simply by passing the
/// `G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flag to the server.
///
/// The `DBusServerRef` type acts as a lightweight Swift reference to an underlying `GDBusServer` instance.
/// It exposes methods that can operate on this data type through `DBusServerProtocol` conformance.
/// Use `DBusServerRef` only as an `unowned` reference to an existing `GDBusServer` instance.
///
public struct DBusServerRef: DBusServerProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GDBusServer` instance.
    /// For type-safe access, use the generated, typed pointer `dbus_server_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DBusServerRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDBusServer>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDBusServer>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDBusServer>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDBusServer>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DBusServerProtocol`
    @inlinable init<T: DBusServerProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: DBusServerProtocol>(_ other: T) -> DBusServerRef { DBusServerRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusServerProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusServerProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusServerProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusServerProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusServerProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new D-Bus server that listens on the first address in
    /// `address` that works.
    /// 
    /// Once constructed, you can use `g_dbus_server_get_client_address()` to
    /// get a D-Bus address string that clients can use to connect.
    /// 
    /// To have control over the available authentication mechanisms and
    /// the users that are authorized to connect, it is strongly recommended
    /// to provide a non-`nil` `GDBusAuthObserver`.
    /// 
    /// Connect to the `GDBusServer::new-connection` signal to handle
    /// incoming connections.
    /// 
    /// The returned `GDBusServer` isn't active - you have to start it with
    /// `g_dbus_server_start()`.
    /// 
    /// `GDBusServer` is used in this [example](#gdbus-peer-to-peer).
    /// 
    /// This is a synchronous failable constructor. There is currently no
    /// asynchronous version.
    @inlinable init<CancellableT: CancellableProtocol, DBusAuthObserverT: DBusAuthObserverProtocol>(sync address: UnsafePointer<gchar>!, flags: DBusServerFlags, guid: UnsafePointer<gchar>!, observer: DBusAuthObserverT?, cancellable: CancellableT?) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_server_new_sync(address, flags.value, guid, observer?.dbus_auth_observer_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new D-Bus server that listens on the first address in
    /// `address` that works.
    /// 
    /// Once constructed, you can use `g_dbus_server_get_client_address()` to
    /// get a D-Bus address string that clients can use to connect.
    /// 
    /// To have control over the available authentication mechanisms and
    /// the users that are authorized to connect, it is strongly recommended
    /// to provide a non-`nil` `GDBusAuthObserver`.
    /// 
    /// Connect to the `GDBusServer::new-connection` signal to handle
    /// incoming connections.
    /// 
    /// The returned `GDBusServer` isn't active - you have to start it with
    /// `g_dbus_server_start()`.
    /// 
    /// `GDBusServer` is used in this [example](#gdbus-peer-to-peer).
    /// 
    /// This is a synchronous failable constructor. There is currently no
    /// asynchronous version.
    @inlinable static func new<CancellableT: CancellableProtocol, DBusAuthObserverT: DBusAuthObserverProtocol>(sync address: UnsafePointer<gchar>!, flags: DBusServerFlags, guid: UnsafePointer<gchar>!, observer: DBusAuthObserverT?, cancellable: CancellableT?) throws -> GIO.DBusServerRef! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_server_new_sync(address, flags.value, guid, observer?.dbus_auth_observer_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusServerRef(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
        return rv
    }
}

/// `GDBusServer` is a helper for listening to and accepting D-Bus
/// connections. This can be used to create a new D-Bus server, allowing two
/// peers to use the D-Bus protocol for their own specialized communication.
/// A server instance provided in this way will not perform message routing or
/// implement the org.freedesktop.DBus interface.
/// 
/// To just export an object on a well-known name on a message bus, such as the
/// session or system bus, you should instead use `g_bus_own_name()`.
/// 
/// An example of peer-to-peer communication with GDBus can be found
/// in [gdbus-example-peer.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-peer.c).
/// 
/// Note that a minimal `GDBusServer` will accept connections from any
/// peer. In many use-cases it will be necessary to add a `GDBusAuthObserver`
/// that only accepts connections that have successfully authenticated
/// as the same user that is running the `GDBusServer`. Since GLib 2.68 this can
/// be achieved more simply by passing the
/// `G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flag to the server.
///
/// The `DBusServer` type acts as a reference-counted owner of an underlying `GDBusServer` instance.
/// It provides the methods that can operate on this data type through `DBusServerProtocol` conformance.
/// Use `DBusServer` as a strong reference or owner of a `GDBusServer` instance.
///
open class DBusServer: GLibObject.Object, DBusServerProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusServer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDBusServer>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusServer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDBusServer>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusServer` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusServer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusServer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDBusServer>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DBusServer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDBusServer>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDBusServer`.
    /// i.e., ownership is transferred to the `DBusServer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDBusServer>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DBusServerProtocol`
    /// Will retain `GDBusServer`.
    /// - Parameter other: an instance of a related type that implements `DBusServerProtocol`
    @inlinable public init<T: DBusServerProtocol>(dBusServer other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusServerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusServerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusServerProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusServerProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusServerProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusServerProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusServerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DBusServerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new D-Bus server that listens on the first address in
    /// `address` that works.
    /// 
    /// Once constructed, you can use `g_dbus_server_get_client_address()` to
    /// get a D-Bus address string that clients can use to connect.
    /// 
    /// To have control over the available authentication mechanisms and
    /// the users that are authorized to connect, it is strongly recommended
    /// to provide a non-`nil` `GDBusAuthObserver`.
    /// 
    /// Connect to the `GDBusServer::new-connection` signal to handle
    /// incoming connections.
    /// 
    /// The returned `GDBusServer` isn't active - you have to start it with
    /// `g_dbus_server_start()`.
    /// 
    /// `GDBusServer` is used in this [example](#gdbus-peer-to-peer).
    /// 
    /// This is a synchronous failable constructor. There is currently no
    /// asynchronous version.
    @inlinable public init<CancellableT: CancellableProtocol, DBusAuthObserverT: DBusAuthObserverProtocol>(sync address: UnsafePointer<gchar>!, flags: DBusServerFlags, guid: UnsafePointer<gchar>!, observer: DBusAuthObserverT?, cancellable: CancellableT?) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_server_new_sync(address, flags.value, guid, observer?.dbus_auth_observer_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new D-Bus server that listens on the first address in
    /// `address` that works.
    /// 
    /// Once constructed, you can use `g_dbus_server_get_client_address()` to
    /// get a D-Bus address string that clients can use to connect.
    /// 
    /// To have control over the available authentication mechanisms and
    /// the users that are authorized to connect, it is strongly recommended
    /// to provide a non-`nil` `GDBusAuthObserver`.
    /// 
    /// Connect to the `GDBusServer::new-connection` signal to handle
    /// incoming connections.
    /// 
    /// The returned `GDBusServer` isn't active - you have to start it with
    /// `g_dbus_server_start()`.
    /// 
    /// `GDBusServer` is used in this [example](#gdbus-peer-to-peer).
    /// 
    /// This is a synchronous failable constructor. There is currently no
    /// asynchronous version.
    @inlinable public static func new<CancellableT: CancellableProtocol, DBusAuthObserverT: DBusAuthObserverProtocol>(sync address: UnsafePointer<gchar>!, flags: DBusServerFlags, guid: UnsafePointer<gchar>!, observer: DBusAuthObserverT?, cancellable: CancellableT?) throws -> GIO.DBusServer! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_dbus_server_new_sync(address, flags.value, guid, observer?.dbus_auth_observer_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let maybeRV = DBusServer(gconstpointer: gconstpointer(result))
        
        guard let rv = maybeRV else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

}

public enum DBusServerPropertyName: String, PropertyNameProtocol {
    /// Whether the server is currently active.
    case active = "active"
    /// The D-Bus address to listen on.
    case address = "address"
    /// A `GDBusAuthObserver` object to assist in the authentication process or `nil`.
    case authenticationObserver = "authentication-observer"
    /// The D-Bus address that clients can use.
    case clientAddress = "client-address"
    /// Flags from the `GDBusServerFlags` enumeration.
    case flags = "flags"
    /// The GUID of the server.
    /// 
    /// See `GDBusConnection:guid` for more details.
    case guid = "guid"
}

public extension DBusServerProtocol {
    /// Bind a `DBusServerPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: DBusServerPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a DBusServer property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: DBusServerPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a DBusServer property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: DBusServerPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum DBusServerSignalName: String, SignalNameProtocol {
    /// Emitted when a new authenticated connection has been made. Use
    /// `g_dbus_connection_get_peer_credentials()` to figure out what
    /// identity (if any), was authenticated.
    /// 
    /// If you want to accept the connection, take a reference to the
    /// `connection` object and return `true`. When you are done with the
    /// connection call `g_dbus_connection_close()` and give up your
    /// reference. Note that the other peer may disconnect at any time -
    /// a typical thing to do when accepting a connection is to listen to
    /// the `GDBusConnection::closed` signal.
    /// 
    /// If `GDBusServer:flags` contains `G_DBUS_SERVER_FLAGS_RUN_IN_THREAD`
    /// then the signal is emitted in a new thread dedicated to the
    /// connection. Otherwise the signal is emitted in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// of the thread that `server` was constructed in.
    /// 
    /// You are guaranteed that signal handlers for this signal runs
    /// before incoming messages on `connection` are processed. This means
    /// that it's suitable to call `g_dbus_connection_register_object()` or
    /// similar from the signal handler.
    case newConnection = "new-connection"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Whether the server is currently active.
    case notifyActive = "notify::active"
    /// The D-Bus address to listen on.
    case notifyAddress = "notify::address"
    /// A `GDBusAuthObserver` object to assist in the authentication process or `nil`.
    case notifyAuthenticationObserver = "notify::authentication-observer"
    /// The D-Bus address that clients can use.
    case notifyClientAddress = "notify::client-address"
    /// Flags from the `GDBusServerFlags` enumeration.
    case notifyFlags = "notify::flags"
    /// The GUID of the server.
    /// 
    /// See `GDBusConnection:guid` for more details.
    case notifyGuid = "notify::guid"
}

// MARK: DBusServer signals
public extension DBusServerProtocol {
    /// Connect a Swift signal handler to the given, typed `DBusServerSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DBusServerSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `DBusServerSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DBusServerSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when a new authenticated connection has been made. Use
    /// `g_dbus_connection_get_peer_credentials()` to figure out what
    /// identity (if any), was authenticated.
    /// 
    /// If you want to accept the connection, take a reference to the
    /// `connection` object and return `true`. When you are done with the
    /// connection call `g_dbus_connection_close()` and give up your
    /// reference. Note that the other peer may disconnect at any time -
    /// a typical thing to do when accepting a connection is to listen to
    /// the `GDBusConnection::closed` signal.
    /// 
    /// If `GDBusServer:flags` contains `G_DBUS_SERVER_FLAGS_RUN_IN_THREAD`
    /// then the signal is emitted in a new thread dedicated to the
    /// connection. Otherwise the signal is emitted in the
    /// [thread-default main context](#g-main-context-push-thread-default)
    /// of the thread that `server` was constructed in.
    /// 
    /// You are guaranteed that signal handlers for this signal runs
    /// before incoming messages on `connection` are processed. This means
    /// that it's suitable to call `g_dbus_connection_register_object()` or
    /// similar from the signal handler.
    /// - Note: This represents the underlying `new-connection` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter connection: A `GDBusConnection` for the new connection.
    /// - Parameter handler: `true` to claim `connection`, `false` to let other handlers run.
    /// Run the given callback whenever the `newConnection` signal is emitted
    @discardableResult @inlinable func onNewConnection(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusServerRef, _ connection: DBusConnectionRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusServerRef, DBusConnectionRef), Bool>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> gboolean = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call((DBusServerRef(raw: unownedSelf), DBusConnectionRef(raw: arg1)))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .newConnection,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `new-connection` signal for using the `connect(signal:)` methods
    static var newConnectionSignal: DBusServerSignalName { .newConnection }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::active` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActive` signal is emitted
    @discardableResult @inlinable func onNotifyActive(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusServerRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusServerRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusServerRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyActive,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::active` signal for using the `connect(signal:)` methods
    static var notifyActiveSignal: DBusServerSignalName { .notifyActive }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::address` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAddress` signal is emitted
    @discardableResult @inlinable func onNotifyAddress(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusServerRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusServerRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusServerRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyAddress,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::address` signal for using the `connect(signal:)` methods
    static var notifyAddressSignal: DBusServerSignalName { .notifyAddress }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::authentication-observer` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAuthenticationObserver` signal is emitted
    @discardableResult @inlinable func onNotifyAuthenticationObserver(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusServerRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusServerRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusServerRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyAuthenticationObserver,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::authentication-observer` signal for using the `connect(signal:)` methods
    static var notifyAuthenticationObserverSignal: DBusServerSignalName { .notifyAuthenticationObserver }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::client-address` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyClientAddress` signal is emitted
    @discardableResult @inlinable func onNotifyClientAddress(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusServerRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusServerRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusServerRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyClientAddress,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::client-address` signal for using the `connect(signal:)` methods
    static var notifyClientAddressSignal: DBusServerSignalName { .notifyClientAddress }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::flags` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFlags` signal is emitted
    @discardableResult @inlinable func onNotifyFlags(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusServerRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusServerRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusServerRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyFlags,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::flags` signal for using the `connect(signal:)` methods
    static var notifyFlagsSignal: DBusServerSignalName { .notifyFlags }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::guid` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyGuid` signal is emitted
    @discardableResult @inlinable func onNotifyGuid(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DBusServerRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DBusServerRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DBusServerRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyGuid,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::guid` signal for using the `connect(signal:)` methods
    static var notifyGuidSignal: DBusServerSignalName { .notifyGuid }
    
}

// MARK: DBusServer Class: DBusServerProtocol extension (methods and fields)
public extension DBusServerProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDBusServer` instance.
    @inlinable var dbus_server_ptr: UnsafeMutablePointer<GDBusServer>! { return ptr?.assumingMemoryBound(to: GDBusServer.self) }

    /// Gets a
    /// [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html`addresses`)
    /// string that can be used by clients to connect to `server`.
    /// 
    /// This is valid and non-empty if initializing the `GDBusServer` succeeded.
    @inlinable func getClientAddress() -> String! {
        let result = g_dbus_server_get_client_address(dbus_server_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets the flags for `server`.
    @inlinable func getFlags() -> GIO.DBusServerFlags {
        let result = g_dbus_server_get_flags(dbus_server_ptr)
        let rv = DBusServerFlags(result)
        return rv
    }

    /// Gets the GUID for `server`, as provided to `g_dbus_server_new_sync()`.
    @inlinable func getGuid() -> String! {
        let result = g_dbus_server_get_guid(dbus_server_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Starts `server`.
    @inlinable func start() {
        
        g_dbus_server_start(dbus_server_ptr)
        
    }

    /// Stops `server`.
    @inlinable func stop() {
        
        g_dbus_server_stop(dbus_server_ptr)
        
    }
    /// Gets a
    /// [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html`addresses`)
    /// string that can be used by clients to connect to `server`.
    /// 
    /// This is valid and non-empty if initializing the `GDBusServer` succeeded.
    @inlinable var clientAddress: String! {
        /// Gets a
        /// [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html`addresses`)
        /// string that can be used by clients to connect to `server`.
        /// 
        /// This is valid and non-empty if initializing the `GDBusServer` succeeded.
        get {
            let result = g_dbus_server_get_client_address(dbus_server_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// Flags from the `GDBusServerFlags` enumeration.
    @inlinable var flags: GIO.DBusServerFlags {
        /// Gets the flags for `server`.
        get {
            let result = g_dbus_server_get_flags(dbus_server_ptr)
        let rv = DBusServerFlags(result)
            return rv
        }
    }

    /// The GUID of the server.
    /// 
    /// See `GDBusConnection:guid` for more details.
    @inlinable var guid: String! {
        /// Gets the GUID for `server`, as provided to `g_dbus_server_new_sync()`.
        get {
            let result = g_dbus_server_get_guid(dbus_server_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// Gets whether `server` is active.
    @inlinable var isActive: Bool {
        /// Gets whether `server` is active.
        get {
            let result = g_dbus_server_is_active(dbus_server_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }


}



// MARK: - DataInputStream Class

/// Data input stream implements `GInputStream` and includes functions for
/// reading structured data directly from a binary input stream.
///
/// The `DataInputStreamProtocol` protocol exposes the methods and properties of an underlying `GDataInputStream` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DataInputStream`.
/// Alternatively, use `DataInputStreamRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DataInputStreamProtocol: BufferedInputStreamProtocol {
        /// Untyped pointer to the underlying `GDataInputStream` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDataInputStream` instance.
    var data_input_stream_ptr: UnsafeMutablePointer<GDataInputStream>! { get }

    /// Required Initialiser for types conforming to `DataInputStreamProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Data input stream implements `GInputStream` and includes functions for
/// reading structured data directly from a binary input stream.
///
/// The `DataInputStreamRef` type acts as a lightweight Swift reference to an underlying `GDataInputStream` instance.
/// It exposes methods that can operate on this data type through `DataInputStreamProtocol` conformance.
/// Use `DataInputStreamRef` only as an `unowned` reference to an existing `GDataInputStream` instance.
///
public struct DataInputStreamRef: DataInputStreamProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GDataInputStream` instance.
    /// For type-safe access, use the generated, typed pointer `data_input_stream_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DataInputStreamRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDataInputStream>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDataInputStream>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDataInputStream>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDataInputStream>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DataInputStreamProtocol`
    @inlinable init<T: DataInputStreamProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: DataInputStreamProtocol>(_ other: T) -> DataInputStreamRef { DataInputStreamRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataInputStreamProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataInputStreamProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataInputStreamProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataInputStreamProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataInputStreamProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new data input stream for the `base_stream`.
    @inlinable init<InputStreamT: InputStreamProtocol>( baseStream: InputStreamT) {
            let result = g_data_input_stream_new(baseStream.input_stream_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// Data input stream implements `GInputStream` and includes functions for
/// reading structured data directly from a binary input stream.
///
/// The `DataInputStream` type acts as a reference-counted owner of an underlying `GDataInputStream` instance.
/// It provides the methods that can operate on this data type through `DataInputStreamProtocol` conformance.
/// Use `DataInputStream` as a strong reference or owner of a `GDataInputStream` instance.
///
open class DataInputStream: BufferedInputStream, DataInputStreamProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DataInputStream` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDataInputStream>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DataInputStream` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDataInputStream>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DataInputStream` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DataInputStream` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DataInputStream` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDataInputStream>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DataInputStream` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDataInputStream>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDataInputStream`.
    /// i.e., ownership is transferred to the `DataInputStream` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDataInputStream>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DataInputStreamProtocol`
    /// Will retain `GDataInputStream`.
    /// - Parameter other: an instance of a related type that implements `DataInputStreamProtocol`
    @inlinable public init<T: DataInputStreamProtocol>(dataInputStream other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataInputStreamProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataInputStreamProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataInputStreamProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataInputStreamProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataInputStreamProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataInputStreamProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataInputStreamProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataInputStreamProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new data input stream for the `base_stream`.
    @inlinable public override init<InputStreamT: InputStreamProtocol>( baseStream: InputStreamT) {
            let result = g_data_input_stream_new(baseStream.input_stream_ptr)
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum DataInputStreamPropertyName: String, PropertyNameProtocol {
    case baseStream = "base-stream"
    case bufferSize = "buffer-size"
    /// The :byte-order property determines the byte ordering that
    /// is used when reading multi-byte entities (such as integers)
    /// from the stream.
    case byteOrder = "byte-order"
    case closeBaseStream = "close-base-stream"
    /// The :newline-type property determines what is considered
    /// as a line ending when reading complete lines from the stream.
    case newlineType = "newline-type"
}

public extension DataInputStreamProtocol {
    /// Bind a `DataInputStreamPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: DataInputStreamPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a DataInputStream property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: DataInputStreamPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a DataInputStream property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: DataInputStreamPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum DataInputStreamSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyBaseStream = "notify::base-stream"
    case notifyBufferSize = "notify::buffer-size"
    /// The :byte-order property determines the byte ordering that
    /// is used when reading multi-byte entities (such as integers)
    /// from the stream.
    case notifyByteOrder = "notify::byte-order"
    case notifyCloseBaseStream = "notify::close-base-stream"
    /// The :newline-type property determines what is considered
    /// as a line ending when reading complete lines from the stream.
    case notifyNewlineType = "notify::newline-type"
}

// MARK: DataInputStream has no signals
// MARK: DataInputStream Class: DataInputStreamProtocol extension (methods and fields)
public extension DataInputStreamProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDataInputStream` instance.
    @inlinable var data_input_stream_ptr: UnsafeMutablePointer<GDataInputStream>! { return ptr?.assumingMemoryBound(to: GDataInputStream.self) }

    /// Gets the byte order for the data input stream.
    @inlinable func getByteOrder() -> GDataStreamByteOrder {
        let result = g_data_input_stream_get_byte_order(data_input_stream_ptr)
        let rv = result
        return rv
    }

    /// Gets the current newline type for the `stream`.
    @inlinable func getNewlineType() -> GDataStreamNewlineType {
        let result = g_data_input_stream_get_newline_type(data_input_stream_ptr)
        let rv = result
        return rv
    }

    /// Reads an unsigned 8-bit/1-byte value from `stream`.
    @inlinable func readByte(cancellable: CancellableRef? = nil) throws -> guchar {
            var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_byte(data_input_stream_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            return rv
    }
    /// Reads an unsigned 8-bit/1-byte value from `stream`.
    @inlinable func readByte<CancellableT: CancellableProtocol>(cancellable: CancellableT?) throws -> guchar {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_byte(data_input_stream_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
        return rv
    }

    /// Reads a 16-bit/2-byte value from `stream`.
    /// 
    /// In order to get the correct byte order for this read operation,
    /// see `g_data_input_stream_get_byte_order()` and `g_data_input_stream_set_byte_order()`.
    @inlinable func readInt16(cancellable: CancellableRef? = nil) throws -> gint16 {
            var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_int16(data_input_stream_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            return rv
    }
    /// Reads a 16-bit/2-byte value from `stream`.
    /// 
    /// In order to get the correct byte order for this read operation,
    /// see `g_data_input_stream_get_byte_order()` and `g_data_input_stream_set_byte_order()`.
    @inlinable func readInt16<CancellableT: CancellableProtocol>(cancellable: CancellableT?) throws -> gint16 {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_int16(data_input_stream_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
        return rv
    }

    /// Reads a signed 32-bit/4-byte value from `stream`.
    /// 
    /// In order to get the correct byte order for this read operation,
    /// see `g_data_input_stream_get_byte_order()` and `g_data_input_stream_set_byte_order()`.
    /// 
    /// If `cancellable` is not `nil`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    @inlinable func readInt32(cancellable: CancellableRef? = nil) throws -> gint32 {
            var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_int32(data_input_stream_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            return rv
    }
    /// Reads a signed 32-bit/4-byte value from `stream`.
    /// 
    /// In order to get the correct byte order for this read operation,
    /// see `g_data_input_stream_get_byte_order()` and `g_data_input_stream_set_byte_order()`.
    /// 
    /// If `cancellable` is not `nil`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    @inlinable func readInt32<CancellableT: CancellableProtocol>(cancellable: CancellableT?) throws -> gint32 {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_int32(data_input_stream_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
        return rv
    }

    /// Reads a 64-bit/8-byte value from `stream`.
    /// 
    /// In order to get the correct byte order for this read operation,
    /// see `g_data_input_stream_get_byte_order()` and `g_data_input_stream_set_byte_order()`.
    /// 
    /// If `cancellable` is not `nil`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    @inlinable func readInt64(cancellable: CancellableRef? = nil) throws -> gint64 {
            var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_int64(data_input_stream_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            return rv
    }
    /// Reads a 64-bit/8-byte value from `stream`.
    /// 
    /// In order to get the correct byte order for this read operation,
    /// see `g_data_input_stream_get_byte_order()` and `g_data_input_stream_set_byte_order()`.
    /// 
    /// If `cancellable` is not `nil`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    @inlinable func readInt64<CancellableT: CancellableProtocol>(cancellable: CancellableT?) throws -> gint64 {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_int64(data_input_stream_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
        return rv
    }

    /// Reads a line from the data input stream.  Note that no encoding
    /// checks or conversion is performed; the input is not guaranteed to
    /// be UTF-8, and may in fact have embedded NUL characters.
    /// 
    /// If `cancellable` is not `nil`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    @inlinable func readLine(length: UnsafeMutablePointer<gsize>! = nil, cancellable: CancellableRef? = nil) throws -> String! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_line(data_input_stream_ptr, length, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result.map({ String(cString: $0) })
            return rv
    }
    /// Reads a line from the data input stream.  Note that no encoding
    /// checks or conversion is performed; the input is not guaranteed to
    /// be UTF-8, and may in fact have embedded NUL characters.
    /// 
    /// If `cancellable` is not `nil`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    @inlinable func readLine<CancellableT: CancellableProtocol>(length: UnsafeMutablePointer<gsize>! = nil, cancellable: CancellableT?) throws -> String! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_line(data_input_stream_ptr, length, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// The asynchronous version of `g_data_input_stream_read_line()`.  It is
    /// an error to have two outstanding calls to this function.
    /// 
    /// When the operation is finished, `callback` will be called. You
    /// can then call `g_data_input_stream_read_line_finish()` to get
    /// the result of the operation.
    @inlinable func readLineAsync(ioPriority: Int, cancellable: CancellableRef? = nil, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
            
        g_data_input_stream_read_line_async(data_input_stream_ptr, gint(ioPriority), cancellable?.cancellable_ptr, callback, userData)
            
    }
    /// The asynchronous version of `g_data_input_stream_read_line()`.  It is
    /// an error to have two outstanding calls to this function.
    /// 
    /// When the operation is finished, `callback` will be called. You
    /// can then call `g_data_input_stream_read_line_finish()` to get
    /// the result of the operation.
    @inlinable func readLineAsync<CancellableT: CancellableProtocol>(ioPriority: Int, cancellable: CancellableT?, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
        
        g_data_input_stream_read_line_async(data_input_stream_ptr, gint(ioPriority), cancellable?.cancellable_ptr, callback, userData)
        
    }

    /// Finish an asynchronous call started by
    /// `g_data_input_stream_read_line_async()`.  Note the warning about
    /// string encoding in `g_data_input_stream_read_line()` applies here as
    /// well.
    @inlinable func readLineFinish<AsyncResultT: AsyncResultProtocol>(result: AsyncResultT, length: UnsafeMutablePointer<gsize>! = nil) throws -> String! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_line_finish(data_input_stream_ptr, result.async_result_ptr, length, &error)
        if let error = error { throw GLibError(error) }
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Finish an asynchronous call started by
    /// `g_data_input_stream_read_line_async()`.
    @inlinable func readLineFinishUTF8<AsyncResultT: AsyncResultProtocol>(result: AsyncResultT, length: UnsafeMutablePointer<gsize>! = nil) throws -> String! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_line_finish_utf8(data_input_stream_ptr, result.async_result_ptr, length, &error)
        if let error = error { throw GLibError(error) }
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Reads a UTF-8 encoded line from the data input stream.
    /// 
    /// If `cancellable` is not `nil`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    @inlinable func readLineUTF8(length: UnsafeMutablePointer<gsize>! = nil, cancellable: CancellableRef? = nil) throws -> String! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_line_utf8(data_input_stream_ptr, length, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result.map({ String(cString: $0) })
            return rv
    }
    /// Reads a UTF-8 encoded line from the data input stream.
    /// 
    /// If `cancellable` is not `nil`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    @inlinable func readLineUTF8<CancellableT: CancellableProtocol>(length: UnsafeMutablePointer<gsize>! = nil, cancellable: CancellableT?) throws -> String! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_line_utf8(data_input_stream_ptr, length, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Reads an unsigned 16-bit/2-byte value from `stream`.
    /// 
    /// In order to get the correct byte order for this read operation,
    /// see `g_data_input_stream_get_byte_order()` and `g_data_input_stream_set_byte_order()`.
    @inlinable func readUint16(cancellable: CancellableRef? = nil) throws -> guint16 {
            var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_uint16(data_input_stream_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            return rv
    }
    /// Reads an unsigned 16-bit/2-byte value from `stream`.
    /// 
    /// In order to get the correct byte order for this read operation,
    /// see `g_data_input_stream_get_byte_order()` and `g_data_input_stream_set_byte_order()`.
    @inlinable func readUint16<CancellableT: CancellableProtocol>(cancellable: CancellableT?) throws -> guint16 {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_uint16(data_input_stream_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
        return rv
    }

    /// Reads an unsigned 32-bit/4-byte value from `stream`.
    /// 
    /// In order to get the correct byte order for this read operation,
    /// see `g_data_input_stream_get_byte_order()` and `g_data_input_stream_set_byte_order()`.
    /// 
    /// If `cancellable` is not `nil`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    @inlinable func readUint32(cancellable: CancellableRef? = nil) throws -> guint32 {
            var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_uint32(data_input_stream_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            return rv
    }
    /// Reads an unsigned 32-bit/4-byte value from `stream`.
    /// 
    /// In order to get the correct byte order for this read operation,
    /// see `g_data_input_stream_get_byte_order()` and `g_data_input_stream_set_byte_order()`.
    /// 
    /// If `cancellable` is not `nil`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    @inlinable func readUint32<CancellableT: CancellableProtocol>(cancellable: CancellableT?) throws -> guint32 {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_uint32(data_input_stream_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
        return rv
    }

    /// Reads an unsigned 64-bit/8-byte value from `stream`.
    /// 
    /// In order to get the correct byte order for this read operation,
    /// see `g_data_input_stream_get_byte_order()`.
    /// 
    /// If `cancellable` is not `nil`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    @inlinable func readUint64(cancellable: CancellableRef? = nil) throws -> guint64 {
            var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_uint64(data_input_stream_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            return rv
    }
    /// Reads an unsigned 64-bit/8-byte value from `stream`.
    /// 
    /// In order to get the correct byte order for this read operation,
    /// see `g_data_input_stream_get_byte_order()`.
    /// 
    /// If `cancellable` is not `nil`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    @inlinable func readUint64<CancellableT: CancellableProtocol>(cancellable: CancellableT?) throws -> guint64 {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_uint64(data_input_stream_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
        return rv
    }

    /// Reads a string from the data input stream, up to the first
    /// occurrence of any of the stop characters.
    /// 
    /// Note that, in contrast to `g_data_input_stream_read_until_async()`,
    /// this function consumes the stop character that it finds.
    /// 
    /// Don't use this function in new code.  Its functionality is
    /// inconsistent with `g_data_input_stream_read_until_async()`.  Both
    /// functions will be marked as deprecated in a future release.  Use
    /// `g_data_input_stream_read_upto()` instead, but note that that function
    /// does not consume the stop character.
    ///
    /// **read_until is deprecated:**
    /// Use g_data_input_stream_read_upto() instead, which has more
    ///     consistent behaviour regarding the stop character.
    @available(*, deprecated) @inlinable func readUntil(stopChars: UnsafePointer<gchar>!, length: UnsafeMutablePointer<gsize>! = nil, cancellable: CancellableRef? = nil) throws -> String! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_until(data_input_stream_ptr, stopChars, length, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result.map({ String(cString: $0) })
            return rv
    }
    /// Reads a string from the data input stream, up to the first
    /// occurrence of any of the stop characters.
    /// 
    /// Note that, in contrast to `g_data_input_stream_read_until_async()`,
    /// this function consumes the stop character that it finds.
    /// 
    /// Don't use this function in new code.  Its functionality is
    /// inconsistent with `g_data_input_stream_read_until_async()`.  Both
    /// functions will be marked as deprecated in a future release.  Use
    /// `g_data_input_stream_read_upto()` instead, but note that that function
    /// does not consume the stop character.
    ///
    /// **read_until is deprecated:**
    /// Use g_data_input_stream_read_upto() instead, which has more
    ///     consistent behaviour regarding the stop character.
    @available(*, deprecated) @inlinable func readUntil<CancellableT: CancellableProtocol>(stopChars: UnsafePointer<gchar>!, length: UnsafeMutablePointer<gsize>! = nil, cancellable: CancellableT?) throws -> String! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_until(data_input_stream_ptr, stopChars, length, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// The asynchronous version of `g_data_input_stream_read_until()`.
    /// It is an error to have two outstanding calls to this function.
    /// 
    /// Note that, in contrast to `g_data_input_stream_read_until()`,
    /// this function does not consume the stop character that it finds.  You
    /// must read it for yourself.
    /// 
    /// When the operation is finished, `callback` will be called. You
    /// can then call `g_data_input_stream_read_until_finish()` to get
    /// the result of the operation.
    /// 
    /// Don't use this function in new code.  Its functionality is
    /// inconsistent with `g_data_input_stream_read_until()`.  Both functions
    /// will be marked as deprecated in a future release.  Use
    /// `g_data_input_stream_read_upto_async()` instead.
    ///
    /// **read_until_async is deprecated:**
    /// Use g_data_input_stream_read_upto_async() instead, which
    ///     has more consistent behaviour regarding the stop character.
    @available(*, deprecated) @inlinable func readUntilAsync(stopChars: UnsafePointer<gchar>!, ioPriority: Int, cancellable: CancellableRef? = nil, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
            
        g_data_input_stream_read_until_async(data_input_stream_ptr, stopChars, gint(ioPriority), cancellable?.cancellable_ptr, callback, userData)
            
    }
    /// The asynchronous version of `g_data_input_stream_read_until()`.
    /// It is an error to have two outstanding calls to this function.
    /// 
    /// Note that, in contrast to `g_data_input_stream_read_until()`,
    /// this function does not consume the stop character that it finds.  You
    /// must read it for yourself.
    /// 
    /// When the operation is finished, `callback` will be called. You
    /// can then call `g_data_input_stream_read_until_finish()` to get
    /// the result of the operation.
    /// 
    /// Don't use this function in new code.  Its functionality is
    /// inconsistent with `g_data_input_stream_read_until()`.  Both functions
    /// will be marked as deprecated in a future release.  Use
    /// `g_data_input_stream_read_upto_async()` instead.
    ///
    /// **read_until_async is deprecated:**
    /// Use g_data_input_stream_read_upto_async() instead, which
    ///     has more consistent behaviour regarding the stop character.
    @available(*, deprecated) @inlinable func readUntilAsync<CancellableT: CancellableProtocol>(stopChars: UnsafePointer<gchar>!, ioPriority: Int, cancellable: CancellableT?, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
        
        g_data_input_stream_read_until_async(data_input_stream_ptr, stopChars, gint(ioPriority), cancellable?.cancellable_ptr, callback, userData)
        
    }

    /// Finish an asynchronous call started by
    /// `g_data_input_stream_read_until_async()`.
    ///
    /// **read_until_finish is deprecated:**
    /// Use g_data_input_stream_read_upto_finish() instead, which
    ///     has more consistent behaviour regarding the stop character.
    @available(*, deprecated) @inlinable func readUntilFinish<AsyncResultT: AsyncResultProtocol>(result: AsyncResultT, length: UnsafeMutablePointer<gsize>! = nil) throws -> String! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_until_finish(data_input_stream_ptr, result.async_result_ptr, length, &error)
        if let error = error { throw GLibError(error) }
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Reads a string from the data input stream, up to the first
    /// occurrence of any of the stop characters.
    /// 
    /// In contrast to `g_data_input_stream_read_until()`, this function
    /// does not consume the stop character. You have to use
    /// `g_data_input_stream_read_byte()` to get it before calling
    /// `g_data_input_stream_read_upto()` again.
    /// 
    /// Note that `stop_chars` may contain '\0' if `stop_chars_len` is
    /// specified.
    /// 
    /// The returned string will always be nul-terminated on success.
    @inlinable func readUpto(stopChars: UnsafePointer<gchar>!, stopCharsLen: gssize, length: UnsafeMutablePointer<gsize>! = nil, cancellable: CancellableRef? = nil) throws -> String! {
            var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_upto(data_input_stream_ptr, stopChars, stopCharsLen, length, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result.map({ String(cString: $0) })
            return rv
    }
    /// Reads a string from the data input stream, up to the first
    /// occurrence of any of the stop characters.
    /// 
    /// In contrast to `g_data_input_stream_read_until()`, this function
    /// does not consume the stop character. You have to use
    /// `g_data_input_stream_read_byte()` to get it before calling
    /// `g_data_input_stream_read_upto()` again.
    /// 
    /// Note that `stop_chars` may contain '\0' if `stop_chars_len` is
    /// specified.
    /// 
    /// The returned string will always be nul-terminated on success.
    @inlinable func readUpto<CancellableT: CancellableProtocol>(stopChars: UnsafePointer<gchar>!, stopCharsLen: gssize, length: UnsafeMutablePointer<gsize>! = nil, cancellable: CancellableT?) throws -> String! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_upto(data_input_stream_ptr, stopChars, stopCharsLen, length, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// The asynchronous version of `g_data_input_stream_read_upto()`.
    /// It is an error to have two outstanding calls to this function.
    /// 
    /// In contrast to `g_data_input_stream_read_until()`, this function
    /// does not consume the stop character. You have to use
    /// `g_data_input_stream_read_byte()` to get it before calling
    /// `g_data_input_stream_read_upto()` again.
    /// 
    /// Note that `stop_chars` may contain '\0' if `stop_chars_len` is
    /// specified.
    /// 
    /// When the operation is finished, `callback` will be called. You
    /// can then call `g_data_input_stream_read_upto_finish()` to get
    /// the result of the operation.
    @inlinable func readUptoAsync(stopChars: UnsafePointer<gchar>!, stopCharsLen: gssize, ioPriority: Int, cancellable: CancellableRef? = nil, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
            
        g_data_input_stream_read_upto_async(data_input_stream_ptr, stopChars, stopCharsLen, gint(ioPriority), cancellable?.cancellable_ptr, callback, userData)
            
    }
    /// The asynchronous version of `g_data_input_stream_read_upto()`.
    /// It is an error to have two outstanding calls to this function.
    /// 
    /// In contrast to `g_data_input_stream_read_until()`, this function
    /// does not consume the stop character. You have to use
    /// `g_data_input_stream_read_byte()` to get it before calling
    /// `g_data_input_stream_read_upto()` again.
    /// 
    /// Note that `stop_chars` may contain '\0' if `stop_chars_len` is
    /// specified.
    /// 
    /// When the operation is finished, `callback` will be called. You
    /// can then call `g_data_input_stream_read_upto_finish()` to get
    /// the result of the operation.
    @inlinable func readUptoAsync<CancellableT: CancellableProtocol>(stopChars: UnsafePointer<gchar>!, stopCharsLen: gssize, ioPriority: Int, cancellable: CancellableT?, callback: GAsyncReadyCallback? = nil, userData: gpointer? = nil) {
        
        g_data_input_stream_read_upto_async(data_input_stream_ptr, stopChars, stopCharsLen, gint(ioPriority), cancellable?.cancellable_ptr, callback, userData)
        
    }

    /// Finish an asynchronous call started by
    /// `g_data_input_stream_read_upto_async()`.
    /// 
    /// Note that this function does not consume the stop character. You
    /// have to use `g_data_input_stream_read_byte()` to get it before calling
    /// `g_data_input_stream_read_upto_async()` again.
    /// 
    /// The returned string will always be nul-terminated on success.
    @inlinable func readUptoFinish<AsyncResultT: AsyncResultProtocol>(result: AsyncResultT, length: UnsafeMutablePointer<gsize>! = nil) throws -> String! {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_input_stream_read_upto_finish(data_input_stream_ptr, result.async_result_ptr, length, &error)
        if let error = error { throw GLibError(error) }
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// This function sets the byte order for the given `stream`. All subsequent
    /// reads from the `stream` will be read in the given `order`.
    @inlinable func setByte(order: GDataStreamByteOrder) {
        
        g_data_input_stream_set_byte_order(data_input_stream_ptr, order)
        
    }

    /// Sets the newline type for the `stream`.
    /// 
    /// Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a read
    /// chunk ends in "CR" we must read an additional byte to know if this is "CR" or
    /// "CR LF", and this might block if there is no more data available.
    @inlinable func setNewline(type: GDataStreamNewlineType) {
        
        g_data_input_stream_set_newline_type(data_input_stream_ptr, type)
        
    }
    /// Gets the byte order for the data input stream.
    @inlinable var byteOrder: GDataStreamByteOrder {
        /// Gets the byte order for the data input stream.
        get {
            let result = g_data_input_stream_get_byte_order(data_input_stream_ptr)
        let rv = result
            return rv
        }
        /// This function sets the byte order for the given `stream`. All subsequent
        /// reads from the `stream` will be read in the given `order`.
        nonmutating set {
            g_data_input_stream_set_byte_order(data_input_stream_ptr, newValue)
        }
    }

    /// Gets the current newline type for the `stream`.
    @inlinable var newlineType: GDataStreamNewlineType {
        /// Gets the current newline type for the `stream`.
        get {
            let result = g_data_input_stream_get_newline_type(data_input_stream_ptr)
        let rv = result
            return rv
        }
        /// Sets the newline type for the `stream`.
        /// 
        /// Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a read
        /// chunk ends in "CR" we must read an additional byte to know if this is "CR" or
        /// "CR LF", and this might block if there is no more data available.
        nonmutating set {
            g_data_input_stream_set_newline_type(data_input_stream_ptr, newValue)
        }
    }

    @inlinable var parentInstance: GBufferedInputStream {
        get {
            let rv = data_input_stream_ptr.pointee.parent_instance
    return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - DataOutputStream Class

/// Data output stream implements `GOutputStream` and includes functions for
/// writing data directly to an output stream.
///
/// The `DataOutputStreamProtocol` protocol exposes the methods and properties of an underlying `GDataOutputStream` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DataOutputStream`.
/// Alternatively, use `DataOutputStreamRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DataOutputStreamProtocol: FilterOutputStreamProtocol, SeekableProtocol {
        /// Untyped pointer to the underlying `GDataOutputStream` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDataOutputStream` instance.
    var data_output_stream_ptr: UnsafeMutablePointer<GDataOutputStream>! { get }

    /// Required Initialiser for types conforming to `DataOutputStreamProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Data output stream implements `GOutputStream` and includes functions for
/// writing data directly to an output stream.
///
/// The `DataOutputStreamRef` type acts as a lightweight Swift reference to an underlying `GDataOutputStream` instance.
/// It exposes methods that can operate on this data type through `DataOutputStreamProtocol` conformance.
/// Use `DataOutputStreamRef` only as an `unowned` reference to an existing `GDataOutputStream` instance.
///
public struct DataOutputStreamRef: DataOutputStreamProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GDataOutputStream` instance.
    /// For type-safe access, use the generated, typed pointer `data_output_stream_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DataOutputStreamRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDataOutputStream>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDataOutputStream>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDataOutputStream>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDataOutputStream>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DataOutputStreamProtocol`
    @inlinable init<T: DataOutputStreamProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: DataOutputStreamProtocol>(_ other: T) -> DataOutputStreamRef { DataOutputStreamRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataOutputStreamProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataOutputStreamProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataOutputStreamProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataOutputStreamProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataOutputStreamProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new data output stream for `base_stream`.
    @inlinable init<OutputStreamT: OutputStreamProtocol>( baseStream: OutputStreamT) {
            let result = g_data_output_stream_new(baseStream.output_stream_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// Data output stream implements `GOutputStream` and includes functions for
/// writing data directly to an output stream.
///
/// The `DataOutputStream` type acts as a reference-counted owner of an underlying `GDataOutputStream` instance.
/// It provides the methods that can operate on this data type through `DataOutputStreamProtocol` conformance.
/// Use `DataOutputStream` as a strong reference or owner of a `GDataOutputStream` instance.
///
open class DataOutputStream: FilterOutputStream, DataOutputStreamProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DataOutputStream` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDataOutputStream>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DataOutputStream` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDataOutputStream>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DataOutputStream` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DataOutputStream` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DataOutputStream` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDataOutputStream>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DataOutputStream` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDataOutputStream>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDataOutputStream`.
    /// i.e., ownership is transferred to the `DataOutputStream` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDataOutputStream>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DataOutputStreamProtocol`
    /// Will retain `GDataOutputStream`.
    /// - Parameter other: an instance of a related type that implements `DataOutputStreamProtocol`
    @inlinable public init<T: DataOutputStreamProtocol>(dataOutputStream other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataOutputStreamProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataOutputStreamProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataOutputStreamProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataOutputStreamProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataOutputStreamProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataOutputStreamProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataOutputStreamProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DataOutputStreamProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new data output stream for `base_stream`.
    @inlinable public init<OutputStreamT: OutputStreamProtocol>( baseStream: OutputStreamT) {
            let result = g_data_output_stream_new(baseStream.output_stream_ptr)
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum DataOutputStreamPropertyName: String, PropertyNameProtocol {
    case baseStream = "base-stream"
    /// Determines the byte ordering that is used when writing
    /// multi-byte entities (such as integers) to the stream.
    case byteOrder = "byte-order"
    case closeBaseStream = "close-base-stream"
}

public extension DataOutputStreamProtocol {
    /// Bind a `DataOutputStreamPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: DataOutputStreamPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a DataOutputStream property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: DataOutputStreamPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a DataOutputStream property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: DataOutputStreamPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum DataOutputStreamSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyBaseStream = "notify::base-stream"
    /// Determines the byte ordering that is used when writing
    /// multi-byte entities (such as integers) to the stream.
    case notifyByteOrder = "notify::byte-order"
    case notifyCloseBaseStream = "notify::close-base-stream"
}

// MARK: DataOutputStream has no signals
// MARK: DataOutputStream Class: DataOutputStreamProtocol extension (methods and fields)
public extension DataOutputStreamProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDataOutputStream` instance.
    @inlinable var data_output_stream_ptr: UnsafeMutablePointer<GDataOutputStream>! { return ptr?.assumingMemoryBound(to: GDataOutputStream.self) }

    /// Gets the byte order for the stream.
    @inlinable func getByteOrder() -> GDataStreamByteOrder {
        let result = g_data_output_stream_get_byte_order(data_output_stream_ptr)
        let rv = result
        return rv
    }

    /// Puts a byte into the output stream.
    @inlinable func putByte(data: guchar, cancellable: CancellableRef? = nil) throws -> Bool {
            var error: UnsafeMutablePointer<GError>?
        let result = g_data_output_stream_put_byte(data_output_stream_ptr, data, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
            return rv
    }
    /// Puts a byte into the output stream.
    @inlinable func putByte<CancellableT: CancellableProtocol>(data: guchar, cancellable: CancellableT?) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_output_stream_put_byte(data_output_stream_ptr, data, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Puts a signed 16-bit integer into the output stream.
    @inlinable func putInt16(data: gint16, cancellable: CancellableRef? = nil) throws -> Bool {
            var error: UnsafeMutablePointer<GError>?
        let result = g_data_output_stream_put_int16(data_output_stream_ptr, data, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
            return rv
    }
    /// Puts a signed 16-bit integer into the output stream.
    @inlinable func putInt16<CancellableT: CancellableProtocol>(data: gint16, cancellable: CancellableT?) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_output_stream_put_int16(data_output_stream_ptr, data, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Puts a signed 32-bit integer into the output stream.
    @inlinable func putInt32(data: gint32, cancellable: CancellableRef? = nil) throws -> Bool {
            var error: UnsafeMutablePointer<GError>?
        let result = g_data_output_stream_put_int32(data_output_stream_ptr, data, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
            return rv
    }
    /// Puts a signed 32-bit integer into the output stream.
    @inlinable func putInt32<CancellableT: CancellableProtocol>(data: gint32, cancellable: CancellableT?) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_output_stream_put_int32(data_output_stream_ptr, data, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Puts a signed 64-bit integer into the stream.
    @inlinable func putInt64(data: gint64, cancellable: CancellableRef? = nil) throws -> Bool {
            var error: UnsafeMutablePointer<GError>?
        let result = g_data_output_stream_put_int64(data_output_stream_ptr, data, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
            return rv
    }
    /// Puts a signed 64-bit integer into the stream.
    @inlinable func putInt64<CancellableT: CancellableProtocol>(data: gint64, cancellable: CancellableT?) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_output_stream_put_int64(data_output_stream_ptr, data, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Puts a string into the output stream.
    @inlinable func putString(str: UnsafePointer<CChar>!, cancellable: CancellableRef? = nil) throws -> Bool {
            var error: UnsafeMutablePointer<GError>?
        let result = g_data_output_stream_put_string(data_output_stream_ptr, str, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
            return rv
    }
    /// Puts a string into the output stream.
    @inlinable func putString<CancellableT: CancellableProtocol>(str: UnsafePointer<CChar>!, cancellable: CancellableT?) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_output_stream_put_string(data_output_stream_ptr, str, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Puts an unsigned 16-bit integer into the output stream.
    @inlinable func putUint16(data: guint16, cancellable: CancellableRef? = nil) throws -> Bool {
            var error: UnsafeMutablePointer<GError>?
        let result = g_data_output_stream_put_uint16(data_output_stream_ptr, data, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
            return rv
    }
    /// Puts an unsigned 16-bit integer into the output stream.
    @inlinable func putUint16<CancellableT: CancellableProtocol>(data: guint16, cancellable: CancellableT?) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_output_stream_put_uint16(data_output_stream_ptr, data, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Puts an unsigned 32-bit integer into the stream.
    @inlinable func putUint32(data: guint32, cancellable: CancellableRef? = nil) throws -> Bool {
            var error: UnsafeMutablePointer<GError>?
        let result = g_data_output_stream_put_uint32(data_output_stream_ptr, data, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
            return rv
    }
    /// Puts an unsigned 32-bit integer into the stream.
    @inlinable func putUint32<CancellableT: CancellableProtocol>(data: guint32, cancellable: CancellableT?) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_output_stream_put_uint32(data_output_stream_ptr, data, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Puts an unsigned 64-bit integer into the stream.
    @inlinable func putUint64(data: guint64, cancellable: CancellableRef? = nil) throws -> Bool {
            var error: UnsafeMutablePointer<GError>?
        let result = g_data_output_stream_put_uint64(data_output_stream_ptr, data, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
            return rv
    }
    /// Puts an unsigned 64-bit integer into the stream.
    @inlinable func putUint64<CancellableT: CancellableProtocol>(data: guint64, cancellable: CancellableT?) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_data_output_stream_put_uint64(data_output_stream_ptr, data, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Sets the byte order of the data output stream to `order`.
    @inlinable func setByte(order: GDataStreamByteOrder) {
        
        g_data_output_stream_set_byte_order(data_output_stream_ptr, order)
        
    }
    /// Gets the byte order for the stream.
    @inlinable var byteOrder: GDataStreamByteOrder {
        /// Gets the byte order for the stream.
        get {
            let result = g_data_output_stream_get_byte_order(data_output_stream_ptr)
        let rv = result
            return rv
        }
        /// Sets the byte order of the data output stream to `order`.
        nonmutating set {
            g_data_output_stream_set_byte_order(data_output_stream_ptr, newValue)
        }
    }

    @inlinable var parentInstance: GFilterOutputStream {
        get {
            let rv = data_output_stream_ptr.pointee.parent_instance
    return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - DebugControllerDBus Class

/// `GDebugControllerDBus` is an implementation of `GDebugController` which exposes
/// debug settings as a D-Bus object.
/// 
/// It is a `GInitable` object, and will register an object at
/// `/org/gtk/Debugging` on the bus given as
/// `GDebugControllerDBus:connection` once its initialized. The object will be
/// unregistered when the last reference to the `GDebugControllerDBus` is dropped.
/// 
/// This D-Bus object can be used by remote processes to enable or disable debug
/// output in this process. Remote processes calling
/// ``org.gtk.Debugging.SetDebugEnabled()`` will affect the value of
/// `GDebugController:debug-enabled` and, by default, `g_log_get_debug_enabled()`.
/// default.
/// 
/// By default, all processes will be able to call ``SetDebugEnabled()``. If this
/// process is privileged, or might expose sensitive information in its debug
/// output, you may want to restrict the ability to enable debug output to
/// privileged users or processes.
/// 
/// One option is to install a D-Bus security policy which restricts access to
/// ``SetDebugEnabled()``, installing something like the following in
/// `$datadir/dbus-1/system.d/`:
/// (XML Language Example):
/// ```XML
/// <?xml version="1.0"?> <!--*-nxml-*-->
/// <!DOCTYPE busconfig PUBLIC "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
///      "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
/// <busconfig>
///   <policy user="root">
///     <allow send_destination="com.example.MyService" send_interface="org.gtk.Debugging"/>
///   </policy>
///   <policy context="default">
///     <deny send_destination="com.example.MyService" send_interface="org.gtk.Debugging"/>
///   </policy>
/// </busconfig>
/// ```
/// 
/// This will prevent the ``SetDebugEnabled()`` method from being called by all
/// except root. It will not prevent the `DebugEnabled` property from being read,
/// as its accessed through the `org.freedesktop.DBus.Properties` interface.
/// 
/// Another option is to use polkit to allow or deny requests on a case-by-case
/// basis, allowing for the possibility of dynamic authorisation. To do this,
/// connect to the `GDebugControllerDBus::authorize` signal and query polkit in
/// it:
/// (C Language Example):
/// ```C
///   g_autoptr(GError) child_error = NULL;
///   g_autoptr(GDBusConnection) connection = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);
///   gulong debug_controller_authorize_id = 0;
/// 
///   // Set up the debug controller.
///   debug_controller = G_DEBUG_CONTROLLER (g_debug_controller_dbus_new (priv->connection, NULL, &child_error));
///   if (debug_controller == NULL)
///     {
///       g_error ("Could not register debug controller on bus: %s"),
///                child_error->message);
///     }
/// 
///   debug_controller_authorize_id = g_signal_connect (debug_controller,
///                                                     "authorize",
///                                                     G_CALLBACK (debug_controller_authorize_cb),
///                                                     self);
/// 
///   static gboolean
///   debug_controller_authorize_cb (GDebugControllerDBus  *debug_controller,
///                                  GDBusMethodInvocation *invocation,
///                                  gpointer               user_data)
///   {
///     g_autoptr(PolkitAuthority) authority = NULL;
///     g_autoptr(PolkitSubject) subject = NULL;
///     g_autoptr(PolkitAuthorizationResult) auth_result = NULL;
///     g_autoptr(GError) local_error = NULL;
///     GDBusMessage *message;
///     GDBusMessageFlags message_flags;
///     PolkitCheckAuthorizationFlags flags = POLKIT_CHECK_AUTHORIZATION_FLAGS_NONE;
/// 
///     message = g_dbus_method_invocation_get_message (invocation);
///     message_flags = g_dbus_message_get_flags (message);
/// 
///     authority = polkit_authority_get_sync (NULL, &local_error);
///     if (authority == NULL)
///       {
///         g_warning ("Failed to get polkit authority: %s", local_error->message);
///         return FALSE;
///       }
/// 
///     if (message_flags & G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION)
///       flags |= POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION;
/// 
///     subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (invocation));
/// 
///     auth_result = polkit_authority_check_authorization_sync (authority,
///                                                              subject,
///                                                              "com.example.MyService.set-debug-enabled",
///                                                              NULL,
///                                                              flags,
///                                                              NULL,
///                                                              &local_error);
///     if (auth_result == NULL)
///       {
///         g_warning ("Failed to get check polkit authorization: %s", local_error->message);
///         return FALSE;
///       }
/// 
///     return polkit_authorization_result_get_is_authorized (auth_result);
///   }
/// ```
/// 
///
/// The `DebugControllerDBusProtocol` protocol exposes the methods and properties of an underlying `GDebugControllerDBus` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DebugControllerDBus`.
/// Alternatively, use `DebugControllerDBusRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DebugControllerDBusProtocol: GLibObject.ObjectProtocol, DebugControllerProtocol, InitableProtocol {
        /// Untyped pointer to the underlying `GDebugControllerDBus` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDebugControllerDBus` instance.
    var debug_controller_dbus_ptr: UnsafeMutablePointer<GDebugControllerDBus>! { get }

    /// Required Initialiser for types conforming to `DebugControllerDBusProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GDebugControllerDBus` is an implementation of `GDebugController` which exposes
/// debug settings as a D-Bus object.
/// 
/// It is a `GInitable` object, and will register an object at
/// `/org/gtk/Debugging` on the bus given as
/// `GDebugControllerDBus:connection` once its initialized. The object will be
/// unregistered when the last reference to the `GDebugControllerDBus` is dropped.
/// 
/// This D-Bus object can be used by remote processes to enable or disable debug
/// output in this process. Remote processes calling
/// ``org.gtk.Debugging.SetDebugEnabled()`` will affect the value of
/// `GDebugController:debug-enabled` and, by default, `g_log_get_debug_enabled()`.
/// default.
/// 
/// By default, all processes will be able to call ``SetDebugEnabled()``. If this
/// process is privileged, or might expose sensitive information in its debug
/// output, you may want to restrict the ability to enable debug output to
/// privileged users or processes.
/// 
/// One option is to install a D-Bus security policy which restricts access to
/// ``SetDebugEnabled()``, installing something like the following in
/// `$datadir/dbus-1/system.d/`:
/// (XML Language Example):
/// ```XML
/// <?xml version="1.0"?> <!--*-nxml-*-->
/// <!DOCTYPE busconfig PUBLIC "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
///      "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
/// <busconfig>
///   <policy user="root">
///     <allow send_destination="com.example.MyService" send_interface="org.gtk.Debugging"/>
///   </policy>
///   <policy context="default">
///     <deny send_destination="com.example.MyService" send_interface="org.gtk.Debugging"/>
///   </policy>
/// </busconfig>
/// ```
/// 
/// This will prevent the ``SetDebugEnabled()`` method from being called by all
/// except root. It will not prevent the `DebugEnabled` property from being read,
/// as its accessed through the `org.freedesktop.DBus.Properties` interface.
/// 
/// Another option is to use polkit to allow or deny requests on a case-by-case
/// basis, allowing for the possibility of dynamic authorisation. To do this,
/// connect to the `GDebugControllerDBus::authorize` signal and query polkit in
/// it:
/// (C Language Example):
/// ```C
///   g_autoptr(GError) child_error = NULL;
///   g_autoptr(GDBusConnection) connection = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);
///   gulong debug_controller_authorize_id = 0;
/// 
///   // Set up the debug controller.
///   debug_controller = G_DEBUG_CONTROLLER (g_debug_controller_dbus_new (priv->connection, NULL, &child_error));
///   if (debug_controller == NULL)
///     {
///       g_error ("Could not register debug controller on bus: %s"),
///                child_error->message);
///     }
/// 
///   debug_controller_authorize_id = g_signal_connect (debug_controller,
///                                                     "authorize",
///                                                     G_CALLBACK (debug_controller_authorize_cb),
///                                                     self);
/// 
///   static gboolean
///   debug_controller_authorize_cb (GDebugControllerDBus  *debug_controller,
///                                  GDBusMethodInvocation *invocation,
///                                  gpointer               user_data)
///   {
///     g_autoptr(PolkitAuthority) authority = NULL;
///     g_autoptr(PolkitSubject) subject = NULL;
///     g_autoptr(PolkitAuthorizationResult) auth_result = NULL;
///     g_autoptr(GError) local_error = NULL;
///     GDBusMessage *message;
///     GDBusMessageFlags message_flags;
///     PolkitCheckAuthorizationFlags flags = POLKIT_CHECK_AUTHORIZATION_FLAGS_NONE;
/// 
///     message = g_dbus_method_invocation_get_message (invocation);
///     message_flags = g_dbus_message_get_flags (message);
/// 
///     authority = polkit_authority_get_sync (NULL, &local_error);
///     if (authority == NULL)
///       {
///         g_warning ("Failed to get polkit authority: %s", local_error->message);
///         return FALSE;
///       }
/// 
///     if (message_flags & G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION)
///       flags |= POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION;
/// 
///     subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (invocation));
/// 
///     auth_result = polkit_authority_check_authorization_sync (authority,
///                                                              subject,
///                                                              "com.example.MyService.set-debug-enabled",
///                                                              NULL,
///                                                              flags,
///                                                              NULL,
///                                                              &local_error);
///     if (auth_result == NULL)
///       {
///         g_warning ("Failed to get check polkit authorization: %s", local_error->message);
///         return FALSE;
///       }
/// 
///     return polkit_authorization_result_get_is_authorized (auth_result);
///   }
/// ```
/// 
///
/// The `DebugControllerDBusRef` type acts as a lightweight Swift reference to an underlying `GDebugControllerDBus` instance.
/// It exposes methods that can operate on this data type through `DebugControllerDBusProtocol` conformance.
/// Use `DebugControllerDBusRef` only as an `unowned` reference to an existing `GDebugControllerDBus` instance.
///
public struct DebugControllerDBusRef: DebugControllerDBusProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GDebugControllerDBus` instance.
    /// For type-safe access, use the generated, typed pointer `debug_controller_dbus_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DebugControllerDBusRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDebugControllerDBus>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDebugControllerDBus>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDebugControllerDBus>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDebugControllerDBus>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DebugControllerDBusProtocol`
    @inlinable init<T: DebugControllerDBusProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: DebugControllerDBusProtocol>(_ other: T) -> DebugControllerDBusRef { DebugControllerDBusRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerDBusProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerDBusProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerDBusProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerDBusProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerDBusProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Create a new `GDebugControllerDBus` and synchronously initialize it.
    /// 
    /// Initializing the object will export the debug object on `connection`. The
    /// object will remain registered until the last reference to the
    /// `GDebugControllerDBus` is dropped.
    /// 
    /// Initialization may fail if registering the object on `connection` fails.
    @inlinable init<CancellableT: CancellableProtocol, DBusConnectionT: DBusConnectionProtocol>( connection: DBusConnectionT, cancellable: CancellableT?) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_debug_controller_dbus_new(connection.dbus_connection_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GDebugControllerDBus` is an implementation of `GDebugController` which exposes
/// debug settings as a D-Bus object.
/// 
/// It is a `GInitable` object, and will register an object at
/// `/org/gtk/Debugging` on the bus given as
/// `GDebugControllerDBus:connection` once its initialized. The object will be
/// unregistered when the last reference to the `GDebugControllerDBus` is dropped.
/// 
/// This D-Bus object can be used by remote processes to enable or disable debug
/// output in this process. Remote processes calling
/// ``org.gtk.Debugging.SetDebugEnabled()`` will affect the value of
/// `GDebugController:debug-enabled` and, by default, `g_log_get_debug_enabled()`.
/// default.
/// 
/// By default, all processes will be able to call ``SetDebugEnabled()``. If this
/// process is privileged, or might expose sensitive information in its debug
/// output, you may want to restrict the ability to enable debug output to
/// privileged users or processes.
/// 
/// One option is to install a D-Bus security policy which restricts access to
/// ``SetDebugEnabled()``, installing something like the following in
/// `$datadir/dbus-1/system.d/`:
/// (XML Language Example):
/// ```XML
/// <?xml version="1.0"?> <!--*-nxml-*-->
/// <!DOCTYPE busconfig PUBLIC "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
///      "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
/// <busconfig>
///   <policy user="root">
///     <allow send_destination="com.example.MyService" send_interface="org.gtk.Debugging"/>
///   </policy>
///   <policy context="default">
///     <deny send_destination="com.example.MyService" send_interface="org.gtk.Debugging"/>
///   </policy>
/// </busconfig>
/// ```
/// 
/// This will prevent the ``SetDebugEnabled()`` method from being called by all
/// except root. It will not prevent the `DebugEnabled` property from being read,
/// as its accessed through the `org.freedesktop.DBus.Properties` interface.
/// 
/// Another option is to use polkit to allow or deny requests on a case-by-case
/// basis, allowing for the possibility of dynamic authorisation. To do this,
/// connect to the `GDebugControllerDBus::authorize` signal and query polkit in
/// it:
/// (C Language Example):
/// ```C
///   g_autoptr(GError) child_error = NULL;
///   g_autoptr(GDBusConnection) connection = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);
///   gulong debug_controller_authorize_id = 0;
/// 
///   // Set up the debug controller.
///   debug_controller = G_DEBUG_CONTROLLER (g_debug_controller_dbus_new (priv->connection, NULL, &child_error));
///   if (debug_controller == NULL)
///     {
///       g_error ("Could not register debug controller on bus: %s"),
///                child_error->message);
///     }
/// 
///   debug_controller_authorize_id = g_signal_connect (debug_controller,
///                                                     "authorize",
///                                                     G_CALLBACK (debug_controller_authorize_cb),
///                                                     self);
/// 
///   static gboolean
///   debug_controller_authorize_cb (GDebugControllerDBus  *debug_controller,
///                                  GDBusMethodInvocation *invocation,
///                                  gpointer               user_data)
///   {
///     g_autoptr(PolkitAuthority) authority = NULL;
///     g_autoptr(PolkitSubject) subject = NULL;
///     g_autoptr(PolkitAuthorizationResult) auth_result = NULL;
///     g_autoptr(GError) local_error = NULL;
///     GDBusMessage *message;
///     GDBusMessageFlags message_flags;
///     PolkitCheckAuthorizationFlags flags = POLKIT_CHECK_AUTHORIZATION_FLAGS_NONE;
/// 
///     message = g_dbus_method_invocation_get_message (invocation);
///     message_flags = g_dbus_message_get_flags (message);
/// 
///     authority = polkit_authority_get_sync (NULL, &local_error);
///     if (authority == NULL)
///       {
///         g_warning ("Failed to get polkit authority: %s", local_error->message);
///         return FALSE;
///       }
/// 
///     if (message_flags & G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION)
///       flags |= POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION;
/// 
///     subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (invocation));
/// 
///     auth_result = polkit_authority_check_authorization_sync (authority,
///                                                              subject,
///                                                              "com.example.MyService.set-debug-enabled",
///                                                              NULL,
///                                                              flags,
///                                                              NULL,
///                                                              &local_error);
///     if (auth_result == NULL)
///       {
///         g_warning ("Failed to get check polkit authorization: %s", local_error->message);
///         return FALSE;
///       }
/// 
///     return polkit_authorization_result_get_is_authorized (auth_result);
///   }
/// ```
/// 
///
/// The `DebugControllerDBus` type acts as a reference-counted owner of an underlying `GDebugControllerDBus` instance.
/// It provides the methods that can operate on this data type through `DebugControllerDBusProtocol` conformance.
/// Use `DebugControllerDBus` as a strong reference or owner of a `GDebugControllerDBus` instance.
///
open class DebugControllerDBus: GLibObject.Object, DebugControllerDBusProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DebugControllerDBus` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDebugControllerDBus>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DebugControllerDBus` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDebugControllerDBus>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DebugControllerDBus` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DebugControllerDBus` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DebugControllerDBus` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDebugControllerDBus>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DebugControllerDBus` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDebugControllerDBus>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDebugControllerDBus`.
    /// i.e., ownership is transferred to the `DebugControllerDBus` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDebugControllerDBus>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DebugControllerDBusProtocol`
    /// Will retain `GDebugControllerDBus`.
    /// - Parameter other: an instance of a related type that implements `DebugControllerDBusProtocol`
    @inlinable public init<T: DebugControllerDBusProtocol>(debugControllerDBus other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerDBusProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerDBusProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerDBusProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerDBusProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerDBusProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerDBusProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerDBusProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DebugControllerDBusProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Create a new `GDebugControllerDBus` and synchronously initialize it.
    /// 
    /// Initializing the object will export the debug object on `connection`. The
    /// object will remain registered until the last reference to the
    /// `GDebugControllerDBus` is dropped.
    /// 
    /// Initialization may fail if registering the object on `connection` fails.
    @inlinable public init<CancellableT: CancellableProtocol, DBusConnectionT: DBusConnectionProtocol>( connection: DBusConnectionT, cancellable: CancellableT?) throws {
            var error: UnsafeMutablePointer<GError>?
        let result = g_debug_controller_dbus_new(connection.dbus_connection_ptr, cancellable?.cancellable_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum DebugControllerDBusPropertyName: String, PropertyNameProtocol {
    /// The D-Bus connection to expose the debugging interface on.
    /// 
    /// Typically this will be the same connection (to the system or session bus)
    /// which the rest of the application or services D-Bus objects are registered
    /// on.
    case connection = "connection"
}

public extension DebugControllerDBusProtocol {
    /// Bind a `DebugControllerDBusPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: DebugControllerDBusPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a DebugControllerDBus property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: DebugControllerDBusPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a DebugControllerDBus property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: DebugControllerDBusPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum DebugControllerDBusSignalName: String, SignalNameProtocol {
    /// Emitted when a D-Bus peer is trying to change the debug settings and used
    /// to determine if that is authorized.
    /// 
    /// This signal is emitted in a dedicated worker thread, so handlers are
    /// allowed to perform blocking I/O. This means that, for example, it is
    /// appropriate to call ``polkit_authority_check_authorization_sync()`` to check
    /// authorization using polkit.
    /// 
    /// If `false` is returned then no further handlers are run and the request to
    /// change the debug settings is rejected.
    /// 
    /// Otherwise, if `true` is returned, signal emission continues. If no handlers
    /// return `false`, then the debug settings are allowed to be changed.
    /// 
    /// Signal handlers must not modify `invocation`, or cause it to return a value.
    /// 
    /// The default class handler just returns `true`.
    case authorize = "authorize"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The D-Bus connection to expose the debugging interface on.
    /// 
    /// Typically this will be the same connection (to the system or session bus)
    /// which the rest of the application or services D-Bus objects are registered
    /// on.
    case notifyConnection = "notify::connection"
}

// MARK: DebugControllerDBus signals
public extension DebugControllerDBusProtocol {
    /// Connect a Swift signal handler to the given, typed `DebugControllerDBusSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DebugControllerDBusSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `DebugControllerDBusSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DebugControllerDBusSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when a D-Bus peer is trying to change the debug settings and used
    /// to determine if that is authorized.
    /// 
    /// This signal is emitted in a dedicated worker thread, so handlers are
    /// allowed to perform blocking I/O. This means that, for example, it is
    /// appropriate to call ``polkit_authority_check_authorization_sync()`` to check
    /// authorization using polkit.
    /// 
    /// If `false` is returned then no further handlers are run and the request to
    /// change the debug settings is rejected.
    /// 
    /// Otherwise, if `true` is returned, signal emission continues. If no handlers
    /// return `false`, then the debug settings are allowed to be changed.
    /// 
    /// Signal handlers must not modify `invocation`, or cause it to return a value.
    /// 
    /// The default class handler just returns `true`.
    /// - Note: This represents the underlying `authorize` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter invocation: A `GDBusMethodInvocation`.
    /// - Parameter handler: `true` if the call is authorized, `false` otherwise.
    /// Run the given callback whenever the `authorize` signal is emitted
    @discardableResult @inlinable func onAuthorize(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DebugControllerDBusRef, _ invocation: DBusMethodInvocationRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DebugControllerDBusRef, DBusMethodInvocationRef), Bool>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> gboolean = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call((DebugControllerDBusRef(raw: unownedSelf), DBusMethodInvocationRef(raw: arg1)))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .authorize,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `authorize` signal for using the `connect(signal:)` methods
    static var authorizeSignal: DebugControllerDBusSignalName { .authorize }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::connection` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyConnection` signal is emitted
    @discardableResult @inlinable func onNotifyConnection(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DebugControllerDBusRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(DebugControllerDBusRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((DebugControllerDBusRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyConnection,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::connection` signal for using the `connect(signal:)` methods
    static var notifyConnectionSignal: DebugControllerDBusSignalName { .notifyConnection }
    
}

// MARK: DebugControllerDBus Class: DebugControllerDBusProtocol extension (methods and fields)
public extension DebugControllerDBusProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDebugControllerDBus` instance.
    @inlinable var debug_controller_dbus_ptr: UnsafeMutablePointer<GDebugControllerDBus>! { return ptr?.assumingMemoryBound(to: GDebugControllerDBus.self) }

    /// Stop the debug controller, unregistering its object from the bus.
    /// 
    /// Any pending method calls to the object will complete successfully, but new
    /// ones will return an error. This method will block until all pending
    /// `GDebugControllerDBus::authorize` signals have been handled. This is expected
    /// to not take long, as it will just be waiting for threads to join. If any
    /// `GDebugControllerDBus::authorize` signal handlers are still executing in other
    /// threads, this will block until after they have returned.
    /// 
    /// This method will be called automatically when the final reference to the
    /// `GDebugControllerDBus` is dropped. You may want to call it explicitly to know
    /// when the controller has been fully removed from the bus, or to break
    /// reference count cycles.
    /// 
    /// Calling this method from within a `GDebugControllerDBus::authorize` signal
    /// handler will cause a deadlock and must not be done.
    @inlinable func stop() {
        
        g_debug_controller_dbus_stop(debug_controller_dbus_ptr)
        
    }

    @inlinable var parentInstance: GObject {
        get {
            let rv = debug_controller_dbus_ptr.pointee.parent_instance
    return rv
        }
    }

}



// MARK: - DesktopAppInfo Class

/// `GDesktopAppInfo` is an implementation of `GAppInfo` based on
/// desktop files.
/// 
/// Note that `&lt;gio/gdesktopappinfo.h&gt;` belongs to the UNIX-specific
/// GIO interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
/// file when using it.
///
/// The `DesktopAppInfoProtocol` protocol exposes the methods and properties of an underlying `GDesktopAppInfo` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `DesktopAppInfo`.
/// Alternatively, use `DesktopAppInfoRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DesktopAppInfoProtocol: GLibObject.ObjectProtocol, AppInfoProtocol {
        /// Untyped pointer to the underlying `GDesktopAppInfo` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GDesktopAppInfo` instance.
    var desktop_app_info_ptr: UnsafeMutablePointer<GDesktopAppInfo>! { get }

    /// Required Initialiser for types conforming to `DesktopAppInfoProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GDesktopAppInfo` is an implementation of `GAppInfo` based on
/// desktop files.
/// 
/// Note that `&lt;gio/gdesktopappinfo.h&gt;` belongs to the UNIX-specific
/// GIO interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
/// file when using it.
///
/// The `DesktopAppInfoRef` type acts as a lightweight Swift reference to an underlying `GDesktopAppInfo` instance.
/// It exposes methods that can operate on this data type through `DesktopAppInfoProtocol` conformance.
/// Use `DesktopAppInfoRef` only as an `unowned` reference to an existing `GDesktopAppInfo` instance.
///
public struct DesktopAppInfoRef: DesktopAppInfoProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GDesktopAppInfo` instance.
    /// For type-safe access, use the generated, typed pointer `desktop_app_info_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DesktopAppInfoRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GDesktopAppInfo>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GDesktopAppInfo>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GDesktopAppInfo>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GDesktopAppInfo>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DesktopAppInfoProtocol`
    @inlinable init<T: DesktopAppInfoProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: DesktopAppInfoProtocol>(_ other: T) -> DesktopAppInfoRef { DesktopAppInfoRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GDesktopAppInfo` based on a desktop file id.
    /// 
    /// A desktop file id is the basename of the desktop file, including the
    /// .desktop extension. GIO is looking for a desktop file with this name
    /// in the `applications` subdirectories of the XDG
    /// data directories (i.e. the directories specified in the `XDG_DATA_HOME`
    /// and `XDG_DATA_DIRS` environment variables). GIO also supports the
    /// prefix-to-subdirectory mapping that is described in the
    /// [Menu Spec](http://standards.freedesktop.org/menu-spec/latest/)
    /// (i.e. a desktop id of kde-foo.desktop will match
    /// `/usr/share/applications/kde/foo.desktop`).
    @inlinable init( desktopID: UnsafePointer<CChar>!) {
            let result = g_desktop_app_info_new(desktopID)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GDesktopAppInfo`.
    @inlinable init(filename: UnsafePointer<CChar>!) {
            let result = g_desktop_app_info_new_from_filename(filename)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GDesktopAppInfo`.
    @inlinable init<GLibKeyFileT: GLib.KeyFileProtocol>(keyfile keyFile: GLibKeyFileT) {
            let result = g_desktop_app_info_new_from_keyfile(keyFile.key_file_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GDesktopAppInfo`.
    @inlinable static func newFrom(filename: UnsafePointer<CChar>!) -> GIO.DesktopAppInfoRef! {
            let result = g_desktop_app_info_new_from_filename(filename)
        guard let rv = DesktopAppInfoRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Creates a new `GDesktopAppInfo`.
    @inlinable static func newFrom<GLibKeyFileT: GLib.KeyFileProtocol>(keyfile keyFile: GLibKeyFileT) -> GIO.DesktopAppInfoRef! {
            let result = g_desktop_app_info_new_from_keyfile(keyFile.key_file_ptr)
        guard let rv = DesktopAppInfoRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }
}

/// `GDesktopAppInfo` is an implementation of `GAppInfo` based on
/// desktop files.
/// 
/// Note that `&lt;gio/gdesktopappinfo.h&gt;` belongs to the UNIX-specific
/// GIO interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
/// file when using it.
///
/// The `DesktopAppInfo` type acts as a reference-counted owner of an underlying `GDesktopAppInfo` instance.
/// It provides the methods that can operate on this data type through `DesktopAppInfoProtocol` conformance.
/// Use `DesktopAppInfo` as a strong reference or owner of a `GDesktopAppInfo` instance.
///
open class DesktopAppInfo: GLibObject.Object, DesktopAppInfoProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DesktopAppInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GDesktopAppInfo>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DesktopAppInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GDesktopAppInfo>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DesktopAppInfo` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DesktopAppInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DesktopAppInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GDesktopAppInfo>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `DesktopAppInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GDesktopAppInfo>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GDesktopAppInfo`.
    /// i.e., ownership is transferred to the `DesktopAppInfo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GDesktopAppInfo>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DesktopAppInfoProtocol`
    /// Will retain `GDesktopAppInfo`.
    /// - Parameter other: an instance of a related type that implements `DesktopAppInfoProtocol`
    @inlinable public init<T: DesktopAppInfoProtocol>(desktopAppInfo other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DesktopAppInfoProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GDesktopAppInfo` based on a desktop file id.
    /// 
    /// A desktop file id is the basename of the desktop file, including the
    /// .desktop extension. GIO is looking for a desktop file with this name
    /// in the `applications` subdirectories of the XDG
    /// data directories (i.e. the directories specified in the `XDG_DATA_HOME`
    /// and `XDG_DATA_DIRS` environment variables). GIO also supports the
    /// prefix-to-subdirectory mapping that is described in the
    /// [Menu Spec](http://standards.freedesktop.org/menu-spec/latest/)
    /// (i.e. a desktop id of kde-foo.desktop will match
    /// `/usr/share/applications/kde/foo.desktop`).
    @inlinable public init( desktopID: UnsafePointer<CChar>!) {
            let result = g_desktop_app_info_new(desktopID)
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GDesktopAppInfo`.
    @inlinable public init(filename: UnsafePointer<CChar>!) {
            let result = g_desktop_app_info_new_from_filename(filename)
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GDesktopAppInfo`.
    @inlinable public init<GLibKeyFileT: GLib.KeyFileProtocol>(keyfile keyFile: GLibKeyFileT) {
            let result = g_desktop_app_info_new_from_keyfile(keyFile.key_file_ptr)
        let rv = result
            super.init(gpointer: (rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GDesktopAppInfo`.
    @inlinable public static func newFrom(filename: UnsafePointer<CChar>!) -> GIO.DesktopAppInfo! {
            let result = g_desktop_app_info_new_from_filename(filename)
        guard let rv = DesktopAppInfo(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

    /// Creates a new `GDesktopAppInfo`.
    @inlinable public static func newFrom<GLibKeyFileT: GLib.KeyFileProtocol>(keyfile keyFile: GLibKeyFileT) -> GIO.DesktopAppInfo! {
            let result = g_desktop_app_info_new_from_keyfile(keyFile.key_file_ptr)
        guard let rv = DesktopAppInfo(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

}

public enum DesktopAppInfoPropertyName: String, PropertyNameProtocol {
    /// The origin filename of this `GDesktopAppInfo`
    case String = "filename"
}

public extension DesktopAppInfoProtocol {
    /// Bind a `DesktopAppInfoPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: DesktopAppInfoPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a DesktopAppInfo property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: DesktopAppInfoPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a DesktopAppInfo property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: DesktopAppInfoPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum DesktopAppInfoSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesnt itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The origin filename of this `GDesktopAppInfo`
    case notifyFilename = "notify::filename"
}

// MARK: DesktopAppInfo has no signals
// MARK: DesktopAppInfo Class: DesktopAppInfoProtocol extension (methods and fields)
public extension DesktopAppInfoProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GDesktopAppInfo` instance.
    @inlinable var desktop_app_info_ptr: UnsafeMutablePointer<GDesktopAppInfo>! { return ptr?.assumingMemoryBound(to: GDesktopAppInfo.self) }

    /// Gets the user-visible display name of the "additional application
    /// action" specified by `action_name`.
    /// 
    /// This corresponds to the "Name" key within the keyfile group for the
    /// action.
    @inlinable func get(actionName: UnsafePointer<gchar>!) -> String! {
        let result = g_desktop_app_info_get_action_name(desktop_app_info_ptr, actionName)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Looks up a boolean value in the keyfile backing `info`.
    /// 
    /// The `key` is looked up in the "Desktop Entry" group.
    @inlinable func getBoolean(key: UnsafePointer<CChar>!) -> Bool {
        let result = g_desktop_app_info_get_boolean(desktop_app_info_ptr, key)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the categories from the desktop file.
    @inlinable func getCategories() -> String! {
        let result = g_desktop_app_info_get_categories(desktop_app_info_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// When `info` was created from a known filename, return it.  In some
    /// situations such as the `GDesktopAppInfo` returned from
    /// `g_desktop_app_info_new_from_keyfile()`, this function will return `nil`.
    @inlinable func getFilename() -> String! {
        let result = g_desktop_app_info_get_filename(desktop_app_info_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets the generic name from the desktop file.
    @inlinable func getGenericName() -> String! {
        let result = g_desktop_app_info_get_generic_name(desktop_app_info_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// A desktop file is hidden if the Hidden key in it is
    /// set to True.
    @inlinable func getIsHidden() -> Bool {
        let result = g_desktop_app_info_get_is_hidden(desktop_app_info_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the keywords from the desktop file.
    @inlinable func getKeywords() -> UnsafePointer<UnsafePointer<CChar>?>! {
        let result = g_desktop_app_info_get_keywords(desktop_app_info_ptr)
        let rv = result
        return rv
    }

    /// Looks up a localized string value in the keyfile backing `info`
    /// translated to the current locale.
    /// 
    /// The `key` is looked up in the "Desktop Entry" group.
    @inlinable func getLocaleString(key: UnsafePointer<CChar>!) -> String! {
        let result = g_desktop_app_info_get_locale_string(desktop_app_info_ptr, key)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets the value of the NoDisplay key, which helps determine if the
    /// application info should be shown in menus. See
    /// `G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY` and `g_app_info_should_show()`.
    @inlinable func getNodisplay() -> Bool {
        let result = g_desktop_app_info_get_nodisplay(desktop_app_info_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Checks if the application info should be shown in menus that list available
    /// applications for a specific name of the desktop, based on the
    /// `OnlyShowIn` and `NotShowIn` keys.
    /// 
    /// `desktop_env` should typically be given as `nil`, in which case the
    /// `XDG_CURRENT_DESKTOP` environment variable is consulted.  If you want
    /// to override the default mechanism then you may specify `desktop_env`,
    /// but this is not recommended.
    /// 
    /// Note that `g_app_info_should_show()` for `info` will include this check (with
    /// `nil` for `desktop_env`) as well as additional checks.
    @inlinable func getShowIn(desktopEnv: UnsafePointer<gchar>? = nil) -> Bool {
        let result = g_desktop_app_info_get_show_in(desktop_app_info_ptr, desktopEnv)
        let rv = ((result) != 0)
        return rv
    }

    /// Retrieves the StartupWMClass field from `info`. This represents the
    /// WM_CLASS property of the main window of the application, if launched
    /// through `info`.
    @inlinable func getStartupWmClass() -> String! {
        let result = g_desktop_app_info_get_startup_wm_class(desktop_app_info_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Looks up a string value in the keyfile backing `info`.
    /// 
    /// The `key` is looked up in the "Desktop Entry" group.
    @inlinable func getString(key: UnsafePointer<CChar>!) -> String! {
        let result = g_desktop_app_info_get_string(desktop_app_info_ptr, key)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Looks up a string list value in the keyfile backing `info`.
    /// 
    /// The `key` is looked up in the "Desktop Entry" group.
    @inlinable func getStringList(key: UnsafePointer<CChar>!, length: UnsafeMutablePointer<gsize>! = nil) -> UnsafeMutablePointer<UnsafeMutablePointer<gchar>?>! {
        let result = g_desktop_app_info_get_string_list(desktop_app_info_ptr, key, length)
        let rv = result
        return rv
    }

    /// Returns whether `key` exists in the "Desktop Entry" group
    /// of the keyfile backing `info`.
    @inlinable func has(key: UnsafePointer<CChar>!) -> Bool {
        let result = g_desktop_app_info_has_key(desktop_app_info_ptr, key)
        let rv = ((result) != 0)
        return rv
    }

    /// Activates the named application action.
    /// 
    /// You may only call this function on action names that were
    /// returned from `g_desktop_app_info_list_actions()`.
    /// 
    /// Note that if the main entry of the desktop file indicates that the
    /// application supports startup notification, and `launch_context` is
    /// non-`nil`, then startup notification will be used when activating the
    /// action (and as such, invocation of the action on the receiving side
    /// must signal the end of startup notification when it is completed).
    /// This is the expected behaviour of applications declaring additional
    /// actions, as per the desktop file specification.
    /// 
    /// As with `g_app_info_launch()` there is no way to detect failures that
    /// occur while using this function.
    @inlinable func launchAction(actionName: UnsafePointer<gchar>!, launchContext: AppLaunchContextRef? = nil) {
            
        g_desktop_app_info_launch_action(desktop_app_info_ptr, actionName, launchContext?.app_launch_context_ptr)
            
    }
    /// Activates the named application action.
    /// 
    /// You may only call this function on action names that were
    /// returned from `g_desktop_app_info_list_actions()`.
    /// 
    /// Note that if the main entry of the desktop file indicates that the
    /// application supports startup notification, and `launch_context` is
    /// non-`nil`, then startup notification will be used when activating the
    /// action (and as such, invocation of the action on the receiving side
    /// must signal the end of startup notification when it is completed).
    /// This is the expected behaviour of applications declaring additional
    /// actions, as per the desktop file specification.
    /// 
    /// As with `g_app_info_launch()` there is no way to detect failures that
    /// occur while using this function.
    @inlinable func launchAction<AppLaunchContextT: AppLaunchContextProtocol>(actionName: UnsafePointer<gchar>!, launchContext: AppLaunchContextT?) {
        
        g_desktop_app_info_launch_action(desktop_app_info_ptr, actionName, launchContext?.app_launch_context_ptr)
        
    }

    /// This function performs the equivalent of `g_app_info_launch_uris()`,
    /// but is intended primarily for operating system components that
    /// launch applications.  Ordinary applications should use
    /// `g_app_info_launch_uris()`.
    /// 
    /// If the application is launched via GSpawn, then `spawn_flags`, `user_setup`
    /// and `user_setup_data` are used for the call to `g_spawn_async()`.
    /// Additionally, `pid_callback` (with `pid_callback_data`) will be called to
    /// inform about the PID of the created process. See `g_spawn_async_with_pipes()`
    /// for information on certain parameter conditions that can enable an
    /// optimized `posix_spawn()` codepath to be used.
    /// 
    /// If application launching occurs via some other mechanism (eg: D-Bus
    /// activation) then `spawn_flags`, `user_setup`, `user_setup_data`,
    /// `pid_callback` and `pid_callback_data` are ignored.
    @inlinable func launchURIsAsManager<GLibListT: GLib.ListProtocol>(uris: GLibListT, launchContext: AppLaunchContextRef? = nil, spawnFlags: GLib.SpawnFlags, userSetup: GSpawnChildSetupFunc? = nil, userSetupData: gpointer? = nil, pidCallback: GDesktopAppLaunchCallback? = nil, pidCallbackData: gpointer? = nil) throws -> Bool {
            var error: UnsafeMutablePointer<GError>?
        let result = g_desktop_app_info_launch_uris_as_manager(desktop_app_info_ptr, uris._ptr, launchContext?.app_launch_context_ptr, spawnFlags.value, userSetup, userSetupData, pidCallback, pidCallbackData, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
            return rv
    }
    /// This function performs the equivalent of `g_app_info_launch_uris()`,
    /// but is intended primarily for operating system components that
    /// launch applications.  Ordinary applications should use
    /// `g_app_info_launch_uris()`.
    /// 
    /// If the application is launched via GSpawn, then `spawn_flags`, `user_setup`
    /// and `user_setup_data` are used for the call to `g_spawn_async()`.
    /// Additionally, `pid_callback` (with `pid_callback_data`) will be called to
    /// inform about the PID of the created process. See `g_spawn_async_with_pipes()`
    /// for information on certain parameter conditions that can enable an
    /// optimized `posix_spawn()` codepath to be used.
    /// 
    /// If application launching occurs via some other mechanism (eg: D-Bus
    /// activation) then `spawn_flags`, `user_setup`, `user_setup_data`,
    /// `pid_callback` and `pid_callback_data` are ignored.
    @inlinable func launchURIsAsManager<AppLaunchContextT: AppLaunchContextProtocol, GLibListT: GLib.ListProtocol>(uris: GLibListT, launchContext: AppLaunchContextT?, spawnFlags: GLib.SpawnFlags, userSetup: GSpawnChildSetupFunc? = nil, userSetupData: gpointer? = nil, pidCallback: GDesktopAppLaunchCallback? = nil, pidCallbackData: gpointer? = nil) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_desktop_app_info_launch_uris_as_manager(desktop_app_info_ptr, uris._ptr, launchContext?.app_launch_context_ptr, spawnFlags.value, userSetup, userSetupData, pidCallback, pidCallbackData, &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Equivalent to `g_desktop_app_info_launch_uris_as_manager()` but allows
    /// you to pass in file descriptors for the stdin, stdout and stderr streams
    /// of the launched process.
    /// 
    /// If application launching occurs via some non-spawn mechanism (e.g. D-Bus
    /// activation) then `stdin_fd`, `stdout_fd` and `stderr_fd` are ignored.
    @inlinable func launchURIsAsManagerWithFds<GLibListT: GLib.ListProtocol>(uris: GLibListT, launchContext: AppLaunchContextRef? = nil, spawnFlags: GLib.SpawnFlags, userSetup: GSpawnChildSetupFunc? = nil, userSetupData: gpointer? = nil, pidCallback: GDesktopAppLaunchCallback? = nil, pidCallbackData: gpointer? = nil, stdinFd: Int, stdoutFd: Int, stderrFd: Int) throws -> Bool {
            var error: UnsafeMutablePointer<GError>?
        let result = g_desktop_app_info_launch_uris_as_manager_with_fds(desktop_app_info_ptr, uris._ptr, launchContext?.app_launch_context_ptr, spawnFlags.value, userSetup, userSetupData, pidCallback, pidCallbackData, gint(stdinFd), gint(stdoutFd), gint(stderrFd), &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
            return rv
    }
    /// Equivalent to `g_desktop_app_info_launch_uris_as_manager()` but allows
    /// you to pass in file descriptors for the stdin, stdout and stderr streams
    /// of the launched process.
    /// 
    /// If application launching occurs via some non-spawn mechanism (e.g. D-Bus
    /// activation) then `stdin_fd`, `stdout_fd` and `stderr_fd` are ignored.
    @inlinable func launchURIsAsManagerWithFds<AppLaunchContextT: AppLaunchContextProtocol, GLibListT: GLib.ListProtocol>(uris: GLibListT, launchContext: AppLaunchContextT?, spawnFlags: GLib.SpawnFlags, userSetup: GSpawnChildSetupFunc? = nil, userSetupData: gpointer? = nil, pidCallback: GDesktopAppLaunchCallback? = nil, pidCallbackData: gpointer? = nil, stdinFd: Int, stdoutFd: Int, stderrFd: Int) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let result = g_desktop_app_info_launch_uris_as_manager_with_fds(desktop_app_info_ptr, uris._ptr, launchContext?.app_launch_context_ptr, spawnFlags.value, userSetup, userSetupData, pidCallback, pidCallbackData, gint(stdinFd), gint(stdoutFd), gint(stderrFd), &error)
        if let error = error { throw GLibError(error) }
        let rv = ((result) != 0)
        return rv
    }

    /// Returns the list of "additional application actions" supported on the
    /// desktop file, as per the desktop file specification.
    /// 
    /// As per the specification, this is the list of actions that are
    /// explicitly listed in the "Actions" key of the [Desktop Entry] group.
    @inlinable func listActions() -> UnsafePointer<UnsafePointer<gchar>?>! {
        let result = g_desktop_app_info_list_actions(desktop_app_info_ptr)
        let rv = result
        return rv
    }
    /// Gets the categories from the desktop file.
    @inlinable var categories: String! {
        /// Gets the categories from the desktop file.
        get {
            let result = g_desktop_app_info_get_categories(desktop_app_info_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// The origin filename of this `GDesktopAppInfo`
    @inlinable var filename: String! {
        /// When `info` was created from a known filename, return it.  In some
        /// situations such as the `GDesktopAppInfo` returned from
        /// `g_desktop_app_info_new_from_keyfile()`, this function will return `nil`.
        get {
            let result = g_desktop_app_info_get_filename(desktop_app_info_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// Gets the generic name from the desktop file.
    @inlinable var genericName: String! {
        /// Gets the generic name from the desktop file.
        get {
            let result = g_desktop_app_info_get_generic_name(desktop_app_info_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// A desktop file is hidden if the Hidden key in it is
    /// set to True.
    @inlinable var isHidden: Bool {
        /// A desktop file is hidden if the Hidden key in it is
        /// set to True.
        get {
            let result = g_desktop_app_info_get_is_hidden(desktop_app_info_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// Gets the keywords from the desktop file.
    @inlinable var keywords: UnsafePointer<UnsafePointer<CChar>?>! {
        /// Gets the keywords from the desktop file.
        get {
            let result = g_desktop_app_info_get_keywords(desktop_app_info_ptr)
        let rv = result
            return rv
        }
    }

    /// Gets the value of the NoDisplay key, which helps determine if the
    /// application info should be shown in menus. See
    /// `G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY` and `g_app_info_should_show()`.
    @inlinable var nodisplay: Bool {
        /// Gets the value of the NoDisplay key, which helps determine if the
        /// application info should be shown in menus. See
        /// `G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY` and `g_app_info_should_show()`.
        get {
            let result = g_desktop_app_info_get_nodisplay(desktop_app_info_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// Retrieves the StartupWMClass field from `info`. This represents the
    /// WM_CLASS property of the main window of the application, if launched
    /// through `info`.
    @inlinable var startupWmClass: String! {
        /// Retrieves the StartupWMClass field from `info`. This represents the
        /// WM_CLASS property of the main window of the application, if launched
        /// through `info`.
        get {
            let result = g_desktop_app_info_get_startup_wm_class(desktop_app_info_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }


}



