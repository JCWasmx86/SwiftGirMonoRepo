import CGLib
import CCairo
import CPango
import CGraphene
import CGdkPixbuf
import CGdk
import CGsk
import CGtk
import GLib
import GLibObject
import GIO
import Graphene
import Pango
import Cairo
import PangoCairo
import GdkPixBuf
import Gdk
import Gsk

// MARK: - CellEditable Interface

/// Interface for widgets that can be used for editing cells
/// 
/// The `GtkCellEditable` interface must be implemented for widgets to be usable
/// to edit the contents of a `GtkTreeView` cell. It provides a way to specify how
/// temporary widgets should be configured for editing, get the new value, etc.
///
/// The `CellEditableProtocol` protocol exposes the methods and properties of an underlying `GtkCellEditable` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellEditable`.
/// Alternatively, use `CellEditableRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellEditableProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkCellEditable` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellEditable` instance.
    var cell_editable_ptr: UnsafeMutablePointer<GtkCellEditable>! { get }

    /// Required Initialiser for types conforming to `CellEditableProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Interface for widgets that can be used for editing cells
/// 
/// The `GtkCellEditable` interface must be implemented for widgets to be usable
/// to edit the contents of a `GtkTreeView` cell. It provides a way to specify how
/// temporary widgets should be configured for editing, get the new value, etc.
///
/// The `CellEditableRef` type acts as a lightweight Swift reference to an underlying `GtkCellEditable` instance.
/// It exposes methods that can operate on this data type through `CellEditableProtocol` conformance.
/// Use `CellEditableRef` only as an `unowned` reference to an existing `GtkCellEditable` instance.
///
public struct CellEditableRef: CellEditableProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellEditable` instance.
    /// For type-safe access, use the generated, typed pointer `cell_editable_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellEditableRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellEditable>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellEditable>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellEditable>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellEditable>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellEditableProtocol`
    @inlinable init<T: CellEditableProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellEditableProtocol>(_ other: T) -> CellEditableRef { CellEditableRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellEditableProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellEditableProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellEditableProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellEditableProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellEditableProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// Interface for widgets that can be used for editing cells
/// 
/// The `GtkCellEditable` interface must be implemented for widgets to be usable
/// to edit the contents of a `GtkTreeView` cell. It provides a way to specify how
/// temporary widgets should be configured for editing, get the new value, etc.
///
/// The `CellEditable` type acts as a reference-counted owner of an underlying `GtkCellEditable` instance.
/// It provides the methods that can operate on this data type through `CellEditableProtocol` conformance.
/// Use `CellEditable` as a strong reference or owner of a `GtkCellEditable` instance.
///
open class CellEditable: Widget, CellEditableProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellEditable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellEditable>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellEditable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellEditable>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellEditable` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellEditable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellEditable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellEditable>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellEditable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellEditable>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellEditable`.
    /// i.e., ownership is transferred to the `CellEditable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellEditable>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellEditableProtocol`
    /// Will retain `GtkCellEditable`.
    /// - Parameter other: an instance of a related type that implements `CellEditableProtocol`
    @inlinable public init<T: CellEditableProtocol>(cellEditable other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellEditableProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellEditableProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellEditableProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellEditableProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellEditableProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellEditableProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellEditableProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellEditableProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum CellEditablePropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Indicates whether editing on the cell has been canceled.
    case editingCanceled = "editing-canceled"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension CellEditableProtocol {
    /// Bind a `CellEditablePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellEditablePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellEditable property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellEditablePropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellEditable property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellEditablePropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellEditableSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// This signal is a sign for the cell renderer to update its
    /// value from the `cell_editable`.
    /// 
    /// Implementations of `GtkCellEditable` are responsible for
    /// emitting this signal when they are done editing, e.g.
    /// `GtkEntry` emits this signal when the user presses Enter. Typical things to
    /// do in a handler for `editing-done` are to capture the edited value,
    /// disconnect the `cell_editable` from signals on the `GtkCellRenderer`, etc.
    /// 
    /// `gtk_cell_editable_editing_done()` is a convenience method
    /// for emitting `GtkCellEditable`editing-done``.
    case editingDone = "editing-done"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// This signal is meant to indicate that the cell is finished
    /// editing, and the `cell_editable` widget is being removed and may
    /// subsequently be destroyed.
    /// 
    /// Implementations of `GtkCellEditable` are responsible for
    /// emitting this signal when they are done editing. It must
    /// be emitted after the `GtkCellEditable`editing-done`` signal,
    /// to give the cell renderer a chance to update the cell's value
    /// before the widget is removed.
    /// 
    /// `gtk_cell_editable_remove_widget()` is a convenience method
    /// for emitting `GtkCellEditable`remove-widget``.
    case removeWidget = "remove-widget"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Indicates whether editing on the cell has been canceled.
    case notifyEditingCanceled = "notify::editing-canceled"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: CellEditable signals
public extension CellEditableProtocol {
    /// Connect a Swift signal handler to the given, typed `CellEditableSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellEditableSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        GLibObject.ObjectRef(raw: ptr).connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `CellEditableSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellEditableSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        GLibObject.ObjectRef(raw: ptr).connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// This signal is a sign for the cell renderer to update its
    /// value from the `cell_editable`.
    /// 
    /// Implementations of `GtkCellEditable` are responsible for
    /// emitting this signal when they are done editing, e.g.
    /// `GtkEntry` emits this signal when the user presses Enter. Typical things to
    /// do in a handler for `editing-done` are to capture the edited value,
    /// disconnect the `cell_editable` from signals on the `GtkCellRenderer`, etc.
    /// 
    /// `gtk_cell_editable_editing_done()` is a convenience method
    /// for emitting `GtkCellEditable`editing-done``.
    /// - Note: This represents the underlying `editing-done` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `editingDone` signal is emitted
    @discardableResult @inlinable func onEditingDone(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellEditableRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellEditableRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellEditableRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .editingDone,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `editing-done` signal for using the `connect(signal:)` methods
    static var editingDoneSignal: CellEditableSignalName { .editingDone }
    
    /// This signal is meant to indicate that the cell is finished
    /// editing, and the `cell_editable` widget is being removed and may
    /// subsequently be destroyed.
    /// 
    /// Implementations of `GtkCellEditable` are responsible for
    /// emitting this signal when they are done editing. It must
    /// be emitted after the `GtkCellEditable`editing-done`` signal,
    /// to give the cell renderer a chance to update the cell's value
    /// before the widget is removed.
    /// 
    /// `gtk_cell_editable_remove_widget()` is a convenience method
    /// for emitting `GtkCellEditable`remove-widget``.
    /// - Note: This represents the underlying `remove-widget` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `removeWidget` signal is emitted
    @discardableResult @inlinable func onRemoveWidget(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellEditableRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellEditableRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellEditableRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .removeWidget,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `remove-widget` signal for using the `connect(signal:)` methods
    static var removeWidgetSignal: CellEditableSignalName { .removeWidget }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::editing-canceled` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEditingCanceled` signal is emitted
    @discardableResult @inlinable func onNotifyEditingCanceled(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellEditableRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellEditableRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellEditableRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyEditingCanceled,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::editing-canceled` signal for using the `connect(signal:)` methods
    static var notifyEditingCanceledSignal: CellEditableSignalName { .notifyEditingCanceled }
    
}

// MARK: CellEditable Interface: CellEditableProtocol extension (methods and fields)
public extension CellEditableProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellEditable` instance.
    @inlinable var cell_editable_ptr: UnsafeMutablePointer<GtkCellEditable>! { return ptr?.assumingMemoryBound(to: GtkCellEditable.self) }

    /// Emits the `GtkCellEditable`editing-done`` signal.
    @inlinable func editingDone() {
        
        gtk_cell_editable_editing_done(cell_editable_ptr)
        
    }

    /// Emits the `GtkCellEditable`remove-widget`` signal.
    @inlinable func removeWidget() {
        
        gtk_cell_editable_remove_widget(cell_editable_ptr)
        
    }

    /// Begins editing on a `cell_editable`.
    /// 
    /// The `GtkCellRenderer` for the cell creates and returns a `GtkCellEditable` from
    /// `gtk_cell_renderer_start_editing()`, configured for the `GtkCellRenderer` type.
    /// 
    /// `gtk_cell_editable_start_editing()` can then set up `cell_editable` suitably for
    /// editing a cell, e.g. making the Esc key emit `GtkCellEditable`editing-done``.
    /// 
    /// Note that the `cell_editable` is created on-demand for the current edit; its
    /// lifetime is temporary and does not persist across other edits and/or cells.
    @inlinable func startEditing(event: Gdk.EventRef? = nil) {
            
        gtk_cell_editable_start_editing(cell_editable_ptr, event?.event_ptr)
            
    }
    /// Begins editing on a `cell_editable`.
    /// 
    /// The `GtkCellRenderer` for the cell creates and returns a `GtkCellEditable` from
    /// `gtk_cell_renderer_start_editing()`, configured for the `GtkCellRenderer` type.
    /// 
    /// `gtk_cell_editable_start_editing()` can then set up `cell_editable` suitably for
    /// editing a cell, e.g. making the Esc key emit `GtkCellEditable`editing-done``.
    /// 
    /// Note that the `cell_editable` is created on-demand for the current edit; its
    /// lifetime is temporary and does not persist across other edits and/or cells.
    @inlinable func startEditing<GdkEventT: Gdk.EventProtocol>(event: GdkEventT?) {
        
        gtk_cell_editable_start_editing(cell_editable_ptr, event?.event_ptr)
        
    }


}



/// Metatype/GType declaration for CallbackAction
public extension CallbackActionClassRef {
    
    /// This getter returns the GLib type identifier registered for `CallbackAction`
    static var metatypeReference: GType { gtk_callback_action_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkCallbackActionClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkCallbackActionClass.self) }
    
    static var metatype: GtkCallbackActionClass? { metatypePointer?.pointee } 
    
    static var wrapper: CallbackActionClassRef? { CallbackActionClassRef(metatypePointer) }
    
    
}

// MARK: - CallbackActionClass Record


///
/// The `CallbackActionClassProtocol` protocol exposes the methods and properties of an underlying `GtkCallbackActionClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CallbackActionClass`.
/// Alternatively, use `CallbackActionClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CallbackActionClassProtocol {
        /// Untyped pointer to the underlying `GtkCallbackActionClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCallbackActionClass` instance.
    var _ptr: UnsafeMutablePointer<GtkCallbackActionClass>! { get }

    /// Required Initialiser for types conforming to `CallbackActionClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `CallbackActionClassRef` type acts as a lightweight Swift reference to an underlying `GtkCallbackActionClass` instance.
/// It exposes methods that can operate on this data type through `CallbackActionClassProtocol` conformance.
/// Use `CallbackActionClassRef` only as an `unowned` reference to an existing `GtkCallbackActionClass` instance.
///
public struct CallbackActionClassRef: CallbackActionClassProtocol {
        /// Untyped pointer to the underlying `GtkCallbackActionClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CallbackActionClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCallbackActionClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCallbackActionClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCallbackActionClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCallbackActionClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CallbackActionClassProtocol`
    @inlinable init<T: CallbackActionClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: CallbackActionClass Record: CallbackActionClassProtocol extension (methods and fields)
public extension CallbackActionClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCallbackActionClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkCallbackActionClass>! { return ptr?.assumingMemoryBound(to: GtkCallbackActionClass.self) }



}



/// Metatype/GType declaration for CellArea
public extension CellAreaClassRef {
    
    /// This getter returns the GLib type identifier registered for `CellArea`
    static var metatypeReference: GType { gtk_cell_area_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkCellAreaClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkCellAreaClass.self) }
    
    static var metatype: GtkCellAreaClass? { metatypePointer?.pointee } 
    
    static var wrapper: CellAreaClassRef? { CellAreaClassRef(metatypePointer) }
    
    
}

// MARK: - CellAreaClass Record


///
/// The `CellAreaClassProtocol` protocol exposes the methods and properties of an underlying `GtkCellAreaClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellAreaClass`.
/// Alternatively, use `CellAreaClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellAreaClassProtocol {
        /// Untyped pointer to the underlying `GtkCellAreaClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellAreaClass` instance.
    var _ptr: UnsafeMutablePointer<GtkCellAreaClass>! { get }

    /// Required Initialiser for types conforming to `CellAreaClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `CellAreaClassRef` type acts as a lightweight Swift reference to an underlying `GtkCellAreaClass` instance.
/// It exposes methods that can operate on this data type through `CellAreaClassProtocol` conformance.
/// Use `CellAreaClassRef` only as an `unowned` reference to an existing `GtkCellAreaClass` instance.
///
public struct CellAreaClassRef: CellAreaClassProtocol {
        /// Untyped pointer to the underlying `GtkCellAreaClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellAreaClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellAreaClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellAreaClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellAreaClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellAreaClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellAreaClassProtocol`
    @inlinable init<T: CellAreaClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: CellAreaClass Record: CellAreaClassProtocol extension (methods and fields)
public extension CellAreaClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellAreaClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkCellAreaClass>! { return ptr?.assumingMemoryBound(to: GtkCellAreaClass.self) }

    /// Finds a cell property of a cell area class by name.
    @inlinable func findCellProperty(propertyName: UnsafePointer<CChar>!) -> GLibObject.ParamSpecRef! {
        let result = gtk_cell_area_class_find_cell_property(_ptr, propertyName)
        let rv = GLibObject.ParamSpecRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Installs a cell property on a cell area class.
    @inlinable func installCellProperty<GObjectParamSpecT: GLibObject.ParamSpecProtocol>(propertyId: Int, pspec: GObjectParamSpecT) {
        
        gtk_cell_area_class_install_cell_property(_ptr, guint(propertyId), pspec.param_spec_ptr)
        
    }

    /// Returns all cell properties of a cell area class.
    @inlinable func listCellProperties(nProperties: UnsafeMutablePointer<guint>!) -> UnsafeMutablePointer<UnsafeMutablePointer<GParamSpec>?>! {
        let result = gtk_cell_area_class_list_cell_properties(_ptr, nProperties)
        let rv = result
        return rv
    }

    // var parentClass is unavailable because parent_class is private

    // var add is unavailable because add is void

    // var remove is unavailable because remove is void

    // var foreach is unavailable because foreach is void

    // var foreachAlloc is unavailable because foreach_alloc is void

    // var event is unavailable because event is void

    // var snapshot is unavailable because snapshot is void

    // var applyAttributes is unavailable because apply_attributes is void

    // var createContext is unavailable because create_context is void

    // var copyContext is unavailable because copy_context is void

    // var getRequestMode is unavailable because get_request_mode is void

    // var getPreferredWidth is unavailable because get_preferred_width is void

    // var getPreferredHeightForWidth is unavailable because get_preferred_height_for_width is void

    // var getPreferredHeight is unavailable because get_preferred_height is void

    // var getPreferredWidthForHeight is unavailable because get_preferred_width_for_height is void

    // var setCellProperty is unavailable because set_cell_property is void

    // var getCellProperty is unavailable because get_cell_property is void

    // var focus is unavailable because focus is void

    // var isActivatable is unavailable because is_activatable is void

    // var activate is unavailable because activate is void

    // var padding is unavailable because padding is private

}



/// Metatype/GType declaration for CellAreaContext
public extension CellAreaContextClassRef {
    
    /// This getter returns the GLib type identifier registered for `CellAreaContext`
    static var metatypeReference: GType { gtk_cell_area_context_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkCellAreaContextClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkCellAreaContextClass.self) }
    
    static var metatype: GtkCellAreaContextClass? { metatypePointer?.pointee } 
    
    static var wrapper: CellAreaContextClassRef? { CellAreaContextClassRef(metatypePointer) }
    
    
}

// MARK: - CellAreaContextClass Record


///
/// The `CellAreaContextClassProtocol` protocol exposes the methods and properties of an underlying `GtkCellAreaContextClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellAreaContextClass`.
/// Alternatively, use `CellAreaContextClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellAreaContextClassProtocol {
        /// Untyped pointer to the underlying `GtkCellAreaContextClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellAreaContextClass` instance.
    var _ptr: UnsafeMutablePointer<GtkCellAreaContextClass>! { get }

    /// Required Initialiser for types conforming to `CellAreaContextClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `CellAreaContextClassRef` type acts as a lightweight Swift reference to an underlying `GtkCellAreaContextClass` instance.
/// It exposes methods that can operate on this data type through `CellAreaContextClassProtocol` conformance.
/// Use `CellAreaContextClassRef` only as an `unowned` reference to an existing `GtkCellAreaContextClass` instance.
///
public struct CellAreaContextClassRef: CellAreaContextClassProtocol {
        /// Untyped pointer to the underlying `GtkCellAreaContextClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellAreaContextClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellAreaContextClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellAreaContextClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellAreaContextClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellAreaContextClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellAreaContextClassProtocol`
    @inlinable init<T: CellAreaContextClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: CellAreaContextClass Record: CellAreaContextClassProtocol extension (methods and fields)
public extension CellAreaContextClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellAreaContextClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkCellAreaContextClass>! { return ptr?.assumingMemoryBound(to: GtkCellAreaContextClass.self) }


    // var parentClass is unavailable because parent_class is private

    // var allocate is unavailable because allocate is void

    // var reset is unavailable because reset is void

    // var getPreferredHeightForWidth is unavailable because get_preferred_height_for_width is void

    // var getPreferredWidthForHeight is unavailable because get_preferred_width_for_height is void

    // var padding is unavailable because padding is private

}



/// Metatype/GType declaration for CellEditable
public extension CellEditableIfaceRef {
    
    /// This getter returns the GLib type identifier registered for `CellEditable`
    static var metatypeReference: GType { gtk_cell_editable_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkCellEditableIface>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkCellEditableIface.self) }
    
    static var metatype: GtkCellEditableIface? { metatypePointer?.pointee } 
    
    static var wrapper: CellEditableIfaceRef? { CellEditableIfaceRef(metatypePointer) }
    
    
}

// MARK: - CellEditableIface Record


///
/// The `CellEditableIfaceProtocol` protocol exposes the methods and properties of an underlying `GtkCellEditableIface` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellEditableIface`.
/// Alternatively, use `CellEditableIfaceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellEditableIfaceProtocol {
        /// Untyped pointer to the underlying `GtkCellEditableIface` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellEditableIface` instance.
    var _ptr: UnsafeMutablePointer<GtkCellEditableIface>! { get }

    /// Required Initialiser for types conforming to `CellEditableIfaceProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `CellEditableIfaceRef` type acts as a lightweight Swift reference to an underlying `GtkCellEditableIface` instance.
/// It exposes methods that can operate on this data type through `CellEditableIfaceProtocol` conformance.
/// Use `CellEditableIfaceRef` only as an `unowned` reference to an existing `GtkCellEditableIface` instance.
///
public struct CellEditableIfaceRef: CellEditableIfaceProtocol {
        /// Untyped pointer to the underlying `GtkCellEditableIface` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellEditableIfaceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellEditableIface>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellEditableIface>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellEditableIface>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellEditableIface>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellEditableIfaceProtocol`
    @inlinable init<T: CellEditableIfaceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellEditableIfaceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellEditableIfaceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellEditableIfaceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellEditableIfaceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellEditableIfaceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: CellEditableIface Record: CellEditableIfaceProtocol extension (methods and fields)
public extension CellEditableIfaceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellEditableIface` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkCellEditableIface>! { return ptr?.assumingMemoryBound(to: GtkCellEditableIface.self) }


    // var gIface is unavailable because g_iface is private

    // var editingDone is unavailable because editing_done is void

    // var removeWidget is unavailable because remove_widget is void

    // var startEditing is unavailable because start_editing is void

}



/// Metatype/GType declaration for CellLayout
public extension CellLayoutIfaceRef {
    
    /// This getter returns the GLib type identifier registered for `CellLayout`
    static var metatypeReference: GType { gtk_cell_layout_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkCellLayoutIface>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkCellLayoutIface.self) }
    
    static var metatype: GtkCellLayoutIface? { metatypePointer?.pointee } 
    
    static var wrapper: CellLayoutIfaceRef? { CellLayoutIfaceRef(metatypePointer) }
    
    
}

// MARK: - CellLayoutIface Record


///
/// The `CellLayoutIfaceProtocol` protocol exposes the methods and properties of an underlying `GtkCellLayoutIface` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellLayoutIface`.
/// Alternatively, use `CellLayoutIfaceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellLayoutIfaceProtocol {
        /// Untyped pointer to the underlying `GtkCellLayoutIface` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellLayoutIface` instance.
    var _ptr: UnsafeMutablePointer<GtkCellLayoutIface>! { get }

    /// Required Initialiser for types conforming to `CellLayoutIfaceProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `CellLayoutIfaceRef` type acts as a lightweight Swift reference to an underlying `GtkCellLayoutIface` instance.
/// It exposes methods that can operate on this data type through `CellLayoutIfaceProtocol` conformance.
/// Use `CellLayoutIfaceRef` only as an `unowned` reference to an existing `GtkCellLayoutIface` instance.
///
public struct CellLayoutIfaceRef: CellLayoutIfaceProtocol {
        /// Untyped pointer to the underlying `GtkCellLayoutIface` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellLayoutIfaceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellLayoutIface>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellLayoutIface>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellLayoutIface>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellLayoutIface>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellLayoutIfaceProtocol`
    @inlinable init<T: CellLayoutIfaceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellLayoutIfaceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellLayoutIfaceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellLayoutIfaceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellLayoutIfaceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellLayoutIfaceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: CellLayoutIface Record: CellLayoutIfaceProtocol extension (methods and fields)
public extension CellLayoutIfaceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellLayoutIface` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkCellLayoutIface>! { return ptr?.assumingMemoryBound(to: GtkCellLayoutIface.self) }


    // var gIface is unavailable because g_iface is private

    // var packStart is unavailable because pack_start is void

    // var packEnd is unavailable because pack_end is void

    // var clear is unavailable because clear is void

    // var addAttribute is unavailable because add_attribute is void

    // var setCellDataFunc is unavailable because set_cell_data_func is void

    // var clearAttributes is unavailable because clear_attributes is void

    // var reorder is unavailable because reorder is void

    // var getCells is unavailable because get_cells is void

    // var getArea is unavailable because get_area is void

}



/// Metatype/GType declaration for CellRenderer
public extension CellRendererClassRef {
    
    /// This getter returns the GLib type identifier registered for `CellRenderer`
    static var metatypeReference: GType { gtk_cell_renderer_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkCellRendererClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkCellRendererClass.self) }
    
    static var metatype: GtkCellRendererClass? { metatypePointer?.pointee } 
    
    static var wrapper: CellRendererClassRef? { CellRendererClassRef(metatypePointer) }
    
    
}

// MARK: - CellRendererClass Record


///
/// The `CellRendererClassProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererClass`.
/// Alternatively, use `CellRendererClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererClassProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererClass` instance.
    var _ptr: UnsafeMutablePointer<GtkCellRendererClass>! { get }

    /// Required Initialiser for types conforming to `CellRendererClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `CellRendererClassRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererClass` instance.
/// It exposes methods that can operate on this data type through `CellRendererClassProtocol` conformance.
/// Use `CellRendererClassRef` only as an `unowned` reference to an existing `GtkCellRendererClass` instance.
///
public struct CellRendererClassRef: CellRendererClassProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererClassProtocol`
    @inlinable init<T: CellRendererClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: CellRendererClass Record: CellRendererClassProtocol extension (methods and fields)
public extension CellRendererClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkCellRendererClass>! { return ptr?.assumingMemoryBound(to: GtkCellRendererClass.self) }


    // var parentClass is unavailable because parent_class is private

    // var getRequestMode is unavailable because get_request_mode is void

    // var getPreferredWidth is unavailable because get_preferred_width is void

    // var getPreferredHeightForWidth is unavailable because get_preferred_height_for_width is void

    // var getPreferredHeight is unavailable because get_preferred_height is void

    // var getPreferredWidthForHeight is unavailable because get_preferred_width_for_height is void

    // var getAlignedArea is unavailable because get_aligned_area is void

    // var snapshot is unavailable because snapshot is void

    // var activate is unavailable because activate is void

    // var startEditing is unavailable because start_editing is void

    // var editingCanceled is unavailable because editing_canceled is void

    // var editingStarted is unavailable because editing_started is void

    // var padding is unavailable because padding is private

}



// MARK: - CellRendererClassPrivate Record


///
/// The `CellRendererClassPrivateProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererClassPrivate` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererClassPrivate`.
/// Alternatively, use `CellRendererClassPrivateRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererClassPrivateProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererClassPrivate` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererClassPrivate` instance.
    var _ptr: UnsafeMutablePointer<GtkCellRendererClassPrivate>! { get }

    /// Required Initialiser for types conforming to `CellRendererClassPrivateProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `CellRendererClassPrivateRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererClassPrivate` instance.
/// It exposes methods that can operate on this data type through `CellRendererClassPrivateProtocol` conformance.
/// Use `CellRendererClassPrivateRef` only as an `unowned` reference to an existing `GtkCellRendererClassPrivate` instance.
///
public struct CellRendererClassPrivateRef: CellRendererClassPrivateProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererClassPrivate` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererClassPrivateRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererClassPrivate>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererClassPrivate>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererClassPrivate>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererClassPrivate>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererClassPrivateProtocol`
    @inlinable init<T: CellRendererClassPrivateProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererClassPrivateProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererClassPrivateProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererClassPrivateProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererClassPrivateProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererClassPrivateProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }


///
/// The `CellRendererClassPrivate` type acts as an owner of an underlying `GtkCellRendererClassPrivate` instance.
/// It provides the methods that can operate on this data type through `CellRendererClassPrivateProtocol` conformance.
/// Use `CellRendererClassPrivate` as a strong reference or owner of a `GtkCellRendererClassPrivate` instance.
///
open class CellRendererClassPrivate: CellRendererClassPrivateProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererClassPrivate` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererClassPrivate` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererClassPrivate>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererClassPrivate` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererClassPrivate>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererClassPrivate` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererClassPrivate` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererClassPrivate` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererClassPrivate>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererClassPrivate` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererClassPrivate>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GtkCellRendererClassPrivate` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `CellRendererClassPrivate` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererClassPrivate>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GtkCellRendererClassPrivate, cannot ref(_ptr)
    }

    /// Reference intialiser for a related type that implements `CellRendererClassPrivateProtocol`
    /// `GtkCellRendererClassPrivate` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `CellRendererClassPrivateProtocol`
    @inlinable public init<T: CellRendererClassPrivateProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GtkCellRendererClassPrivate, cannot ref(_ptr)
    }

    /// Do-nothing destructor for `GtkCellRendererClassPrivate`.
    deinit {
        // no reference counting for GtkCellRendererClassPrivate, cannot unref(_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererClassPrivateProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererClassPrivateProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GtkCellRendererClassPrivate, cannot ref(_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererClassPrivateProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererClassPrivateProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GtkCellRendererClassPrivate, cannot ref(_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererClassPrivateProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererClassPrivateProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GtkCellRendererClassPrivate, cannot ref(_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererClassPrivateProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererClassPrivateProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GtkCellRendererClassPrivate, cannot ref(_ptr)
    }



}

// MARK: no CellRendererClassPrivate properties

// MARK: no CellRendererClassPrivate signals

// MARK: CellRendererClassPrivate has no signals
// MARK: CellRendererClassPrivate Record: CellRendererClassPrivateProtocol extension (methods and fields)
public extension CellRendererClassPrivateProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererClassPrivate` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkCellRendererClassPrivate>! { return ptr?.assumingMemoryBound(to: GtkCellRendererClassPrivate.self) }



}



/// Metatype/GType declaration for CellRendererText
public extension CellRendererTextClassRef {
    
    /// This getter returns the GLib type identifier registered for `CellRendererText`
    static var metatypeReference: GType { gtk_cell_renderer_text_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkCellRendererTextClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkCellRendererTextClass.self) }
    
    static var metatype: GtkCellRendererTextClass? { metatypePointer?.pointee } 
    
    static var wrapper: CellRendererTextClassRef? { CellRendererTextClassRef(metatypePointer) }
    
    
}

// MARK: - CellRendererTextClass Record


///
/// The `CellRendererTextClassProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererTextClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererTextClass`.
/// Alternatively, use `CellRendererTextClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererTextClassProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererTextClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererTextClass` instance.
    var _ptr: UnsafeMutablePointer<GtkCellRendererTextClass>! { get }

    /// Required Initialiser for types conforming to `CellRendererTextClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `CellRendererTextClassRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererTextClass` instance.
/// It exposes methods that can operate on this data type through `CellRendererTextClassProtocol` conformance.
/// Use `CellRendererTextClassRef` only as an `unowned` reference to an existing `GtkCellRendererTextClass` instance.
///
public struct CellRendererTextClassRef: CellRendererTextClassProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererTextClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererTextClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererTextClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererTextClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererTextClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererTextClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererTextClassProtocol`
    @inlinable init<T: CellRendererTextClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: CellRendererTextClass Record: CellRendererTextClassProtocol extension (methods and fields)
public extension CellRendererTextClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererTextClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkCellRendererTextClass>! { return ptr?.assumingMemoryBound(to: GtkCellRendererTextClass.self) }


    @inlinable var parentClass: GtkCellRendererClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var edited is unavailable because edited is void

    // var padding is unavailable because padding is private

}



/// Metatype/GType declaration for CenterBox
public extension CenterBoxClassRef {
    
    /// This getter returns the GLib type identifier registered for `CenterBox`
    static var metatypeReference: GType { gtk_center_box_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkCenterBoxClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkCenterBoxClass.self) }
    
    static var metatype: GtkCenterBoxClass? { metatypePointer?.pointee } 
    
    static var wrapper: CenterBoxClassRef? { CenterBoxClassRef(metatypePointer) }
    
    
}

// MARK: - CenterBoxClass Record


///
/// The `CenterBoxClassProtocol` protocol exposes the methods and properties of an underlying `GtkCenterBoxClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CenterBoxClass`.
/// Alternatively, use `CenterBoxClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CenterBoxClassProtocol {
        /// Untyped pointer to the underlying `GtkCenterBoxClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCenterBoxClass` instance.
    var _ptr: UnsafeMutablePointer<GtkCenterBoxClass>! { get }

    /// Required Initialiser for types conforming to `CenterBoxClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `CenterBoxClassRef` type acts as a lightweight Swift reference to an underlying `GtkCenterBoxClass` instance.
/// It exposes methods that can operate on this data type through `CenterBoxClassProtocol` conformance.
/// Use `CenterBoxClassRef` only as an `unowned` reference to an existing `GtkCenterBoxClass` instance.
///
public struct CenterBoxClassRef: CenterBoxClassProtocol {
        /// Untyped pointer to the underlying `GtkCenterBoxClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CenterBoxClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCenterBoxClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCenterBoxClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCenterBoxClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCenterBoxClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CenterBoxClassProtocol`
    @inlinable init<T: CenterBoxClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: CenterBoxClass Record: CenterBoxClassProtocol extension (methods and fields)
public extension CenterBoxClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCenterBoxClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkCenterBoxClass>! { return ptr?.assumingMemoryBound(to: GtkCenterBoxClass.self) }



}



/// Metatype/GType declaration for CenterLayout
public extension CenterLayoutClassRef {
    
    /// This getter returns the GLib type identifier registered for `CenterLayout`
    static var metatypeReference: GType { gtk_center_layout_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkCenterLayoutClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkCenterLayoutClass.self) }
    
    static var metatype: GtkCenterLayoutClass? { metatypePointer?.pointee } 
    
    static var wrapper: CenterLayoutClassRef? { CenterLayoutClassRef(metatypePointer) }
    
    
}

// MARK: - CenterLayoutClass Record


///
/// The `CenterLayoutClassProtocol` protocol exposes the methods and properties of an underlying `GtkCenterLayoutClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CenterLayoutClass`.
/// Alternatively, use `CenterLayoutClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CenterLayoutClassProtocol {
        /// Untyped pointer to the underlying `GtkCenterLayoutClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCenterLayoutClass` instance.
    var _ptr: UnsafeMutablePointer<GtkCenterLayoutClass>! { get }

    /// Required Initialiser for types conforming to `CenterLayoutClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `CenterLayoutClassRef` type acts as a lightweight Swift reference to an underlying `GtkCenterLayoutClass` instance.
/// It exposes methods that can operate on this data type through `CenterLayoutClassProtocol` conformance.
/// Use `CenterLayoutClassRef` only as an `unowned` reference to an existing `GtkCenterLayoutClass` instance.
///
public struct CenterLayoutClassRef: CenterLayoutClassProtocol {
        /// Untyped pointer to the underlying `GtkCenterLayoutClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CenterLayoutClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCenterLayoutClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCenterLayoutClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCenterLayoutClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCenterLayoutClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CenterLayoutClassProtocol`
    @inlinable init<T: CenterLayoutClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: CenterLayoutClass Record: CenterLayoutClassProtocol extension (methods and fields)
public extension CenterLayoutClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCenterLayoutClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkCenterLayoutClass>! { return ptr?.assumingMemoryBound(to: GtkCenterLayoutClass.self) }


    @inlinable var parentClass: GtkLayoutManagerClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

}



/// Metatype/GType declaration for CheckButton
public extension CheckButtonClassRef {
    
    /// This getter returns the GLib type identifier registered for `CheckButton`
    static var metatypeReference: GType { gtk_check_button_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkCheckButtonClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkCheckButtonClass.self) }
    
    static var metatype: GtkCheckButtonClass? { metatypePointer?.pointee } 
    
    static var wrapper: CheckButtonClassRef? { CheckButtonClassRef(metatypePointer) }
    
    
}

// MARK: - CheckButtonClass Record


///
/// The `CheckButtonClassProtocol` protocol exposes the methods and properties of an underlying `GtkCheckButtonClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CheckButtonClass`.
/// Alternatively, use `CheckButtonClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CheckButtonClassProtocol {
        /// Untyped pointer to the underlying `GtkCheckButtonClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCheckButtonClass` instance.
    var _ptr: UnsafeMutablePointer<GtkCheckButtonClass>! { get }

    /// Required Initialiser for types conforming to `CheckButtonClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `CheckButtonClassRef` type acts as a lightweight Swift reference to an underlying `GtkCheckButtonClass` instance.
/// It exposes methods that can operate on this data type through `CheckButtonClassProtocol` conformance.
/// Use `CheckButtonClassRef` only as an `unowned` reference to an existing `GtkCheckButtonClass` instance.
///
public struct CheckButtonClassRef: CheckButtonClassProtocol {
        /// Untyped pointer to the underlying `GtkCheckButtonClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CheckButtonClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCheckButtonClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCheckButtonClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCheckButtonClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCheckButtonClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CheckButtonClassProtocol`
    @inlinable init<T: CheckButtonClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: CheckButtonClass Record: CheckButtonClassProtocol extension (methods and fields)
public extension CheckButtonClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCheckButtonClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkCheckButtonClass>! { return ptr?.assumingMemoryBound(to: GtkCheckButtonClass.self) }


    @inlinable var parentClass: GtkWidgetClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var toggled is unavailable because toggled is void

    // var activate is unavailable because activate is void

    // var padding is unavailable because padding is private

}



/// Metatype/GType declaration for ColorChooser
public extension ColorChooserInterfaceRef {
    
    /// This getter returns the GLib type identifier registered for `ColorChooser`
    static var metatypeReference: GType { gtk_color_chooser_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkColorChooserInterface>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkColorChooserInterface.self) }
    
    static var metatype: GtkColorChooserInterface? { metatypePointer?.pointee } 
    
    static var wrapper: ColorChooserInterfaceRef? { ColorChooserInterfaceRef(metatypePointer) }
    
    
}

// MARK: - ColorChooserInterface Record


///
/// The `ColorChooserInterfaceProtocol` protocol exposes the methods and properties of an underlying `GtkColorChooserInterface` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColorChooserInterface`.
/// Alternatively, use `ColorChooserInterfaceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ColorChooserInterfaceProtocol {
        /// Untyped pointer to the underlying `GtkColorChooserInterface` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkColorChooserInterface` instance.
    var _ptr: UnsafeMutablePointer<GtkColorChooserInterface>! { get }

    /// Required Initialiser for types conforming to `ColorChooserInterfaceProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `ColorChooserInterfaceRef` type acts as a lightweight Swift reference to an underlying `GtkColorChooserInterface` instance.
/// It exposes methods that can operate on this data type through `ColorChooserInterfaceProtocol` conformance.
/// Use `ColorChooserInterfaceRef` only as an `unowned` reference to an existing `GtkColorChooserInterface` instance.
///
public struct ColorChooserInterfaceRef: ColorChooserInterfaceProtocol {
        /// Untyped pointer to the underlying `GtkColorChooserInterface` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ColorChooserInterfaceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkColorChooserInterface>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkColorChooserInterface>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkColorChooserInterface>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkColorChooserInterface>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ColorChooserInterfaceProtocol`
    @inlinable init<T: ColorChooserInterfaceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserInterfaceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserInterfaceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserInterfaceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserInterfaceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserInterfaceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: ColorChooserInterface Record: ColorChooserInterfaceProtocol extension (methods and fields)
public extension ColorChooserInterfaceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColorChooserInterface` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkColorChooserInterface>! { return ptr?.assumingMemoryBound(to: GtkColorChooserInterface.self) }


    @inlinable var baseInterface: GTypeInterface {
        get {
            let rv = _ptr.pointee.base_interface
    return rv
        }
    }

    // var getRgba is unavailable because get_rgba is void

    // var setRgba is unavailable because set_rgba is void

    // var addPalette is unavailable because add_palette is void

    // var colorActivated is unavailable because color_activated is void

    // var padding is unavailable because padding is private

}



/// Metatype/GType declaration for ColumnView
public extension ColumnViewClassRef {
    
    /// This getter returns the GLib type identifier registered for `ColumnView`
    static var metatypeReference: GType { gtk_column_view_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkColumnViewClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkColumnViewClass.self) }
    
    static var metatype: GtkColumnViewClass? { metatypePointer?.pointee } 
    
    static var wrapper: ColumnViewClassRef? { ColumnViewClassRef(metatypePointer) }
    
    
}

// MARK: - ColumnViewClass Record


///
/// The `ColumnViewClassProtocol` protocol exposes the methods and properties of an underlying `GtkColumnViewClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColumnViewClass`.
/// Alternatively, use `ColumnViewClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ColumnViewClassProtocol {
        /// Untyped pointer to the underlying `GtkColumnViewClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkColumnViewClass` instance.
    var _ptr: UnsafeMutablePointer<GtkColumnViewClass>! { get }

    /// Required Initialiser for types conforming to `ColumnViewClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `ColumnViewClassRef` type acts as a lightweight Swift reference to an underlying `GtkColumnViewClass` instance.
/// It exposes methods that can operate on this data type through `ColumnViewClassProtocol` conformance.
/// Use `ColumnViewClassRef` only as an `unowned` reference to an existing `GtkColumnViewClass` instance.
///
public struct ColumnViewClassRef: ColumnViewClassProtocol {
        /// Untyped pointer to the underlying `GtkColumnViewClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ColumnViewClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkColumnViewClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkColumnViewClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkColumnViewClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkColumnViewClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ColumnViewClassProtocol`
    @inlinable init<T: ColumnViewClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: ColumnViewClass Record: ColumnViewClassProtocol extension (methods and fields)
public extension ColumnViewClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColumnViewClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkColumnViewClass>! { return ptr?.assumingMemoryBound(to: GtkColumnViewClass.self) }



}



// MARK: - CellLayout Interface

/// An interface for packing cells
/// 
/// `GtkCellLayout` is an interface to be implemented by all objects which
/// want to provide a `GtkTreeViewColumn` like API for packing cells,
/// setting attributes and data funcs.
/// 
/// One of the notable features provided by implementations of
/// `GtkCellLayout` are attributes. Attributes let you set the properties
/// in flexible ways. They can just be set to constant values like regular
/// properties. But they can also be mapped to a column of the underlying
/// tree model with `gtk_cell_layout_set_attributes()`, which means that the value
/// of the attribute can change from cell to cell as they are rendered by
/// the cell renderer. Finally, it is possible to specify a function with
/// `gtk_cell_layout_set_cell_data_func()` that is called to determine the
/// value of the attribute for each cell that is rendered.
/// 
/// # GtkCellLayouts as GtkBuildable
/// 
/// Implementations of GtkCellLayout which also implement the GtkBuildable
/// interface (`GtkCellView`, `GtkIconView`, `GtkComboBox`,
/// `GtkEntryCompletion`, `GtkTreeViewColumn`) accept `GtkCellRenderer` objects
/// as `&lt;child&gt;` elements in UI definitions. They support a custom `&lt;attributes&gt;`
/// element for their children, which can contain multiple `&lt;attribute&gt;`
/// elements. Each `&lt;attribute&gt;` element has a name attribute which specifies
/// a property of the cell renderer; the content of the element is the
/// attribute value.
/// 
/// This is an example of a UI definition fragment specifying attributes:
/// 
/// ```xml
/// &lt;object class="GtkCellView"&gt;
///   &lt;child&gt;
///     &lt;object class="GtkCellRendererText"/&gt;
///     &lt;attributes&gt;
///       &lt;attribute name="text"&gt;0&lt;/attribute&gt;
///     &lt;/attributes&gt;
///   &lt;/child&gt;
/// &lt;/object&gt;
/// ```
/// 
/// Furthermore for implementations of `GtkCellLayout` that use a `GtkCellArea`
/// to lay out cells (all `GtkCellLayout`s in GTK use a `GtkCellArea`)
/// [cell properties](class.CellArea.html`cell-properties`) can also be defined
/// in the format by specifying the custom `&lt;cell-packing&gt;` attribute which can
/// contain multiple `&lt;property&gt;` elements.
/// 
/// Here is a UI definition fragment specifying cell properties:
/// 
/// ```xml
/// &lt;object class="GtkTreeViewColumn"&gt;
///   &lt;child&gt;
///     &lt;object class="GtkCellRendererText"/&gt;
///     &lt;cell-packing&gt;
///       &lt;property name="align"&gt;True&lt;/property&gt;
///       &lt;property name="expand"&gt;False&lt;/property&gt;
///     &lt;/cell-packing&gt;
///   &lt;/child&gt;
/// &lt;/object&gt;
/// ```
/// 
/// # Subclassing GtkCellLayout implementations
/// 
/// When subclassing a widget that implements `GtkCellLayout` like
/// `GtkIconView` or `GtkComboBox`, there are some considerations related
/// to the fact that these widgets internally use a `GtkCellArea`.
/// The cell area is exposed as a construct-only property by these
/// widgets. This means that it is possible to e.g. do
/// 
/// ```c
/// GtkWIdget *combo =
///   g_object_new (GTK_TYPE_COMBO_BOX, "cell-area", my_cell_area, NULL);
/// ```
/// 
/// to use a custom cell area with a combo box. But construct properties
/// are only initialized after instance ``init()``
/// functions have run, which means that using functions which rely on
/// the existence of the cell area in your subclass ``init()`` function will
/// cause the default cell area to be instantiated. In this case, a provided
/// construct property value will be ignored (with a warning, to alert
/// you to the problem).
/// 
/// ```c
/// static void
/// my_combo_box_init (MyComboBox *b)
/// {
///   GtkCellRenderer *cell;
/// 
///   cell = gtk_cell_renderer_pixbuf_new ();
/// 
///   // The following call causes the default cell area for combo boxes,
///   // a GtkCellAreaBox, to be instantiated
///   gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (b), cell, FALSE);
///   ...
/// }
/// 
/// GtkWidget *
/// my_combo_box_new (GtkCellArea *area)
/// {
///   // This call is going to cause a warning about area being ignored
///   return g_object_new (MY_TYPE_COMBO_BOX, "cell-area", area, NULL);
/// }
/// ```
/// 
/// If supporting alternative cell areas with your derived widget is
/// not important, then this does not have to concern you. If you want
/// to support alternative cell areas, you can do so by moving the
/// problematic calls out of ``init()`` and into a ``constructor()``
/// for your class.
///
/// The `CellLayoutProtocol` protocol exposes the methods and properties of an underlying `GtkCellLayout` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellLayout`.
/// Alternatively, use `CellLayoutRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellLayoutProtocol {
        /// Untyped pointer to the underlying `GtkCellLayout` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellLayout` instance.
    var cell_layout_ptr: UnsafeMutablePointer<GtkCellLayout>! { get }

    /// Required Initialiser for types conforming to `CellLayoutProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// An interface for packing cells
/// 
/// `GtkCellLayout` is an interface to be implemented by all objects which
/// want to provide a `GtkTreeViewColumn` like API for packing cells,
/// setting attributes and data funcs.
/// 
/// One of the notable features provided by implementations of
/// `GtkCellLayout` are attributes. Attributes let you set the properties
/// in flexible ways. They can just be set to constant values like regular
/// properties. But they can also be mapped to a column of the underlying
/// tree model with `gtk_cell_layout_set_attributes()`, which means that the value
/// of the attribute can change from cell to cell as they are rendered by
/// the cell renderer. Finally, it is possible to specify a function with
/// `gtk_cell_layout_set_cell_data_func()` that is called to determine the
/// value of the attribute for each cell that is rendered.
/// 
/// # GtkCellLayouts as GtkBuildable
/// 
/// Implementations of GtkCellLayout which also implement the GtkBuildable
/// interface (`GtkCellView`, `GtkIconView`, `GtkComboBox`,
/// `GtkEntryCompletion`, `GtkTreeViewColumn`) accept `GtkCellRenderer` objects
/// as `&lt;child&gt;` elements in UI definitions. They support a custom `&lt;attributes&gt;`
/// element for their children, which can contain multiple `&lt;attribute&gt;`
/// elements. Each `&lt;attribute&gt;` element has a name attribute which specifies
/// a property of the cell renderer; the content of the element is the
/// attribute value.
/// 
/// This is an example of a UI definition fragment specifying attributes:
/// 
/// ```xml
/// &lt;object class="GtkCellView"&gt;
///   &lt;child&gt;
///     &lt;object class="GtkCellRendererText"/&gt;
///     &lt;attributes&gt;
///       &lt;attribute name="text"&gt;0&lt;/attribute&gt;
///     &lt;/attributes&gt;
///   &lt;/child&gt;
/// &lt;/object&gt;
/// ```
/// 
/// Furthermore for implementations of `GtkCellLayout` that use a `GtkCellArea`
/// to lay out cells (all `GtkCellLayout`s in GTK use a `GtkCellArea`)
/// [cell properties](class.CellArea.html`cell-properties`) can also be defined
/// in the format by specifying the custom `&lt;cell-packing&gt;` attribute which can
/// contain multiple `&lt;property&gt;` elements.
/// 
/// Here is a UI definition fragment specifying cell properties:
/// 
/// ```xml
/// &lt;object class="GtkTreeViewColumn"&gt;
///   &lt;child&gt;
///     &lt;object class="GtkCellRendererText"/&gt;
///     &lt;cell-packing&gt;
///       &lt;property name="align"&gt;True&lt;/property&gt;
///       &lt;property name="expand"&gt;False&lt;/property&gt;
///     &lt;/cell-packing&gt;
///   &lt;/child&gt;
/// &lt;/object&gt;
/// ```
/// 
/// # Subclassing GtkCellLayout implementations
/// 
/// When subclassing a widget that implements `GtkCellLayout` like
/// `GtkIconView` or `GtkComboBox`, there are some considerations related
/// to the fact that these widgets internally use a `GtkCellArea`.
/// The cell area is exposed as a construct-only property by these
/// widgets. This means that it is possible to e.g. do
/// 
/// ```c
/// GtkWIdget *combo =
///   g_object_new (GTK_TYPE_COMBO_BOX, "cell-area", my_cell_area, NULL);
/// ```
/// 
/// to use a custom cell area with a combo box. But construct properties
/// are only initialized after instance ``init()``
/// functions have run, which means that using functions which rely on
/// the existence of the cell area in your subclass ``init()`` function will
/// cause the default cell area to be instantiated. In this case, a provided
/// construct property value will be ignored (with a warning, to alert
/// you to the problem).
/// 
/// ```c
/// static void
/// my_combo_box_init (MyComboBox *b)
/// {
///   GtkCellRenderer *cell;
/// 
///   cell = gtk_cell_renderer_pixbuf_new ();
/// 
///   // The following call causes the default cell area for combo boxes,
///   // a GtkCellAreaBox, to be instantiated
///   gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (b), cell, FALSE);
///   ...
/// }
/// 
/// GtkWidget *
/// my_combo_box_new (GtkCellArea *area)
/// {
///   // This call is going to cause a warning about area being ignored
///   return g_object_new (MY_TYPE_COMBO_BOX, "cell-area", area, NULL);
/// }
/// ```
/// 
/// If supporting alternative cell areas with your derived widget is
/// not important, then this does not have to concern you. If you want
/// to support alternative cell areas, you can do so by moving the
/// problematic calls out of ``init()`` and into a ``constructor()``
/// for your class.
///
/// The `CellLayoutRef` type acts as a lightweight Swift reference to an underlying `GtkCellLayout` instance.
/// It exposes methods that can operate on this data type through `CellLayoutProtocol` conformance.
/// Use `CellLayoutRef` only as an `unowned` reference to an existing `GtkCellLayout` instance.
///
public struct CellLayoutRef: CellLayoutProtocol {
        /// Untyped pointer to the underlying `GtkCellLayout` instance.
    /// For type-safe access, use the generated, typed pointer `cell_layout_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellLayoutRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellLayout>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellLayout>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellLayout>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellLayout>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellLayoutProtocol`
    @inlinable init<T: CellLayoutProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellLayoutProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellLayoutProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellLayoutProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellLayoutProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellLayoutProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// An interface for packing cells
/// 
/// `GtkCellLayout` is an interface to be implemented by all objects which
/// want to provide a `GtkTreeViewColumn` like API for packing cells,
/// setting attributes and data funcs.
/// 
/// One of the notable features provided by implementations of
/// `GtkCellLayout` are attributes. Attributes let you set the properties
/// in flexible ways. They can just be set to constant values like regular
/// properties. But they can also be mapped to a column of the underlying
/// tree model with `gtk_cell_layout_set_attributes()`, which means that the value
/// of the attribute can change from cell to cell as they are rendered by
/// the cell renderer. Finally, it is possible to specify a function with
/// `gtk_cell_layout_set_cell_data_func()` that is called to determine the
/// value of the attribute for each cell that is rendered.
/// 
/// # GtkCellLayouts as GtkBuildable
/// 
/// Implementations of GtkCellLayout which also implement the GtkBuildable
/// interface (`GtkCellView`, `GtkIconView`, `GtkComboBox`,
/// `GtkEntryCompletion`, `GtkTreeViewColumn`) accept `GtkCellRenderer` objects
/// as `&lt;child&gt;` elements in UI definitions. They support a custom `&lt;attributes&gt;`
/// element for their children, which can contain multiple `&lt;attribute&gt;`
/// elements. Each `&lt;attribute&gt;` element has a name attribute which specifies
/// a property of the cell renderer; the content of the element is the
/// attribute value.
/// 
/// This is an example of a UI definition fragment specifying attributes:
/// 
/// ```xml
/// &lt;object class="GtkCellView"&gt;
///   &lt;child&gt;
///     &lt;object class="GtkCellRendererText"/&gt;
///     &lt;attributes&gt;
///       &lt;attribute name="text"&gt;0&lt;/attribute&gt;
///     &lt;/attributes&gt;
///   &lt;/child&gt;
/// &lt;/object&gt;
/// ```
/// 
/// Furthermore for implementations of `GtkCellLayout` that use a `GtkCellArea`
/// to lay out cells (all `GtkCellLayout`s in GTK use a `GtkCellArea`)
/// [cell properties](class.CellArea.html`cell-properties`) can also be defined
/// in the format by specifying the custom `&lt;cell-packing&gt;` attribute which can
/// contain multiple `&lt;property&gt;` elements.
/// 
/// Here is a UI definition fragment specifying cell properties:
/// 
/// ```xml
/// &lt;object class="GtkTreeViewColumn"&gt;
///   &lt;child&gt;
///     &lt;object class="GtkCellRendererText"/&gt;
///     &lt;cell-packing&gt;
///       &lt;property name="align"&gt;True&lt;/property&gt;
///       &lt;property name="expand"&gt;False&lt;/property&gt;
///     &lt;/cell-packing&gt;
///   &lt;/child&gt;
/// &lt;/object&gt;
/// ```
/// 
/// # Subclassing GtkCellLayout implementations
/// 
/// When subclassing a widget that implements `GtkCellLayout` like
/// `GtkIconView` or `GtkComboBox`, there are some considerations related
/// to the fact that these widgets internally use a `GtkCellArea`.
/// The cell area is exposed as a construct-only property by these
/// widgets. This means that it is possible to e.g. do
/// 
/// ```c
/// GtkWIdget *combo =
///   g_object_new (GTK_TYPE_COMBO_BOX, "cell-area", my_cell_area, NULL);
/// ```
/// 
/// to use a custom cell area with a combo box. But construct properties
/// are only initialized after instance ``init()``
/// functions have run, which means that using functions which rely on
/// the existence of the cell area in your subclass ``init()`` function will
/// cause the default cell area to be instantiated. In this case, a provided
/// construct property value will be ignored (with a warning, to alert
/// you to the problem).
/// 
/// ```c
/// static void
/// my_combo_box_init (MyComboBox *b)
/// {
///   GtkCellRenderer *cell;
/// 
///   cell = gtk_cell_renderer_pixbuf_new ();
/// 
///   // The following call causes the default cell area for combo boxes,
///   // a GtkCellAreaBox, to be instantiated
///   gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (b), cell, FALSE);
///   ...
/// }
/// 
/// GtkWidget *
/// my_combo_box_new (GtkCellArea *area)
/// {
///   // This call is going to cause a warning about area being ignored
///   return g_object_new (MY_TYPE_COMBO_BOX, "cell-area", area, NULL);
/// }
/// ```
/// 
/// If supporting alternative cell areas with your derived widget is
/// not important, then this does not have to concern you. If you want
/// to support alternative cell areas, you can do so by moving the
/// problematic calls out of ``init()`` and into a ``constructor()``
/// for your class.
///
/// The `CellLayout` type acts as an owner of an underlying `GtkCellLayout` instance.
/// It provides the methods that can operate on this data type through `CellLayoutProtocol` conformance.
/// Use `CellLayout` as a strong reference or owner of a `GtkCellLayout` instance.
///
open class CellLayout: CellLayoutProtocol {
        /// Untyped pointer to the underlying `GtkCellLayout` instance.
    /// For type-safe access, use the generated, typed pointer `cell_layout_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellLayout>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellLayout>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellLayout` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellLayout>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellLayout>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GtkCellLayout` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `CellLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellLayout>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GtkCellLayout, cannot ref(cell_layout_ptr)
    }

    /// Reference intialiser for a related type that implements `CellLayoutProtocol`
    /// `GtkCellLayout` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `CellLayoutProtocol`
    @inlinable public init<T: CellLayoutProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GtkCellLayout, cannot ref(cell_layout_ptr)
    }

    /// Do-nothing destructor for `GtkCellLayout`.
    deinit {
        // no reference counting for GtkCellLayout, cannot unref(cell_layout_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellLayoutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellLayoutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GtkCellLayout, cannot ref(cell_layout_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellLayoutProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellLayoutProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GtkCellLayout, cannot ref(cell_layout_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellLayoutProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellLayoutProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GtkCellLayout, cannot ref(cell_layout_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellLayoutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellLayoutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GtkCellLayout, cannot ref(cell_layout_ptr)
    }



}

// MARK: no CellLayout properties

// MARK: no CellLayout signals

// MARK: CellLayout has no signals
// MARK: CellLayout Interface: CellLayoutProtocol extension (methods and fields)
public extension CellLayoutProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellLayout` instance.
    @inlinable var cell_layout_ptr: UnsafeMutablePointer<GtkCellLayout>! { return ptr?.assumingMemoryBound(to: GtkCellLayout.self) }

    /// Adds an attribute mapping to the list in `cell_layout`.
    /// 
    /// The `column` is the column of the model to get a value from, and the
    /// `attribute` is the property on `cell` to be set from that value. So for
    /// example if column 2 of the model contains strings, you could have the
    /// “text” attribute of a `GtkCellRendererText` get its values from column 2.
    /// In this context "attribute" and "property" are used interchangeably.
    @inlinable func addAttribute<CellRendererT: CellRendererProtocol>(cell: CellRendererT, attribute: UnsafePointer<CChar>!, column: Int) {
        
        gtk_cell_layout_add_attribute(cell_layout_ptr, cell.cell_renderer_ptr, attribute, gint(column))
        
    }

    /// Unsets all the mappings on all renderers on `cell_layout` and
    /// removes all renderers from `cell_layout`.
    @inlinable func clear() {
        
        gtk_cell_layout_clear(cell_layout_ptr)
        
    }

    /// Clears all existing attributes previously set with
    /// `gtk_cell_layout_set_attributes()`.
    @inlinable func clearAttributes<CellRendererT: CellRendererProtocol>(cell: CellRendererT) {
        
        gtk_cell_layout_clear_attributes(cell_layout_ptr, cell.cell_renderer_ptr)
        
    }

    /// Returns the underlying `GtkCellArea` which might be `cell_layout`
    /// if called on a `GtkCellArea` or might be `nil` if no `GtkCellArea`
    /// is used by `cell_layout`.
    @inlinable func getArea() -> CellAreaRef! {
        let result = gtk_cell_layout_get_area(cell_layout_ptr)
        let rv = CellAreaRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns the cell renderers which have been added to `cell_layout`.
    @inlinable func getCells() -> GLib.ListRef! {
        let result = gtk_cell_layout_get_cells(cell_layout_ptr)
        let rv = GLib.ListRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Adds the `cell` to the end of `cell_layout`. If `expand` is `false`, then the
    /// `cell` is allocated no more space than it needs. Any unused space is
    /// divided evenly between cells for which `expand` is `true`.
    /// 
    /// Note that reusing the same cell renderer is not supported.
    @inlinable func packEnd<CellRendererT: CellRendererProtocol>(cell: CellRendererT, expand: Bool) {
        
        gtk_cell_layout_pack_end(cell_layout_ptr, cell.cell_renderer_ptr, gboolean((expand) ? 1 : 0))
        
    }

    /// Packs the `cell` into the beginning of `cell_layout`. If `expand` is `false`,
    /// then the `cell` is allocated no more space than it needs. Any unused space
    /// is divided evenly between cells for which `expand` is `true`.
    /// 
    /// Note that reusing the same cell renderer is not supported.
    @inlinable func packStart<CellRendererT: CellRendererProtocol>(cell: CellRendererT, expand: Bool) {
        
        gtk_cell_layout_pack_start(cell_layout_ptr, cell.cell_renderer_ptr, gboolean((expand) ? 1 : 0))
        
    }

    /// Re-inserts `cell` at `position`.
    /// 
    /// Note that `cell` has already to be packed into `cell_layout`
    /// for this to function properly.
    @inlinable func reorder<CellRendererT: CellRendererProtocol>(cell: CellRendererT, position: Int) {
        
        gtk_cell_layout_reorder(cell_layout_ptr, cell.cell_renderer_ptr, gint(position))
        
    }


    // *** setAttributes() is not available because it has a varargs (...) parameter!


    /// Sets the `GtkCellLayout`DataFunc to use for `cell_layout`.
    /// 
    /// This function is used instead of the standard attributes mapping
    /// for setting the column value, and should set the value of `cell_layout`’s
    /// cell `renderer(s)` as appropriate.
    /// 
    /// `func` may be `nil` to remove a previously set function.
    @inlinable func setCellDataFunc<CellRendererT: CellRendererProtocol>(cell: CellRendererT, `func`: GtkCellLayoutDataFunc? = nil, funcData: gpointer? = nil, destroy: GDestroyNotify?) {
        
        gtk_cell_layout_set_cell_data_func(cell_layout_ptr, cell.cell_renderer_ptr, `func`, funcData, destroy)
        
    }
    /// Returns the underlying `GtkCellArea` which might be `cell_layout`
    /// if called on a `GtkCellArea` or might be `nil` if no `GtkCellArea`
    /// is used by `cell_layout`.
    @inlinable var area: CellAreaRef! {
        /// Returns the underlying `GtkCellArea` which might be `cell_layout`
        /// if called on a `GtkCellArea` or might be `nil` if no `GtkCellArea`
        /// is used by `cell_layout`.
        get {
            let result = gtk_cell_layout_get_area(cell_layout_ptr)
        let rv = CellAreaRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Returns the cell renderers which have been added to `cell_layout`.
    @inlinable var cells: GLib.ListRef! {
        /// Returns the cell renderers which have been added to `cell_layout`.
        get {
            let result = gtk_cell_layout_get_cells(cell_layout_ptr)
        let rv = GLib.ListRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }


}



/// Metatype/GType declaration for ColumnViewColumn
public extension ColumnViewColumnClassRef {
    
    /// This getter returns the GLib type identifier registered for `ColumnViewColumn`
    static var metatypeReference: GType { gtk_column_view_column_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkColumnViewColumnClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkColumnViewColumnClass.self) }
    
    static var metatype: GtkColumnViewColumnClass? { metatypePointer?.pointee } 
    
    static var wrapper: ColumnViewColumnClassRef? { ColumnViewColumnClassRef(metatypePointer) }
    
    
}

// MARK: - ColumnViewColumnClass Record


///
/// The `ColumnViewColumnClassProtocol` protocol exposes the methods and properties of an underlying `GtkColumnViewColumnClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColumnViewColumnClass`.
/// Alternatively, use `ColumnViewColumnClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ColumnViewColumnClassProtocol {
        /// Untyped pointer to the underlying `GtkColumnViewColumnClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkColumnViewColumnClass` instance.
    var _ptr: UnsafeMutablePointer<GtkColumnViewColumnClass>! { get }

    /// Required Initialiser for types conforming to `ColumnViewColumnClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `ColumnViewColumnClassRef` type acts as a lightweight Swift reference to an underlying `GtkColumnViewColumnClass` instance.
/// It exposes methods that can operate on this data type through `ColumnViewColumnClassProtocol` conformance.
/// Use `ColumnViewColumnClassRef` only as an `unowned` reference to an existing `GtkColumnViewColumnClass` instance.
///
public struct ColumnViewColumnClassRef: ColumnViewColumnClassProtocol {
        /// Untyped pointer to the underlying `GtkColumnViewColumnClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ColumnViewColumnClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkColumnViewColumnClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkColumnViewColumnClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkColumnViewColumnClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkColumnViewColumnClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ColumnViewColumnClassProtocol`
    @inlinable init<T: ColumnViewColumnClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: ColumnViewColumnClass Record: ColumnViewColumnClassProtocol extension (methods and fields)
public extension ColumnViewColumnClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColumnViewColumnClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkColumnViewColumnClass>! { return ptr?.assumingMemoryBound(to: GtkColumnViewColumnClass.self) }



}



/// Metatype/GType declaration for ComboBox
public extension ComboBoxClassRef {
    
    /// This getter returns the GLib type identifier registered for `ComboBox`
    static var metatypeReference: GType { gtk_combo_box_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkComboBoxClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkComboBoxClass.self) }
    
    static var metatype: GtkComboBoxClass? { metatypePointer?.pointee } 
    
    static var wrapper: ComboBoxClassRef? { ComboBoxClassRef(metatypePointer) }
    
    
}

// MARK: - ComboBoxClass Record


///
/// The `ComboBoxClassProtocol` protocol exposes the methods and properties of an underlying `GtkComboBoxClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ComboBoxClass`.
/// Alternatively, use `ComboBoxClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ComboBoxClassProtocol {
        /// Untyped pointer to the underlying `GtkComboBoxClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkComboBoxClass` instance.
    var _ptr: UnsafeMutablePointer<GtkComboBoxClass>! { get }

    /// Required Initialiser for types conforming to `ComboBoxClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `ComboBoxClassRef` type acts as a lightweight Swift reference to an underlying `GtkComboBoxClass` instance.
/// It exposes methods that can operate on this data type through `ComboBoxClassProtocol` conformance.
/// Use `ComboBoxClassRef` only as an `unowned` reference to an existing `GtkComboBoxClass` instance.
///
public struct ComboBoxClassRef: ComboBoxClassProtocol {
        /// Untyped pointer to the underlying `GtkComboBoxClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ComboBoxClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkComboBoxClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkComboBoxClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkComboBoxClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkComboBoxClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ComboBoxClassProtocol`
    @inlinable init<T: ComboBoxClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: ComboBoxClass Record: ComboBoxClassProtocol extension (methods and fields)
public extension ComboBoxClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkComboBoxClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkComboBoxClass>! { return ptr?.assumingMemoryBound(to: GtkComboBoxClass.self) }


    /// The parent class.
    @inlinable var parentClass: GtkWidgetClass {
        /// The parent class.
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var changed is unavailable because changed is void

    // var formatEntryText is unavailable because format_entry_text is void

    // var activate is unavailable because activate is void

    // var padding is unavailable because padding is private

}



/// Metatype/GType declaration for Constraint
public extension ConstraintClassRef {
    
    /// This getter returns the GLib type identifier registered for `Constraint`
    static var metatypeReference: GType { gtk_constraint_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkConstraintClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkConstraintClass.self) }
    
    static var metatype: GtkConstraintClass? { metatypePointer?.pointee } 
    
    static var wrapper: ConstraintClassRef? { ConstraintClassRef(metatypePointer) }
    
    
}

// MARK: - ConstraintClass Record


///
/// The `ConstraintClassProtocol` protocol exposes the methods and properties of an underlying `GtkConstraintClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ConstraintClass`.
/// Alternatively, use `ConstraintClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ConstraintClassProtocol {
        /// Untyped pointer to the underlying `GtkConstraintClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstraintClass` instance.
    var _ptr: UnsafeMutablePointer<GtkConstraintClass>! { get }

    /// Required Initialiser for types conforming to `ConstraintClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `ConstraintClassRef` type acts as a lightweight Swift reference to an underlying `GtkConstraintClass` instance.
/// It exposes methods that can operate on this data type through `ConstraintClassProtocol` conformance.
/// Use `ConstraintClassRef` only as an `unowned` reference to an existing `GtkConstraintClass` instance.
///
public struct ConstraintClassRef: ConstraintClassProtocol {
        /// Untyped pointer to the underlying `GtkConstraintClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstraintClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstraintClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstraintClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstraintClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstraintClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstraintClassProtocol`
    @inlinable init<T: ConstraintClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: ConstraintClass Record: ConstraintClassProtocol extension (methods and fields)
public extension ConstraintClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstraintClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkConstraintClass>! { return ptr?.assumingMemoryBound(to: GtkConstraintClass.self) }


    @inlinable var parentClass: GObjectClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

}



/// Metatype/GType declaration for ConstraintGuide
public extension ConstraintGuideClassRef {
    
    /// This getter returns the GLib type identifier registered for `ConstraintGuide`
    static var metatypeReference: GType { gtk_constraint_guide_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkConstraintGuideClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkConstraintGuideClass.self) }
    
    static var metatype: GtkConstraintGuideClass? { metatypePointer?.pointee } 
    
    static var wrapper: ConstraintGuideClassRef? { ConstraintGuideClassRef(metatypePointer) }
    
    
}

// MARK: - ConstraintGuideClass Record


///
/// The `ConstraintGuideClassProtocol` protocol exposes the methods and properties of an underlying `GtkConstraintGuideClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ConstraintGuideClass`.
/// Alternatively, use `ConstraintGuideClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ConstraintGuideClassProtocol {
        /// Untyped pointer to the underlying `GtkConstraintGuideClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstraintGuideClass` instance.
    var _ptr: UnsafeMutablePointer<GtkConstraintGuideClass>! { get }

    /// Required Initialiser for types conforming to `ConstraintGuideClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `ConstraintGuideClassRef` type acts as a lightweight Swift reference to an underlying `GtkConstraintGuideClass` instance.
/// It exposes methods that can operate on this data type through `ConstraintGuideClassProtocol` conformance.
/// Use `ConstraintGuideClassRef` only as an `unowned` reference to an existing `GtkConstraintGuideClass` instance.
///
public struct ConstraintGuideClassRef: ConstraintGuideClassProtocol {
        /// Untyped pointer to the underlying `GtkConstraintGuideClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstraintGuideClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstraintGuideClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstraintGuideClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstraintGuideClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstraintGuideClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstraintGuideClassProtocol`
    @inlinable init<T: ConstraintGuideClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: ConstraintGuideClass Record: ConstraintGuideClassProtocol extension (methods and fields)
public extension ConstraintGuideClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstraintGuideClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkConstraintGuideClass>! { return ptr?.assumingMemoryBound(to: GtkConstraintGuideClass.self) }


    @inlinable var parentClass: GObjectClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

}



/// Metatype/GType declaration for ConstraintLayoutChild
public extension ConstraintLayoutChildClassRef {
    
    /// This getter returns the GLib type identifier registered for `ConstraintLayoutChild`
    static var metatypeReference: GType { gtk_constraint_layout_child_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkConstraintLayoutChildClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkConstraintLayoutChildClass.self) }
    
    static var metatype: GtkConstraintLayoutChildClass? { metatypePointer?.pointee } 
    
    static var wrapper: ConstraintLayoutChildClassRef? { ConstraintLayoutChildClassRef(metatypePointer) }
    
    
}

// MARK: - ConstraintLayoutChildClass Record


///
/// The `ConstraintLayoutChildClassProtocol` protocol exposes the methods and properties of an underlying `GtkConstraintLayoutChildClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ConstraintLayoutChildClass`.
/// Alternatively, use `ConstraintLayoutChildClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ConstraintLayoutChildClassProtocol {
        /// Untyped pointer to the underlying `GtkConstraintLayoutChildClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstraintLayoutChildClass` instance.
    var _ptr: UnsafeMutablePointer<GtkConstraintLayoutChildClass>! { get }

    /// Required Initialiser for types conforming to `ConstraintLayoutChildClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `ConstraintLayoutChildClassRef` type acts as a lightweight Swift reference to an underlying `GtkConstraintLayoutChildClass` instance.
/// It exposes methods that can operate on this data type through `ConstraintLayoutChildClassProtocol` conformance.
/// Use `ConstraintLayoutChildClassRef` only as an `unowned` reference to an existing `GtkConstraintLayoutChildClass` instance.
///
public struct ConstraintLayoutChildClassRef: ConstraintLayoutChildClassProtocol {
        /// Untyped pointer to the underlying `GtkConstraintLayoutChildClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstraintLayoutChildClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstraintLayoutChildClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstraintLayoutChildClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstraintLayoutChildClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstraintLayoutChildClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstraintLayoutChildClassProtocol`
    @inlinable init<T: ConstraintLayoutChildClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: ConstraintLayoutChildClass Record: ConstraintLayoutChildClassProtocol extension (methods and fields)
public extension ConstraintLayoutChildClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstraintLayoutChildClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkConstraintLayoutChildClass>! { return ptr?.assumingMemoryBound(to: GtkConstraintLayoutChildClass.self) }


    @inlinable var parentClass: GtkLayoutChildClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

}



/// Metatype/GType declaration for ConstraintLayout
public extension ConstraintLayoutClassRef {
    
    /// This getter returns the GLib type identifier registered for `ConstraintLayout`
    static var metatypeReference: GType { gtk_constraint_layout_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkConstraintLayoutClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkConstraintLayoutClass.self) }
    
    static var metatype: GtkConstraintLayoutClass? { metatypePointer?.pointee } 
    
    static var wrapper: ConstraintLayoutClassRef? { ConstraintLayoutClassRef(metatypePointer) }
    
    
}

// MARK: - ConstraintLayoutClass Record


///
/// The `ConstraintLayoutClassProtocol` protocol exposes the methods and properties of an underlying `GtkConstraintLayoutClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ConstraintLayoutClass`.
/// Alternatively, use `ConstraintLayoutClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ConstraintLayoutClassProtocol {
        /// Untyped pointer to the underlying `GtkConstraintLayoutClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstraintLayoutClass` instance.
    var _ptr: UnsafeMutablePointer<GtkConstraintLayoutClass>! { get }

    /// Required Initialiser for types conforming to `ConstraintLayoutClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `ConstraintLayoutClassRef` type acts as a lightweight Swift reference to an underlying `GtkConstraintLayoutClass` instance.
/// It exposes methods that can operate on this data type through `ConstraintLayoutClassProtocol` conformance.
/// Use `ConstraintLayoutClassRef` only as an `unowned` reference to an existing `GtkConstraintLayoutClass` instance.
///
public struct ConstraintLayoutClassRef: ConstraintLayoutClassProtocol {
        /// Untyped pointer to the underlying `GtkConstraintLayoutClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstraintLayoutClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstraintLayoutClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstraintLayoutClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstraintLayoutClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstraintLayoutClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstraintLayoutClassProtocol`
    @inlinable init<T: ConstraintLayoutClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: ConstraintLayoutClass Record: ConstraintLayoutClassProtocol extension (methods and fields)
public extension ConstraintLayoutClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstraintLayoutClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkConstraintLayoutClass>! { return ptr?.assumingMemoryBound(to: GtkConstraintLayoutClass.self) }


    @inlinable var parentClass: GtkLayoutManagerClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

}



/// Metatype/GType declaration for ConstraintTarget
public extension ConstraintTargetInterfaceRef {
    
    /// This getter returns the GLib type identifier registered for `ConstraintTarget`
    static var metatypeReference: GType { gtk_constraint_target_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkConstraintTargetInterface>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkConstraintTargetInterface.self) }
    
    static var metatype: GtkConstraintTargetInterface? { metatypePointer?.pointee } 
    
    static var wrapper: ConstraintTargetInterfaceRef? { ConstraintTargetInterfaceRef(metatypePointer) }
    
    
}

// MARK: - ConstraintTargetInterface Record


///
/// The `ConstraintTargetInterfaceProtocol` protocol exposes the methods and properties of an underlying `GtkConstraintTargetInterface` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ConstraintTargetInterface`.
/// Alternatively, use `ConstraintTargetInterfaceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ConstraintTargetInterfaceProtocol {
        /// Untyped pointer to the underlying `GtkConstraintTargetInterface` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstraintTargetInterface` instance.
    var _ptr: UnsafeMutablePointer<GtkConstraintTargetInterface>! { get }

    /// Required Initialiser for types conforming to `ConstraintTargetInterfaceProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `ConstraintTargetInterfaceRef` type acts as a lightweight Swift reference to an underlying `GtkConstraintTargetInterface` instance.
/// It exposes methods that can operate on this data type through `ConstraintTargetInterfaceProtocol` conformance.
/// Use `ConstraintTargetInterfaceRef` only as an `unowned` reference to an existing `GtkConstraintTargetInterface` instance.
///
public struct ConstraintTargetInterfaceRef: ConstraintTargetInterfaceProtocol {
        /// Untyped pointer to the underlying `GtkConstraintTargetInterface` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstraintTargetInterfaceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstraintTargetInterface>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstraintTargetInterface>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstraintTargetInterface>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstraintTargetInterface>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstraintTargetInterfaceProtocol`
    @inlinable init<T: ConstraintTargetInterfaceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintTargetInterfaceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintTargetInterfaceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintTargetInterfaceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintTargetInterfaceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintTargetInterfaceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: ConstraintTargetInterface Record: ConstraintTargetInterfaceProtocol extension (methods and fields)
public extension ConstraintTargetInterfaceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstraintTargetInterface` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkConstraintTargetInterface>! { return ptr?.assumingMemoryBound(to: GtkConstraintTargetInterface.self) }



}



// MARK: - CssLocation Record

/// Represents a location in a file or other source of data parsed
/// by the CSS engine.
/// 
/// The `bytes` and `line_bytes` offsets are meant to be used to
/// programmatically match data. The `lines` and `line_chars` offsets
/// can be used for printing the location in a file.
/// 
/// Note that the `lines` parameter starts from 0 and is increased
/// whenever a CSS line break is encountered. (CSS defines the C character
/// sequences "\r\n", "\r", "\n" and "\f" as newlines.)
/// If your document uses different rules for line breaking, you might want
/// run into problems here.
///
/// The `CssLocationProtocol` protocol exposes the methods and properties of an underlying `GtkCssLocation` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CssLocation`.
/// Alternatively, use `CssLocationRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CssLocationProtocol {
        /// Untyped pointer to the underlying `GtkCssLocation` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCssLocation` instance.
    var _ptr: UnsafeMutablePointer<GtkCssLocation>! { get }

    /// Required Initialiser for types conforming to `CssLocationProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Represents a location in a file or other source of data parsed
/// by the CSS engine.
/// 
/// The `bytes` and `line_bytes` offsets are meant to be used to
/// programmatically match data. The `lines` and `line_chars` offsets
/// can be used for printing the location in a file.
/// 
/// Note that the `lines` parameter starts from 0 and is increased
/// whenever a CSS line break is encountered. (CSS defines the C character
/// sequences "\r\n", "\r", "\n" and "\f" as newlines.)
/// If your document uses different rules for line breaking, you might want
/// run into problems here.
///
/// The `CssLocationRef` type acts as a lightweight Swift reference to an underlying `GtkCssLocation` instance.
/// It exposes methods that can operate on this data type through `CssLocationProtocol` conformance.
/// Use `CssLocationRef` only as an `unowned` reference to an existing `GtkCssLocation` instance.
///
public struct CssLocationRef: CssLocationProtocol {
        /// Untyped pointer to the underlying `GtkCssLocation` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CssLocationRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCssLocation>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCssLocation>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCssLocation>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCssLocation>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CssLocationProtocol`
    @inlinable init<T: CssLocationProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssLocationProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssLocationProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssLocationProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssLocationProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssLocationProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// Represents a location in a file or other source of data parsed
/// by the CSS engine.
/// 
/// The `bytes` and `line_bytes` offsets are meant to be used to
/// programmatically match data. The `lines` and `line_chars` offsets
/// can be used for printing the location in a file.
/// 
/// Note that the `lines` parameter starts from 0 and is increased
/// whenever a CSS line break is encountered. (CSS defines the C character
/// sequences "\r\n", "\r", "\n" and "\f" as newlines.)
/// If your document uses different rules for line breaking, you might want
/// run into problems here.
///
/// The `CssLocation` type acts as an owner of an underlying `GtkCssLocation` instance.
/// It provides the methods that can operate on this data type through `CssLocationProtocol` conformance.
/// Use `CssLocation` as a strong reference or owner of a `GtkCssLocation` instance.
///
open class CssLocation: CssLocationProtocol {
        /// Untyped pointer to the underlying `GtkCssLocation` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssLocation` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCssLocation>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssLocation` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCssLocation>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssLocation` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssLocation` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssLocation` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCssLocation>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssLocation` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCssLocation>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GtkCssLocation` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `CssLocation` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCssLocation>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GtkCssLocation, cannot ref(_ptr)
    }

    /// Reference intialiser for a related type that implements `CssLocationProtocol`
    /// `GtkCssLocation` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `CssLocationProtocol`
    @inlinable public init<T: CssLocationProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GtkCssLocation, cannot ref(_ptr)
    }

    /// Do-nothing destructor for `GtkCssLocation`.
    deinit {
        // no reference counting for GtkCssLocation, cannot unref(_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssLocationProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssLocationProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GtkCssLocation, cannot ref(_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssLocationProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssLocationProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GtkCssLocation, cannot ref(_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssLocationProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssLocationProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GtkCssLocation, cannot ref(_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssLocationProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssLocationProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GtkCssLocation, cannot ref(_ptr)
    }



}

// MARK: no CssLocation properties

// MARK: no CssLocation signals

// MARK: CssLocation has no signals
// MARK: CssLocation Record: CssLocationProtocol extension (methods and fields)
public extension CssLocationProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCssLocation` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkCssLocation>! { return ptr?.assumingMemoryBound(to: GtkCssLocation.self) }


    /// number of bytes parsed since the beginning
    @inlinable var bytes: gsize {
        /// number of bytes parsed since the beginning
        get {
            let rv = _ptr.pointee.bytes
    return rv
        }
        /// number of bytes parsed since the beginning
         set {
            _ptr.pointee.bytes = newValue
        }
    }

    /// number of characters parsed since the beginning
    @inlinable var chars: gsize {
        /// number of characters parsed since the beginning
        get {
            let rv = _ptr.pointee.chars
    return rv
        }
        /// number of characters parsed since the beginning
         set {
            _ptr.pointee.chars = newValue
        }
    }

    /// number of full lines that have been parsed. If you want to
    ///   display this as a line number, you need to add 1 to this.
    @inlinable var lines: gsize {
        /// number of full lines that have been parsed. If you want to
        ///   display this as a line number, you need to add 1 to this.
        get {
            let rv = _ptr.pointee.lines
    return rv
        }
        /// number of full lines that have been parsed. If you want to
        ///   display this as a line number, you need to add 1 to this.
         set {
            _ptr.pointee.lines = newValue
        }
    }

    /// Number of bytes parsed since the last line break
    @inlinable var lineBytes: gsize {
        /// Number of bytes parsed since the last line break
        get {
            let rv = _ptr.pointee.line_bytes
    return rv
        }
        /// Number of bytes parsed since the last line break
         set {
            _ptr.pointee.line_bytes = newValue
        }
    }

    /// Number of characters parsed since the last line break
    @inlinable var lineChars: gsize {
        /// Number of characters parsed since the last line break
        get {
            let rv = _ptr.pointee.line_chars
    return rv
        }
        /// Number of characters parsed since the last line break
         set {
            _ptr.pointee.line_chars = newValue
        }
    }

}



/// Metatype/GType declaration for CssProvider
public extension CssProviderClassRef {
    
    /// This getter returns the GLib type identifier registered for `CssProvider`
    static var metatypeReference: GType { gtk_css_provider_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkCssProviderClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkCssProviderClass.self) }
    
    static var metatype: GtkCssProviderClass? { metatypePointer?.pointee } 
    
    static var wrapper: CssProviderClassRef? { CssProviderClassRef(metatypePointer) }
    
    
}

// MARK: - CssProviderClass Record


///
/// The `CssProviderClassProtocol` protocol exposes the methods and properties of an underlying `GtkCssProviderClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CssProviderClass`.
/// Alternatively, use `CssProviderClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CssProviderClassProtocol {
        /// Untyped pointer to the underlying `GtkCssProviderClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCssProviderClass` instance.
    var _ptr: UnsafeMutablePointer<GtkCssProviderClass>! { get }

    /// Required Initialiser for types conforming to `CssProviderClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `CssProviderClassRef` type acts as a lightweight Swift reference to an underlying `GtkCssProviderClass` instance.
/// It exposes methods that can operate on this data type through `CssProviderClassProtocol` conformance.
/// Use `CssProviderClassRef` only as an `unowned` reference to an existing `GtkCssProviderClass` instance.
///
public struct CssProviderClassRef: CssProviderClassProtocol {
        /// Untyped pointer to the underlying `GtkCssProviderClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CssProviderClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCssProviderClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCssProviderClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCssProviderClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCssProviderClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CssProviderClassProtocol`
    @inlinable init<T: CssProviderClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: CssProviderClass Record: CssProviderClassProtocol extension (methods and fields)
public extension CssProviderClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCssProviderClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkCssProviderClass>! { return ptr?.assumingMemoryBound(to: GtkCssProviderClass.self) }



}



// MARK: - ColorChooser Interface

/// `GtkColorChooser` is an interface that is implemented by widgets
/// for choosing colors.
/// 
/// Depending on the situation, colors may be allowed to have alpha (translucency).
/// 
/// In GTK, the main widgets that implement this interface are
/// [class`Gtk.ColorChooserWidget`], [class`Gtk.ColorChooserDialog`] and
/// [class`Gtk.ColorButton`].
///
/// The `ColorChooserProtocol` protocol exposes the methods and properties of an underlying `GtkColorChooser` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColorChooser`.
/// Alternatively, use `ColorChooserRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ColorChooserProtocol {
        /// Untyped pointer to the underlying `GtkColorChooser` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkColorChooser` instance.
    var color_chooser_ptr: UnsafeMutablePointer<GtkColorChooser>! { get }

    /// Required Initialiser for types conforming to `ColorChooserProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkColorChooser` is an interface that is implemented by widgets
/// for choosing colors.
/// 
/// Depending on the situation, colors may be allowed to have alpha (translucency).
/// 
/// In GTK, the main widgets that implement this interface are
/// [class`Gtk.ColorChooserWidget`], [class`Gtk.ColorChooserDialog`] and
/// [class`Gtk.ColorButton`].
///
/// The `ColorChooserRef` type acts as a lightweight Swift reference to an underlying `GtkColorChooser` instance.
/// It exposes methods that can operate on this data type through `ColorChooserProtocol` conformance.
/// Use `ColorChooserRef` only as an `unowned` reference to an existing `GtkColorChooser` instance.
///
public struct ColorChooserRef: ColorChooserProtocol {
        /// Untyped pointer to the underlying `GtkColorChooser` instance.
    /// For type-safe access, use the generated, typed pointer `color_chooser_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ColorChooserRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkColorChooser>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkColorChooser>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkColorChooser>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkColorChooser>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ColorChooserProtocol`
    @inlinable init<T: ColorChooserProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// `GtkColorChooser` is an interface that is implemented by widgets
/// for choosing colors.
/// 
/// Depending on the situation, colors may be allowed to have alpha (translucency).
/// 
/// In GTK, the main widgets that implement this interface are
/// [class`Gtk.ColorChooserWidget`], [class`Gtk.ColorChooserDialog`] and
/// [class`Gtk.ColorButton`].
///
/// The `ColorChooser` type acts as an owner of an underlying `GtkColorChooser` instance.
/// It provides the methods that can operate on this data type through `ColorChooserProtocol` conformance.
/// Use `ColorChooser` as a strong reference or owner of a `GtkColorChooser` instance.
///
open class ColorChooser: ColorChooserProtocol {
        /// Untyped pointer to the underlying `GtkColorChooser` instance.
    /// For type-safe access, use the generated, typed pointer `color_chooser_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooser` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkColorChooser>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooser` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkColorChooser>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooser` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooser` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooser` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkColorChooser>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooser` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkColorChooser>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GtkColorChooser` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `ColorChooser` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkColorChooser>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GtkColorChooser, cannot ref(color_chooser_ptr)
    }

    /// Reference intialiser for a related type that implements `ColorChooserProtocol`
    /// `GtkColorChooser` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `ColorChooserProtocol`
    @inlinable public init<T: ColorChooserProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GtkColorChooser, cannot ref(color_chooser_ptr)
    }

    /// Do-nothing destructor for `GtkColorChooser`.
    deinit {
        // no reference counting for GtkColorChooser, cannot unref(color_chooser_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GtkColorChooser, cannot ref(color_chooser_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GtkColorChooser, cannot ref(color_chooser_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GtkColorChooser, cannot ref(color_chooser_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GtkColorChooser, cannot ref(color_chooser_ptr)
    }



}

public enum ColorChooserPropertyName: String, PropertyNameProtocol {
    /// The currently selected color, as a `GdkRGBA` struct.
    /// 
    /// The property can be set to change the current selection
    /// programmatically.
    case rgba = "rgba"
    /// Whether colors may have alpha (translucency).
    /// 
    /// When `use-alpha` is `false`, the `GdkRGBA` struct obtained
    /// via the [property`Gtk.ColorChooser:rgba`] property will be
    /// forced to have alpha == 1.
    /// 
    /// Implementations are expected to show alpha by rendering the color
    /// over a non-uniform background (like a checkerboard pattern).
    case useAlpha = "use-alpha"
}

public extension ColorChooserProtocol {
    /// Bind a `ColorChooserPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColorChooserPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ColorChooser property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ColorChooserPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ColorChooser property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ColorChooserPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ColorChooserSignalName: String, SignalNameProtocol {
    /// Emitted when a color is activated from the color chooser.
    /// 
    /// This usually happens when the user clicks a color swatch,
    /// or a color is selected and the user presses one of the keys
    /// Space, Shift+Space, Return or Enter.
    case colorActivated = "color-activated"
    /// The currently selected color, as a `GdkRGBA` struct.
    /// 
    /// The property can be set to change the current selection
    /// programmatically.
    case notifyRgba = "notify::rgba"
    /// Whether colors may have alpha (translucency).
    /// 
    /// When `use-alpha` is `false`, the `GdkRGBA` struct obtained
    /// via the [property`Gtk.ColorChooser:rgba`] property will be
    /// forced to have alpha == 1.
    /// 
    /// Implementations are expected to show alpha by rendering the color
    /// over a non-uniform background (like a checkerboard pattern).
    case notifyUseAlpha = "notify::use-alpha"
}

// MARK: ColorChooser signals
public extension ColorChooserProtocol {
    /// Connect a Swift signal handler to the given, typed `ColorChooserSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ColorChooserSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        GLibObject.ObjectRef(raw: ptr).connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `ColorChooserSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ColorChooserSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        GLibObject.ObjectRef(raw: ptr).connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when a color is activated from the color chooser.
    /// 
    /// This usually happens when the user clicks a color swatch,
    /// or a color is selected and the user presses one of the keys
    /// Space, Shift+Space, Return or Enter.
    /// - Note: This represents the underlying `color-activated` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter color: the color
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `colorActivated` signal is emitted
    @discardableResult @inlinable func onColorActivated(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColorChooserRef, _ color: Gdk.RGBARef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ColorChooserRef, Gdk.RGBARef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ColorChooserRef(raw: unownedSelf), Gdk.RGBARef(raw: arg1)))
            return output
        }
        return connect(
            signal: .colorActivated,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `color-activated` signal for using the `connect(signal:)` methods
    static var colorActivatedSignal: ColorChooserSignalName { .colorActivated }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::rgba` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyRgba` signal is emitted
    @discardableResult @inlinable func onNotifyRgba(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColorChooserRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ColorChooserRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ColorChooserRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyRgba,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::rgba` signal for using the `connect(signal:)` methods
    static var notifyRgbaSignal: ColorChooserSignalName { .notifyRgba }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::use-alpha` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyUseAlpha` signal is emitted
    @discardableResult @inlinable func onNotifyUseAlpha(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColorChooserRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ColorChooserRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ColorChooserRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyUseAlpha,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::use-alpha` signal for using the `connect(signal:)` methods
    static var notifyUseAlphaSignal: ColorChooserSignalName { .notifyUseAlpha }
    
}

// MARK: ColorChooser Interface: ColorChooserProtocol extension (methods and fields)
public extension ColorChooserProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColorChooser` instance.
    @inlinable var color_chooser_ptr: UnsafeMutablePointer<GtkColorChooser>! { return ptr?.assumingMemoryBound(to: GtkColorChooser.self) }

    /// Adds a palette to the color chooser.
    /// 
    /// If `orientation` is horizontal, the colors are grouped in rows,
    /// with `colors_per_line` colors in each row. If `horizontal` is `false`,
    /// the colors are grouped in columns instead.
    /// 
    /// The default color palette of [class`Gtk.ColorChooserWidget`] has
    /// 45 colors, organized in columns of 5 colors (this includes some
    /// grays).
    /// 
    /// The layout of the color chooser widget works best when the
    /// palettes have 9-10 columns.
    /// 
    /// Calling this function for the first time has the side effect
    /// of removing the default color palette from the color chooser.
    /// 
    /// If `colors` is `nil`, removes all previously added palettes.
    @inlinable func addPalette(orientation: GtkOrientation, colorsPerLine: Int, nColors: Int, colors: UnsafeMutablePointer<GdkRGBA>! = nil) {
        
        gtk_color_chooser_add_palette(color_chooser_ptr, orientation, gint(colorsPerLine), gint(nColors), colors)
        
    }

    /// Gets the currently-selected color.
    @inlinable func getRgba<GdkRGBAT: Gdk.RGBAProtocol>(color: GdkRGBAT) {
        
        gtk_color_chooser_get_rgba(color_chooser_ptr, color.rgba_ptr)
        
    }

    /// Returns whether the color chooser shows the alpha channel.
    @inlinable func getUseAlpha() -> Bool {
        let result = gtk_color_chooser_get_use_alpha(color_chooser_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Sets the color.
    @inlinable func setRgba<GdkRGBAT: Gdk.RGBAProtocol>(color: GdkRGBAT) {
        
        gtk_color_chooser_set_rgba(color_chooser_ptr, color.rgba_ptr)
        
    }

    /// Sets whether or not the color chooser should use the alpha channel.
    @inlinable func set(useAlpha: Bool) {
        
        gtk_color_chooser_set_use_alpha(color_chooser_ptr, gboolean((useAlpha) ? 1 : 0))
        
    }
    /// Returns whether the color chooser shows the alpha channel.
    @inlinable var useAlpha: Bool {
        /// Returns whether the color chooser shows the alpha channel.
        get {
            let result = gtk_color_chooser_get_use_alpha(color_chooser_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether or not the color chooser should use the alpha channel.
        nonmutating set {
            gtk_color_chooser_set_use_alpha(color_chooser_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - ConstraintTarget Interface

/// The `GtkConstraintTarget` interface is implemented by objects that
/// can be used as source or target in `GtkConstraint`s.
/// 
/// Besides `GtkWidget`, it is also implemented by `GtkConstraintGuide`.
///
/// The `ConstraintTargetProtocol` protocol exposes the methods and properties of an underlying `GtkConstraintTarget` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ConstraintTarget`.
/// Alternatively, use `ConstraintTargetRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ConstraintTargetProtocol {
        /// Untyped pointer to the underlying `GtkConstraintTarget` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstraintTarget` instance.
    var constraint_target_ptr: UnsafeMutablePointer<GtkConstraintTarget>! { get }

    /// Required Initialiser for types conforming to `ConstraintTargetProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `GtkConstraintTarget` interface is implemented by objects that
/// can be used as source or target in `GtkConstraint`s.
/// 
/// Besides `GtkWidget`, it is also implemented by `GtkConstraintGuide`.
///
/// The `ConstraintTargetRef` type acts as a lightweight Swift reference to an underlying `GtkConstraintTarget` instance.
/// It exposes methods that can operate on this data type through `ConstraintTargetProtocol` conformance.
/// Use `ConstraintTargetRef` only as an `unowned` reference to an existing `GtkConstraintTarget` instance.
///
public struct ConstraintTargetRef: ConstraintTargetProtocol {
        /// Untyped pointer to the underlying `GtkConstraintTarget` instance.
    /// For type-safe access, use the generated, typed pointer `constraint_target_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstraintTargetRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstraintTarget>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstraintTarget>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstraintTarget>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstraintTarget>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstraintTargetProtocol`
    @inlinable init<T: ConstraintTargetProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintTargetProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintTargetProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintTargetProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintTargetProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintTargetProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `GtkConstraintTarget` interface is implemented by objects that
/// can be used as source or target in `GtkConstraint`s.
/// 
/// Besides `GtkWidget`, it is also implemented by `GtkConstraintGuide`.
///
/// The `ConstraintTarget` type acts as an owner of an underlying `GtkConstraintTarget` instance.
/// It provides the methods that can operate on this data type through `ConstraintTargetProtocol` conformance.
/// Use `ConstraintTarget` as a strong reference or owner of a `GtkConstraintTarget` instance.
///
open class ConstraintTarget: ConstraintTargetProtocol {
        /// Untyped pointer to the underlying `GtkConstraintTarget` instance.
    /// For type-safe access, use the generated, typed pointer `constraint_target_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintTarget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkConstraintTarget>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintTarget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkConstraintTarget>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintTarget` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintTarget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintTarget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkConstraintTarget>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintTarget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkConstraintTarget>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GtkConstraintTarget` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `ConstraintTarget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkConstraintTarget>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GtkConstraintTarget, cannot ref(constraint_target_ptr)
    }

    /// Reference intialiser for a related type that implements `ConstraintTargetProtocol`
    /// `GtkConstraintTarget` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `ConstraintTargetProtocol`
    @inlinable public init<T: ConstraintTargetProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GtkConstraintTarget, cannot ref(constraint_target_ptr)
    }

    /// Do-nothing destructor for `GtkConstraintTarget`.
    deinit {
        // no reference counting for GtkConstraintTarget, cannot unref(constraint_target_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintTargetProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintTargetProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GtkConstraintTarget, cannot ref(constraint_target_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintTargetProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintTargetProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GtkConstraintTarget, cannot ref(constraint_target_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintTargetProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintTargetProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GtkConstraintTarget, cannot ref(constraint_target_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintTargetProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintTargetProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GtkConstraintTarget, cannot ref(constraint_target_ptr)
    }



}

// MARK: no ConstraintTarget properties

// MARK: no ConstraintTarget signals

// MARK: ConstraintTarget has no signals
// MARK: ConstraintTarget Interface: ConstraintTargetProtocol extension (methods and fields)
public extension ConstraintTargetProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstraintTarget` instance.
    @inlinable var constraint_target_ptr: UnsafeMutablePointer<GtkConstraintTarget>! { return ptr?.assumingMemoryBound(to: GtkConstraintTarget.self) }



}



// MARK: - CssSection Record

/// Defines a part of a CSS document.
/// 
/// Because sections are nested into one another, you can use
/// [method`CssSection.get_parent`] to get the containing region.
///
/// The `CssSectionProtocol` protocol exposes the methods and properties of an underlying `GtkCssSection` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CssSection`.
/// Alternatively, use `CssSectionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CssSectionProtocol {
        /// Untyped pointer to the underlying `GtkCssSection` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCssSection` instance.
    var css_section_ptr: UnsafeMutablePointer<GtkCssSection>! { get }

    /// Required Initialiser for types conforming to `CssSectionProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Defines a part of a CSS document.
/// 
/// Because sections are nested into one another, you can use
/// [method`CssSection.get_parent`] to get the containing region.
///
/// The `CssSectionRef` type acts as a lightweight Swift reference to an underlying `GtkCssSection` instance.
/// It exposes methods that can operate on this data type through `CssSectionProtocol` conformance.
/// Use `CssSectionRef` only as an `unowned` reference to an existing `GtkCssSection` instance.
///
public struct CssSectionRef: CssSectionProtocol {
        /// Untyped pointer to the underlying `GtkCssSection` instance.
    /// For type-safe access, use the generated, typed pointer `css_section_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CssSectionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCssSection>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCssSection>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCssSection>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCssSection>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CssSectionProtocol`
    @inlinable init<T: CssSectionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssSectionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssSectionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssSectionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssSectionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssSectionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCssSection` referring to the section
    /// in the given `file` from the `start` location to the
    /// `end` location.
    @inlinable init<CssLocationT: CssLocationProtocol, GIOFileT: GIO.FileProtocol>( file: GIOFileT?, start: CssLocationT, end: CssLocationT) {
            let result = gtk_css_section_new(file?.file_ptr, start._ptr, end._ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// Defines a part of a CSS document.
/// 
/// Because sections are nested into one another, you can use
/// [method`CssSection.get_parent`] to get the containing region.
///
/// The `CssSection` type acts as a reference-counted owner of an underlying `GtkCssSection` instance.
/// It provides the methods that can operate on this data type through `CssSectionProtocol` conformance.
/// Use `CssSection` as a strong reference or owner of a `GtkCssSection` instance.
///
open class CssSection: CssSectionProtocol {
        /// Untyped pointer to the underlying `GtkCssSection` instance.
    /// For type-safe access, use the generated, typed pointer `css_section_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssSection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCssSection>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssSection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCssSection>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssSection` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssSection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssSection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCssSection>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssSection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCssSection>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCssSection`.
    /// i.e., ownership is transferred to the `CssSection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCssSection>) {
        ptr = UnsafeMutableRawPointer(op)
        gtk_css_section_ref(ptr.assumingMemoryBound(to: GtkCssSection.self))
    }

    /// Reference intialiser for a related type that implements `CssSectionProtocol`
    /// Will retain `GtkCssSection`.
    /// - Parameter other: an instance of a related type that implements `CssSectionProtocol`
    @inlinable public init<T: CssSectionProtocol>(_ other: T) {
        ptr = other.ptr
        gtk_css_section_ref(ptr.assumingMemoryBound(to: GtkCssSection.self))
    }

    /// Releases the underlying `GtkCssSection` instance using `gtk_css_section_unref`.
    deinit {
        gtk_css_section_unref(ptr.assumingMemoryBound(to: GtkCssSection.self))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssSectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssSectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        gtk_css_section_ref(ptr.assumingMemoryBound(to: GtkCssSection.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssSectionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssSectionProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        gtk_css_section_ref(ptr.assumingMemoryBound(to: GtkCssSection.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssSectionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssSectionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        gtk_css_section_ref(ptr.assumingMemoryBound(to: GtkCssSection.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssSectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssSectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        gtk_css_section_ref(ptr.assumingMemoryBound(to: GtkCssSection.self))
    }

    /// Creates a new `GtkCssSection` referring to the section
    /// in the given `file` from the `start` location to the
    /// `end` location.
    @inlinable public init<CssLocationT: CssLocationProtocol, GIOFileT: GIO.FileProtocol>( file: GIOFileT?, start: CssLocationT, end: CssLocationT) {
            let result = gtk_css_section_new(file?.file_ptr, start._ptr, end._ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }


}

// MARK: no CssSection properties

// MARK: no CssSection signals

// MARK: CssSection has no signals
// MARK: CssSection Record: CssSectionProtocol extension (methods and fields)
public extension CssSectionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCssSection` instance.
    @inlinable var css_section_ptr: UnsafeMutablePointer<GtkCssSection>! { return ptr?.assumingMemoryBound(to: GtkCssSection.self) }

    /// Returns the location in the CSS document where this section ends.
    @inlinable func getEndLocation() -> CssLocationRef! {
        let result = gtk_css_section_get_end_location(css_section_ptr)
        let rv = CssLocationRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the file that `section` was parsed from.
    /// 
    /// If no such file exists, for example because the CSS was loaded via
    /// [method`Gtk.CssProvider.load_from_data`], then `NULL` is returned.
    @inlinable func getFile() -> GIO.FileRef! {
        let result = gtk_css_section_get_file(css_section_ptr)
        let rv = GIO.FileRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the parent section for the given `section`.
    /// 
    /// The parent section is the section that contains this `section`. A special
    /// case are sections of  type `GTK_CSS_SECTION_DOCUMEN`T. Their parent will
    /// either be `NULL` if they are the original CSS document that was loaded by
    /// [method`Gtk.CssProvider.load_from_file`] or a section of type
    /// `GTK_CSS_SECTION_IMPORT` if it was loaded with an ``import`` rule from
    /// a different file.
    @inlinable func getParent() -> CssSectionRef! {
        let result = gtk_css_section_get_parent(css_section_ptr)
        guard let rv = CssSectionRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Returns the location in the CSS document where this section starts.
    @inlinable func getStartLocation() -> CssLocationRef! {
        let result = gtk_css_section_get_start_location(css_section_ptr)
        let rv = CssLocationRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Prints the `section` into `string` in a human-readable form.
    /// 
    /// This is a form like `gtk.css:32:1-23` to denote line 32, characters
    /// 1 to 23 in the file `gtk.css`.
    @inlinable func print<GLibStringTypeT: GLib.StringProtocol>(string: GLibStringTypeT) {
        
        gtk_css_section_print(css_section_ptr, string.gstring_ptr)
        
    }

    /// Increments the reference count on `section`.
    @discardableResult @inlinable func ref() -> CssSectionRef! {
        let result = gtk_css_section_ref(css_section_ptr)
        guard let rv = CssSectionRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Prints the section into a human-readable text form using
    /// [method`Gtk.CssSection.print`].
    @inlinable func toString() -> String! {
        let result = gtk_css_section_to_string(css_section_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Decrements the reference count on `section`, freeing the
    /// structure if the reference count reaches 0.
    @inlinable func unref() {
        
        gtk_css_section_unref(css_section_ptr)
        
    }
    /// Returns the location in the CSS document where this section ends.
    @inlinable var endLocation: CssLocationRef! {
        /// Returns the location in the CSS document where this section ends.
        get {
            let result = gtk_css_section_get_end_location(css_section_ptr)
        let rv = CssLocationRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Gets the file that `section` was parsed from.
    /// 
    /// If no such file exists, for example because the CSS was loaded via
    /// [method`Gtk.CssProvider.load_from_data`], then `NULL` is returned.
    @inlinable var file: GIO.FileRef! {
        /// Gets the file that `section` was parsed from.
        /// 
        /// If no such file exists, for example because the CSS was loaded via
        /// [method`Gtk.CssProvider.load_from_data`], then `NULL` is returned.
        get {
            let result = gtk_css_section_get_file(css_section_ptr)
        let rv = GIO.FileRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Gets the parent section for the given `section`.
    /// 
    /// The parent section is the section that contains this `section`. A special
    /// case are sections of  type `GTK_CSS_SECTION_DOCUMEN`T. Their parent will
    /// either be `NULL` if they are the original CSS document that was loaded by
    /// [method`Gtk.CssProvider.load_from_file`] or a section of type
    /// `GTK_CSS_SECTION_IMPORT` if it was loaded with an ``import`` rule from
    /// a different file.
    @inlinable var parent: CssSectionRef! {
        /// Gets the parent section for the given `section`.
        /// 
        /// The parent section is the section that contains this `section`. A special
        /// case are sections of  type `GTK_CSS_SECTION_DOCUMEN`T. Their parent will
        /// either be `NULL` if they are the original CSS document that was loaded by
        /// [method`Gtk.CssProvider.load_from_file`] or a section of type
        /// `GTK_CSS_SECTION_IMPORT` if it was loaded with an ``import`` rule from
        /// a different file.
        get {
            let result = gtk_css_section_get_parent(css_section_ptr)
        guard let rv = CssSectionRef(gconstpointer: gconstpointer(result)) else { return nil }
            return rv
        }
    }

    /// Returns the location in the CSS document where this section starts.
    @inlinable var startLocation: CssLocationRef! {
        /// Returns the location in the CSS document where this section starts.
        get {
            let result = gtk_css_section_get_start_location(css_section_ptr)
        let rv = CssLocationRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }


}



// MARK: - CssStyleChange Record


///
/// The `CssStyleChangeProtocol` protocol exposes the methods and properties of an underlying `GtkCssStyleChange` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CssStyleChange`.
/// Alternatively, use `CssStyleChangeRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CssStyleChangeProtocol {
        /// Untyped pointer to the underlying `GtkCssStyleChange` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCssStyleChange` instance.
    var _ptr: UnsafeMutablePointer<GtkCssStyleChange>! { get }

    /// Required Initialiser for types conforming to `CssStyleChangeProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `CssStyleChangeRef` type acts as a lightweight Swift reference to an underlying `GtkCssStyleChange` instance.
/// It exposes methods that can operate on this data type through `CssStyleChangeProtocol` conformance.
/// Use `CssStyleChangeRef` only as an `unowned` reference to an existing `GtkCssStyleChange` instance.
///
public struct CssStyleChangeRef: CssStyleChangeProtocol {
        /// Untyped pointer to the underlying `GtkCssStyleChange` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CssStyleChangeRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCssStyleChange>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCssStyleChange>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCssStyleChange>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCssStyleChange>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CssStyleChangeProtocol`
    @inlinable init<T: CssStyleChangeProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssStyleChangeProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssStyleChangeProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssStyleChangeProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssStyleChangeProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssStyleChangeProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }


///
/// The `CssStyleChange` type acts as an owner of an underlying `GtkCssStyleChange` instance.
/// It provides the methods that can operate on this data type through `CssStyleChangeProtocol` conformance.
/// Use `CssStyleChange` as a strong reference or owner of a `GtkCssStyleChange` instance.
///
open class CssStyleChange: CssStyleChangeProtocol {
        /// Untyped pointer to the underlying `GtkCssStyleChange` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssStyleChange` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCssStyleChange>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssStyleChange` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCssStyleChange>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssStyleChange` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssStyleChange` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssStyleChange` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCssStyleChange>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssStyleChange` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCssStyleChange>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GtkCssStyleChange` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `CssStyleChange` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCssStyleChange>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GtkCssStyleChange, cannot ref(_ptr)
    }

    /// Reference intialiser for a related type that implements `CssStyleChangeProtocol`
    /// `GtkCssStyleChange` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `CssStyleChangeProtocol`
    @inlinable public init<T: CssStyleChangeProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GtkCssStyleChange, cannot ref(_ptr)
    }

    /// Do-nothing destructor for `GtkCssStyleChange`.
    deinit {
        // no reference counting for GtkCssStyleChange, cannot unref(_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssStyleChangeProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssStyleChangeProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GtkCssStyleChange, cannot ref(_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssStyleChangeProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssStyleChangeProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GtkCssStyleChange, cannot ref(_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssStyleChangeProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssStyleChangeProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GtkCssStyleChange, cannot ref(_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssStyleChangeProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssStyleChangeProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GtkCssStyleChange, cannot ref(_ptr)
    }



}

// MARK: no CssStyleChange properties

// MARK: no CssStyleChange signals

// MARK: CssStyleChange has no signals
// MARK: CssStyleChange Record: CssStyleChangeProtocol extension (methods and fields)
public extension CssStyleChangeProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCssStyleChange` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkCssStyleChange>! { return ptr?.assumingMemoryBound(to: GtkCssStyleChange.self) }



}



/// Metatype/GType declaration for CustomFilter
public extension CustomFilterClassRef {
    
    /// This getter returns the GLib type identifier registered for `CustomFilter`
    static var metatypeReference: GType { gtk_custom_filter_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkCustomFilterClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkCustomFilterClass.self) }
    
    static var metatype: GtkCustomFilterClass? { metatypePointer?.pointee } 
    
    static var wrapper: CustomFilterClassRef? { CustomFilterClassRef(metatypePointer) }
    
    
}

// MARK: - CustomFilterClass Record


///
/// The `CustomFilterClassProtocol` protocol exposes the methods and properties of an underlying `GtkCustomFilterClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CustomFilterClass`.
/// Alternatively, use `CustomFilterClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CustomFilterClassProtocol {
        /// Untyped pointer to the underlying `GtkCustomFilterClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCustomFilterClass` instance.
    var _ptr: UnsafeMutablePointer<GtkCustomFilterClass>! { get }

    /// Required Initialiser for types conforming to `CustomFilterClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `CustomFilterClassRef` type acts as a lightweight Swift reference to an underlying `GtkCustomFilterClass` instance.
/// It exposes methods that can operate on this data type through `CustomFilterClassProtocol` conformance.
/// Use `CustomFilterClassRef` only as an `unowned` reference to an existing `GtkCustomFilterClass` instance.
///
public struct CustomFilterClassRef: CustomFilterClassProtocol {
        /// Untyped pointer to the underlying `GtkCustomFilterClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CustomFilterClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCustomFilterClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCustomFilterClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCustomFilterClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCustomFilterClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CustomFilterClassProtocol`
    @inlinable init<T: CustomFilterClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: CustomFilterClass Record: CustomFilterClassProtocol extension (methods and fields)
public extension CustomFilterClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCustomFilterClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkCustomFilterClass>! { return ptr?.assumingMemoryBound(to: GtkCustomFilterClass.self) }


    @inlinable var parentClass: GtkFilterClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

}



/// Metatype/GType declaration for CustomLayout
public extension CustomLayoutClassRef {
    
    /// This getter returns the GLib type identifier registered for `CustomLayout`
    static var metatypeReference: GType { gtk_custom_layout_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkCustomLayoutClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkCustomLayoutClass.self) }
    
    static var metatype: GtkCustomLayoutClass? { metatypePointer?.pointee } 
    
    static var wrapper: CustomLayoutClassRef? { CustomLayoutClassRef(metatypePointer) }
    
    
}

// MARK: - CustomLayoutClass Record


///
/// The `CustomLayoutClassProtocol` protocol exposes the methods and properties of an underlying `GtkCustomLayoutClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CustomLayoutClass`.
/// Alternatively, use `CustomLayoutClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CustomLayoutClassProtocol {
        /// Untyped pointer to the underlying `GtkCustomLayoutClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCustomLayoutClass` instance.
    var _ptr: UnsafeMutablePointer<GtkCustomLayoutClass>! { get }

    /// Required Initialiser for types conforming to `CustomLayoutClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `CustomLayoutClassRef` type acts as a lightweight Swift reference to an underlying `GtkCustomLayoutClass` instance.
/// It exposes methods that can operate on this data type through `CustomLayoutClassProtocol` conformance.
/// Use `CustomLayoutClassRef` only as an `unowned` reference to an existing `GtkCustomLayoutClass` instance.
///
public struct CustomLayoutClassRef: CustomLayoutClassProtocol {
        /// Untyped pointer to the underlying `GtkCustomLayoutClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CustomLayoutClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCustomLayoutClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCustomLayoutClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCustomLayoutClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCustomLayoutClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CustomLayoutClassProtocol`
    @inlinable init<T: CustomLayoutClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: CustomLayoutClass Record: CustomLayoutClassProtocol extension (methods and fields)
public extension CustomLayoutClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCustomLayoutClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkCustomLayoutClass>! { return ptr?.assumingMemoryBound(to: GtkCustomLayoutClass.self) }


    @inlinable var parentClass: GtkLayoutManagerClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

}



/// Metatype/GType declaration for CustomSorter
public extension CustomSorterClassRef {
    
    /// This getter returns the GLib type identifier registered for `CustomSorter`
    static var metatypeReference: GType { gtk_custom_sorter_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkCustomSorterClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkCustomSorterClass.self) }
    
    static var metatype: GtkCustomSorterClass? { metatypePointer?.pointee } 
    
    static var wrapper: CustomSorterClassRef? { CustomSorterClassRef(metatypePointer) }
    
    
}

// MARK: - CustomSorterClass Record


///
/// The `CustomSorterClassProtocol` protocol exposes the methods and properties of an underlying `GtkCustomSorterClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CustomSorterClass`.
/// Alternatively, use `CustomSorterClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CustomSorterClassProtocol {
        /// Untyped pointer to the underlying `GtkCustomSorterClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCustomSorterClass` instance.
    var _ptr: UnsafeMutablePointer<GtkCustomSorterClass>! { get }

    /// Required Initialiser for types conforming to `CustomSorterClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `CustomSorterClassRef` type acts as a lightweight Swift reference to an underlying `GtkCustomSorterClass` instance.
/// It exposes methods that can operate on this data type through `CustomSorterClassProtocol` conformance.
/// Use `CustomSorterClassRef` only as an `unowned` reference to an existing `GtkCustomSorterClass` instance.
///
public struct CustomSorterClassRef: CustomSorterClassProtocol {
        /// Untyped pointer to the underlying `GtkCustomSorterClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CustomSorterClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCustomSorterClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCustomSorterClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCustomSorterClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCustomSorterClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CustomSorterClassProtocol`
    @inlinable init<T: CustomSorterClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: CustomSorterClass Record: CustomSorterClassProtocol extension (methods and fields)
public extension CustomSorterClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCustomSorterClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkCustomSorterClass>! { return ptr?.assumingMemoryBound(to: GtkCustomSorterClass.self) }


    @inlinable var parentClass: GtkSorterClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

}



// MARK: - CClosureExpression Class

/// A variant of `GtkClosureExpression` using a C closure.
///
/// The `CClosureExpressionProtocol` protocol exposes the methods and properties of an underlying `GtkCClosureExpression` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CClosureExpression`.
/// Alternatively, use `CClosureExpressionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CClosureExpressionProtocol: ExpressionProtocol {
        /// Untyped pointer to the underlying `GtkCClosureExpression` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCClosureExpression` instance.
    var cclosure_expression_ptr: UnsafeMutablePointer<GtkCClosureExpression>! { get }

    /// Required Initialiser for types conforming to `CClosureExpressionProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A variant of `GtkClosureExpression` using a C closure.
///
/// The `CClosureExpressionRef` type acts as a lightweight Swift reference to an underlying `GtkCClosureExpression` instance.
/// It exposes methods that can operate on this data type through `CClosureExpressionProtocol` conformance.
/// Use `CClosureExpressionRef` only as an `unowned` reference to an existing `GtkCClosureExpression` instance.
///
public struct CClosureExpressionRef: CClosureExpressionProtocol {
        /// Untyped pointer to the underlying `GtkCClosureExpression` instance.
    /// For type-safe access, use the generated, typed pointer `cclosure_expression_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CClosureExpressionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCClosureExpression>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCClosureExpression>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCClosureExpression>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCClosureExpression>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CClosureExpressionProtocol`
    @inlinable init<T: CClosureExpressionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CClosureExpressionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CClosureExpressionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CClosureExpressionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CClosureExpressionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CClosureExpressionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// A variant of `GtkClosureExpression` using a C closure.
///
/// The `CClosureExpression` type acts as a reference-counted owner of an underlying `GtkCClosureExpression` instance.
/// It provides the methods that can operate on this data type through `CClosureExpressionProtocol` conformance.
/// Use `CClosureExpression` as a strong reference or owner of a `GtkCClosureExpression` instance.
///
open class CClosureExpression: Expression, CClosureExpressionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCClosureExpression>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCClosureExpression>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CClosureExpression` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCClosureExpression>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCClosureExpression>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCClosureExpression`.
    /// i.e., ownership is transferred to the `CClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCClosureExpression>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CClosureExpressionProtocol`
    /// Will retain `GtkCClosureExpression`.
    /// - Parameter other: an instance of a related type that implements `CClosureExpressionProtocol`
    @inlinable public init<T: CClosureExpressionProtocol>(cClosureExpression other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CClosureExpressionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CClosureExpressionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CClosureExpressionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CClosureExpressionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CClosureExpressionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CClosureExpressionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CClosureExpressionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CClosureExpressionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

// MARK: no CClosureExpression properties

// MARK: no CClosureExpression signals

// MARK: CClosureExpression has no signals
// MARK: CClosureExpression Class: CClosureExpressionProtocol extension (methods and fields)
public extension CClosureExpressionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCClosureExpression` instance.
    @inlinable var cclosure_expression_ptr: UnsafeMutablePointer<GtkCClosureExpression>! { return ptr?.assumingMemoryBound(to: GtkCClosureExpression.self) }



}



// MARK: - Calendar Class

/// `GtkCalendar` is a widget that displays a Gregorian calendar, one month
/// at a time.
/// 
/// ![An example GtkCalendar](calendar.png)
/// 
/// A `GtkCalendar` can be created with [ctor`Gtk.Calendar.new`].
/// 
/// The date that is currently displayed can be altered with
/// [method`Gtk.Calendar.select_day`].
/// 
/// To place a visual marker on a particular day, use
/// [method`Gtk.Calendar.mark_day`] and to remove the marker,
/// [method`Gtk.Calendar.unmark_day`]. Alternative, all
/// marks can be cleared with [method`Gtk.Calendar.clear_marks`].
/// 
/// The selected date can be retrieved from a `GtkCalendar` using
/// [method`Gtk.Calendar.get_date`].
/// 
/// Users should be aware that, although the Gregorian calendar is the
/// legal calendar in most countries, it was adopted progressively
/// between 1582 and 1929. Display before these dates is likely to be
/// historically incorrect.
/// 
/// # CSS nodes
/// 
/// ```
/// calendar.view
/// ├── header
/// │   ├── button
/// │   ├── stack.month
/// │   ├── button
/// │   ├── button
/// │   ├── label.year
/// │   ╰── button
/// ╰── grid
///     ╰── label[.day-name][.week-number][.day-number][.other-month][.today]
/// ```
/// 
/// `GtkCalendar` has a main node with name calendar. It contains a subnode
/// called header containing the widgets for switching between years and months.
/// 
/// The grid subnode contains all day labels, including week numbers on the left
/// (marked with the .week-number css class) and day names on top (marked with the
/// .day-name css class).
/// 
/// Day labels that belong to the previous or next month get the .other-month
/// style class. The label of the current day get the .today style class.
/// 
/// Marked day labels get the :selected state assigned.
///
/// The `CalendarProtocol` protocol exposes the methods and properties of an underlying `GtkCalendar` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Calendar`.
/// Alternatively, use `CalendarRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CalendarProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkCalendar` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCalendar` instance.
    var calendar_ptr: UnsafeMutablePointer<GtkCalendar>! { get }

    /// Required Initialiser for types conforming to `CalendarProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkCalendar` is a widget that displays a Gregorian calendar, one month
/// at a time.
/// 
/// ![An example GtkCalendar](calendar.png)
/// 
/// A `GtkCalendar` can be created with [ctor`Gtk.Calendar.new`].
/// 
/// The date that is currently displayed can be altered with
/// [method`Gtk.Calendar.select_day`].
/// 
/// To place a visual marker on a particular day, use
/// [method`Gtk.Calendar.mark_day`] and to remove the marker,
/// [method`Gtk.Calendar.unmark_day`]. Alternative, all
/// marks can be cleared with [method`Gtk.Calendar.clear_marks`].
/// 
/// The selected date can be retrieved from a `GtkCalendar` using
/// [method`Gtk.Calendar.get_date`].
/// 
/// Users should be aware that, although the Gregorian calendar is the
/// legal calendar in most countries, it was adopted progressively
/// between 1582 and 1929. Display before these dates is likely to be
/// historically incorrect.
/// 
/// # CSS nodes
/// 
/// ```
/// calendar.view
/// ├── header
/// │   ├── button
/// │   ├── stack.month
/// │   ├── button
/// │   ├── button
/// │   ├── label.year
/// │   ╰── button
/// ╰── grid
///     ╰── label[.day-name][.week-number][.day-number][.other-month][.today]
/// ```
/// 
/// `GtkCalendar` has a main node with name calendar. It contains a subnode
/// called header containing the widgets for switching between years and months.
/// 
/// The grid subnode contains all day labels, including week numbers on the left
/// (marked with the .week-number css class) and day names on top (marked with the
/// .day-name css class).
/// 
/// Day labels that belong to the previous or next month get the .other-month
/// style class. The label of the current day get the .today style class.
/// 
/// Marked day labels get the :selected state assigned.
///
/// The `CalendarRef` type acts as a lightweight Swift reference to an underlying `GtkCalendar` instance.
/// It exposes methods that can operate on this data type through `CalendarProtocol` conformance.
/// Use `CalendarRef` only as an `unowned` reference to an existing `GtkCalendar` instance.
///
public struct CalendarRef: CalendarProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCalendar` instance.
    /// For type-safe access, use the generated, typed pointer `calendar_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CalendarRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCalendar>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCalendar>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCalendar>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCalendar>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CalendarProtocol`
    @inlinable init<T: CalendarProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CalendarProtocol>(_ other: T) -> CalendarRef { CalendarRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new calendar, with the current date being selected.
    @inlinable init() {
            let result = gtk_calendar_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkCalendar` is a widget that displays a Gregorian calendar, one month
/// at a time.
/// 
/// ![An example GtkCalendar](calendar.png)
/// 
/// A `GtkCalendar` can be created with [ctor`Gtk.Calendar.new`].
/// 
/// The date that is currently displayed can be altered with
/// [method`Gtk.Calendar.select_day`].
/// 
/// To place a visual marker on a particular day, use
/// [method`Gtk.Calendar.mark_day`] and to remove the marker,
/// [method`Gtk.Calendar.unmark_day`]. Alternative, all
/// marks can be cleared with [method`Gtk.Calendar.clear_marks`].
/// 
/// The selected date can be retrieved from a `GtkCalendar` using
/// [method`Gtk.Calendar.get_date`].
/// 
/// Users should be aware that, although the Gregorian calendar is the
/// legal calendar in most countries, it was adopted progressively
/// between 1582 and 1929. Display before these dates is likely to be
/// historically incorrect.
/// 
/// # CSS nodes
/// 
/// ```
/// calendar.view
/// ├── header
/// │   ├── button
/// │   ├── stack.month
/// │   ├── button
/// │   ├── button
/// │   ├── label.year
/// │   ╰── button
/// ╰── grid
///     ╰── label[.day-name][.week-number][.day-number][.other-month][.today]
/// ```
/// 
/// `GtkCalendar` has a main node with name calendar. It contains a subnode
/// called header containing the widgets for switching between years and months.
/// 
/// The grid subnode contains all day labels, including week numbers on the left
/// (marked with the .week-number css class) and day names on top (marked with the
/// .day-name css class).
/// 
/// Day labels that belong to the previous or next month get the .other-month
/// style class. The label of the current day get the .today style class.
/// 
/// Marked day labels get the :selected state assigned.
///
/// The `Calendar` type acts as a reference-counted owner of an underlying `GtkCalendar` instance.
/// It provides the methods that can operate on this data type through `CalendarProtocol` conformance.
/// Use `Calendar` as a strong reference or owner of a `GtkCalendar` instance.
///
open class Calendar: Widget, CalendarProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCalendar>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCalendar>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCalendar>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCalendar>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCalendar`.
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCalendar>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CalendarProtocol`
    /// Will retain `GtkCalendar`.
    /// - Parameter other: an instance of a related type that implements `CalendarProtocol`
    @inlinable public init<T: CalendarProtocol>(calendar other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new calendar, with the current date being selected.
    @inlinable public init() {
            let result = gtk_calendar_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CalendarPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// The selected day (as a number between 1 and 31).
    case day = "day"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The selected month (as a number between 0 and 11).
    /// 
    /// This property gets initially set to the current month.
    case month = "month"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Determines whether day names are displayed.
    case showDayNames = "show-day-names"
    /// Determines whether a heading is displayed.
    case showHeading = "show-heading"
    /// Determines whether week numbers are displayed.
    case showWeekNumbers = "show-week-numbers"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
    /// The selected year.
    /// 
    /// This property gets initially set to the current year.
    case year = "year"
}

public extension CalendarProtocol {
    /// Bind a `CalendarPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CalendarPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Calendar property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CalendarPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Calendar property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CalendarPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CalendarSignalName: String, SignalNameProtocol {
    /// Emitted when the user selects a day.
    case daySelected = "day-selected"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// Emitted when the user switched to the next month.
    case nextMonth = "next-month"
    /// Emitted when user switched to the next year.
    case nextYear = "next-year"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the user switched to the previous month.
    case prevMonth = "prev-month"
    /// Emitted when user switched to the previous year.
    case prevYear = "prev-year"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// The selected day (as a number between 1 and 31).
    case notifyDay = "notify::day"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The selected month (as a number between 0 and 11).
    /// 
    /// This property gets initially set to the current month.
    case notifyMonth = "notify::month"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Determines whether day names are displayed.
    case notifyShowDayNames = "notify::show-day-names"
    /// Determines whether a heading is displayed.
    case notifyShowHeading = "notify::show-heading"
    /// Determines whether week numbers are displayed.
    case notifyShowWeekNumbers = "notify::show-week-numbers"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
    /// The selected year.
    /// 
    /// This property gets initially set to the current year.
    case notifyYear = "notify::year"
}

// MARK: Calendar signals
public extension CalendarProtocol {
    /// Connect a Swift signal handler to the given, typed `CalendarSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CalendarSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `CalendarSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CalendarSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when the user selects a day.
    /// - Note: This represents the underlying `day-selected` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `daySelected` signal is emitted
    @discardableResult @inlinable func onDaySelected(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CalendarRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CalendarRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .daySelected,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `day-selected` signal for using the `connect(signal:)` methods
    static var daySelectedSignal: CalendarSignalName { .daySelected }
    
    /// Emitted when the user switched to the next month.
    /// - Note: This represents the underlying `next-month` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `nextMonth` signal is emitted
    @discardableResult @inlinable func onNextMonth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CalendarRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CalendarRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .nextMonth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `next-month` signal for using the `connect(signal:)` methods
    static var nextMonthSignal: CalendarSignalName { .nextMonth }
    
    /// Emitted when user switched to the next year.
    /// - Note: This represents the underlying `next-year` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `nextYear` signal is emitted
    @discardableResult @inlinable func onNextYear(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CalendarRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CalendarRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .nextYear,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `next-year` signal for using the `connect(signal:)` methods
    static var nextYearSignal: CalendarSignalName { .nextYear }
    
    /// Emitted when the user switched to the previous month.
    /// - Note: This represents the underlying `prev-month` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `prevMonth` signal is emitted
    @discardableResult @inlinable func onPrevMonth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CalendarRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CalendarRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .prevMonth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `prev-month` signal for using the `connect(signal:)` methods
    static var prevMonthSignal: CalendarSignalName { .prevMonth }
    
    /// Emitted when user switched to the previous year.
    /// - Note: This represents the underlying `prev-year` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `prevYear` signal is emitted
    @discardableResult @inlinable func onPrevYear(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CalendarRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CalendarRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .prevYear,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `prev-year` signal for using the `connect(signal:)` methods
    static var prevYearSignal: CalendarSignalName { .prevYear }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::day` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyDay` signal is emitted
    @discardableResult @inlinable func onNotifyDay(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CalendarRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CalendarRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyDay,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::day` signal for using the `connect(signal:)` methods
    static var notifyDaySignal: CalendarSignalName { .notifyDay }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::month` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMonth` signal is emitted
    @discardableResult @inlinable func onNotifyMonth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CalendarRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CalendarRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyMonth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::month` signal for using the `connect(signal:)` methods
    static var notifyMonthSignal: CalendarSignalName { .notifyMonth }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::show-day-names` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyShowDayNames` signal is emitted
    @discardableResult @inlinable func onNotifyShowDayNames(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CalendarRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CalendarRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyShowDayNames,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::show-day-names` signal for using the `connect(signal:)` methods
    static var notifyShowDayNamesSignal: CalendarSignalName { .notifyShowDayNames }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::show-heading` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyShowHeading` signal is emitted
    @discardableResult @inlinable func onNotifyShowHeading(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CalendarRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CalendarRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyShowHeading,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::show-heading` signal for using the `connect(signal:)` methods
    static var notifyShowHeadingSignal: CalendarSignalName { .notifyShowHeading }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::show-week-numbers` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyShowWeekNumbers` signal is emitted
    @discardableResult @inlinable func onNotifyShowWeekNumbers(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CalendarRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CalendarRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyShowWeekNumbers,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::show-week-numbers` signal for using the `connect(signal:)` methods
    static var notifyShowWeekNumbersSignal: CalendarSignalName { .notifyShowWeekNumbers }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::year` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyYear` signal is emitted
    @discardableResult @inlinable func onNotifyYear(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CalendarRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CalendarRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyYear,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::year` signal for using the `connect(signal:)` methods
    static var notifyYearSignal: CalendarSignalName { .notifyYear }
    
}

// MARK: Calendar Class: CalendarProtocol extension (methods and fields)
public extension CalendarProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCalendar` instance.
    @inlinable var calendar_ptr: UnsafeMutablePointer<GtkCalendar>! { return ptr?.assumingMemoryBound(to: GtkCalendar.self) }

    /// Remove all visual markers.
    @inlinable func clearMarks() {
        
        gtk_calendar_clear_marks(calendar_ptr)
        
    }

    /// Returns a `GDateTime` representing the shown
    /// year, month and the selected day.
    /// 
    /// The returned date is in the local time zone.
    @inlinable func getDate() -> GLib.DateTimeRef! {
        let result = gtk_calendar_get_date(calendar_ptr)
        let rv = GLib.DateTimeRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns if the `day` of the `calendar` is already marked.
    @inlinable func getDayIsMarked(day: Int) -> Bool {
        let result = gtk_calendar_get_day_is_marked(calendar_ptr, guint(day))
        let rv = ((result) != 0)
        return rv
    }

    /// Returns whether `self` is currently showing the names
    /// of the week days.
    /// 
    /// This is the value of the [property`Gtk.Calendar:show-day-names`]
    /// property.
    @inlinable func getShowDayNames() -> Bool {
        let result = gtk_calendar_get_show_day_names(calendar_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns whether `self` is currently showing the heading.
    /// 
    /// This is the value of the [property`Gtk.Calendar:show-heading`]
    /// property.
    @inlinable func getShowHeading() -> Bool {
        let result = gtk_calendar_get_show_heading(calendar_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns whether `self` is showing week numbers right
    /// now.
    /// 
    /// This is the value of the [property`Gtk.Calendar:show-week-numbers`]
    /// property.
    @inlinable func getShowWeekNumbers() -> Bool {
        let result = gtk_calendar_get_show_week_numbers(calendar_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Places a visual marker on a particular day.
    @inlinable func mark(day: Int) {
        
        gtk_calendar_mark_day(calendar_ptr, guint(day))
        
    }

    /// Switches to `date`'s year and month and select its day.
    @inlinable func selectDay<GLibDateTimeT: GLib.DateTimeProtocol>(date: GLibDateTimeT) {
        
        gtk_calendar_select_day(calendar_ptr, date.date_time_ptr)
        
    }

    /// Sets whether the calendar shows day names.
    @inlinable func setShowDayNames(value: Bool) {
        
        gtk_calendar_set_show_day_names(calendar_ptr, gboolean((value) ? 1 : 0))
        
    }

    /// Sets whether the calendar should show a heading.
    /// 
    /// The heading contains the current year and month as well as
    /// buttons for changing both.
    @inlinable func setShowHeading(value: Bool) {
        
        gtk_calendar_set_show_heading(calendar_ptr, gboolean((value) ? 1 : 0))
        
    }

    /// Sets whether week numbers are shown in the calendar.
    @inlinable func setShowWeekNumbers(value: Bool) {
        
        gtk_calendar_set_show_week_numbers(calendar_ptr, gboolean((value) ? 1 : 0))
        
    }

    /// Removes the visual marker from a particular day.
    @inlinable func unmark(day: Int) {
        
        gtk_calendar_unmark_day(calendar_ptr, guint(day))
        
    }
    /// Returns a `GDateTime` representing the shown
    /// year, month and the selected day.
    /// 
    /// The returned date is in the local time zone.
    @inlinable var date: GLib.DateTimeRef! {
        /// Returns a `GDateTime` representing the shown
        /// year, month and the selected day.
        /// 
        /// The returned date is in the local time zone.
        get {
            let result = gtk_calendar_get_date(calendar_ptr)
        let rv = GLib.DateTimeRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Returns whether `self` is currently showing the names
    /// of the week days.
    /// 
    /// This is the value of the [property`Gtk.Calendar:show-day-names`]
    /// property.
    @inlinable var showDayNames: Bool {
        /// Returns whether `self` is currently showing the names
        /// of the week days.
        /// 
        /// This is the value of the [property`Gtk.Calendar:show-day-names`]
        /// property.
        get {
            let result = gtk_calendar_get_show_day_names(calendar_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether the calendar shows day names.
        nonmutating set {
            gtk_calendar_set_show_day_names(calendar_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether `self` is currently showing the heading.
    /// 
    /// This is the value of the [property`Gtk.Calendar:show-heading`]
    /// property.
    @inlinable var showHeading: Bool {
        /// Returns whether `self` is currently showing the heading.
        /// 
        /// This is the value of the [property`Gtk.Calendar:show-heading`]
        /// property.
        get {
            let result = gtk_calendar_get_show_heading(calendar_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether the calendar should show a heading.
        /// 
        /// The heading contains the current year and month as well as
        /// buttons for changing both.
        nonmutating set {
            gtk_calendar_set_show_heading(calendar_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether `self` is showing week numbers right
    /// now.
    /// 
    /// This is the value of the [property`Gtk.Calendar:show-week-numbers`]
    /// property.
    @inlinable var showWeekNumbers: Bool {
        /// Returns whether `self` is showing week numbers right
        /// now.
        /// 
        /// This is the value of the [property`Gtk.Calendar:show-week-numbers`]
        /// property.
        get {
            let result = gtk_calendar_get_show_week_numbers(calendar_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether week numbers are shown in the calendar.
        nonmutating set {
            gtk_calendar_set_show_week_numbers(calendar_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - CallbackAction Class

/// A `GtkShortcutAction` that invokes a callback.
///
/// The `CallbackActionProtocol` protocol exposes the methods and properties of an underlying `GtkCallbackAction` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CallbackAction`.
/// Alternatively, use `CallbackActionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CallbackActionProtocol: ShortcutActionProtocol {
        /// Untyped pointer to the underlying `GtkCallbackAction` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCallbackAction` instance.
    var callback_action_ptr: UnsafeMutablePointer<GtkCallbackAction>! { get }

    /// Required Initialiser for types conforming to `CallbackActionProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkShortcutAction` that invokes a callback.
///
/// The `CallbackActionRef` type acts as a lightweight Swift reference to an underlying `GtkCallbackAction` instance.
/// It exposes methods that can operate on this data type through `CallbackActionProtocol` conformance.
/// Use `CallbackActionRef` only as an `unowned` reference to an existing `GtkCallbackAction` instance.
///
public struct CallbackActionRef: CallbackActionProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCallbackAction` instance.
    /// For type-safe access, use the generated, typed pointer `callback_action_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CallbackActionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCallbackAction>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCallbackAction>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCallbackAction>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCallbackAction>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CallbackActionProtocol`
    @inlinable init<T: CallbackActionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CallbackActionProtocol>(_ other: T) -> CallbackActionRef { CallbackActionRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// A `GtkShortcutAction` that invokes a callback.
///
/// The `CallbackAction` type acts as a reference-counted owner of an underlying `GtkCallbackAction` instance.
/// It provides the methods that can operate on this data type through `CallbackActionProtocol` conformance.
/// Use `CallbackAction` as a strong reference or owner of a `GtkCallbackAction` instance.
///
open class CallbackAction: ShortcutAction, CallbackActionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCallbackAction>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCallbackAction>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCallbackAction>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCallbackAction>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCallbackAction`.
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCallbackAction>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CallbackActionProtocol`
    /// Will retain `GtkCallbackAction`.
    /// - Parameter other: an instance of a related type that implements `CallbackActionProtocol`
    @inlinable public init<T: CallbackActionProtocol>(callbackAction other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

// MARK: no CallbackAction properties

public enum CallbackActionSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: CallbackAction has no signals
// MARK: CallbackAction Class: CallbackActionProtocol extension (methods and fields)
public extension CallbackActionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCallbackAction` instance.
    @inlinable var callback_action_ptr: UnsafeMutablePointer<GtkCallbackAction>! { return ptr?.assumingMemoryBound(to: GtkCallbackAction.self) }



}



// MARK: - CellArea Class

/// An abstract class for laying out `GtkCellRenderer`s
/// 
/// The `GtkCellArea` is an abstract class for [iface`Gtk.CellLayout`]
/// widgets (also referred to as "layouting widgets") to interface with
/// an arbitrary number of [class`Gtk.CellRenderer`]s and interact with the user
/// for a given [iface`Gtk.TreeModel`] row.
/// 
/// The cell area handles events, focus navigation, drawing and
/// size requests and allocations for a given row of data.
/// 
/// Usually users dont have to interact with the `GtkCellArea` directly
/// unless they are implementing a cell-layouting widget themselves.
/// 
/// # Requesting area sizes
/// 
/// As outlined in
/// [GtkWidget’s geometry management section](class.Widget.html`height-for-width-geometry-management`),
/// GTK uses a height-for-width
/// geometry management system to compute the sizes of widgets and user
/// interfaces. `GtkCellArea` uses the same semantics to calculate the
/// size of an area for an arbitrary number of `GtkTreeModel` rows.
/// 
/// When requesting the size of a cell area one needs to calculate
/// the size for a handful of rows, and this will be done differently by
/// different layouting widgets. For instance a [class`Gtk.TreeViewColumn`]
/// always lines up the areas from top to bottom while a [class`Gtk.IconView`]
/// on the other hand might enforce that all areas received the same
/// width and wrap the areas around, requesting height for more cell
/// areas when allocated less width.
/// 
/// It’s also important for areas to maintain some cell
/// alignments with areas rendered for adjacent rows (cells can
/// appear “columnized” inside an area even when the size of
/// cells are different in each row). For this reason the `GtkCellArea`
/// uses a [class`Gtk.CellAreaContext`] object to store the alignments
/// and sizes along the way (as well as the overall largest minimum
/// and natural size for all the rows which have been calculated
/// with the said context).
/// 
/// The [class`Gtk.CellAreaContext`] is an opaque object specific to the
/// `GtkCellArea` which created it (see [method`Gtk.CellArea.create_context`]).
/// 
/// The owning cell-layouting widget can create as many contexts as
/// it wishes to calculate sizes of rows which should receive the
/// same size in at least one orientation (horizontally or vertically),
/// However, it’s important that the same [class`Gtk.CellAreaContext`] which
/// was used to request the sizes for a given `GtkTreeModel` row be
/// used when rendering or processing events for that row.
/// 
/// In order to request the width of all the rows at the root level
/// of a `GtkTreeModel` one would do the following:
/// 
/// ```c
/// GtkTreeIter iter;
/// int minimum_width;
/// int natural_width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_width (area, context, widget, NULL, NULL);
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// 
/// gtk_cell_area_context_get_preferred_width (context, &minimum_width, &natural_width);
/// ```
/// 
/// Note that in this example it’s not important to observe the
/// returned minimum and natural width of the area for each row
/// unless the cell-layouting object is actually interested in the
/// widths of individual rows. The overall width is however stored
/// in the accompanying `GtkCellAreaContext` object and can be consulted
/// at any time.
/// 
/// This can be useful since `GtkCellLayout` widgets usually have to
/// support requesting and rendering rows in treemodels with an
/// exceedingly large amount of rows. The `GtkCellLayout` widget in
/// that case would calculate the required width of the rows in an
/// idle or timeout source (see [func`GLib.timeout_add`]) and when the widget
/// is requested its actual width in [vfunc`Gtk.Widget.measure`]
/// it can simply consult the width accumulated so far in the
/// `GtkCellAreaContext` object.
/// 
/// A simple example where rows are rendered from top to bottom and
/// take up the full width of the layouting widget would look like:
/// 
/// ```c
/// static void
/// foo_get_preferred_width (GtkWidget *widget,
///                          int       *minimum_size,
///                          int       *natural_size)
/// {
///   Foo *self = FOO (widget);
///   FooPrivate *priv = foo_get_instance_private (self);
/// 
///   foo_ensure_at_least_one_handfull_of_rows_have_been_requested (self);
/// 
///   gtk_cell_area_context_get_preferred_width (priv-&gt;context, minimum_size, natural_size);
/// }
/// ```
/// 
/// In the above example the `Foo` widget has to make sure that some
/// row sizes have been calculated (the amount of rows that `Foo` judged
/// was appropriate to request space for in a single timeout iteration)
/// before simply returning the amount of space required by the area via
/// the `GtkCellAreaContext`.
/// 
/// Requesting the height for width (or width for height) of an area is
/// a similar task except in this case the `GtkCellAreaContext` does not
/// store the data (actually, it does not know how much space the layouting
/// widget plans to allocate it for every row. It’s up to the layouting
/// widget to render each row of data with the appropriate height and
/// width which was requested by the `GtkCellArea`).
/// 
/// In order to request the height for width of all the rows at the
/// root level of a `GtkTreeModel` one would do the following:
/// 
/// ```c
/// GtkTreeIter iter;
/// int minimum_height;
/// int natural_height;
/// int full_minimum_height = 0;
/// int full_natural_height = 0;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_height_for_width (area, context, widget,
///                                                   width, &minimum_height, &natural_height);
/// 
///     if (width_is_for_allocation)
///        cache_row_height (&iter, minimum_height, natural_height);
/// 
///     full_minimum_height += minimum_height;
///     full_natural_height += natural_height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that in the above example we would need to cache the heights
/// returned for each row so that we would know what sizes to render the
/// areas for each row. However we would only want to really cache the
/// heights if the request is intended for the layouting widgets real
/// allocation.
/// 
/// In some cases the layouting widget is requested the height for an
/// arbitrary for_width, this is a special case for layouting widgets
/// who need to request size for tens of thousands  of rows. For this
/// case it’s only important that the layouting widget calculate
/// one reasonably sized chunk of rows and return that height
/// synchronously. The reasoning here is that any layouting widget is
/// at least capable of synchronously calculating enough height to fill
/// the screen height (or scrolled window height) in response to a single
/// call to [vfunc`Gtk.Widget.measure`]. Returning
/// a perfect height for width that is larger than the screen area is
/// inconsequential since after the layouting receives an allocation
/// from a scrolled window it simply continues to drive the scrollbar
/// values while more and more height is required for the row heights
/// that are calculated in the background.
/// 
/// # Rendering Areas
/// 
/// Once area sizes have been acquired at least for the rows in the
/// visible area of the layouting widget they can be rendered at
/// [vfunc`Gtk.Widget.snapshot`] time.
/// 
/// A crude example of how to render all the rows at the root level
/// runs as follows:
/// 
/// ```c
/// GtkAllocation allocation;
/// GdkRectangle cell_area = { 0, };
/// GtkTreeIter iter;
/// int minimum_width;
/// int natural_width;
/// 
/// gtk_widget_get_allocation (widget, &allocation);
/// cell_area.width = allocation.width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     cell_area.height = get_cached_height_for_row (&iter);
/// 
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_render (area, context, widget, cr,
///                           &cell_area, &cell_area, state_flags, FALSE);
/// 
///     cell_area.y += cell_area.height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that the cached height in this example really depends on how
/// the layouting widget works. The layouting widget might decide to
/// give every row its minimum or natural height or, if the model content
/// is expected to fit inside the layouting widget without scrolling, it
/// would make sense to calculate the allocation for each row at
/// the time the widget is allocated using [func`Gtk.distribute_natural_allocation`].
/// 
/// # Handling Events and Driving Keyboard Focus
/// 
/// Passing events to the area is as simple as handling events on any
/// normal widget and then passing them to the [method`Gtk.CellArea.event`]
/// API as they come in. Usually `GtkCellArea` is only interested in
/// button events, however some customized derived areas can be implemented
/// who are interested in handling other events. Handling an event can
/// trigger the [`signal`Gtk.CellArea::focus-changed``] signal to fire; as well
/// as [`signal`GtkCellArea::add-editable``] in the case that an editable cell
/// was clicked and needs to start editing. You can call
/// [method`Gtk.CellArea.stop_editing`] at any time to cancel any cell editing
/// that is currently in progress.
/// 
/// The `GtkCellArea` drives keyboard focus from cell to cell in a way
/// similar to `GtkWidget`. For layouting widgets that support giving
/// focus to cells it’s important to remember to pass `GTK_CELL_RENDERER_FOCUSED`
/// to the area functions for the row that has focus and to tell the
/// area to paint the focus at render time.
/// 
/// Layouting widgets that accept focus on cells should implement the
/// [vfunc`Gtk.Widget.focus`] virtual method. The layouting widget is always
/// responsible for knowing where `GtkTreeModel` rows are rendered inside
/// the widget, so at [vfunc`Gtk.Widget.focus`] time the layouting widget
/// should use the `GtkCellArea` methods to navigate focus inside the area
/// and then observe the [enum`Gtk.DirectionType`] to pass the focus to adjacent
/// rows and areas.
/// 
/// A basic example of how the [vfunc`Gtk.Widget.focus`] virtual method
/// should be implemented:
/// 
/// ```
/// static gboolean
/// foo_focus (GtkWidget       *widget,
///            GtkDirectionType direction)
/// {
///   Foo *self = FOO (widget);
///   FooPrivate *priv = foo_get_instance_private (self);
///   int focus_row = priv-&gt;focus_row;
///   gboolean have_focus = FALSE;
/// 
///   if (!gtk_widget_has_focus (widget))
///     gtk_widget_grab_focus (widget);
/// 
///   valid = gtk_tree_model_iter_nth_child (priv-&gt;model, &iter, NULL, priv-&gt;focus_row);
///   while (valid)
///     {
///       gtk_cell_area_apply_attributes (priv-&gt;area, priv-&gt;model, &iter, FALSE, FALSE);
/// 
///       if (gtk_cell_area_focus (priv-&gt;area, direction))
///         {
///            priv-&gt;focus_row = focus_row;
///            have_focus = TRUE;
///            break;
///         }
///       else
///         {
///           if (direction == GTK_DIR_RIGHT ||
///               direction == GTK_DIR_LEFT)
///             break;
///           else if (direction == GTK_DIR_UP ||
///                    direction == GTK_DIR_TAB_BACKWARD)
///            {
///               if (focus_row == 0)
///                 break;
///               else
///                {
///                   focus_row--;
///                   valid = gtk_tree_model_iter_nth_child (priv-&gt;model, &iter, NULL, focus_row);
///                }
///             }
///           else
///             {
///               if (focus_row == last_row)
///                 break;
///               else
///                 {
///                   focus_row++;
///                   valid = gtk_tree_model_iter_next (priv-&gt;model, &iter);
///                 }
///             }
///         }
///     }
///     return have_focus;
/// }
/// ```
/// 
/// Note that the layouting widget is responsible for matching the
/// `GtkDirectionType` values to the way it lays out its cells.
/// 
/// # Cell Properties
/// 
/// The `GtkCellArea` introduces cell properties for `GtkCellRenderer`s.
/// This provides some general interfaces for defining the relationship
/// cell areas have with their cells. For instance in a [class`Gtk.CellAreaBox`]
/// a cell might “expand” and receive extra space when the area is allocated
/// more than its full natural request, or a cell might be configured to “align”
/// with adjacent rows which were requested and rendered with the same
/// `GtkCellAreaContext`.
/// 
/// Use [method`Gtk.CellAreaClass.install_cell_property`] to install cell
/// properties for a cell area class and [method`Gtk.CellAreaClass.find_cell_property`]
/// or [method`Gtk.CellAreaClass.list_cell_properties`] to get information about
/// existing cell properties.
/// 
/// To set the value of a cell property, use [method`Gtk.CellArea.cell_set_property`],
/// [method`Gtk.CellArea.cell_set`] or [method`Gtk.CellArea.cell_set_valist`]. To obtain
/// the value of a cell property, use [method`Gtk.CellArea.cell_get_property`]
/// [method`Gtk.CellArea.cell_get`] or [method`Gtk.CellArea.cell_get_valist`].
///
/// The `CellAreaProtocol` protocol exposes the methods and properties of an underlying `GtkCellArea` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellArea`.
/// Alternatively, use `CellAreaRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellAreaProtocol: GLibObject.InitiallyUnownedProtocol, BuildableProtocol, CellLayoutProtocol {
        /// Untyped pointer to the underlying `GtkCellArea` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellArea` instance.
    var cell_area_ptr: UnsafeMutablePointer<GtkCellArea>! { get }

    /// Required Initialiser for types conforming to `CellAreaProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// An abstract class for laying out `GtkCellRenderer`s
/// 
/// The `GtkCellArea` is an abstract class for [iface`Gtk.CellLayout`]
/// widgets (also referred to as "layouting widgets") to interface with
/// an arbitrary number of [class`Gtk.CellRenderer`]s and interact with the user
/// for a given [iface`Gtk.TreeModel`] row.
/// 
/// The cell area handles events, focus navigation, drawing and
/// size requests and allocations for a given row of data.
/// 
/// Usually users dont have to interact with the `GtkCellArea` directly
/// unless they are implementing a cell-layouting widget themselves.
/// 
/// # Requesting area sizes
/// 
/// As outlined in
/// [GtkWidget’s geometry management section](class.Widget.html`height-for-width-geometry-management`),
/// GTK uses a height-for-width
/// geometry management system to compute the sizes of widgets and user
/// interfaces. `GtkCellArea` uses the same semantics to calculate the
/// size of an area for an arbitrary number of `GtkTreeModel` rows.
/// 
/// When requesting the size of a cell area one needs to calculate
/// the size for a handful of rows, and this will be done differently by
/// different layouting widgets. For instance a [class`Gtk.TreeViewColumn`]
/// always lines up the areas from top to bottom while a [class`Gtk.IconView`]
/// on the other hand might enforce that all areas received the same
/// width and wrap the areas around, requesting height for more cell
/// areas when allocated less width.
/// 
/// It’s also important for areas to maintain some cell
/// alignments with areas rendered for adjacent rows (cells can
/// appear “columnized” inside an area even when the size of
/// cells are different in each row). For this reason the `GtkCellArea`
/// uses a [class`Gtk.CellAreaContext`] object to store the alignments
/// and sizes along the way (as well as the overall largest minimum
/// and natural size for all the rows which have been calculated
/// with the said context).
/// 
/// The [class`Gtk.CellAreaContext`] is an opaque object specific to the
/// `GtkCellArea` which created it (see [method`Gtk.CellArea.create_context`]).
/// 
/// The owning cell-layouting widget can create as many contexts as
/// it wishes to calculate sizes of rows which should receive the
/// same size in at least one orientation (horizontally or vertically),
/// However, it’s important that the same [class`Gtk.CellAreaContext`] which
/// was used to request the sizes for a given `GtkTreeModel` row be
/// used when rendering or processing events for that row.
/// 
/// In order to request the width of all the rows at the root level
/// of a `GtkTreeModel` one would do the following:
/// 
/// ```c
/// GtkTreeIter iter;
/// int minimum_width;
/// int natural_width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_width (area, context, widget, NULL, NULL);
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// 
/// gtk_cell_area_context_get_preferred_width (context, &minimum_width, &natural_width);
/// ```
/// 
/// Note that in this example it’s not important to observe the
/// returned minimum and natural width of the area for each row
/// unless the cell-layouting object is actually interested in the
/// widths of individual rows. The overall width is however stored
/// in the accompanying `GtkCellAreaContext` object and can be consulted
/// at any time.
/// 
/// This can be useful since `GtkCellLayout` widgets usually have to
/// support requesting and rendering rows in treemodels with an
/// exceedingly large amount of rows. The `GtkCellLayout` widget in
/// that case would calculate the required width of the rows in an
/// idle or timeout source (see [func`GLib.timeout_add`]) and when the widget
/// is requested its actual width in [vfunc`Gtk.Widget.measure`]
/// it can simply consult the width accumulated so far in the
/// `GtkCellAreaContext` object.
/// 
/// A simple example where rows are rendered from top to bottom and
/// take up the full width of the layouting widget would look like:
/// 
/// ```c
/// static void
/// foo_get_preferred_width (GtkWidget *widget,
///                          int       *minimum_size,
///                          int       *natural_size)
/// {
///   Foo *self = FOO (widget);
///   FooPrivate *priv = foo_get_instance_private (self);
/// 
///   foo_ensure_at_least_one_handfull_of_rows_have_been_requested (self);
/// 
///   gtk_cell_area_context_get_preferred_width (priv-&gt;context, minimum_size, natural_size);
/// }
/// ```
/// 
/// In the above example the `Foo` widget has to make sure that some
/// row sizes have been calculated (the amount of rows that `Foo` judged
/// was appropriate to request space for in a single timeout iteration)
/// before simply returning the amount of space required by the area via
/// the `GtkCellAreaContext`.
/// 
/// Requesting the height for width (or width for height) of an area is
/// a similar task except in this case the `GtkCellAreaContext` does not
/// store the data (actually, it does not know how much space the layouting
/// widget plans to allocate it for every row. It’s up to the layouting
/// widget to render each row of data with the appropriate height and
/// width which was requested by the `GtkCellArea`).
/// 
/// In order to request the height for width of all the rows at the
/// root level of a `GtkTreeModel` one would do the following:
/// 
/// ```c
/// GtkTreeIter iter;
/// int minimum_height;
/// int natural_height;
/// int full_minimum_height = 0;
/// int full_natural_height = 0;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_height_for_width (area, context, widget,
///                                                   width, &minimum_height, &natural_height);
/// 
///     if (width_is_for_allocation)
///        cache_row_height (&iter, minimum_height, natural_height);
/// 
///     full_minimum_height += minimum_height;
///     full_natural_height += natural_height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that in the above example we would need to cache the heights
/// returned for each row so that we would know what sizes to render the
/// areas for each row. However we would only want to really cache the
/// heights if the request is intended for the layouting widgets real
/// allocation.
/// 
/// In some cases the layouting widget is requested the height for an
/// arbitrary for_width, this is a special case for layouting widgets
/// who need to request size for tens of thousands  of rows. For this
/// case it’s only important that the layouting widget calculate
/// one reasonably sized chunk of rows and return that height
/// synchronously. The reasoning here is that any layouting widget is
/// at least capable of synchronously calculating enough height to fill
/// the screen height (or scrolled window height) in response to a single
/// call to [vfunc`Gtk.Widget.measure`]. Returning
/// a perfect height for width that is larger than the screen area is
/// inconsequential since after the layouting receives an allocation
/// from a scrolled window it simply continues to drive the scrollbar
/// values while more and more height is required for the row heights
/// that are calculated in the background.
/// 
/// # Rendering Areas
/// 
/// Once area sizes have been acquired at least for the rows in the
/// visible area of the layouting widget they can be rendered at
/// [vfunc`Gtk.Widget.snapshot`] time.
/// 
/// A crude example of how to render all the rows at the root level
/// runs as follows:
/// 
/// ```c
/// GtkAllocation allocation;
/// GdkRectangle cell_area = { 0, };
/// GtkTreeIter iter;
/// int minimum_width;
/// int natural_width;
/// 
/// gtk_widget_get_allocation (widget, &allocation);
/// cell_area.width = allocation.width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     cell_area.height = get_cached_height_for_row (&iter);
/// 
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_render (area, context, widget, cr,
///                           &cell_area, &cell_area, state_flags, FALSE);
/// 
///     cell_area.y += cell_area.height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that the cached height in this example really depends on how
/// the layouting widget works. The layouting widget might decide to
/// give every row its minimum or natural height or, if the model content
/// is expected to fit inside the layouting widget without scrolling, it
/// would make sense to calculate the allocation for each row at
/// the time the widget is allocated using [func`Gtk.distribute_natural_allocation`].
/// 
/// # Handling Events and Driving Keyboard Focus
/// 
/// Passing events to the area is as simple as handling events on any
/// normal widget and then passing them to the [method`Gtk.CellArea.event`]
/// API as they come in. Usually `GtkCellArea` is only interested in
/// button events, however some customized derived areas can be implemented
/// who are interested in handling other events. Handling an event can
/// trigger the [`signal`Gtk.CellArea::focus-changed``] signal to fire; as well
/// as [`signal`GtkCellArea::add-editable``] in the case that an editable cell
/// was clicked and needs to start editing. You can call
/// [method`Gtk.CellArea.stop_editing`] at any time to cancel any cell editing
/// that is currently in progress.
/// 
/// The `GtkCellArea` drives keyboard focus from cell to cell in a way
/// similar to `GtkWidget`. For layouting widgets that support giving
/// focus to cells it’s important to remember to pass `GTK_CELL_RENDERER_FOCUSED`
/// to the area functions for the row that has focus and to tell the
/// area to paint the focus at render time.
/// 
/// Layouting widgets that accept focus on cells should implement the
/// [vfunc`Gtk.Widget.focus`] virtual method. The layouting widget is always
/// responsible for knowing where `GtkTreeModel` rows are rendered inside
/// the widget, so at [vfunc`Gtk.Widget.focus`] time the layouting widget
/// should use the `GtkCellArea` methods to navigate focus inside the area
/// and then observe the [enum`Gtk.DirectionType`] to pass the focus to adjacent
/// rows and areas.
/// 
/// A basic example of how the [vfunc`Gtk.Widget.focus`] virtual method
/// should be implemented:
/// 
/// ```
/// static gboolean
/// foo_focus (GtkWidget       *widget,
///            GtkDirectionType direction)
/// {
///   Foo *self = FOO (widget);
///   FooPrivate *priv = foo_get_instance_private (self);
///   int focus_row = priv-&gt;focus_row;
///   gboolean have_focus = FALSE;
/// 
///   if (!gtk_widget_has_focus (widget))
///     gtk_widget_grab_focus (widget);
/// 
///   valid = gtk_tree_model_iter_nth_child (priv-&gt;model, &iter, NULL, priv-&gt;focus_row);
///   while (valid)
///     {
///       gtk_cell_area_apply_attributes (priv-&gt;area, priv-&gt;model, &iter, FALSE, FALSE);
/// 
///       if (gtk_cell_area_focus (priv-&gt;area, direction))
///         {
///            priv-&gt;focus_row = focus_row;
///            have_focus = TRUE;
///            break;
///         }
///       else
///         {
///           if (direction == GTK_DIR_RIGHT ||
///               direction == GTK_DIR_LEFT)
///             break;
///           else if (direction == GTK_DIR_UP ||
///                    direction == GTK_DIR_TAB_BACKWARD)
///            {
///               if (focus_row == 0)
///                 break;
///               else
///                {
///                   focus_row--;
///                   valid = gtk_tree_model_iter_nth_child (priv-&gt;model, &iter, NULL, focus_row);
///                }
///             }
///           else
///             {
///               if (focus_row == last_row)
///                 break;
///               else
///                 {
///                   focus_row++;
///                   valid = gtk_tree_model_iter_next (priv-&gt;model, &iter);
///                 }
///             }
///         }
///     }
///     return have_focus;
/// }
/// ```
/// 
/// Note that the layouting widget is responsible for matching the
/// `GtkDirectionType` values to the way it lays out its cells.
/// 
/// # Cell Properties
/// 
/// The `GtkCellArea` introduces cell properties for `GtkCellRenderer`s.
/// This provides some general interfaces for defining the relationship
/// cell areas have with their cells. For instance in a [class`Gtk.CellAreaBox`]
/// a cell might “expand” and receive extra space when the area is allocated
/// more than its full natural request, or a cell might be configured to “align”
/// with adjacent rows which were requested and rendered with the same
/// `GtkCellAreaContext`.
/// 
/// Use [method`Gtk.CellAreaClass.install_cell_property`] to install cell
/// properties for a cell area class and [method`Gtk.CellAreaClass.find_cell_property`]
/// or [method`Gtk.CellAreaClass.list_cell_properties`] to get information about
/// existing cell properties.
/// 
/// To set the value of a cell property, use [method`Gtk.CellArea.cell_set_property`],
/// [method`Gtk.CellArea.cell_set`] or [method`Gtk.CellArea.cell_set_valist`]. To obtain
/// the value of a cell property, use [method`Gtk.CellArea.cell_get_property`]
/// [method`Gtk.CellArea.cell_get`] or [method`Gtk.CellArea.cell_get_valist`].
///
/// The `CellAreaRef` type acts as a lightweight Swift reference to an underlying `GtkCellArea` instance.
/// It exposes methods that can operate on this data type through `CellAreaProtocol` conformance.
/// Use `CellAreaRef` only as an `unowned` reference to an existing `GtkCellArea` instance.
///
public struct CellAreaRef: CellAreaProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellArea` instance.
    /// For type-safe access, use the generated, typed pointer `cell_area_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellAreaRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellArea>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellArea>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellArea>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellArea>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellAreaProtocol`
    @inlinable init<T: CellAreaProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellAreaProtocol>(_ other: T) -> CellAreaRef { CellAreaRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// An abstract class for laying out `GtkCellRenderer`s
/// 
/// The `GtkCellArea` is an abstract class for [iface`Gtk.CellLayout`]
/// widgets (also referred to as "layouting widgets") to interface with
/// an arbitrary number of [class`Gtk.CellRenderer`]s and interact with the user
/// for a given [iface`Gtk.TreeModel`] row.
/// 
/// The cell area handles events, focus navigation, drawing and
/// size requests and allocations for a given row of data.
/// 
/// Usually users dont have to interact with the `GtkCellArea` directly
/// unless they are implementing a cell-layouting widget themselves.
/// 
/// # Requesting area sizes
/// 
/// As outlined in
/// [GtkWidget’s geometry management section](class.Widget.html`height-for-width-geometry-management`),
/// GTK uses a height-for-width
/// geometry management system to compute the sizes of widgets and user
/// interfaces. `GtkCellArea` uses the same semantics to calculate the
/// size of an area for an arbitrary number of `GtkTreeModel` rows.
/// 
/// When requesting the size of a cell area one needs to calculate
/// the size for a handful of rows, and this will be done differently by
/// different layouting widgets. For instance a [class`Gtk.TreeViewColumn`]
/// always lines up the areas from top to bottom while a [class`Gtk.IconView`]
/// on the other hand might enforce that all areas received the same
/// width and wrap the areas around, requesting height for more cell
/// areas when allocated less width.
/// 
/// It’s also important for areas to maintain some cell
/// alignments with areas rendered for adjacent rows (cells can
/// appear “columnized” inside an area even when the size of
/// cells are different in each row). For this reason the `GtkCellArea`
/// uses a [class`Gtk.CellAreaContext`] object to store the alignments
/// and sizes along the way (as well as the overall largest minimum
/// and natural size for all the rows which have been calculated
/// with the said context).
/// 
/// The [class`Gtk.CellAreaContext`] is an opaque object specific to the
/// `GtkCellArea` which created it (see [method`Gtk.CellArea.create_context`]).
/// 
/// The owning cell-layouting widget can create as many contexts as
/// it wishes to calculate sizes of rows which should receive the
/// same size in at least one orientation (horizontally or vertically),
/// However, it’s important that the same [class`Gtk.CellAreaContext`] which
/// was used to request the sizes for a given `GtkTreeModel` row be
/// used when rendering or processing events for that row.
/// 
/// In order to request the width of all the rows at the root level
/// of a `GtkTreeModel` one would do the following:
/// 
/// ```c
/// GtkTreeIter iter;
/// int minimum_width;
/// int natural_width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_width (area, context, widget, NULL, NULL);
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// 
/// gtk_cell_area_context_get_preferred_width (context, &minimum_width, &natural_width);
/// ```
/// 
/// Note that in this example it’s not important to observe the
/// returned minimum and natural width of the area for each row
/// unless the cell-layouting object is actually interested in the
/// widths of individual rows. The overall width is however stored
/// in the accompanying `GtkCellAreaContext` object and can be consulted
/// at any time.
/// 
/// This can be useful since `GtkCellLayout` widgets usually have to
/// support requesting and rendering rows in treemodels with an
/// exceedingly large amount of rows. The `GtkCellLayout` widget in
/// that case would calculate the required width of the rows in an
/// idle or timeout source (see [func`GLib.timeout_add`]) and when the widget
/// is requested its actual width in [vfunc`Gtk.Widget.measure`]
/// it can simply consult the width accumulated so far in the
/// `GtkCellAreaContext` object.
/// 
/// A simple example where rows are rendered from top to bottom and
/// take up the full width of the layouting widget would look like:
/// 
/// ```c
/// static void
/// foo_get_preferred_width (GtkWidget *widget,
///                          int       *minimum_size,
///                          int       *natural_size)
/// {
///   Foo *self = FOO (widget);
///   FooPrivate *priv = foo_get_instance_private (self);
/// 
///   foo_ensure_at_least_one_handfull_of_rows_have_been_requested (self);
/// 
///   gtk_cell_area_context_get_preferred_width (priv-&gt;context, minimum_size, natural_size);
/// }
/// ```
/// 
/// In the above example the `Foo` widget has to make sure that some
/// row sizes have been calculated (the amount of rows that `Foo` judged
/// was appropriate to request space for in a single timeout iteration)
/// before simply returning the amount of space required by the area via
/// the `GtkCellAreaContext`.
/// 
/// Requesting the height for width (or width for height) of an area is
/// a similar task except in this case the `GtkCellAreaContext` does not
/// store the data (actually, it does not know how much space the layouting
/// widget plans to allocate it for every row. It’s up to the layouting
/// widget to render each row of data with the appropriate height and
/// width which was requested by the `GtkCellArea`).
/// 
/// In order to request the height for width of all the rows at the
/// root level of a `GtkTreeModel` one would do the following:
/// 
/// ```c
/// GtkTreeIter iter;
/// int minimum_height;
/// int natural_height;
/// int full_minimum_height = 0;
/// int full_natural_height = 0;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_height_for_width (area, context, widget,
///                                                   width, &minimum_height, &natural_height);
/// 
///     if (width_is_for_allocation)
///        cache_row_height (&iter, minimum_height, natural_height);
/// 
///     full_minimum_height += minimum_height;
///     full_natural_height += natural_height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that in the above example we would need to cache the heights
/// returned for each row so that we would know what sizes to render the
/// areas for each row. However we would only want to really cache the
/// heights if the request is intended for the layouting widgets real
/// allocation.
/// 
/// In some cases the layouting widget is requested the height for an
/// arbitrary for_width, this is a special case for layouting widgets
/// who need to request size for tens of thousands  of rows. For this
/// case it’s only important that the layouting widget calculate
/// one reasonably sized chunk of rows and return that height
/// synchronously. The reasoning here is that any layouting widget is
/// at least capable of synchronously calculating enough height to fill
/// the screen height (or scrolled window height) in response to a single
/// call to [vfunc`Gtk.Widget.measure`]. Returning
/// a perfect height for width that is larger than the screen area is
/// inconsequential since after the layouting receives an allocation
/// from a scrolled window it simply continues to drive the scrollbar
/// values while more and more height is required for the row heights
/// that are calculated in the background.
/// 
/// # Rendering Areas
/// 
/// Once area sizes have been acquired at least for the rows in the
/// visible area of the layouting widget they can be rendered at
/// [vfunc`Gtk.Widget.snapshot`] time.
/// 
/// A crude example of how to render all the rows at the root level
/// runs as follows:
/// 
/// ```c
/// GtkAllocation allocation;
/// GdkRectangle cell_area = { 0, };
/// GtkTreeIter iter;
/// int minimum_width;
/// int natural_width;
/// 
/// gtk_widget_get_allocation (widget, &allocation);
/// cell_area.width = allocation.width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     cell_area.height = get_cached_height_for_row (&iter);
/// 
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_render (area, context, widget, cr,
///                           &cell_area, &cell_area, state_flags, FALSE);
/// 
///     cell_area.y += cell_area.height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that the cached height in this example really depends on how
/// the layouting widget works. The layouting widget might decide to
/// give every row its minimum or natural height or, if the model content
/// is expected to fit inside the layouting widget without scrolling, it
/// would make sense to calculate the allocation for each row at
/// the time the widget is allocated using [func`Gtk.distribute_natural_allocation`].
/// 
/// # Handling Events and Driving Keyboard Focus
/// 
/// Passing events to the area is as simple as handling events on any
/// normal widget and then passing them to the [method`Gtk.CellArea.event`]
/// API as they come in. Usually `GtkCellArea` is only interested in
/// button events, however some customized derived areas can be implemented
/// who are interested in handling other events. Handling an event can
/// trigger the [`signal`Gtk.CellArea::focus-changed``] signal to fire; as well
/// as [`signal`GtkCellArea::add-editable``] in the case that an editable cell
/// was clicked and needs to start editing. You can call
/// [method`Gtk.CellArea.stop_editing`] at any time to cancel any cell editing
/// that is currently in progress.
/// 
/// The `GtkCellArea` drives keyboard focus from cell to cell in a way
/// similar to `GtkWidget`. For layouting widgets that support giving
/// focus to cells it’s important to remember to pass `GTK_CELL_RENDERER_FOCUSED`
/// to the area functions for the row that has focus and to tell the
/// area to paint the focus at render time.
/// 
/// Layouting widgets that accept focus on cells should implement the
/// [vfunc`Gtk.Widget.focus`] virtual method. The layouting widget is always
/// responsible for knowing where `GtkTreeModel` rows are rendered inside
/// the widget, so at [vfunc`Gtk.Widget.focus`] time the layouting widget
/// should use the `GtkCellArea` methods to navigate focus inside the area
/// and then observe the [enum`Gtk.DirectionType`] to pass the focus to adjacent
/// rows and areas.
/// 
/// A basic example of how the [vfunc`Gtk.Widget.focus`] virtual method
/// should be implemented:
/// 
/// ```
/// static gboolean
/// foo_focus (GtkWidget       *widget,
///            GtkDirectionType direction)
/// {
///   Foo *self = FOO (widget);
///   FooPrivate *priv = foo_get_instance_private (self);
///   int focus_row = priv-&gt;focus_row;
///   gboolean have_focus = FALSE;
/// 
///   if (!gtk_widget_has_focus (widget))
///     gtk_widget_grab_focus (widget);
/// 
///   valid = gtk_tree_model_iter_nth_child (priv-&gt;model, &iter, NULL, priv-&gt;focus_row);
///   while (valid)
///     {
///       gtk_cell_area_apply_attributes (priv-&gt;area, priv-&gt;model, &iter, FALSE, FALSE);
/// 
///       if (gtk_cell_area_focus (priv-&gt;area, direction))
///         {
///            priv-&gt;focus_row = focus_row;
///            have_focus = TRUE;
///            break;
///         }
///       else
///         {
///           if (direction == GTK_DIR_RIGHT ||
///               direction == GTK_DIR_LEFT)
///             break;
///           else if (direction == GTK_DIR_UP ||
///                    direction == GTK_DIR_TAB_BACKWARD)
///            {
///               if (focus_row == 0)
///                 break;
///               else
///                {
///                   focus_row--;
///                   valid = gtk_tree_model_iter_nth_child (priv-&gt;model, &iter, NULL, focus_row);
///                }
///             }
///           else
///             {
///               if (focus_row == last_row)
///                 break;
///               else
///                 {
///                   focus_row++;
///                   valid = gtk_tree_model_iter_next (priv-&gt;model, &iter);
///                 }
///             }
///         }
///     }
///     return have_focus;
/// }
/// ```
/// 
/// Note that the layouting widget is responsible for matching the
/// `GtkDirectionType` values to the way it lays out its cells.
/// 
/// # Cell Properties
/// 
/// The `GtkCellArea` introduces cell properties for `GtkCellRenderer`s.
/// This provides some general interfaces for defining the relationship
/// cell areas have with their cells. For instance in a [class`Gtk.CellAreaBox`]
/// a cell might “expand” and receive extra space when the area is allocated
/// more than its full natural request, or a cell might be configured to “align”
/// with adjacent rows which were requested and rendered with the same
/// `GtkCellAreaContext`.
/// 
/// Use [method`Gtk.CellAreaClass.install_cell_property`] to install cell
/// properties for a cell area class and [method`Gtk.CellAreaClass.find_cell_property`]
/// or [method`Gtk.CellAreaClass.list_cell_properties`] to get information about
/// existing cell properties.
/// 
/// To set the value of a cell property, use [method`Gtk.CellArea.cell_set_property`],
/// [method`Gtk.CellArea.cell_set`] or [method`Gtk.CellArea.cell_set_valist`]. To obtain
/// the value of a cell property, use [method`Gtk.CellArea.cell_get_property`]
/// [method`Gtk.CellArea.cell_get`] or [method`Gtk.CellArea.cell_get_valist`].
///
/// The `CellArea` type acts as a reference-counted owner of an underlying `GtkCellArea` instance.
/// It provides the methods that can operate on this data type through `CellAreaProtocol` conformance.
/// Use `CellArea` as a strong reference or owner of a `GtkCellArea` instance.
///
open class CellArea: GLibObject.InitiallyUnowned, CellAreaProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellArea>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellArea>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellArea>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellArea>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellArea`.
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellArea>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellAreaProtocol`
    /// Will retain `GtkCellArea`.
    /// - Parameter other: an instance of a related type that implements `CellAreaProtocol`
    @inlinable public init<T: CellAreaProtocol>(cellArea other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum CellAreaPropertyName: String, PropertyNameProtocol {
    /// The widget currently editing the edited cell
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case editWidget = "edit-widget"
    /// The cell in the area that is currently edited
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case editedCell = "edited-cell"
    /// The cell in the area that currently has focus
    case focusCell = "focus-cell"
}

public extension CellAreaProtocol {
    /// Bind a `CellAreaPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellAreaPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellArea property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellAreaPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellArea property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellAreaPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellAreaSignalName: String, SignalNameProtocol {
    /// Indicates that editing has started on `renderer` and that `editable`
    /// should be added to the owning cell-layouting widget at `cell_area`.
    case addEditable = "add-editable"
    /// This signal is emitted whenever applying attributes to `area` from `model`
    case applyAttributes = "apply-attributes"
    /// Indicates that focus changed on this `area`. This signal
    /// is emitted either as a result of focus handling or event
    /// handling.
    /// 
    /// It's possible that the signal is emitted even if the
    /// currently focused renderer did not change, this is
    /// because focus may change to the same renderer in the
    /// same cell area for a different row of data.
    case focusChanged = "focus-changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Indicates that editing finished on `renderer` and that `editable`
    /// should be removed from the owning cell-layouting widget.
    case removeEditable = "remove-editable"
    /// The widget currently editing the edited cell
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case notifyEditWidget = "notify::edit-widget"
    /// The cell in the area that is currently edited
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case notifyEditedCell = "notify::edited-cell"
    /// The cell in the area that currently has focus
    case notifyFocusCell = "notify::focus-cell"
}

// MARK: CellArea signals
public extension CellAreaProtocol {
    /// Connect a Swift signal handler to the given, typed `CellAreaSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellAreaSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `CellAreaSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellAreaSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Indicates that editing has started on `renderer` and that `editable`
    /// should be added to the owning cell-layouting widget at `cell_area`.
    /// - Note: This represents the underlying `add-editable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter renderer: the `GtkCellRenderer` that started the edited
    /// - Parameter editable: the `GtkCellEditable` widget to add
    /// - Parameter cellArea: the `GtkWidget` relative `GdkRectangle` coordinates             where `editable` should be added
    /// - Parameter path: the `GtkTreePath` string this edit was initiated for
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `addEditable` signal is emitted
    @discardableResult @inlinable func onAddEditable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellAreaRef, _ renderer: CellRendererRef, _ editable: CellEditableRef, _ cellArea: Gdk.RectangleRef, _ path: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellAreaRef, CellRendererRef, CellEditableRef, Gdk.RectangleRef, String), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, arg2, arg3, arg4, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellAreaRef(raw: unownedSelf), CellRendererRef(raw: arg1), CellEditableRef(raw: arg2), Gdk.RectangleRef(raw: arg3), arg4.map({ String(cString: $0) })!))
            return output
        }
        return connect(
            signal: .addEditable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `add-editable` signal for using the `connect(signal:)` methods
    static var addEditableSignal: CellAreaSignalName { .addEditable }
    
    /// This signal is emitted whenever applying attributes to `area` from `model`
    /// - Note: This represents the underlying `apply-attributes` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter model: the `GtkTreeModel` to apply the attributes from
    /// - Parameter iter: the `GtkTreeIter` indicating which row to apply the attributes of
    /// - Parameter isExpander: whether the view shows children for this row
    /// - Parameter isExpanded: whether the view is currently showing the children of this row
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `applyAttributes` signal is emitted
    @discardableResult @inlinable func onApplyAttributes(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellAreaRef, _ model: TreeModelRef, _ iter: TreeIterRef, _ isExpander: Bool, _ isExpanded: Bool) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellAreaRef, TreeModelRef, TreeIterRef, Bool, Bool), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gboolean, gboolean, gpointer) -> Void = { unownedSelf, arg1, arg2, arg3, arg4, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellAreaRef(raw: unownedSelf), TreeModelRef(raw: arg1), TreeIterRef(raw: arg2), ((arg3) != 0), ((arg4) != 0)))
            return output
        }
        return connect(
            signal: .applyAttributes,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `apply-attributes` signal for using the `connect(signal:)` methods
    static var applyAttributesSignal: CellAreaSignalName { .applyAttributes }
    
    /// Indicates that focus changed on this `area`. This signal
    /// is emitted either as a result of focus handling or event
    /// handling.
    /// 
    /// It's possible that the signal is emitted even if the
    /// currently focused renderer did not change, this is
    /// because focus may change to the same renderer in the
    /// same cell area for a different row of data.
    /// - Note: This represents the underlying `focus-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter renderer: the `GtkCellRenderer` that has focus
    /// - Parameter path: the current `GtkTreePath` string set for `area`
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `focusChanged` signal is emitted
    @discardableResult @inlinable func onFocusChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellAreaRef, _ renderer: CellRendererRef, _ path: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellAreaRef, CellRendererRef, String), Void>
        let cCallback: @convention(c) (gpointer, gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellAreaRef(raw: unownedSelf), CellRendererRef(raw: arg1), arg2.map({ String(cString: $0) })!))
            return output
        }
        return connect(
            signal: .focusChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `focus-changed` signal for using the `connect(signal:)` methods
    static var focusChangedSignal: CellAreaSignalName { .focusChanged }
    
    /// Indicates that editing finished on `renderer` and that `editable`
    /// should be removed from the owning cell-layouting widget.
    /// - Note: This represents the underlying `remove-editable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter renderer: the `GtkCellRenderer` that finished editeding
    /// - Parameter editable: the `GtkCellEditable` widget to remove
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `removeEditable` signal is emitted
    @discardableResult @inlinable func onRemoveEditable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellAreaRef, _ renderer: CellRendererRef, _ editable: CellEditableRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellAreaRef, CellRendererRef, CellEditableRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellAreaRef(raw: unownedSelf), CellRendererRef(raw: arg1), CellEditableRef(raw: arg2)))
            return output
        }
        return connect(
            signal: .removeEditable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `remove-editable` signal for using the `connect(signal:)` methods
    static var removeEditableSignal: CellAreaSignalName { .removeEditable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::edit-widget` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEditWidget` signal is emitted
    @discardableResult @inlinable func onNotifyEditWidget(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellAreaRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellAreaRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellAreaRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyEditWidget,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::edit-widget` signal for using the `connect(signal:)` methods
    static var notifyEditWidgetSignal: CellAreaSignalName { .notifyEditWidget }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::edited-cell` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEditedCell` signal is emitted
    @discardableResult @inlinable func onNotifyEditedCell(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellAreaRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellAreaRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellAreaRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyEditedCell,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::edited-cell` signal for using the `connect(signal:)` methods
    static var notifyEditedCellSignal: CellAreaSignalName { .notifyEditedCell }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::focus-cell` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFocusCell` signal is emitted
    @discardableResult @inlinable func onNotifyFocusCell(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellAreaRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellAreaRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellAreaRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyFocusCell,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::focus-cell` signal for using the `connect(signal:)` methods
    static var notifyFocusCellSignal: CellAreaSignalName { .notifyFocusCell }
    
}

// MARK: CellArea Class: CellAreaProtocol extension (methods and fields)
public extension CellAreaProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellArea` instance.
    @inlinable var cell_area_ptr: UnsafeMutablePointer<GtkCellArea>! { return ptr?.assumingMemoryBound(to: GtkCellArea.self) }

    /// Activates `area`, usually by activating the currently focused
    /// cell, however some subclasses which embed widgets in the area
    /// can also activate a widget if it currently has the focus.
    @inlinable func activate<CellAreaContextT: CellAreaContextProtocol, GdkRectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, cellArea: GdkRectangleT, flags: CellRendererState, editOnly: Bool) -> Bool {
        let result = gtk_cell_area_activate(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, cellArea.rectangle_ptr, flags.value, gboolean((editOnly) ? 1 : 0))
        let rv = ((result) != 0)
        return rv
    }

    /// This is used by `GtkCellArea` subclasses when handling events
    /// to activate cells, the base `GtkCellArea` class activates cells
    /// for keyboard events for free in its own GtkCellArea-&gt;`activate()`
    /// implementation.
    @inlinable func activateCell<CellRendererT: CellRendererProtocol, GdkEventT: Gdk.EventProtocol, GdkRectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(widget: WidgetT, renderer: CellRendererT, event: GdkEventT, cellArea: GdkRectangleT, flags: CellRendererState) -> Bool {
        let result = gtk_cell_area_activate_cell(cell_area_ptr, widget.widget_ptr, renderer.cell_renderer_ptr, event.event_ptr, cellArea.rectangle_ptr, flags.value)
        let rv = ((result) != 0)
        return rv
    }

    /// Adds `renderer` to `area` with the default child cell properties.
    @inlinable func add<CellRendererT: CellRendererProtocol>(renderer: CellRendererT) {
        
        gtk_cell_area_add(cell_area_ptr, renderer.cell_renderer_ptr)
        
    }

    /// Adds `sibling` to `renderer`’s focusable area, focus will be drawn
    /// around `renderer` and all of its siblings if `renderer` can
    /// focus for a given row.
    /// 
    /// Events handled by focus siblings can also activate the given
    /// focusable `renderer`.
    @inlinable func addFocusSibling<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, sibling: CellRendererT) {
        
        gtk_cell_area_add_focus_sibling(cell_area_ptr, renderer.cell_renderer_ptr, sibling.cell_renderer_ptr)
        
    }


    // *** addWithProperties() is not available because it has a varargs (...) parameter!


    /// Applies any connected attributes to the renderers in
    /// `area` by pulling the values from `tree_model`.
    @inlinable func applyAttributes<TreeIterT: TreeIterProtocol, TreeModelT: TreeModelProtocol>(treeModel: TreeModelT, iter: TreeIterT, isExpander: Bool, isExpanded: Bool) {
        
        gtk_cell_area_apply_attributes(cell_area_ptr, treeModel.tree_model_ptr, iter.tree_iter_ptr, gboolean((isExpander) ? 1 : 0), gboolean((isExpanded) ? 1 : 0))
        
    }

    /// Connects an `attribute` to apply values from `column` for the
    /// `GtkTreeModel` in use.
    @inlinable func attributeConnect<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, attribute: UnsafePointer<CChar>!, column: Int) {
        
        gtk_cell_area_attribute_connect(cell_area_ptr, renderer.cell_renderer_ptr, attribute, gint(column))
        
    }

    /// Disconnects `attribute` for the `renderer` in `area` so that
    /// attribute will no longer be updated with values from the
    /// model.
    @inlinable func attributeDisconnect<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, attribute: UnsafePointer<CChar>!) {
        
        gtk_cell_area_attribute_disconnect(cell_area_ptr, renderer.cell_renderer_ptr, attribute)
        
    }

    /// Returns the model column that an attribute has been mapped to,
    /// or -1 if the attribute is not mapped.
    @inlinable func attributeGetColumn<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, attribute: UnsafePointer<CChar>!) -> Int {
        let result = gtk_cell_area_attribute_get_column(cell_area_ptr, renderer.cell_renderer_ptr, attribute)
        let rv = Int(result)
        return rv
    }


    // *** cellGet() is not available because it has a varargs (...) parameter!


    /// Gets the value of a cell property for `renderer` in `area`.
    @inlinable func cellGetProperty<CellRendererT: CellRendererProtocol, GObjectValueT: GLibObject.ValueProtocol>(renderer: CellRendererT, propertyName: UnsafePointer<CChar>!, value: GObjectValueT) {
        
        gtk_cell_area_cell_get_property(cell_area_ptr, renderer.cell_renderer_ptr, propertyName, value.value_ptr)
        
    }

    /// Gets the values of one or more cell properties for `renderer` in `area`.
    @inlinable func cellGetValist<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, firstPropertyName: UnsafePointer<CChar>!, varArgs: CVaListPointer) {
        
        gtk_cell_area_cell_get_valist(cell_area_ptr, renderer.cell_renderer_ptr, firstPropertyName, varArgs)
        
    }


    // *** cellSet() is not available because it has a varargs (...) parameter!


    /// Sets a cell property for `renderer` in `area`.
    @inlinable func cellSetProperty<CellRendererT: CellRendererProtocol, GObjectValueT: GLibObject.ValueProtocol>(renderer: CellRendererT, propertyName: UnsafePointer<CChar>!, value: GObjectValueT) {
        
        gtk_cell_area_cell_set_property(cell_area_ptr, renderer.cell_renderer_ptr, propertyName, value.value_ptr)
        
    }

    /// Sets one or more cell properties for `renderer` in `area`.
    @inlinable func cellSetValist<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, firstPropertyName: UnsafePointer<CChar>!, varArgs: CVaListPointer) {
        
        gtk_cell_area_cell_set_valist(cell_area_ptr, renderer.cell_renderer_ptr, firstPropertyName, varArgs)
        
    }

    /// This is sometimes needed for cases where rows need to share
    /// alignments in one orientation but may be separately grouped
    /// in the opposing orientation.
    /// 
    /// For instance, `GtkIconView` creates all icons (rows) to have
    /// the same width and the cells theirin to have the same
    /// horizontal alignments. However each row of icons may have
    /// a separate collective height. `GtkIconView` uses this to
    /// request the heights of each row based on a context which
    /// was already used to request all the row widths that are
    /// to be displayed.
    @inlinable func copy<CellAreaContextT: CellAreaContextProtocol>(context: CellAreaContextT) -> CellAreaContextRef! {
        let result = gtk_cell_area_copy_context(cell_area_ptr, context.cell_area_context_ptr)
        let rv = CellAreaContextRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Creates a `GtkCellArea`Context to be used with `area` for
    /// all purposes. `GtkCellArea`Context stores geometry information
    /// for rows for which it was operated on, it is important to use
    /// the same context for the same row of data at all times (i.e.
    /// one should render and handle events with the same `GtkCellArea`Context
    /// which was used to request the size of those rows of data).
    @inlinable func createContext() -> CellAreaContextRef! {
        let result = gtk_cell_area_create_context(cell_area_ptr)
        let rv = CellAreaContextRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Delegates event handling to a `GtkCellArea`.
    @inlinable func event<CellAreaContextT: CellAreaContextProtocol, GdkEventT: Gdk.EventProtocol, GdkRectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, event: GdkEventT, cellArea: GdkRectangleT, flags: CellRendererState) -> Int {
        let result = gtk_cell_area_event(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, event.event_ptr, cellArea.rectangle_ptr, flags.value)
        let rv = Int(result)
        return rv
    }

    /// This should be called by the `area`’s owning layout widget
    /// when focus is to be passed to `area`, or moved within `area`
    /// for a given `direction` and row data.
    /// 
    /// Implementing `GtkCellArea` classes should implement this
    /// method to receive and navigate focus in its own way particular
    /// to how it lays out cells.
    @inlinable func focus(direction: GtkDirectionType) -> Bool {
        let result = gtk_cell_area_focus(cell_area_ptr, direction)
        let rv = ((result) != 0)
        return rv
    }

    /// Calls `callback` for every `GtkCellRenderer` in `area`.
    @inlinable func foreach(callback: GtkCellCallback?, callbackData: gpointer? = nil) {
        
        gtk_cell_area_foreach(cell_area_ptr, callback, callbackData)
        
    }

    /// Calls `callback` for every `GtkCellRenderer` in `area` with the
    /// allocated rectangle inside `cell_area`.
    @inlinable func foreachAlloc<CellAreaContextT: CellAreaContextProtocol, GdkRectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, cellArea: GdkRectangleT, backgroundArea: GdkRectangleT, callback: GtkCellAllocCallback?, callbackData: gpointer? = nil) {
        
        gtk_cell_area_foreach_alloc(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, cellArea.rectangle_ptr, backgroundArea.rectangle_ptr, callback, callbackData)
        
    }

    /// Derives the allocation of `renderer` inside `area` if `area`
    /// were to be renderered in `cell_area`.
    @inlinable func getCellAllocation<CellAreaContextT: CellAreaContextProtocol, CellRendererT: CellRendererProtocol, GdkRectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, renderer: CellRendererT, cellArea: GdkRectangleT, allocation: GdkRectangleT) {
        
        gtk_cell_area_get_cell_allocation(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, renderer.cell_renderer_ptr, cellArea.rectangle_ptr, allocation.rectangle_ptr)
        
    }

    /// Gets the `GtkCellRenderer` at `x` and `y` coordinates inside `area` and optionally
    /// returns the full cell allocation for it inside `cell_area`.
    @inlinable func getCellAtPosition<CellAreaContextT: CellAreaContextProtocol, GdkRectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, cellArea: GdkRectangleT, x: Int, y: Int, allocArea: GdkRectangleT?) -> CellRendererRef! {
        let result = gtk_cell_area_get_cell_at_position(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, cellArea.rectangle_ptr, gint(x), gint(y), allocArea?.rectangle_ptr)
        let rv = CellRendererRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the current `GtkTreePath` string for the currently
    /// applied `GtkTreeIter`, this is implicitly updated when
    /// `gtk_cell_area_apply_attributes()` is called and can be
    /// used to interact with renderers from `GtkCellArea`
    /// subclasses.
    @inlinable func getCurrentPathString() -> String! {
        let result = gtk_cell_area_get_current_path_string(cell_area_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets the `GtkCellEditable` widget currently used
    /// to edit the currently edited cell.
    @inlinable func getEditWidget() -> CellEditableRef! {
        let result = gtk_cell_area_get_edit_widget(cell_area_ptr)
        let rv = CellEditableRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the `GtkCellRenderer` in `area` that is currently
    /// being edited.
    @inlinable func getEditedCell() -> CellRendererRef! {
        let result = gtk_cell_area_get_edited_cell(cell_area_ptr)
        let rv = CellRendererRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Retrieves the currently focused cell for `area`
    @inlinable func getFocusCell() -> CellRendererRef! {
        let result = gtk_cell_area_get_focus_cell(cell_area_ptr)
        let rv = CellRendererRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the `GtkCellRenderer` which is expected to be focusable
    /// for which `renderer` is, or may be a sibling.
    /// 
    /// This is handy for `GtkCellArea` subclasses when handling events,
    /// after determining the renderer at the event location it can
    /// then chose to activate the focus cell for which the event
    /// cell may have been a sibling.
    @inlinable func getFocusFromSibling<CellRendererT: CellRendererProtocol>(renderer: CellRendererT) -> CellRendererRef! {
        let result = gtk_cell_area_get_focus_from_sibling(cell_area_ptr, renderer.cell_renderer_ptr)
        let rv = CellRendererRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the focus sibling cell renderers for `renderer`.
    @inlinable func getFocusSiblings<CellRendererT: CellRendererProtocol>(renderer: CellRendererT) -> GLib.ListRef! {
        let result = gtk_cell_area_get_focus_siblings(cell_area_ptr, renderer.cell_renderer_ptr)
        let rv = GLib.ListRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Retrieves a cell area’s initial minimum and natural height.
    /// 
    /// `area` will store some geometrical information in `context` along the way;
    /// when requesting sizes over an arbitrary number of rows, it’s not important
    /// to check the `minimum_height` and `natural_height` of this call but rather to
    /// consult `gtk_cell_area_context_get_preferred_height()` after a series of
    /// requests.
    @inlinable func getPreferredHeight<CellAreaContextT: CellAreaContextProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, minimumHeight: UnsafeMutablePointer<gint>! = nil, naturalHeight: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_cell_area_get_preferred_height(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, minimumHeight, naturalHeight)
        
    }

    /// Retrieves a cell area’s minimum and natural height if it would be given
    /// the specified `width`.
    /// 
    /// `area` stores some geometrical information in `context` along the way
    /// while calling `gtk_cell_area_get_preferred_width()`. It’s important to
    /// perform a series of `gtk_cell_area_get_preferred_width()` requests with
    /// `context` first and then call `gtk_cell_area_get_preferred_height_for_width()`
    /// on each cell area individually to get the height for width of each
    /// fully requested row.
    /// 
    /// If at some point, the width of a single row changes, it should be
    /// requested with `gtk_cell_area_get_preferred_width()` again and then
    /// the full width of the requested rows checked again with
    /// `gtk_cell_area_context_get_preferred_width()`.
    @inlinable func getPreferredHeightForWidth<CellAreaContextT: CellAreaContextProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, width: Int, minimumHeight: UnsafeMutablePointer<gint>! = nil, naturalHeight: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_cell_area_get_preferred_height_for_width(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, gint(width), minimumHeight, naturalHeight)
        
    }

    /// Retrieves a cell area’s initial minimum and natural width.
    /// 
    /// `area` will store some geometrical information in `context` along the way;
    /// when requesting sizes over an arbitrary number of rows, it’s not important
    /// to check the `minimum_width` and `natural_width` of this call but rather to
    /// consult `gtk_cell_area_context_get_preferred_width()` after a series of
    /// requests.
    @inlinable func getPreferredWidth<CellAreaContextT: CellAreaContextProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, minimumWidth: UnsafeMutablePointer<gint>! = nil, naturalWidth: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_cell_area_get_preferred_width(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, minimumWidth, naturalWidth)
        
    }

    /// Retrieves a cell area’s minimum and natural width if it would be given
    /// the specified `height`.
    /// 
    /// `area` stores some geometrical information in `context` along the way
    /// while calling `gtk_cell_area_get_preferred_height()`. It’s important to
    /// perform a series of `gtk_cell_area_get_preferred_height()` requests with
    /// `context` first and then call `gtk_cell_area_get_preferred_width_for_height()`
    /// on each cell area individually to get the height for width of each
    /// fully requested row.
    /// 
    /// If at some point, the height of a single row changes, it should be
    /// requested with `gtk_cell_area_get_preferred_height()` again and then
    /// the full height of the requested rows checked again with
    /// `gtk_cell_area_context_get_preferred_height()`.
    @inlinable func getPreferredWidthForHeight<CellAreaContextT: CellAreaContextProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, height: Int, minimumWidth: UnsafeMutablePointer<gint>! = nil, naturalWidth: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_cell_area_get_preferred_width_for_height(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, gint(height), minimumWidth, naturalWidth)
        
    }

    /// Gets whether the area prefers a height-for-width layout
    /// or a width-for-height layout.
    @inlinable func getRequestMode() -> GtkSizeRequestMode {
        let result = gtk_cell_area_get_request_mode(cell_area_ptr)
        let rv = result
        return rv
    }

    /// Checks if `area` contains `renderer`.
    @inlinable func has<CellRendererT: CellRendererProtocol>(renderer: CellRendererT) -> Bool {
        let result = gtk_cell_area_has_renderer(cell_area_ptr, renderer.cell_renderer_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// This is a convenience function for `GtkCellArea` implementations
    /// to get the inner area where a given `GtkCellRenderer` will be
    /// rendered. It removes any padding previously added by `gtk_cell_area_request_renderer()`.
    @inlinable func innerCellArea<GdkRectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(widget: WidgetT, cellArea: GdkRectangleT, innerArea: GdkRectangleT) {
        
        gtk_cell_area_inner_cell_area(cell_area_ptr, widget.widget_ptr, cellArea.rectangle_ptr, innerArea.rectangle_ptr)
        
    }

    /// Returns whether `sibling` is one of `renderer`’s focus siblings
    /// (see `gtk_cell_area_add_focus_sibling()`).
    @inlinable func isFocusSibling<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, sibling: CellRendererT) -> Bool {
        let result = gtk_cell_area_is_focus_sibling(cell_area_ptr, renderer.cell_renderer_ptr, sibling.cell_renderer_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Removes `renderer` from `area`.
    @inlinable func remove<CellRendererT: CellRendererProtocol>(renderer: CellRendererT) {
        
        gtk_cell_area_remove(cell_area_ptr, renderer.cell_renderer_ptr)
        
    }

    /// Removes `sibling` from `renderer`’s focus sibling list
    /// (see `gtk_cell_area_add_focus_sibling()`).
    @inlinable func removeFocusSibling<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, sibling: CellRendererT) {
        
        gtk_cell_area_remove_focus_sibling(cell_area_ptr, renderer.cell_renderer_ptr, sibling.cell_renderer_ptr)
        
    }

    /// This is a convenience function for `GtkCellArea` implementations
    /// to request size for cell renderers. It’s important to use this
    /// function to request size and then use `gtk_cell_area_inner_cell_area()`
    /// at render and event time since this function will add padding
    /// around the cell for focus painting.
    @inlinable func request<CellRendererT: CellRendererProtocol, WidgetT: WidgetProtocol>(renderer: CellRendererT, orientation: GtkOrientation, widget: WidgetT, `for` size: Int, minimumSize: UnsafeMutablePointer<gint>! = nil, naturalSize: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_cell_area_request_renderer(cell_area_ptr, renderer.cell_renderer_ptr, orientation, widget.widget_ptr, gint(size), minimumSize, naturalSize)
        
    }

    /// Explicitly sets the currently focused cell to `renderer`.
    /// 
    /// This is generally called by implementations of
    /// ``GtkCellAreaClass.focus()`` or ``GtkCellAreaClass.event()``,
    /// however it can also be used to implement functions such
    /// as `gtk_tree_view_set_cursor_on_cell()`.
    @inlinable func setFocusCell(renderer: CellRendererRef? = nil) {
            
        gtk_cell_area_set_focus_cell(cell_area_ptr, renderer?.cell_renderer_ptr)
            
    }
    /// Explicitly sets the currently focused cell to `renderer`.
    /// 
    /// This is generally called by implementations of
    /// ``GtkCellAreaClass.focus()`` or ``GtkCellAreaClass.event()``,
    /// however it can also be used to implement functions such
    /// as `gtk_tree_view_set_cursor_on_cell()`.
    @inlinable func setFocusCell<CellRendererT: CellRendererProtocol>(renderer: CellRendererT?) {
        
        gtk_cell_area_set_focus_cell(cell_area_ptr, renderer?.cell_renderer_ptr)
        
    }

    /// Snapshots `area`’s cells according to `area`’s layout onto at
    /// the given coordinates.
    @inlinable func snapshot<CellAreaContextT: CellAreaContextProtocol, GdkRectangleT: Gdk.RectangleProtocol, SnapshotT: SnapshotProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, snapshot: SnapshotT, backgroundArea: GdkRectangleT, cellArea: GdkRectangleT, flags: CellRendererState, paintFocus: Bool) {
        
        gtk_cell_area_snapshot(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, snapshot.snapshot_ptr, backgroundArea.rectangle_ptr, cellArea.rectangle_ptr, flags.value, gboolean((paintFocus) ? 1 : 0))
        
    }

    /// Explicitly stops the editing of the currently edited cell.
    /// 
    /// If `canceled` is `true`, the currently edited cell renderer
    /// will emit the `editing-canceled` signal, otherwise the
    /// the `editing-done` signal will be emitted on the current
    /// edit widget.
    /// 
    /// See `gtk_cell_area_get_edited_cell()` and `gtk_cell_area_get_edit_widget()`.
    @inlinable func stopEditing(canceled: Bool) {
        
        gtk_cell_area_stop_editing(cell_area_ptr, gboolean((canceled) ? 1 : 0))
        
    }
    /// Gets the current `GtkTreePath` string for the currently
    /// applied `GtkTreeIter`, this is implicitly updated when
    /// `gtk_cell_area_apply_attributes()` is called and can be
    /// used to interact with renderers from `GtkCellArea`
    /// subclasses.
    @inlinable var currentPathString: String! {
        /// Gets the current `GtkTreePath` string for the currently
        /// applied `GtkTreeIter`, this is implicitly updated when
        /// `gtk_cell_area_apply_attributes()` is called and can be
        /// used to interact with renderers from `GtkCellArea`
        /// subclasses.
        get {
            let result = gtk_cell_area_get_current_path_string(cell_area_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// Gets the `GtkCellEditable` widget currently used
    /// to edit the currently edited cell.
    @inlinable var editWidget: CellEditableRef! {
        /// Gets the `GtkCellEditable` widget currently used
        /// to edit the currently edited cell.
        get {
            let result = gtk_cell_area_get_edit_widget(cell_area_ptr)
        let rv = CellEditableRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Gets the `GtkCellRenderer` in `area` that is currently
    /// being edited.
    @inlinable var editedCell: CellRendererRef! {
        /// Gets the `GtkCellRenderer` in `area` that is currently
        /// being edited.
        get {
            let result = gtk_cell_area_get_edited_cell(cell_area_ptr)
        let rv = CellRendererRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Retrieves the currently focused cell for `area`
    @inlinable var focusCell: CellRendererRef! {
        /// Retrieves the currently focused cell for `area`
        get {
            let result = gtk_cell_area_get_focus_cell(cell_area_ptr)
        let rv = CellRendererRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Explicitly sets the currently focused cell to `renderer`.
        /// 
        /// This is generally called by implementations of
        /// ``GtkCellAreaClass.focus()`` or ``GtkCellAreaClass.event()``,
        /// however it can also be used to implement functions such
        /// as `gtk_tree_view_set_cursor_on_cell()`.
        nonmutating set {
            gtk_cell_area_set_focus_cell(cell_area_ptr, UnsafeMutablePointer<GtkCellRenderer>(newValue?.cell_renderer_ptr))
        }
    }

    /// Returns whether the area can do anything when activated,
    /// after applying new attributes to `area`.
    @inlinable var isActivatable: Bool {
        /// Returns whether the area can do anything when activated,
        /// after applying new attributes to `area`.
        get {
            let result = gtk_cell_area_is_activatable(cell_area_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// Gets whether the area prefers a height-for-width layout
    /// or a width-for-height layout.
    @inlinable var requestMode: GtkSizeRequestMode {
        /// Gets whether the area prefers a height-for-width layout
        /// or a width-for-height layout.
        get {
            let result = gtk_cell_area_get_request_mode(cell_area_ptr)
        let rv = result
            return rv
        }
    }

    // var parentInstance is unavailable because parent_instance is private

}



// MARK: - CellAreaBox Class

/// A cell area that renders GtkCellRenderers into a row or a column
/// 
/// The `GtkCellAreaBox` renders cell renderers into a row or a column
/// depending on its `GtkOrientation`.
/// 
/// GtkCellAreaBox uses a notion of packing. Packing
/// refers to adding cell renderers with reference to a particular position
/// in a `GtkCellAreaBox`. There are two reference positions: the
/// start and the end of the box.
/// When the `GtkCellAreaBox` is oriented in the `GTK_ORIENTATION_VERTICAL`
/// orientation, the start is defined as the top of the box and the end is
/// defined as the bottom. In the `GTK_ORIENTATION_HORIZONTAL` orientation
/// start is defined as the left side and the end is defined as the right
/// side.
/// 
/// Alignments of `GtkCellRenderer`s rendered in adjacent rows can be
/// configured by configuring the `GtkCellAreaBox` align child cell property
/// with `gtk_cell_area_cell_set_property()` or by specifying the "align"
/// argument to `gtk_cell_area_box_pack_start()` and `gtk_cell_area_box_pack_end()`.
///
/// The `CellAreaBoxProtocol` protocol exposes the methods and properties of an underlying `GtkCellAreaBox` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellAreaBox`.
/// Alternatively, use `CellAreaBoxRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellAreaBoxProtocol: CellAreaProtocol, OrientableProtocol {
        /// Untyped pointer to the underlying `GtkCellAreaBox` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellAreaBox` instance.
    var cell_area_box_ptr: UnsafeMutablePointer<GtkCellAreaBox>! { get }

    /// Required Initialiser for types conforming to `CellAreaBoxProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A cell area that renders GtkCellRenderers into a row or a column
/// 
/// The `GtkCellAreaBox` renders cell renderers into a row or a column
/// depending on its `GtkOrientation`.
/// 
/// GtkCellAreaBox uses a notion of packing. Packing
/// refers to adding cell renderers with reference to a particular position
/// in a `GtkCellAreaBox`. There are two reference positions: the
/// start and the end of the box.
/// When the `GtkCellAreaBox` is oriented in the `GTK_ORIENTATION_VERTICAL`
/// orientation, the start is defined as the top of the box and the end is
/// defined as the bottom. In the `GTK_ORIENTATION_HORIZONTAL` orientation
/// start is defined as the left side and the end is defined as the right
/// side.
/// 
/// Alignments of `GtkCellRenderer`s rendered in adjacent rows can be
/// configured by configuring the `GtkCellAreaBox` align child cell property
/// with `gtk_cell_area_cell_set_property()` or by specifying the "align"
/// argument to `gtk_cell_area_box_pack_start()` and `gtk_cell_area_box_pack_end()`.
///
/// The `CellAreaBoxRef` type acts as a lightweight Swift reference to an underlying `GtkCellAreaBox` instance.
/// It exposes methods that can operate on this data type through `CellAreaBoxProtocol` conformance.
/// Use `CellAreaBoxRef` only as an `unowned` reference to an existing `GtkCellAreaBox` instance.
///
public struct CellAreaBoxRef: CellAreaBoxProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellAreaBox` instance.
    /// For type-safe access, use the generated, typed pointer `cell_area_box_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellAreaBoxRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellAreaBox>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellAreaBox>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellAreaBox>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellAreaBox>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellAreaBoxProtocol`
    @inlinable init<T: CellAreaBoxProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellAreaBoxProtocol>(_ other: T) -> CellAreaBoxRef { CellAreaBoxRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellAreaBox`.
    @inlinable init() {
            let result = gtk_cell_area_box_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// A cell area that renders GtkCellRenderers into a row or a column
/// 
/// The `GtkCellAreaBox` renders cell renderers into a row or a column
/// depending on its `GtkOrientation`.
/// 
/// GtkCellAreaBox uses a notion of packing. Packing
/// refers to adding cell renderers with reference to a particular position
/// in a `GtkCellAreaBox`. There are two reference positions: the
/// start and the end of the box.
/// When the `GtkCellAreaBox` is oriented in the `GTK_ORIENTATION_VERTICAL`
/// orientation, the start is defined as the top of the box and the end is
/// defined as the bottom. In the `GTK_ORIENTATION_HORIZONTAL` orientation
/// start is defined as the left side and the end is defined as the right
/// side.
/// 
/// Alignments of `GtkCellRenderer`s rendered in adjacent rows can be
/// configured by configuring the `GtkCellAreaBox` align child cell property
/// with `gtk_cell_area_cell_set_property()` or by specifying the "align"
/// argument to `gtk_cell_area_box_pack_start()` and `gtk_cell_area_box_pack_end()`.
///
/// The `CellAreaBox` type acts as a reference-counted owner of an underlying `GtkCellAreaBox` instance.
/// It provides the methods that can operate on this data type through `CellAreaBoxProtocol` conformance.
/// Use `CellAreaBox` as a strong reference or owner of a `GtkCellAreaBox` instance.
///
open class CellAreaBox: CellArea, CellAreaBoxProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellAreaBox>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellAreaBox>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellAreaBox>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellAreaBox>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellAreaBox`.
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellAreaBox>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellAreaBoxProtocol`
    /// Will retain `GtkCellAreaBox`.
    /// - Parameter other: an instance of a related type that implements `CellAreaBoxProtocol`
    @inlinable public init<T: CellAreaBoxProtocol>(cellAreaBox other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellAreaBox`.
    @inlinable public init() {
            let result = gtk_cell_area_box_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CellAreaBoxPropertyName: String, PropertyNameProtocol {
    /// The widget currently editing the edited cell
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case editWidget = "edit-widget"
    /// The cell in the area that is currently edited
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case editedCell = "edited-cell"
    /// The cell in the area that currently has focus
    case focusCell = "focus-cell"
    /// The amount of space to reserve between cells.
    case spacing = "spacing"
}

public extension CellAreaBoxProtocol {
    /// Bind a `CellAreaBoxPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellAreaBoxPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellAreaBox property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellAreaBoxPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellAreaBox property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellAreaBoxPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellAreaBoxSignalName: String, SignalNameProtocol {
    /// Indicates that editing has started on `renderer` and that `editable`
    /// should be added to the owning cell-layouting widget at `cell_area`.
    case addEditable = "add-editable"
    /// This signal is emitted whenever applying attributes to `area` from `model`
    case applyAttributes = "apply-attributes"
    /// Indicates that focus changed on this `area`. This signal
    /// is emitted either as a result of focus handling or event
    /// handling.
    /// 
    /// It's possible that the signal is emitted even if the
    /// currently focused renderer did not change, this is
    /// because focus may change to the same renderer in the
    /// same cell area for a different row of data.
    case focusChanged = "focus-changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Indicates that editing finished on `renderer` and that `editable`
    /// should be removed from the owning cell-layouting widget.
    case removeEditable = "remove-editable"
    /// The widget currently editing the edited cell
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case notifyEditWidget = "notify::edit-widget"
    /// The cell in the area that is currently edited
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case notifyEditedCell = "notify::edited-cell"
    /// The cell in the area that currently has focus
    case notifyFocusCell = "notify::focus-cell"
    /// The amount of space to reserve between cells.
    case notifySpacing = "notify::spacing"
}

// MARK: CellAreaBox has no signals
// MARK: CellAreaBox Class: CellAreaBoxProtocol extension (methods and fields)
public extension CellAreaBoxProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellAreaBox` instance.
    @inlinable var cell_area_box_ptr: UnsafeMutablePointer<GtkCellAreaBox>! { return ptr?.assumingMemoryBound(to: GtkCellAreaBox.self) }

    /// Gets the spacing added between cell renderers.
    @inlinable func getSpacing() -> Int {
        let result = gtk_cell_area_box_get_spacing(cell_area_box_ptr)
        let rv = Int(result)
        return rv
    }

    /// Adds `renderer` to `box`, packed with reference to the end of `box`.
    /// 
    /// The `renderer` is packed after (away from end of) any other
    /// `GtkCellRenderer` packed with reference to the end of `box`.
    @inlinable func packEnd<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, expand: Bool, align: Bool, fixed: Bool) {
        
        gtk_cell_area_box_pack_end(cell_area_box_ptr, renderer.cell_renderer_ptr, gboolean((expand) ? 1 : 0), gboolean((align) ? 1 : 0), gboolean((fixed) ? 1 : 0))
        
    }

    /// Adds `renderer` to `box`, packed with reference to the start of `box`.
    /// 
    /// The `renderer` is packed after any other `GtkCellRenderer` packed
    /// with reference to the start of `box`.
    @inlinable func packStart<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, expand: Bool, align: Bool, fixed: Bool) {
        
        gtk_cell_area_box_pack_start(cell_area_box_ptr, renderer.cell_renderer_ptr, gboolean((expand) ? 1 : 0), gboolean((align) ? 1 : 0), gboolean((fixed) ? 1 : 0))
        
    }

    /// Sets the spacing to add between cell renderers in `box`.
    @inlinable func set(spacing: Int) {
        
        gtk_cell_area_box_set_spacing(cell_area_box_ptr, gint(spacing))
        
    }
    /// The amount of space to reserve between cells.
    @inlinable var spacing: Int {
        /// Gets the spacing added between cell renderers.
        get {
            let result = gtk_cell_area_box_get_spacing(cell_area_box_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the spacing to add between cell renderers in `box`.
        nonmutating set {
            gtk_cell_area_box_set_spacing(cell_area_box_ptr, gint(newValue))
        }
    }


}



// MARK: - CellAreaContext Class

/// Stores geometrical information for a series of rows in a GtkCellArea
/// 
/// The `GtkCellAreaContext` object is created by a given `GtkCellArea`
/// implementation via its ``GtkCellAreaClass.create_context()`` virtual
/// method and is used to store cell sizes and alignments for a series of
/// `GtkTreeModel` rows that are requested and rendered in the same context.
/// 
/// `GtkCellLayout` widgets can create any number of contexts in which to
/// request and render groups of data rows. However, it’s important that the
/// same context which was used to request sizes for a given `GtkTreeModel`
/// row also be used for the same row when calling other `GtkCellArea` APIs
/// such as `gtk_cell_area_render()` and `gtk_cell_area_event()`.
///
/// The `CellAreaContextProtocol` protocol exposes the methods and properties of an underlying `GtkCellAreaContext` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellAreaContext`.
/// Alternatively, use `CellAreaContextRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellAreaContextProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkCellAreaContext` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellAreaContext` instance.
    var cell_area_context_ptr: UnsafeMutablePointer<GtkCellAreaContext>! { get }

    /// Required Initialiser for types conforming to `CellAreaContextProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Stores geometrical information for a series of rows in a GtkCellArea
/// 
/// The `GtkCellAreaContext` object is created by a given `GtkCellArea`
/// implementation via its ``GtkCellAreaClass.create_context()`` virtual
/// method and is used to store cell sizes and alignments for a series of
/// `GtkTreeModel` rows that are requested and rendered in the same context.
/// 
/// `GtkCellLayout` widgets can create any number of contexts in which to
/// request and render groups of data rows. However, it’s important that the
/// same context which was used to request sizes for a given `GtkTreeModel`
/// row also be used for the same row when calling other `GtkCellArea` APIs
/// such as `gtk_cell_area_render()` and `gtk_cell_area_event()`.
///
/// The `CellAreaContextRef` type acts as a lightweight Swift reference to an underlying `GtkCellAreaContext` instance.
/// It exposes methods that can operate on this data type through `CellAreaContextProtocol` conformance.
/// Use `CellAreaContextRef` only as an `unowned` reference to an existing `GtkCellAreaContext` instance.
///
public struct CellAreaContextRef: CellAreaContextProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellAreaContext` instance.
    /// For type-safe access, use the generated, typed pointer `cell_area_context_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellAreaContextRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellAreaContext>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellAreaContext>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellAreaContext>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellAreaContext>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellAreaContextProtocol`
    @inlinable init<T: CellAreaContextProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellAreaContextProtocol>(_ other: T) -> CellAreaContextRef { CellAreaContextRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// Stores geometrical information for a series of rows in a GtkCellArea
/// 
/// The `GtkCellAreaContext` object is created by a given `GtkCellArea`
/// implementation via its ``GtkCellAreaClass.create_context()`` virtual
/// method and is used to store cell sizes and alignments for a series of
/// `GtkTreeModel` rows that are requested and rendered in the same context.
/// 
/// `GtkCellLayout` widgets can create any number of contexts in which to
/// request and render groups of data rows. However, it’s important that the
/// same context which was used to request sizes for a given `GtkTreeModel`
/// row also be used for the same row when calling other `GtkCellArea` APIs
/// such as `gtk_cell_area_render()` and `gtk_cell_area_event()`.
///
/// The `CellAreaContext` type acts as a reference-counted owner of an underlying `GtkCellAreaContext` instance.
/// It provides the methods that can operate on this data type through `CellAreaContextProtocol` conformance.
/// Use `CellAreaContext` as a strong reference or owner of a `GtkCellAreaContext` instance.
///
open class CellAreaContext: GLibObject.Object, CellAreaContextProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellAreaContext>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellAreaContext>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellAreaContext>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellAreaContext>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellAreaContext`.
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellAreaContext>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellAreaContextProtocol`
    /// Will retain `GtkCellAreaContext`.
    /// - Parameter other: an instance of a related type that implements `CellAreaContextProtocol`
    @inlinable public init<T: CellAreaContextProtocol>(cellAreaContext other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum CellAreaContextPropertyName: String, PropertyNameProtocol {
    /// The `GtkCellArea` this context was created by
    case area = "area"
    /// The minimum height for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_height()`.
    case minimumHeight = "minimum-height"
    /// The minimum width for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_width()`.
    case minimumWidth = "minimum-width"
    /// The natural height for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_height()`.
    case naturalHeight = "natural-height"
    /// The natural width for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_width()`.
    case naturalWidth = "natural-width"
}

public extension CellAreaContextProtocol {
    /// Bind a `CellAreaContextPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellAreaContextPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellAreaContext property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellAreaContextPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellAreaContext property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellAreaContextPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellAreaContextSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `GtkCellArea` this context was created by
    case notifyArea = "notify::area"
    /// The minimum height for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_height()`.
    case notifyMinimumHeight = "notify::minimum-height"
    /// The minimum width for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_width()`.
    case notifyMinimumWidth = "notify::minimum-width"
    /// The natural height for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_height()`.
    case notifyNaturalHeight = "notify::natural-height"
    /// The natural width for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_width()`.
    case notifyNaturalWidth = "notify::natural-width"
}

// MARK: CellAreaContext has no signals
// MARK: CellAreaContext Class: CellAreaContextProtocol extension (methods and fields)
public extension CellAreaContextProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellAreaContext` instance.
    @inlinable var cell_area_context_ptr: UnsafeMutablePointer<GtkCellAreaContext>! { return ptr?.assumingMemoryBound(to: GtkCellAreaContext.self) }

    /// Allocates a width and/or a height for all rows which are to be
    /// rendered with `context`.
    /// 
    /// Usually allocation is performed only horizontally or sometimes
    /// vertically since a group of rows are usually rendered side by
    /// side vertically or horizontally and share either the same width
    /// or the same height. Sometimes they are allocated in both horizontal
    /// and vertical orientations producing a homogeneous effect of the
    /// rows. This is generally the case for `GtkTreeView` when
    /// `GtkTreeView:fixed-height-mode` is enabled.
    @inlinable func allocate(width: Int, height: Int) {
        
        gtk_cell_area_context_allocate(cell_area_context_ptr, gint(width), gint(height))
        
    }

    /// Fetches the current allocation size for `context`.
    /// 
    /// If the context was not allocated in width or height, or if the
    /// context was recently reset with `gtk_cell_area_context_reset()`,
    /// the returned value will be -1.
    @inlinable func getAllocation(width: UnsafeMutablePointer<gint>! = nil, height: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_cell_area_context_get_allocation(cell_area_context_ptr, width, height)
        
    }

    /// Fetches the `GtkCellArea` this `context` was created by.
    /// 
    /// This is generally unneeded by layouting widgets; however,
    /// it is important for the context implementation itself to
    /// fetch information about the area it is being used for.
    /// 
    /// For instance at ``GtkCellAreaContextClass.allocate()`` time
    /// it’s important to know details about any cell spacing
    /// that the `GtkCellArea` is configured with in order to
    /// compute a proper allocation.
    @inlinable func getArea() -> CellAreaRef! {
        let result = gtk_cell_area_context_get_area(cell_area_context_ptr)
        let rv = CellAreaRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the accumulative preferred height for all rows which have been
    /// requested with this context.
    /// 
    /// After `gtk_cell_area_context_reset()` is called and/or before ever
    /// requesting the size of a `GtkCellArea`, the returned values are 0.
    @inlinable func getPreferredHeight(minimumHeight: UnsafeMutablePointer<gint>! = nil, naturalHeight: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_cell_area_context_get_preferred_height(cell_area_context_ptr, minimumHeight, naturalHeight)
        
    }

    /// Gets the accumulative preferred height for `width` for all rows
    /// which have been requested for the same said `width` with this context.
    /// 
    /// After `gtk_cell_area_context_reset()` is called and/or before ever
    /// requesting the size of a `GtkCellArea`, the returned values are -1.
    @inlinable func getPreferredHeightFor(width: Int, minimumHeight: UnsafeMutablePointer<gint>! = nil, naturalHeight: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_cell_area_context_get_preferred_height_for_width(cell_area_context_ptr, gint(width), minimumHeight, naturalHeight)
        
    }

    /// Gets the accumulative preferred width for all rows which have been
    /// requested with this context.
    /// 
    /// After `gtk_cell_area_context_reset()` is called and/or before ever
    /// requesting the size of a `GtkCellArea`, the returned values are 0.
    @inlinable func getPreferredWidth(minimumWidth: UnsafeMutablePointer<gint>! = nil, naturalWidth: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_cell_area_context_get_preferred_width(cell_area_context_ptr, minimumWidth, naturalWidth)
        
    }

    /// Gets the accumulative preferred width for `height` for all rows which
    /// have been requested for the same said `height` with this context.
    /// 
    /// After `gtk_cell_area_context_reset()` is called and/or before ever
    /// requesting the size of a `GtkCellArea`, the returned values are -1.
    @inlinable func getPreferredWidthFor(height: Int, minimumWidth: UnsafeMutablePointer<gint>! = nil, naturalWidth: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_cell_area_context_get_preferred_width_for_height(cell_area_context_ptr, gint(height), minimumWidth, naturalWidth)
        
    }

    /// Causes the minimum and/or natural height to grow if the new
    /// proposed sizes exceed the current minimum and natural height.
    /// 
    /// This is used by `GtkCellAreaContext` implementations during
    /// the request process over a series of `GtkTreeModel` rows to
    /// progressively push the requested height over a series of
    /// `gtk_cell_area_get_preferred_height()` requests.
    @inlinable func pushPreferredHeight(minimumHeight: Int, naturalHeight: Int) {
        
        gtk_cell_area_context_push_preferred_height(cell_area_context_ptr, gint(minimumHeight), gint(naturalHeight))
        
    }

    /// Causes the minimum and/or natural width to grow if the new
    /// proposed sizes exceed the current minimum and natural width.
    /// 
    /// This is used by `GtkCellAreaContext` implementations during
    /// the request process over a series of `GtkTreeModel` rows to
    /// progressively push the requested width over a series of
    /// `gtk_cell_area_get_preferred_width()` requests.
    @inlinable func pushPreferredWidth(minimumWidth: Int, naturalWidth: Int) {
        
        gtk_cell_area_context_push_preferred_width(cell_area_context_ptr, gint(minimumWidth), gint(naturalWidth))
        
    }

    /// Resets any previously cached request and allocation
    /// data.
    /// 
    /// When underlying `GtkTreeModel` data changes its
    /// important to reset the context if the content
    /// size is allowed to shrink. If the content size
    /// is only allowed to grow (this is usually an option
    /// for views rendering large data stores as a measure
    /// of optimization), then only the row that changed
    /// or was inserted needs to be (re)requested with
    /// `gtk_cell_area_get_preferred_width()`.
    /// 
    /// When the new overall size of the context requires
    /// that the allocated size changes (or whenever this
    /// allocation changes at all), the variable row
    /// sizes need to be re-requested for every row.
    /// 
    /// For instance, if the rows are displayed all with
    /// the same width from top to bottom then a change
    /// in the allocated width necessitates a recalculation
    /// of all the displayed row heights using
    /// `gtk_cell_area_get_preferred_height_for_width()`.
    @inlinable func reset() {
        
        gtk_cell_area_context_reset(cell_area_context_ptr)
        
    }
    /// The `GtkCellArea` this context was created by
    @inlinable var area: CellAreaRef! {
        /// Fetches the `GtkCellArea` this `context` was created by.
        /// 
        /// This is generally unneeded by layouting widgets; however,
        /// it is important for the context implementation itself to
        /// fetch information about the area it is being used for.
        /// 
        /// For instance at ``GtkCellAreaContextClass.allocate()`` time
        /// it’s important to know details about any cell spacing
        /// that the `GtkCellArea` is configured with in order to
        /// compute a proper allocation.
        get {
            let result = gtk_cell_area_context_get_area(cell_area_context_ptr)
        let rv = CellAreaRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    // var parentInstance is unavailable because parent_instance is private

}



// MARK: - CellRenderer Class

/// An object for rendering a single cell
/// 
/// The `GtkCellRenderer` is a base class of a set of objects used for
/// rendering a cell to a `cairo_t`.  These objects are used primarily by
/// the `GtkTreeView` widget, though they aren’t tied to them in any
/// specific way.  It is worth noting that `GtkCellRenderer` is not a
/// `GtkWidget` and cannot be treated as such.
/// 
/// The primary use of a `GtkCellRenderer` is for drawing a certain graphical
/// elements on a `cairo_t`. Typically, one cell renderer is used to
/// draw many cells on the screen.  To this extent, it isn’t expected that a
/// CellRenderer keep any permanent state around.  Instead, any state is set
/// just prior to use using `GObject`s property system.  Then, the
/// cell is measured using `gtk_cell_renderer_get_preferred_size()`. Finally, the cell
/// is rendered in the correct location using `gtk_cell_renderer_snapshot()`.
/// 
/// There are a number of rules that must be followed when writing a new
/// `GtkCellRenderer`.  First and foremost, it’s important that a certain set
/// of properties will always yield a cell renderer of the same size,
/// barring a style change. The `GtkCellRenderer` also has a number of
/// generic properties that are expected to be honored by all children.
/// 
/// Beyond merely rendering a cell, cell renderers can optionally
/// provide active user interface elements. A cell renderer can be
/// “activatable” like `GtkCellRenderer`Toggle,
/// which toggles when it gets activated by a mouse click, or it can be
/// “editable” like `GtkCellRenderer`Text, which
/// allows the user to edit the text using a widget implementing the
/// `GtkCellEditable` interface, e.g. `GtkEntry`.
/// To make a cell renderer activatable or editable, you have to
/// implement the `GtkCellRenderer`Class.activate or
/// `GtkCellRenderer`Class.start_editing virtual functions, respectively.
/// 
/// Many properties of `GtkCellRenderer` and its subclasses have a
/// corresponding “set” property, e.g. “cell-background-set” corresponds
/// to “cell-background”. These “set” properties reflect whether a property
/// has been set or not. You should not set them independently.
///
/// The `CellRendererProtocol` protocol exposes the methods and properties of an underlying `GtkCellRenderer` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRenderer`.
/// Alternatively, use `CellRendererRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererProtocol: GLibObject.InitiallyUnownedProtocol {
        /// Untyped pointer to the underlying `GtkCellRenderer` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRenderer` instance.
    var cell_renderer_ptr: UnsafeMutablePointer<GtkCellRenderer>! { get }

    /// Required Initialiser for types conforming to `CellRendererProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// An object for rendering a single cell
/// 
/// The `GtkCellRenderer` is a base class of a set of objects used for
/// rendering a cell to a `cairo_t`.  These objects are used primarily by
/// the `GtkTreeView` widget, though they aren’t tied to them in any
/// specific way.  It is worth noting that `GtkCellRenderer` is not a
/// `GtkWidget` and cannot be treated as such.
/// 
/// The primary use of a `GtkCellRenderer` is for drawing a certain graphical
/// elements on a `cairo_t`. Typically, one cell renderer is used to
/// draw many cells on the screen.  To this extent, it isn’t expected that a
/// CellRenderer keep any permanent state around.  Instead, any state is set
/// just prior to use using `GObject`s property system.  Then, the
/// cell is measured using `gtk_cell_renderer_get_preferred_size()`. Finally, the cell
/// is rendered in the correct location using `gtk_cell_renderer_snapshot()`.
/// 
/// There are a number of rules that must be followed when writing a new
/// `GtkCellRenderer`.  First and foremost, it’s important that a certain set
/// of properties will always yield a cell renderer of the same size,
/// barring a style change. The `GtkCellRenderer` also has a number of
/// generic properties that are expected to be honored by all children.
/// 
/// Beyond merely rendering a cell, cell renderers can optionally
/// provide active user interface elements. A cell renderer can be
/// “activatable” like `GtkCellRenderer`Toggle,
/// which toggles when it gets activated by a mouse click, or it can be
/// “editable” like `GtkCellRenderer`Text, which
/// allows the user to edit the text using a widget implementing the
/// `GtkCellEditable` interface, e.g. `GtkEntry`.
/// To make a cell renderer activatable or editable, you have to
/// implement the `GtkCellRenderer`Class.activate or
/// `GtkCellRenderer`Class.start_editing virtual functions, respectively.
/// 
/// Many properties of `GtkCellRenderer` and its subclasses have a
/// corresponding “set” property, e.g. “cell-background-set” corresponds
/// to “cell-background”. These “set” properties reflect whether a property
/// has been set or not. You should not set them independently.
///
/// The `CellRendererRef` type acts as a lightweight Swift reference to an underlying `GtkCellRenderer` instance.
/// It exposes methods that can operate on this data type through `CellRendererProtocol` conformance.
/// Use `CellRendererRef` only as an `unowned` reference to an existing `GtkCellRenderer` instance.
///
public struct CellRendererRef: CellRendererProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellRenderer` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRenderer>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRenderer>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRenderer>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRenderer>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererProtocol`
    @inlinable init<T: CellRendererProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellRendererProtocol>(_ other: T) -> CellRendererRef { CellRendererRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// An object for rendering a single cell
/// 
/// The `GtkCellRenderer` is a base class of a set of objects used for
/// rendering a cell to a `cairo_t`.  These objects are used primarily by
/// the `GtkTreeView` widget, though they aren’t tied to them in any
/// specific way.  It is worth noting that `GtkCellRenderer` is not a
/// `GtkWidget` and cannot be treated as such.
/// 
/// The primary use of a `GtkCellRenderer` is for drawing a certain graphical
/// elements on a `cairo_t`. Typically, one cell renderer is used to
/// draw many cells on the screen.  To this extent, it isn’t expected that a
/// CellRenderer keep any permanent state around.  Instead, any state is set
/// just prior to use using `GObject`s property system.  Then, the
/// cell is measured using `gtk_cell_renderer_get_preferred_size()`. Finally, the cell
/// is rendered in the correct location using `gtk_cell_renderer_snapshot()`.
/// 
/// There are a number of rules that must be followed when writing a new
/// `GtkCellRenderer`.  First and foremost, it’s important that a certain set
/// of properties will always yield a cell renderer of the same size,
/// barring a style change. The `GtkCellRenderer` also has a number of
/// generic properties that are expected to be honored by all children.
/// 
/// Beyond merely rendering a cell, cell renderers can optionally
/// provide active user interface elements. A cell renderer can be
/// “activatable” like `GtkCellRenderer`Toggle,
/// which toggles when it gets activated by a mouse click, or it can be
/// “editable” like `GtkCellRenderer`Text, which
/// allows the user to edit the text using a widget implementing the
/// `GtkCellEditable` interface, e.g. `GtkEntry`.
/// To make a cell renderer activatable or editable, you have to
/// implement the `GtkCellRenderer`Class.activate or
/// `GtkCellRenderer`Class.start_editing virtual functions, respectively.
/// 
/// Many properties of `GtkCellRenderer` and its subclasses have a
/// corresponding “set” property, e.g. “cell-background-set” corresponds
/// to “cell-background”. These “set” properties reflect whether a property
/// has been set or not. You should not set them independently.
///
/// The `CellRenderer` type acts as a reference-counted owner of an underlying `GtkCellRenderer` instance.
/// It provides the methods that can operate on this data type through `CellRendererProtocol` conformance.
/// Use `CellRenderer` as a strong reference or owner of a `GtkCellRenderer` instance.
///
open class CellRenderer: GLibObject.InitiallyUnowned, CellRendererProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRenderer>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRenderer>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRenderer>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRenderer>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRenderer`.
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRenderer>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererProtocol`
    /// Will retain `GtkCellRenderer`.
    /// - Parameter other: an instance of a related type that implements `CellRendererProtocol`
    @inlinable public init<T: CellRendererProtocol>(cellRenderer other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum CellRendererPropertyName: String, PropertyNameProtocol {
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editing = "editing"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case mode = "mode"
    case sensitive = "sensitive"
    case visible = "visible"
    case width = "width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererProtocol {
    /// Bind a `CellRendererPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRenderer property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRenderer property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererSignalName: String, SignalNameProtocol {
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditing = "notify::editing"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyMode = "notify::mode"
    case notifySensitive = "notify::sensitive"
    case notifyVisible = "notify::visible"
    case notifyWidth = "notify::width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

// MARK: CellRenderer signals
public extension CellRendererProtocol {
    /// Connect a Swift signal handler to the given, typed `CellRendererSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellRendererSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `CellRendererSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellRendererSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    /// - Note: This represents the underlying `editing-canceled` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `editingCanceled` signal is emitted
    @discardableResult @inlinable func onEditingCanceled(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .editingCanceled,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `editing-canceled` signal for using the `connect(signal:)` methods
    static var editingCanceledSignal: CellRendererSignalName { .editingCanceled }
    
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    /// - Note: This represents the underlying `editing-started` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter editable: the `GtkCellEditable`
    /// - Parameter path: the path identifying the edited cell
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `editingStarted` signal is emitted
    @discardableResult @inlinable func onEditingStarted(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ editable: CellEditableRef, _ path: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererRef, CellEditableRef, String), Void>
        let cCallback: @convention(c) (gpointer, gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererRef(raw: unownedSelf), CellEditableRef(raw: arg1), arg2.map({ String(cString: $0) })!))
            return output
        }
        return connect(
            signal: .editingStarted,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `editing-started` signal for using the `connect(signal:)` methods
    static var editingStartedSignal: CellRendererSignalName { .editingStarted }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::cell-background` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyCellBackground` signal is emitted
    @discardableResult @inlinable func onNotifyCellBackground(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyCellBackground,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::cell-background` signal for using the `connect(signal:)` methods
    static var notifyCellBackgroundSignal: CellRendererSignalName { .notifyCellBackground }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::cell-background-rgba` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyCellBackgroundRgba` signal is emitted
    @discardableResult @inlinable func onNotifyCellBackgroundRgba(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyCellBackgroundRgba,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::cell-background-rgba` signal for using the `connect(signal:)` methods
    static var notifyCellBackgroundRgbaSignal: CellRendererSignalName { .notifyCellBackgroundRgba }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::cell-background-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyCellBackgroundSet` signal is emitted
    @discardableResult @inlinable func onNotifyCellBackgroundSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyCellBackgroundSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::cell-background-set` signal for using the `connect(signal:)` methods
    static var notifyCellBackgroundSetSignal: CellRendererSignalName { .notifyCellBackgroundSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::editing` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEditing` signal is emitted
    @discardableResult @inlinable func onNotifyEditing(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyEditing,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::editing` signal for using the `connect(signal:)` methods
    static var notifyEditingSignal: CellRendererSignalName { .notifyEditing }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::height` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHeight` signal is emitted
    @discardableResult @inlinable func onNotifyHeight(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyHeight,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::height` signal for using the `connect(signal:)` methods
    static var notifyHeightSignal: CellRendererSignalName { .notifyHeight }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::is-expanded` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyIsExpanded` signal is emitted
    @discardableResult @inlinable func onNotifyIsExpanded(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyIsExpanded,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::is-expanded` signal for using the `connect(signal:)` methods
    static var notifyIsExpandedSignal: CellRendererSignalName { .notifyIsExpanded }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::is-expander` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyIsExpander` signal is emitted
    @discardableResult @inlinable func onNotifyIsExpander(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyIsExpander,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::is-expander` signal for using the `connect(signal:)` methods
    static var notifyIsExpanderSignal: CellRendererSignalName { .notifyIsExpander }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::mode` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMode` signal is emitted
    @discardableResult @inlinable func onNotifyMode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyMode,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::mode` signal for using the `connect(signal:)` methods
    static var notifyModeSignal: CellRendererSignalName { .notifyMode }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::sensitive` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySensitive` signal is emitted
    @discardableResult @inlinable func onNotifySensitive(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifySensitive,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::sensitive` signal for using the `connect(signal:)` methods
    static var notifySensitiveSignal: CellRendererSignalName { .notifySensitive }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::visible` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyVisible` signal is emitted
    @discardableResult @inlinable func onNotifyVisible(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyVisible,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::visible` signal for using the `connect(signal:)` methods
    static var notifyVisibleSignal: CellRendererSignalName { .notifyVisible }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::width` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWidth` signal is emitted
    @discardableResult @inlinable func onNotifyWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyWidth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::width` signal for using the `connect(signal:)` methods
    static var notifyWidthSignal: CellRendererSignalName { .notifyWidth }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::xalign` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyXalign` signal is emitted
    @discardableResult @inlinable func onNotifyXalign(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyXalign,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::xalign` signal for using the `connect(signal:)` methods
    static var notifyXalignSignal: CellRendererSignalName { .notifyXalign }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::xpad` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyXpad` signal is emitted
    @discardableResult @inlinable func onNotifyXpad(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyXpad,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::xpad` signal for using the `connect(signal:)` methods
    static var notifyXpadSignal: CellRendererSignalName { .notifyXpad }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::yalign` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyYalign` signal is emitted
    @discardableResult @inlinable func onNotifyYalign(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyYalign,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::yalign` signal for using the `connect(signal:)` methods
    static var notifyYalignSignal: CellRendererSignalName { .notifyYalign }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::ypad` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyYpad` signal is emitted
    @discardableResult @inlinable func onNotifyYpad(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyYpad,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::ypad` signal for using the `connect(signal:)` methods
    static var notifyYpadSignal: CellRendererSignalName { .notifyYpad }
    
}

// MARK: CellRenderer Class: CellRendererProtocol extension (methods and fields)
public extension CellRendererProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRenderer` instance.
    @inlinable var cell_renderer_ptr: UnsafeMutablePointer<GtkCellRenderer>! { return ptr?.assumingMemoryBound(to: GtkCellRenderer.self) }

    /// Passes an activate event to the cell renderer for possible processing.
    /// Some cell renderers may use events; for example, `GtkCellRendererToggle`
    /// toggles when it gets a mouse click.
    @inlinable func activate<GdkEventT: Gdk.EventProtocol, GdkRectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(event: GdkEventT, widget: WidgetT, path: UnsafePointer<CChar>!, backgroundArea: GdkRectangleT, cellArea: GdkRectangleT, flags: CellRendererState) -> Bool {
        let result = gtk_cell_renderer_activate(cell_renderer_ptr, event.event_ptr, widget.widget_ptr, path, backgroundArea.rectangle_ptr, cellArea.rectangle_ptr, flags.value)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the aligned area used by `cell` inside `cell_area`. Used for finding
    /// the appropriate edit and focus rectangle.
    @inlinable func getAlignedArea<GdkRectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(widget: WidgetT, flags: CellRendererState, cellArea: GdkRectangleT, alignedArea: GdkRectangleT) {
        
        gtk_cell_renderer_get_aligned_area(cell_renderer_ptr, widget.widget_ptr, flags.value, cellArea.rectangle_ptr, alignedArea.rectangle_ptr)
        
    }

    /// Fills in `xalign` and `yalign` with the appropriate values of `cell`.
    @inlinable func getAlignment(xalign: UnsafeMutablePointer<CFloat>! = nil, yalign: UnsafeMutablePointer<CFloat>! = nil) {
        
        gtk_cell_renderer_get_alignment(cell_renderer_ptr, xalign, yalign)
        
    }

    /// Fills in `width` and `height` with the appropriate size of `cell`.
    @inlinable func getFixedSize(width: UnsafeMutablePointer<gint>! = nil, height: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_cell_renderer_get_fixed_size(cell_renderer_ptr, width, height)
        
    }

    /// Checks whether the given `GtkCellRenderer` is expanded.
    @inlinable func getIsExpanded() -> Bool {
        let result = gtk_cell_renderer_get_is_expanded(cell_renderer_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Checks whether the given `GtkCellRenderer` is an expander.
    @inlinable func getIsExpander() -> Bool {
        let result = gtk_cell_renderer_get_is_expander(cell_renderer_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Fills in `xpad` and `ypad` with the appropriate values of `cell`.
    @inlinable func getPadding(xpad: UnsafeMutablePointer<gint>! = nil, ypad: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_cell_renderer_get_padding(cell_renderer_ptr, xpad, ypad)
        
    }

    /// Retrieves a renderer’s natural size when rendered to `widget`.
    @inlinable func getPreferredHeight<WidgetT: WidgetProtocol>(widget: WidgetT, minimumSize: UnsafeMutablePointer<gint>! = nil, naturalSize: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_cell_renderer_get_preferred_height(cell_renderer_ptr, widget.widget_ptr, minimumSize, naturalSize)
        
    }

    /// Retrieves a cell renderers’s minimum and natural height if it were rendered to
    /// `widget` with the specified `width`.
    @inlinable func getPreferredHeightForWidth<WidgetT: WidgetProtocol>(widget: WidgetT, width: Int, minimumHeight: UnsafeMutablePointer<gint>! = nil, naturalHeight: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_cell_renderer_get_preferred_height_for_width(cell_renderer_ptr, widget.widget_ptr, gint(width), minimumHeight, naturalHeight)
        
    }

    /// Retrieves the minimum and natural size of a cell taking
    /// into account the widget’s preference for height-for-width management.
    @inlinable func getPreferredSize<WidgetT: WidgetProtocol>(widget: WidgetT, minimumSize: RequisitionRef? = nil, naturalSize: RequisitionRef? = nil) {
            
        gtk_cell_renderer_get_preferred_size(cell_renderer_ptr, widget.widget_ptr, minimumSize?.requisition_ptr, naturalSize?.requisition_ptr)
            
    }
    /// Retrieves the minimum and natural size of a cell taking
    /// into account the widget’s preference for height-for-width management.
    @inlinable func getPreferredSize<RequisitionT: RequisitionProtocol, WidgetT: WidgetProtocol>(widget: WidgetT, minimumSize: RequisitionT?, naturalSize: RequisitionT?) {
        
        gtk_cell_renderer_get_preferred_size(cell_renderer_ptr, widget.widget_ptr, minimumSize?.requisition_ptr, naturalSize?.requisition_ptr)
        
    }

    /// Retrieves a renderer’s natural size when rendered to `widget`.
    @inlinable func getPreferredWidth<WidgetT: WidgetProtocol>(widget: WidgetT, minimumSize: UnsafeMutablePointer<gint>! = nil, naturalSize: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_cell_renderer_get_preferred_width(cell_renderer_ptr, widget.widget_ptr, minimumSize, naturalSize)
        
    }

    /// Retrieves a cell renderers’s minimum and natural width if it were rendered to
    /// `widget` with the specified `height`.
    @inlinable func getPreferredWidthForHeight<WidgetT: WidgetProtocol>(widget: WidgetT, height: Int, minimumWidth: UnsafeMutablePointer<gint>! = nil, naturalWidth: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_cell_renderer_get_preferred_width_for_height(cell_renderer_ptr, widget.widget_ptr, gint(height), minimumWidth, naturalWidth)
        
    }

    /// Gets whether the cell renderer prefers a height-for-width layout
    /// or a width-for-height layout.
    @inlinable func getRequestMode() -> GtkSizeRequestMode {
        let result = gtk_cell_renderer_get_request_mode(cell_renderer_ptr)
        let rv = result
        return rv
    }

    /// Returns the cell renderer’s sensitivity.
    @inlinable func getSensitive() -> Bool {
        let result = gtk_cell_renderer_get_sensitive(cell_renderer_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Translates the cell renderer state to `GtkStateFlags`,
    /// based on the cell renderer and widget sensitivity, and
    /// the given `GtkCellRenderer`State.
    @inlinable func getState(widget: WidgetRef? = nil, cellState: CellRendererState) -> Gtk.StateFlags {
            let result = gtk_cell_renderer_get_state(cell_renderer_ptr, widget?.widget_ptr, cellState.value)
        let rv = StateFlags(result)
            return rv
    }
    /// Translates the cell renderer state to `GtkStateFlags`,
    /// based on the cell renderer and widget sensitivity, and
    /// the given `GtkCellRenderer`State.
    @inlinable func getState<WidgetT: WidgetProtocol>(widget: WidgetT?, cellState: CellRendererState) -> Gtk.StateFlags {
        let result = gtk_cell_renderer_get_state(cell_renderer_ptr, widget?.widget_ptr, cellState.value)
        let rv = StateFlags(result)
        return rv
    }

    /// Returns the cell renderer’s visibility.
    @inlinable func getVisible() -> Bool {
        let result = gtk_cell_renderer_get_visible(cell_renderer_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Sets the renderer’s alignment within its available space.
    @inlinable func setAlignment(xalign: CFloat, yalign: CFloat) {
        
        gtk_cell_renderer_set_alignment(cell_renderer_ptr, xalign, yalign)
        
    }

    /// Sets the renderer size to be explicit, independent of the properties set.
    @inlinable func setFixedSize(width: Int, height: Int) {
        
        gtk_cell_renderer_set_fixed_size(cell_renderer_ptr, gint(width), gint(height))
        
    }

    /// Sets whether the given `GtkCellRenderer` is expanded.
    @inlinable func set(isExpanded: Bool) {
        
        gtk_cell_renderer_set_is_expanded(cell_renderer_ptr, gboolean((isExpanded) ? 1 : 0))
        
    }

    /// Sets whether the given `GtkCellRenderer` is an expander.
    @inlinable func set(isExpander: Bool) {
        
        gtk_cell_renderer_set_is_expander(cell_renderer_ptr, gboolean((isExpander) ? 1 : 0))
        
    }

    /// Sets the renderer’s padding.
    @inlinable func setPadding(xpad: Int, ypad: Int) {
        
        gtk_cell_renderer_set_padding(cell_renderer_ptr, gint(xpad), gint(ypad))
        
    }

    /// Sets the cell renderer’s sensitivity.
    @inlinable func set(sensitive: Bool) {
        
        gtk_cell_renderer_set_sensitive(cell_renderer_ptr, gboolean((sensitive) ? 1 : 0))
        
    }

    /// Sets the cell renderer’s visibility.
    @inlinable func set(visible: Bool) {
        
        gtk_cell_renderer_set_visible(cell_renderer_ptr, gboolean((visible) ? 1 : 0))
        
    }

    /// Invokes the virtual render function of the `GtkCellRenderer`. The three
    /// passed-in rectangles are areas in `cr`. Most renderers will draw within
    /// `cell_area`; the xalign, yalign, xpad, and ypad fields of the `GtkCellRenderer`
    /// should be honored with respect to `cell_area`. `background_area` includes the
    /// blank space around the cell, and also the area containing the tree expander;
    /// so the `background_area` rectangles for all cells tile to cover the entire
    /// `window`.
    @inlinable func snapshot<GdkRectangleT: Gdk.RectangleProtocol, SnapshotT: SnapshotProtocol, WidgetT: WidgetProtocol>(snapshot: SnapshotT, widget: WidgetT, backgroundArea: GdkRectangleT, cellArea: GdkRectangleT, flags: CellRendererState) {
        
        gtk_cell_renderer_snapshot(cell_renderer_ptr, snapshot.snapshot_ptr, widget.widget_ptr, backgroundArea.rectangle_ptr, cellArea.rectangle_ptr, flags.value)
        
    }

    /// Starts editing the contents of this `cell`, through a new `GtkCellEditable`
    /// widget created by the `GtkCellRenderer`Class.start_editing virtual function.
    @inlinable func startEditing<GdkRectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(event: Gdk.EventRef? = nil, widget: WidgetT, path: UnsafePointer<CChar>!, backgroundArea: GdkRectangleT, cellArea: GdkRectangleT, flags: CellRendererState) -> CellEditableRef! {
            let result = gtk_cell_renderer_start_editing(cell_renderer_ptr, event?.event_ptr, widget.widget_ptr, path, backgroundArea.rectangle_ptr, cellArea.rectangle_ptr, flags.value)
        let rv = CellEditableRef(gconstpointer: gconstpointer(result))
            return rv
    }
    /// Starts editing the contents of this `cell`, through a new `GtkCellEditable`
    /// widget created by the `GtkCellRenderer`Class.start_editing virtual function.
    @inlinable func startEditing<GdkEventT: Gdk.EventProtocol, GdkRectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(event: GdkEventT?, widget: WidgetT, path: UnsafePointer<CChar>!, backgroundArea: GdkRectangleT, cellArea: GdkRectangleT, flags: CellRendererState) -> CellEditableRef! {
        let result = gtk_cell_renderer_start_editing(cell_renderer_ptr, event?.event_ptr, widget.widget_ptr, path, backgroundArea.rectangle_ptr, cellArea.rectangle_ptr, flags.value)
        let rv = CellEditableRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Informs the cell renderer that the editing is stopped.
    /// If `canceled` is `true`, the cell renderer will emit the
    /// `GtkCellRenderer``editing-canceled` signal.
    /// 
    /// This function should be called by cell renderer implementations
    /// in response to the `GtkCellEditable`editing-done`` signal of
    /// `GtkCellEditable`.
    @inlinable func stopEditing(canceled: Bool) {
        
        gtk_cell_renderer_stop_editing(cell_renderer_ptr, gboolean((canceled) ? 1 : 0))
        
    }
    /// Checks whether the cell renderer can do something when activated.
    @inlinable var isActivatable: Bool {
        /// Checks whether the cell renderer can do something when activated.
        get {
            let result = gtk_cell_renderer_is_activatable(cell_renderer_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// Checks whether the given `GtkCellRenderer` is expanded.
    @inlinable var isExpanded: Bool {
        /// Checks whether the given `GtkCellRenderer` is expanded.
        get {
            let result = gtk_cell_renderer_get_is_expanded(cell_renderer_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether the given `GtkCellRenderer` is expanded.
        nonmutating set {
            gtk_cell_renderer_set_is_expanded(cell_renderer_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Checks whether the given `GtkCellRenderer` is an expander.
    @inlinable var isExpander: Bool {
        /// Checks whether the given `GtkCellRenderer` is an expander.
        get {
            let result = gtk_cell_renderer_get_is_expander(cell_renderer_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether the given `GtkCellRenderer` is an expander.
        nonmutating set {
            gtk_cell_renderer_set_is_expander(cell_renderer_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets whether the cell renderer prefers a height-for-width layout
    /// or a width-for-height layout.
    @inlinable var requestMode: GtkSizeRequestMode {
        /// Gets whether the cell renderer prefers a height-for-width layout
        /// or a width-for-height layout.
        get {
            let result = gtk_cell_renderer_get_request_mode(cell_renderer_ptr)
        let rv = result
            return rv
        }
    }

    @inlinable var sensitive: Bool {
        /// Returns the cell renderer’s sensitivity.
        get {
            let result = gtk_cell_renderer_get_sensitive(cell_renderer_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets the cell renderer’s sensitivity.
        nonmutating set {
            gtk_cell_renderer_set_sensitive(cell_renderer_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var visible: Bool {
        /// Returns the cell renderer’s visibility.
        get {
            let result = gtk_cell_renderer_get_visible(cell_renderer_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets the cell renderer’s visibility.
        nonmutating set {
            gtk_cell_renderer_set_visible(cell_renderer_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var parentInstance: GInitiallyUnowned {
        get {
            let rv = cell_renderer_ptr.pointee.parent_instance
    return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - CellRendererAccel Class

/// Renders a keyboard accelerator in a cell
/// 
/// `GtkCellRendererAccel` displays a keyboard accelerator (i.e. a key
/// combination like `Control + a`). If the cell renderer is editable,
/// the accelerator can be changed by simply typing the new combination.
///
/// The `CellRendererAccelProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererAccel` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererAccel`.
/// Alternatively, use `CellRendererAccelRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererAccelProtocol: CellRendererTextProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererAccel` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererAccel` instance.
    var cell_renderer_accel_ptr: UnsafeMutablePointer<GtkCellRendererAccel>! { get }

    /// Required Initialiser for types conforming to `CellRendererAccelProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Renders a keyboard accelerator in a cell
/// 
/// `GtkCellRendererAccel` displays a keyboard accelerator (i.e. a key
/// combination like `Control + a`). If the cell renderer is editable,
/// the accelerator can be changed by simply typing the new combination.
///
/// The `CellRendererAccelRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererAccel` instance.
/// It exposes methods that can operate on this data type through `CellRendererAccelProtocol` conformance.
/// Use `CellRendererAccelRef` only as an `unowned` reference to an existing `GtkCellRendererAccel` instance.
///
public struct CellRendererAccelRef: CellRendererAccelProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellRendererAccel` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_accel_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererAccelRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererAccel>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererAccel>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererAccel>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererAccel>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererAccelProtocol`
    @inlinable init<T: CellRendererAccelProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellRendererAccelProtocol>(_ other: T) -> CellRendererAccelRef { CellRendererAccelRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererAccel`.
    @inlinable init() {
            let result = gtk_cell_renderer_accel_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// Renders a keyboard accelerator in a cell
/// 
/// `GtkCellRendererAccel` displays a keyboard accelerator (i.e. a key
/// combination like `Control + a`). If the cell renderer is editable,
/// the accelerator can be changed by simply typing the new combination.
///
/// The `CellRendererAccel` type acts as a reference-counted owner of an underlying `GtkCellRendererAccel` instance.
/// It provides the methods that can operate on this data type through `CellRendererAccelProtocol` conformance.
/// Use `CellRendererAccel` as a strong reference or owner of a `GtkCellRendererAccel` instance.
///
open class CellRendererAccel: CellRendererText, CellRendererAccelProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererAccel>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererAccel>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererAccel>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererAccel>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererAccel`.
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererAccel>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererAccelProtocol`
    /// Will retain `GtkCellRendererAccel`.
    /// - Parameter other: an instance of a related type that implements `CellRendererAccelProtocol`
    @inlinable public init<T: CellRendererAccelProtocol>(cellRendererAccel other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererAccel`.
    @inlinable override public init() {
            let result = gtk_cell_renderer_accel_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CellRendererAccelPropertyName: String, PropertyNameProtocol {
    /// The keyval of the accelerator.
    case accelKey = "accel-key"
    /// Determines if the edited accelerators are GTK accelerators. If
    /// they are, consumed modifiers are suppressed, only accelerators
    /// accepted by GTK are allowed, and the accelerators are rendered
    /// in the same way as they are in menus.
    case accelMode = "accel-mode"
    /// The modifier mask of the accelerator.
    case accelMods = "accel-mods"
    case alignSet = "align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case alignment = "alignment"
    case attributes = "attributes"
    case background = "background"
    /// Background color as a `GdkRGBA`
    case backgroundRgba = "background-rgba"
    case backgroundSet = "background-set"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editable = "editable"
    case editableSet = "editable-set"
    case editing = "editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case ellipsize = "ellipsize"
    case ellipsizeSet = "ellipsize-set"
    case family = "family"
    case familySet = "family-set"
    case font = "font"
    case fontDesc = "font-desc"
    case foreground = "foreground"
    /// Foreground color as a `GdkRGBA`
    case foregroundRgba = "foreground-rgba"
    case foregroundSet = "foreground-set"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    /// The hardware keycode of the accelerator. Note that the hardware keycode is
    /// only relevant if the key does not have a keyval. Normally, the keyboard
    /// configuration should assign keyvals to all keys.
    case keycode = "keycode"
    case language = "language"
    case languageSet = "language-set"
    case markup = "markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case maxWidthChars = "max-width-chars"
    case mode = "mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case placeholderText = "placeholder-text"
    case rise = "rise"
    case riseSet = "rise-set"
    case scale = "scale"
    case scaleSet = "scale-set"
    case sensitive = "sensitive"
    case singleParagraphMode = "single-paragraph-mode"
    case size = "size"
    case sizePoints = "size-points"
    case sizeSet = "size-set"
    case stretch = "stretch"
    case stretchSet = "stretch-set"
    case strikethrough = "strikethrough"
    case strikethroughSet = "strikethrough-set"
    case style = "style"
    case styleSet = "style-set"
    case text = "text"
    case underline = "underline"
    case underlineSet = "underline-set"
    case variant = "variant"
    case variantSet = "variant-set"
    case visible = "visible"
    case weight = "weight"
    case weightSet = "weight-set"
    case width = "width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case widthChars = "width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case wrapMode = "wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case wrapWidth = "wrap-width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererAccelProtocol {
    /// Bind a `CellRendererAccelPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererAccelPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererAccel property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererAccelPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererAccel property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererAccelPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererAccelSignalName: String, SignalNameProtocol {
    /// Gets emitted when the user has removed the accelerator.
    case accelCleared = "accel-cleared"
    /// Gets emitted when the user has selected a new accelerator.
    case accelEdited = "accel-edited"
    /// This signal is emitted after `renderer` has been edited.
    /// 
    /// It is the responsibility of the application to update the model
    /// and store `new_text` at the position indicated by `path`.
    case edited = "edited"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The keyval of the accelerator.
    case notifyAccelKey = "notify::accel-key"
    /// Determines if the edited accelerators are GTK accelerators. If
    /// they are, consumed modifiers are suppressed, only accelerators
    /// accepted by GTK are allowed, and the accelerators are rendered
    /// in the same way as they are in menus.
    case notifyAccelMode = "notify::accel-mode"
    /// The modifier mask of the accelerator.
    case notifyAccelMods = "notify::accel-mods"
    case notifyAlignSet = "notify::align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case notifyAlignment = "notify::alignment"
    case notifyAttributes = "notify::attributes"
    case notifyBackground = "notify::background"
    /// Background color as a `GdkRGBA`
    case notifyBackgroundRgba = "notify::background-rgba"
    case notifyBackgroundSet = "notify::background-set"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditable = "notify::editable"
    case notifyEditableSet = "notify::editable-set"
    case notifyEditing = "notify::editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case notifyEllipsize = "notify::ellipsize"
    case notifyEllipsizeSet = "notify::ellipsize-set"
    case notifyFamily = "notify::family"
    case notifyFamilySet = "notify::family-set"
    case notifyFont = "notify::font"
    case notifyFontDesc = "notify::font-desc"
    case notifyForeground = "notify::foreground"
    /// Foreground color as a `GdkRGBA`
    case notifyForegroundRgba = "notify::foreground-rgba"
    case notifyForegroundSet = "notify::foreground-set"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    /// The hardware keycode of the accelerator. Note that the hardware keycode is
    /// only relevant if the key does not have a keyval. Normally, the keyboard
    /// configuration should assign keyvals to all keys.
    case notifyKeycode = "notify::keycode"
    case notifyLanguage = "notify::language"
    case notifyLanguageSet = "notify::language-set"
    case notifyMarkup = "notify::markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case notifyMaxWidthChars = "notify::max-width-chars"
    case notifyMode = "notify::mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case notifyPlaceholderText = "notify::placeholder-text"
    case notifyRise = "notify::rise"
    case notifyRiseSet = "notify::rise-set"
    case notifyScale = "notify::scale"
    case notifyScaleSet = "notify::scale-set"
    case notifySensitive = "notify::sensitive"
    case notifySingleParagraphMode = "notify::single-paragraph-mode"
    case notifySize = "notify::size"
    case notifySizePoints = "notify::size-points"
    case notifySizeSet = "notify::size-set"
    case notifyStretch = "notify::stretch"
    case notifyStretchSet = "notify::stretch-set"
    case notifyStrikethrough = "notify::strikethrough"
    case notifyStrikethroughSet = "notify::strikethrough-set"
    case notifyStyle = "notify::style"
    case notifyStyleSet = "notify::style-set"
    case notifyText = "notify::text"
    case notifyUnderline = "notify::underline"
    case notifyUnderlineSet = "notify::underline-set"
    case notifyVariant = "notify::variant"
    case notifyVariantSet = "notify::variant-set"
    case notifyVisible = "notify::visible"
    case notifyWeight = "notify::weight"
    case notifyWeightSet = "notify::weight-set"
    case notifyWidth = "notify::width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case notifyWidthChars = "notify::width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case notifyWrapMode = "notify::wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case notifyWrapWidth = "notify::wrap-width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

// MARK: CellRendererAccel signals
public extension CellRendererAccelProtocol {
    /// Connect a Swift signal handler to the given, typed `CellRendererAccelSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellRendererAccelSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `CellRendererAccelSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellRendererAccelSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Gets emitted when the user has removed the accelerator.
    /// - Note: This represents the underlying `accel-cleared` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pathString: the path identifying the row of the edited cell
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `accelCleared` signal is emitted
    @discardableResult @inlinable func onAccelCleared(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererAccelRef, _ pathString: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererAccelRef, String), Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererAccelRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!))
            return output
        }
        return connect(
            signal: .accelCleared,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `accel-cleared` signal for using the `connect(signal:)` methods
    static var accelClearedSignal: CellRendererAccelSignalName { .accelCleared }
    
    /// Gets emitted when the user has selected a new accelerator.
    /// - Note: This represents the underlying `accel-edited` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pathString: the path identifying the row of the edited cell
    /// - Parameter accelKey: the new accelerator keyval
    /// - Parameter accelMods: the new acclerator modifier mask
    /// - Parameter hardwareKeycode: the keycode of the new accelerator
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `accelEdited` signal is emitted
    @discardableResult @inlinable func onAccelEdited(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererAccelRef, _ pathString: String, _ accelKey: UInt, _ accelMods: Gdk.ModifierType, _ hardwareKeycode: UInt) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererAccelRef, String, UInt, Gdk.ModifierType, UInt), Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, guint, UInt32, guint, gpointer) -> Void = { unownedSelf, arg1, arg2, arg3, arg4, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererAccelRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!, UInt(arg2), Gdk.ModifierType(arg3), UInt(arg4)))
            return output
        }
        return connect(
            signal: .accelEdited,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `accel-edited` signal for using the `connect(signal:)` methods
    static var accelEditedSignal: CellRendererAccelSignalName { .accelEdited }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::accel-key` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAccelKey` signal is emitted
    @discardableResult @inlinable func onNotifyAccelKey(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererAccelRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererAccelRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererAccelRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyAccelKey,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::accel-key` signal for using the `connect(signal:)` methods
    static var notifyAccelKeySignal: CellRendererAccelSignalName { .notifyAccelKey }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::accel-mode` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAccelMode` signal is emitted
    @discardableResult @inlinable func onNotifyAccelMode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererAccelRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererAccelRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererAccelRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyAccelMode,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::accel-mode` signal for using the `connect(signal:)` methods
    static var notifyAccelModeSignal: CellRendererAccelSignalName { .notifyAccelMode }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::accel-mods` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAccelMods` signal is emitted
    @discardableResult @inlinable func onNotifyAccelMods(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererAccelRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererAccelRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererAccelRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyAccelMods,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::accel-mods` signal for using the `connect(signal:)` methods
    static var notifyAccelModsSignal: CellRendererAccelSignalName { .notifyAccelMods }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::keycode` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyKeycode` signal is emitted
    @discardableResult @inlinable func onNotifyKeycode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererAccelRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererAccelRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererAccelRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyKeycode,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::keycode` signal for using the `connect(signal:)` methods
    static var notifyKeycodeSignal: CellRendererAccelSignalName { .notifyKeycode }
    
}

// MARK: CellRendererAccel Class: CellRendererAccelProtocol extension (methods and fields)
public extension CellRendererAccelProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererAccel` instance.
    @inlinable var cell_renderer_accel_ptr: UnsafeMutablePointer<GtkCellRendererAccel>! { return ptr?.assumingMemoryBound(to: GtkCellRendererAccel.self) }



}



// MARK: - CellRendererCombo Class

/// Renders a combobox in a cell
/// 
/// `GtkCellRendererCombo` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererCombo` offers a `GtkComboBox`
/// widget to edit the text. The values to display in the combo box are taken from
/// the tree model specified in the `GtkCellRendererCombo`:model property.
/// 
/// The combo cell renderer takes care of adding a text cell renderer to the combo
/// box and sets it to display the column specified by its
/// `GtkCellRendererCombo`:text-column property. Further properties of the combo box
/// can be set in a handler for the `GtkCellRenderer`editing-started`` signal.
///
/// The `CellRendererComboProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererCombo` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererCombo`.
/// Alternatively, use `CellRendererComboRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererComboProtocol: CellRendererTextProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererCombo` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererCombo` instance.
    var cell_renderer_combo_ptr: UnsafeMutablePointer<GtkCellRendererCombo>! { get }

    /// Required Initialiser for types conforming to `CellRendererComboProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Renders a combobox in a cell
/// 
/// `GtkCellRendererCombo` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererCombo` offers a `GtkComboBox`
/// widget to edit the text. The values to display in the combo box are taken from
/// the tree model specified in the `GtkCellRendererCombo`:model property.
/// 
/// The combo cell renderer takes care of adding a text cell renderer to the combo
/// box and sets it to display the column specified by its
/// `GtkCellRendererCombo`:text-column property. Further properties of the combo box
/// can be set in a handler for the `GtkCellRenderer`editing-started`` signal.
///
/// The `CellRendererComboRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererCombo` instance.
/// It exposes methods that can operate on this data type through `CellRendererComboProtocol` conformance.
/// Use `CellRendererComboRef` only as an `unowned` reference to an existing `GtkCellRendererCombo` instance.
///
public struct CellRendererComboRef: CellRendererComboProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellRendererCombo` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_combo_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererComboRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererCombo>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererCombo>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererCombo>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererCombo>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererComboProtocol`
    @inlinable init<T: CellRendererComboProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellRendererComboProtocol>(_ other: T) -> CellRendererComboRef { CellRendererComboRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererCombo`.
    /// Adjust how text is drawn using object properties.
    /// Object properties can be set globally (with `g_object_set()`).
    /// Also, with `GtkTreeViewColumn`, you can bind a property to a value
    /// in a `GtkTreeModel`. For example, you can bind the “text” property
    /// on the cell renderer to a string value in the model, thus rendering
    /// a different string in each row of the `GtkTreeView`.
    @inlinable init() {
            let result = gtk_cell_renderer_combo_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// Renders a combobox in a cell
/// 
/// `GtkCellRendererCombo` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererCombo` offers a `GtkComboBox`
/// widget to edit the text. The values to display in the combo box are taken from
/// the tree model specified in the `GtkCellRendererCombo`:model property.
/// 
/// The combo cell renderer takes care of adding a text cell renderer to the combo
/// box and sets it to display the column specified by its
/// `GtkCellRendererCombo`:text-column property. Further properties of the combo box
/// can be set in a handler for the `GtkCellRenderer`editing-started`` signal.
///
/// The `CellRendererCombo` type acts as a reference-counted owner of an underlying `GtkCellRendererCombo` instance.
/// It provides the methods that can operate on this data type through `CellRendererComboProtocol` conformance.
/// Use `CellRendererCombo` as a strong reference or owner of a `GtkCellRendererCombo` instance.
///
open class CellRendererCombo: CellRendererText, CellRendererComboProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererCombo>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererCombo>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererCombo>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererCombo>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererCombo`.
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererCombo>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererComboProtocol`
    /// Will retain `GtkCellRendererCombo`.
    /// - Parameter other: an instance of a related type that implements `CellRendererComboProtocol`
    @inlinable public init<T: CellRendererComboProtocol>(cellRendererCombo other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererCombo`.
    /// Adjust how text is drawn using object properties.
    /// Object properties can be set globally (with `g_object_set()`).
    /// Also, with `GtkTreeViewColumn`, you can bind a property to a value
    /// in a `GtkTreeModel`. For example, you can bind the “text” property
    /// on the cell renderer to a string value in the model, thus rendering
    /// a different string in each row of the `GtkTreeView`.
    @inlinable override public init() {
            let result = gtk_cell_renderer_combo_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CellRendererComboPropertyName: String, PropertyNameProtocol {
    case alignSet = "align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case alignment = "alignment"
    case attributes = "attributes"
    case background = "background"
    /// Background color as a `GdkRGBA`
    case backgroundRgba = "background-rgba"
    case backgroundSet = "background-set"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editable = "editable"
    case editableSet = "editable-set"
    case editing = "editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case ellipsize = "ellipsize"
    case ellipsizeSet = "ellipsize-set"
    case family = "family"
    case familySet = "family-set"
    case font = "font"
    case fontDesc = "font-desc"
    case foreground = "foreground"
    /// Foreground color as a `GdkRGBA`
    case foregroundRgba = "foreground-rgba"
    case foregroundSet = "foreground-set"
    /// If `true`, the cell renderer will include an entry and allow to enter
    /// values other than the ones in the popup list.
    case hasEntry = "has-entry"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case language = "language"
    case languageSet = "language-set"
    case markup = "markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case maxWidthChars = "max-width-chars"
    case mode = "mode"
    /// Holds a tree model containing the possible values for the combo box.
    /// Use the text_column property to specify the column holding the values.
    case model = "model"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case placeholderText = "placeholder-text"
    case rise = "rise"
    case riseSet = "rise-set"
    case scale = "scale"
    case scaleSet = "scale-set"
    case sensitive = "sensitive"
    case singleParagraphMode = "single-paragraph-mode"
    case size = "size"
    case sizePoints = "size-points"
    case sizeSet = "size-set"
    case stretch = "stretch"
    case stretchSet = "stretch-set"
    case strikethrough = "strikethrough"
    case strikethroughSet = "strikethrough-set"
    case style = "style"
    case styleSet = "style-set"
    case text = "text"
    /// Specifies the model column which holds the possible values for the
    /// combo box.
    /// 
    /// Note that this refers to the model specified in the model property,
    /// not the model backing the tree view to which
    /// this cell renderer is attached.
    /// 
    /// `GtkCellRendererCombo` automatically adds a text cell renderer for
    /// this column to its combo box.
    case textColumn = "text-column"
    case underline = "underline"
    case underlineSet = "underline-set"
    case variant = "variant"
    case variantSet = "variant-set"
    case visible = "visible"
    case weight = "weight"
    case weightSet = "weight-set"
    case width = "width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case widthChars = "width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case wrapMode = "wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case wrapWidth = "wrap-width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererComboProtocol {
    /// Bind a `CellRendererComboPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererComboPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererCombo property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererComboPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererCombo property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererComboPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererComboSignalName: String, SignalNameProtocol {
    /// This signal is emitted each time after the user selected an item in
    /// the combo box, either by using the mouse or the arrow keys.  Contrary
    /// to GtkComboBox, GtkCellRendererCombo`changed` is not emitted for
    /// changes made to a selected item in the entry.  The argument `new_iter`
    /// corresponds to the newly selected item in the combo box and it is relative
    /// to the GtkTreeModel set via the model property on GtkCellRendererCombo.
    /// 
    /// Note that as soon as you change the model displayed in the tree view,
    /// the tree view will immediately cease the editing operating.  This
    /// means that you most probably want to refrain from changing the model
    /// until the combo cell renderer emits the edited or editing_canceled signal.
    case changed = "changed"
    /// This signal is emitted after `renderer` has been edited.
    /// 
    /// It is the responsibility of the application to update the model
    /// and store `new_text` at the position indicated by `path`.
    case edited = "edited"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyAlignSet = "notify::align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case notifyAlignment = "notify::alignment"
    case notifyAttributes = "notify::attributes"
    case notifyBackground = "notify::background"
    /// Background color as a `GdkRGBA`
    case notifyBackgroundRgba = "notify::background-rgba"
    case notifyBackgroundSet = "notify::background-set"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditable = "notify::editable"
    case notifyEditableSet = "notify::editable-set"
    case notifyEditing = "notify::editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case notifyEllipsize = "notify::ellipsize"
    case notifyEllipsizeSet = "notify::ellipsize-set"
    case notifyFamily = "notify::family"
    case notifyFamilySet = "notify::family-set"
    case notifyFont = "notify::font"
    case notifyFontDesc = "notify::font-desc"
    case notifyForeground = "notify::foreground"
    /// Foreground color as a `GdkRGBA`
    case notifyForegroundRgba = "notify::foreground-rgba"
    case notifyForegroundSet = "notify::foreground-set"
    /// If `true`, the cell renderer will include an entry and allow to enter
    /// values other than the ones in the popup list.
    case notifyHasEntry = "notify::has-entry"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyLanguage = "notify::language"
    case notifyLanguageSet = "notify::language-set"
    case notifyMarkup = "notify::markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case notifyMaxWidthChars = "notify::max-width-chars"
    case notifyMode = "notify::mode"
    /// Holds a tree model containing the possible values for the combo box.
    /// Use the text_column property to specify the column holding the values.
    case notifyModel = "notify::model"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case notifyPlaceholderText = "notify::placeholder-text"
    case notifyRise = "notify::rise"
    case notifyRiseSet = "notify::rise-set"
    case notifyScale = "notify::scale"
    case notifyScaleSet = "notify::scale-set"
    case notifySensitive = "notify::sensitive"
    case notifySingleParagraphMode = "notify::single-paragraph-mode"
    case notifySize = "notify::size"
    case notifySizePoints = "notify::size-points"
    case notifySizeSet = "notify::size-set"
    case notifyStretch = "notify::stretch"
    case notifyStretchSet = "notify::stretch-set"
    case notifyStrikethrough = "notify::strikethrough"
    case notifyStrikethroughSet = "notify::strikethrough-set"
    case notifyStyle = "notify::style"
    case notifyStyleSet = "notify::style-set"
    case notifyText = "notify::text"
    /// Specifies the model column which holds the possible values for the
    /// combo box.
    /// 
    /// Note that this refers to the model specified in the model property,
    /// not the model backing the tree view to which
    /// this cell renderer is attached.
    /// 
    /// `GtkCellRendererCombo` automatically adds a text cell renderer for
    /// this column to its combo box.
    case notifyTextColumn = "notify::text-column"
    case notifyUnderline = "notify::underline"
    case notifyUnderlineSet = "notify::underline-set"
    case notifyVariant = "notify::variant"
    case notifyVariantSet = "notify::variant-set"
    case notifyVisible = "notify::visible"
    case notifyWeight = "notify::weight"
    case notifyWeightSet = "notify::weight-set"
    case notifyWidth = "notify::width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case notifyWidthChars = "notify::width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case notifyWrapMode = "notify::wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case notifyWrapWidth = "notify::wrap-width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

// MARK: CellRendererCombo signals
public extension CellRendererComboProtocol {
    /// Connect a Swift signal handler to the given, typed `CellRendererComboSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellRendererComboSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `CellRendererComboSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellRendererComboSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// This signal is emitted each time after the user selected an item in
    /// the combo box, either by using the mouse or the arrow keys.  Contrary
    /// to GtkComboBox, GtkCellRendererCombo`changed` is not emitted for
    /// changes made to a selected item in the entry.  The argument `new_iter`
    /// corresponds to the newly selected item in the combo box and it is relative
    /// to the GtkTreeModel set via the model property on GtkCellRendererCombo.
    /// 
    /// Note that as soon as you change the model displayed in the tree view,
    /// the tree view will immediately cease the editing operating.  This
    /// means that you most probably want to refrain from changing the model
    /// until the combo cell renderer emits the edited or editing_canceled signal.
    /// - Note: This represents the underlying `changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pathString: a string of the path identifying the edited cell               (relative to the tree view model)
    /// - Parameter newIter: the new iter selected in the combo box            (relative to the combo box model)
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `changed` signal is emitted
    @discardableResult @inlinable func onChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererComboRef, _ pathString: String, _ newIter: TreeIterRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererComboRef, String, TreeIterRef), Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererComboRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!, TreeIterRef(raw: arg2)))
            return output
        }
        return connect(
            signal: .changed,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `changed` signal for using the `connect(signal:)` methods
    static var changedSignal: CellRendererComboSignalName { .changed }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::has-entry` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHasEntry` signal is emitted
    @discardableResult @inlinable func onNotifyHasEntry(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererComboRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererComboRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererComboRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyHasEntry,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::has-entry` signal for using the `connect(signal:)` methods
    static var notifyHasEntrySignal: CellRendererComboSignalName { .notifyHasEntry }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::model` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyModel` signal is emitted
    @discardableResult @inlinable func onNotifyModel(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererComboRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererComboRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererComboRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyModel,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::model` signal for using the `connect(signal:)` methods
    static var notifyModelSignal: CellRendererComboSignalName { .notifyModel }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::text-column` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTextColumn` signal is emitted
    @discardableResult @inlinable func onNotifyTextColumn(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererComboRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererComboRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererComboRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyTextColumn,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::text-column` signal for using the `connect(signal:)` methods
    static var notifyTextColumnSignal: CellRendererComboSignalName { .notifyTextColumn }
    
}

// MARK: CellRendererCombo Class: CellRendererComboProtocol extension (methods and fields)
public extension CellRendererComboProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererCombo` instance.
    @inlinable var cell_renderer_combo_ptr: UnsafeMutablePointer<GtkCellRendererCombo>! { return ptr?.assumingMemoryBound(to: GtkCellRendererCombo.self) }



}



// MARK: - CellRendererPixbuf Class

/// Renders a pixbuf in a cell
/// 
/// A `GtkCellRendererPixbuf` can be used to render an image in a cell. It allows
/// to render either a given `GdkPixbuf` (set via the
/// `GtkCellRendererPixbuf:pixbuf` property) or a named icon (set via the
/// `GtkCellRendererPixbuf:icon-name` property).
/// 
/// To support the tree view, `GtkCellRendererPixbuf` also supports rendering two
/// alternative pixbufs, when the `GtkCellRenderer:is-expander` property is `true`.
/// If the `GtkCellRenderer:is-expanded property` is `true` and the
/// `GtkCellRendererPixbuf:pixbuf-expander-open` property is set to a pixbuf, it
/// renders that pixbuf, if the `GtkCellRenderer:is-expanded` property is `false`
/// and the `GtkCellRendererPixbuf:pixbuf-expander-closed` property is set to a
/// pixbuf, it renders that one.
///
/// The `CellRendererPixbufProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererPixbuf` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererPixbuf`.
/// Alternatively, use `CellRendererPixbufRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererPixbufProtocol: CellRendererProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererPixbuf` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererPixbuf` instance.
    var cell_renderer_pixbuf_ptr: UnsafeMutablePointer<GtkCellRendererPixbuf>! { get }

    /// Required Initialiser for types conforming to `CellRendererPixbufProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Renders a pixbuf in a cell
/// 
/// A `GtkCellRendererPixbuf` can be used to render an image in a cell. It allows
/// to render either a given `GdkPixbuf` (set via the
/// `GtkCellRendererPixbuf:pixbuf` property) or a named icon (set via the
/// `GtkCellRendererPixbuf:icon-name` property).
/// 
/// To support the tree view, `GtkCellRendererPixbuf` also supports rendering two
/// alternative pixbufs, when the `GtkCellRenderer:is-expander` property is `true`.
/// If the `GtkCellRenderer:is-expanded property` is `true` and the
/// `GtkCellRendererPixbuf:pixbuf-expander-open` property is set to a pixbuf, it
/// renders that pixbuf, if the `GtkCellRenderer:is-expanded` property is `false`
/// and the `GtkCellRendererPixbuf:pixbuf-expander-closed` property is set to a
/// pixbuf, it renders that one.
///
/// The `CellRendererPixbufRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererPixbuf` instance.
/// It exposes methods that can operate on this data type through `CellRendererPixbufProtocol` conformance.
/// Use `CellRendererPixbufRef` only as an `unowned` reference to an existing `GtkCellRendererPixbuf` instance.
///
public struct CellRendererPixbufRef: CellRendererPixbufProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellRendererPixbuf` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_pixbuf_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererPixbufRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererPixbuf>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererPixbuf>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererPixbuf>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererPixbuf>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererPixbufProtocol`
    @inlinable init<T: CellRendererPixbufProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellRendererPixbufProtocol>(_ other: T) -> CellRendererPixbufRef { CellRendererPixbufRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererPixbuf`. Adjust rendering
    /// parameters using object properties. Object properties can be set
    /// globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`, you
    /// can bind a property to a value in a `GtkTreeModel`. For example, you
    /// can bind the “pixbuf” property on the cell renderer to a pixbuf value
    /// in the model, thus rendering a different image in each row of the
    /// `GtkTreeView`.
    @inlinable init() {
            let result = gtk_cell_renderer_pixbuf_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// Renders a pixbuf in a cell
/// 
/// A `GtkCellRendererPixbuf` can be used to render an image in a cell. It allows
/// to render either a given `GdkPixbuf` (set via the
/// `GtkCellRendererPixbuf:pixbuf` property) or a named icon (set via the
/// `GtkCellRendererPixbuf:icon-name` property).
/// 
/// To support the tree view, `GtkCellRendererPixbuf` also supports rendering two
/// alternative pixbufs, when the `GtkCellRenderer:is-expander` property is `true`.
/// If the `GtkCellRenderer:is-expanded property` is `true` and the
/// `GtkCellRendererPixbuf:pixbuf-expander-open` property is set to a pixbuf, it
/// renders that pixbuf, if the `GtkCellRenderer:is-expanded` property is `false`
/// and the `GtkCellRendererPixbuf:pixbuf-expander-closed` property is set to a
/// pixbuf, it renders that one.
///
/// The `CellRendererPixbuf` type acts as a reference-counted owner of an underlying `GtkCellRendererPixbuf` instance.
/// It provides the methods that can operate on this data type through `CellRendererPixbufProtocol` conformance.
/// Use `CellRendererPixbuf` as a strong reference or owner of a `GtkCellRendererPixbuf` instance.
///
open class CellRendererPixbuf: CellRenderer, CellRendererPixbufProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererPixbuf>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererPixbuf>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererPixbuf>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererPixbuf>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererPixbuf`.
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererPixbuf>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererPixbufProtocol`
    /// Will retain `GtkCellRendererPixbuf`.
    /// - Parameter other: an instance of a related type that implements `CellRendererPixbufProtocol`
    @inlinable public init<T: CellRendererPixbufProtocol>(cellRendererPixbuf other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererPixbuf`. Adjust rendering
    /// parameters using object properties. Object properties can be set
    /// globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`, you
    /// can bind a property to a value in a `GtkTreeModel`. For example, you
    /// can bind the “pixbuf” property on the cell renderer to a pixbuf value
    /// in the model, thus rendering a different image in each row of the
    /// `GtkTreeView`.
    @inlinable public init() {
            let result = gtk_cell_renderer_pixbuf_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CellRendererPixbufPropertyName: String, PropertyNameProtocol {
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editing = "editing"
    /// The GIcon representing the icon to display.
    /// If the icon theme is changed, the image will be updated
    /// automatically.
    case gicon = "gicon"
    case height = "height"
    /// The name of the themed icon to display.
    /// This property only has an effect if not overridden by the "pixbuf" property.
    case iconName = "icon-name"
    /// The `GtkIconSize` value that specifies the size of the rendered icon.
    case iconSize = "icon-size"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case mode = "mode"
    case pixbuf = "pixbuf"
    case pixbufExpanderClosed = "pixbuf-expander-closed"
    case pixbufExpanderOpen = "pixbuf-expander-open"
    case sensitive = "sensitive"
    case texture = "texture"
    case visible = "visible"
    case width = "width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererPixbufProtocol {
    /// Bind a `CellRendererPixbufPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererPixbufPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererPixbuf property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererPixbufPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererPixbuf property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererPixbufPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererPixbufSignalName: String, SignalNameProtocol {
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditing = "notify::editing"
    /// The GIcon representing the icon to display.
    /// If the icon theme is changed, the image will be updated
    /// automatically.
    case notifyGicon = "notify::gicon"
    case notifyHeight = "notify::height"
    /// The name of the themed icon to display.
    /// This property only has an effect if not overridden by the "pixbuf" property.
    case notifyIconName = "notify::icon-name"
    /// The `GtkIconSize` value that specifies the size of the rendered icon.
    case notifyIconSize = "notify::icon-size"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyMode = "notify::mode"
    case notifyPixbuf = "notify::pixbuf"
    case notifyPixbufExpanderClosed = "notify::pixbuf-expander-closed"
    case notifyPixbufExpanderOpen = "notify::pixbuf-expander-open"
    case notifySensitive = "notify::sensitive"
    case notifyTexture = "notify::texture"
    case notifyVisible = "notify::visible"
    case notifyWidth = "notify::width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

// MARK: CellRendererPixbuf has no signals
// MARK: CellRendererPixbuf Class: CellRendererPixbufProtocol extension (methods and fields)
public extension CellRendererPixbufProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererPixbuf` instance.
    @inlinable var cell_renderer_pixbuf_ptr: UnsafeMutablePointer<GtkCellRendererPixbuf>! { return ptr?.assumingMemoryBound(to: GtkCellRendererPixbuf.self) }



}



// MARK: - CellRendererProgress Class

/// Renders numbers as progress bars
/// 
/// `GtkCellRendererProgress` renders a numeric value as a progress par in a cell.
/// Additionally, it can display a text on top of the progress bar.
///
/// The `CellRendererProgressProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererProgress` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererProgress`.
/// Alternatively, use `CellRendererProgressRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererProgressProtocol: CellRendererProtocol, OrientableProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererProgress` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererProgress` instance.
    var cell_renderer_progress_ptr: UnsafeMutablePointer<GtkCellRendererProgress>! { get }

    /// Required Initialiser for types conforming to `CellRendererProgressProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Renders numbers as progress bars
/// 
/// `GtkCellRendererProgress` renders a numeric value as a progress par in a cell.
/// Additionally, it can display a text on top of the progress bar.
///
/// The `CellRendererProgressRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererProgress` instance.
/// It exposes methods that can operate on this data type through `CellRendererProgressProtocol` conformance.
/// Use `CellRendererProgressRef` only as an `unowned` reference to an existing `GtkCellRendererProgress` instance.
///
public struct CellRendererProgressRef: CellRendererProgressProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellRendererProgress` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_progress_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererProgressRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererProgress>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererProgress>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererProgress>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererProgress>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererProgressProtocol`
    @inlinable init<T: CellRendererProgressProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellRendererProgressProtocol>(_ other: T) -> CellRendererProgressRef { CellRendererProgressRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererProgress`.
    @inlinable init() {
            let result = gtk_cell_renderer_progress_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// Renders numbers as progress bars
/// 
/// `GtkCellRendererProgress` renders a numeric value as a progress par in a cell.
/// Additionally, it can display a text on top of the progress bar.
///
/// The `CellRendererProgress` type acts as a reference-counted owner of an underlying `GtkCellRendererProgress` instance.
/// It provides the methods that can operate on this data type through `CellRendererProgressProtocol` conformance.
/// Use `CellRendererProgress` as a strong reference or owner of a `GtkCellRendererProgress` instance.
///
open class CellRendererProgress: CellRenderer, CellRendererProgressProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererProgress>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererProgress>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererProgress>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererProgress>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererProgress`.
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererProgress>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererProgressProtocol`
    /// Will retain `GtkCellRendererProgress`.
    /// - Parameter other: an instance of a related type that implements `CellRendererProgressProtocol`
    @inlinable public init<T: CellRendererProgressProtocol>(cellRendererProgress other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererProgress`.
    @inlinable public init() {
            let result = gtk_cell_renderer_progress_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CellRendererProgressPropertyName: String, PropertyNameProtocol {
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editing = "editing"
    case height = "height"
    case inverted = "inverted"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case mode = "mode"
    /// Setting this to a non-negative value causes the cell renderer to
    /// enter "activity mode", where a block bounces back and forth to
    /// indicate that some progress is made, without specifying exactly how
    /// much.
    /// 
    /// Each increment of the property causes the block to move by a little
    /// bit.
    /// 
    /// To indicate that the activity has not started yet, set the property
    /// to zero. To indicate completion, set the property to `G_MAXINT`.
    case pulse = "pulse"
    case sensitive = "sensitive"
    /// The "text" property determines the label which will be drawn
    /// over the progress bar. Setting this property to `nil` causes the default
    /// label to be displayed. Setting this property to an empty string causes
    /// no label to be displayed.
    case text = "text"
    /// The "text-xalign" property controls the horizontal alignment of the
    /// text in the progress bar.  Valid values range from 0 (left) to 1
    /// (right).  Reserved for RTL layouts.
    case textXalign = "text-xalign"
    /// The "text-yalign" property controls the vertical alignment of the
    /// text in the progress bar.  Valid values range from 0 (top) to 1
    /// (bottom).
    case textYalign = "text-yalign"
    /// The "value" property determines the percentage to which the
    /// progress bar will be "filled in".
    case value = "value"
    case visible = "visible"
    case width = "width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererProgressProtocol {
    /// Bind a `CellRendererProgressPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererProgressPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererProgress property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererProgressPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererProgress property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererProgressPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererProgressSignalName: String, SignalNameProtocol {
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditing = "notify::editing"
    case notifyHeight = "notify::height"
    case notifyInverted = "notify::inverted"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyMode = "notify::mode"
    /// Setting this to a non-negative value causes the cell renderer to
    /// enter "activity mode", where a block bounces back and forth to
    /// indicate that some progress is made, without specifying exactly how
    /// much.
    /// 
    /// Each increment of the property causes the block to move by a little
    /// bit.
    /// 
    /// To indicate that the activity has not started yet, set the property
    /// to zero. To indicate completion, set the property to `G_MAXINT`.
    case notifyPulse = "notify::pulse"
    case notifySensitive = "notify::sensitive"
    /// The "text" property determines the label which will be drawn
    /// over the progress bar. Setting this property to `nil` causes the default
    /// label to be displayed. Setting this property to an empty string causes
    /// no label to be displayed.
    case notifyText = "notify::text"
    /// The "text-xalign" property controls the horizontal alignment of the
    /// text in the progress bar.  Valid values range from 0 (left) to 1
    /// (right).  Reserved for RTL layouts.
    case notifyTextXalign = "notify::text-xalign"
    /// The "text-yalign" property controls the vertical alignment of the
    /// text in the progress bar.  Valid values range from 0 (top) to 1
    /// (bottom).
    case notifyTextYalign = "notify::text-yalign"
    /// The "value" property determines the percentage to which the
    /// progress bar will be "filled in".
    case notifyValue = "notify::value"
    case notifyVisible = "notify::visible"
    case notifyWidth = "notify::width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

// MARK: CellRendererProgress has no signals
// MARK: CellRendererProgress Class: CellRendererProgressProtocol extension (methods and fields)
public extension CellRendererProgressProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererProgress` instance.
    @inlinable var cell_renderer_progress_ptr: UnsafeMutablePointer<GtkCellRendererProgress>! { return ptr?.assumingMemoryBound(to: GtkCellRendererProgress.self) }



}



// MARK: - CellRendererSpin Class

/// Renders a spin button in a cell
/// 
/// `GtkCellRendererSpin` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererSpin` offers a `GtkSpinButton` widget. Of course,
/// that means that the text has to be parseable as a floating point number.
/// 
/// The range of the spinbutton is taken from the adjustment property of the
/// cell renderer, which can be set explicitly or mapped to a column in the
/// tree model, like all properties of cell renders. `GtkCellRendererSpin`
/// also has properties for the `GtkCellRendererSpin:climb-rate` and the number
/// of `GtkCellRendererSpin:digits` to display. Other `GtkSpinButton` properties
/// can be set in a handler for the `GtkCellRenderer`editing-started`` signal.
/// 
/// The `GtkCellRendererSpin` cell renderer was added in GTK 2.10.
///
/// The `CellRendererSpinProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererSpin` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererSpin`.
/// Alternatively, use `CellRendererSpinRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererSpinProtocol: CellRendererTextProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererSpin` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererSpin` instance.
    var cell_renderer_spin_ptr: UnsafeMutablePointer<GtkCellRendererSpin>! { get }

    /// Required Initialiser for types conforming to `CellRendererSpinProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Renders a spin button in a cell
/// 
/// `GtkCellRendererSpin` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererSpin` offers a `GtkSpinButton` widget. Of course,
/// that means that the text has to be parseable as a floating point number.
/// 
/// The range of the spinbutton is taken from the adjustment property of the
/// cell renderer, which can be set explicitly or mapped to a column in the
/// tree model, like all properties of cell renders. `GtkCellRendererSpin`
/// also has properties for the `GtkCellRendererSpin:climb-rate` and the number
/// of `GtkCellRendererSpin:digits` to display. Other `GtkSpinButton` properties
/// can be set in a handler for the `GtkCellRenderer`editing-started`` signal.
/// 
/// The `GtkCellRendererSpin` cell renderer was added in GTK 2.10.
///
/// The `CellRendererSpinRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererSpin` instance.
/// It exposes methods that can operate on this data type through `CellRendererSpinProtocol` conformance.
/// Use `CellRendererSpinRef` only as an `unowned` reference to an existing `GtkCellRendererSpin` instance.
///
public struct CellRendererSpinRef: CellRendererSpinProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellRendererSpin` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_spin_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererSpinRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererSpin>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererSpin>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererSpin>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererSpin>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererSpinProtocol`
    @inlinable init<T: CellRendererSpinProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellRendererSpinProtocol>(_ other: T) -> CellRendererSpinRef { CellRendererSpinRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererSpin`.
    @inlinable init() {
            let result = gtk_cell_renderer_spin_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// Renders a spin button in a cell
/// 
/// `GtkCellRendererSpin` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererSpin` offers a `GtkSpinButton` widget. Of course,
/// that means that the text has to be parseable as a floating point number.
/// 
/// The range of the spinbutton is taken from the adjustment property of the
/// cell renderer, which can be set explicitly or mapped to a column in the
/// tree model, like all properties of cell renders. `GtkCellRendererSpin`
/// also has properties for the `GtkCellRendererSpin:climb-rate` and the number
/// of `GtkCellRendererSpin:digits` to display. Other `GtkSpinButton` properties
/// can be set in a handler for the `GtkCellRenderer`editing-started`` signal.
/// 
/// The `GtkCellRendererSpin` cell renderer was added in GTK 2.10.
///
/// The `CellRendererSpin` type acts as a reference-counted owner of an underlying `GtkCellRendererSpin` instance.
/// It provides the methods that can operate on this data type through `CellRendererSpinProtocol` conformance.
/// Use `CellRendererSpin` as a strong reference or owner of a `GtkCellRendererSpin` instance.
///
open class CellRendererSpin: CellRendererText, CellRendererSpinProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererSpin>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererSpin>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererSpin>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererSpin>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererSpin`.
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererSpin>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererSpinProtocol`
    /// Will retain `GtkCellRendererSpin`.
    /// - Parameter other: an instance of a related type that implements `CellRendererSpinProtocol`
    @inlinable public init<T: CellRendererSpinProtocol>(cellRendererSpin other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererSpin`.
    @inlinable override public init() {
            let result = gtk_cell_renderer_spin_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CellRendererSpinPropertyName: String, PropertyNameProtocol {
    /// The adjustment that holds the value of the spinbutton.
    /// This must be non-`nil` for the cell renderer to be editable.
    case adjustment = "adjustment"
    case alignSet = "align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case alignment = "alignment"
    case attributes = "attributes"
    case background = "background"
    /// Background color as a `GdkRGBA`
    case backgroundRgba = "background-rgba"
    case backgroundSet = "background-set"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    /// The acceleration rate when you hold down a button.
    case climbRate = "climb-rate"
    /// The number of decimal places to display.
    case digits = "digits"
    case editable = "editable"
    case editableSet = "editable-set"
    case editing = "editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case ellipsize = "ellipsize"
    case ellipsizeSet = "ellipsize-set"
    case family = "family"
    case familySet = "family-set"
    case font = "font"
    case fontDesc = "font-desc"
    case foreground = "foreground"
    /// Foreground color as a `GdkRGBA`
    case foregroundRgba = "foreground-rgba"
    case foregroundSet = "foreground-set"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case language = "language"
    case languageSet = "language-set"
    case markup = "markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case maxWidthChars = "max-width-chars"
    case mode = "mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case placeholderText = "placeholder-text"
    case rise = "rise"
    case riseSet = "rise-set"
    case scale = "scale"
    case scaleSet = "scale-set"
    case sensitive = "sensitive"
    case singleParagraphMode = "single-paragraph-mode"
    case size = "size"
    case sizePoints = "size-points"
    case sizeSet = "size-set"
    case stretch = "stretch"
    case stretchSet = "stretch-set"
    case strikethrough = "strikethrough"
    case strikethroughSet = "strikethrough-set"
    case style = "style"
    case styleSet = "style-set"
    case text = "text"
    case underline = "underline"
    case underlineSet = "underline-set"
    case variant = "variant"
    case variantSet = "variant-set"
    case visible = "visible"
    case weight = "weight"
    case weightSet = "weight-set"
    case width = "width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case widthChars = "width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case wrapMode = "wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case wrapWidth = "wrap-width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererSpinProtocol {
    /// Bind a `CellRendererSpinPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererSpinPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererSpin property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererSpinPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererSpin property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererSpinPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererSpinSignalName: String, SignalNameProtocol {
    /// This signal is emitted after `renderer` has been edited.
    /// 
    /// It is the responsibility of the application to update the model
    /// and store `new_text` at the position indicated by `path`.
    case edited = "edited"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The adjustment that holds the value of the spinbutton.
    /// This must be non-`nil` for the cell renderer to be editable.
    case notifyAdjustment = "notify::adjustment"
    case notifyAlignSet = "notify::align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case notifyAlignment = "notify::alignment"
    case notifyAttributes = "notify::attributes"
    case notifyBackground = "notify::background"
    /// Background color as a `GdkRGBA`
    case notifyBackgroundRgba = "notify::background-rgba"
    case notifyBackgroundSet = "notify::background-set"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    /// The acceleration rate when you hold down a button.
    case notifyClimbRate = "notify::climb-rate"
    /// The number of decimal places to display.
    case notifyDigits = "notify::digits"
    case notifyEditable = "notify::editable"
    case notifyEditableSet = "notify::editable-set"
    case notifyEditing = "notify::editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case notifyEllipsize = "notify::ellipsize"
    case notifyEllipsizeSet = "notify::ellipsize-set"
    case notifyFamily = "notify::family"
    case notifyFamilySet = "notify::family-set"
    case notifyFont = "notify::font"
    case notifyFontDesc = "notify::font-desc"
    case notifyForeground = "notify::foreground"
    /// Foreground color as a `GdkRGBA`
    case notifyForegroundRgba = "notify::foreground-rgba"
    case notifyForegroundSet = "notify::foreground-set"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyLanguage = "notify::language"
    case notifyLanguageSet = "notify::language-set"
    case notifyMarkup = "notify::markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case notifyMaxWidthChars = "notify::max-width-chars"
    case notifyMode = "notify::mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case notifyPlaceholderText = "notify::placeholder-text"
    case notifyRise = "notify::rise"
    case notifyRiseSet = "notify::rise-set"
    case notifyScale = "notify::scale"
    case notifyScaleSet = "notify::scale-set"
    case notifySensitive = "notify::sensitive"
    case notifySingleParagraphMode = "notify::single-paragraph-mode"
    case notifySize = "notify::size"
    case notifySizePoints = "notify::size-points"
    case notifySizeSet = "notify::size-set"
    case notifyStretch = "notify::stretch"
    case notifyStretchSet = "notify::stretch-set"
    case notifyStrikethrough = "notify::strikethrough"
    case notifyStrikethroughSet = "notify::strikethrough-set"
    case notifyStyle = "notify::style"
    case notifyStyleSet = "notify::style-set"
    case notifyText = "notify::text"
    case notifyUnderline = "notify::underline"
    case notifyUnderlineSet = "notify::underline-set"
    case notifyVariant = "notify::variant"
    case notifyVariantSet = "notify::variant-set"
    case notifyVisible = "notify::visible"
    case notifyWeight = "notify::weight"
    case notifyWeightSet = "notify::weight-set"
    case notifyWidth = "notify::width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case notifyWidthChars = "notify::width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case notifyWrapMode = "notify::wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case notifyWrapWidth = "notify::wrap-width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

// MARK: CellRendererSpin has no signals
// MARK: CellRendererSpin Class: CellRendererSpinProtocol extension (methods and fields)
public extension CellRendererSpinProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererSpin` instance.
    @inlinable var cell_renderer_spin_ptr: UnsafeMutablePointer<GtkCellRendererSpin>! { return ptr?.assumingMemoryBound(to: GtkCellRendererSpin.self) }



}



// MARK: - CellRendererSpinner Class

/// Renders a spinning animation in a cell
/// 
/// `GtkCellRendererSpinner` renders a spinning animation in a cell, very
/// similar to `GtkSpinner`. It can often be used as an alternative
/// to a `GtkCellRendererProgress` for displaying indefinite activity,
/// instead of actual progress.
/// 
/// To start the animation in a cell, set the `GtkCellRendererSpinner:active`
/// property to `true` and increment the `GtkCellRendererSpinner:pulse` property
/// at regular intervals. The usual way to set the cell renderer properties
/// for each cell is to bind them to columns in your tree model using e.g.
/// `gtk_tree_view_column_add_attribute()`.
///
/// The `CellRendererSpinnerProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererSpinner` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererSpinner`.
/// Alternatively, use `CellRendererSpinnerRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererSpinnerProtocol: CellRendererProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererSpinner` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererSpinner` instance.
    var cell_renderer_spinner_ptr: UnsafeMutablePointer<GtkCellRendererSpinner>! { get }

    /// Required Initialiser for types conforming to `CellRendererSpinnerProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Renders a spinning animation in a cell
/// 
/// `GtkCellRendererSpinner` renders a spinning animation in a cell, very
/// similar to `GtkSpinner`. It can often be used as an alternative
/// to a `GtkCellRendererProgress` for displaying indefinite activity,
/// instead of actual progress.
/// 
/// To start the animation in a cell, set the `GtkCellRendererSpinner:active`
/// property to `true` and increment the `GtkCellRendererSpinner:pulse` property
/// at regular intervals. The usual way to set the cell renderer properties
/// for each cell is to bind them to columns in your tree model using e.g.
/// `gtk_tree_view_column_add_attribute()`.
///
/// The `CellRendererSpinnerRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererSpinner` instance.
/// It exposes methods that can operate on this data type through `CellRendererSpinnerProtocol` conformance.
/// Use `CellRendererSpinnerRef` only as an `unowned` reference to an existing `GtkCellRendererSpinner` instance.
///
public struct CellRendererSpinnerRef: CellRendererSpinnerProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellRendererSpinner` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_spinner_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererSpinnerRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererSpinner>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererSpinner>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererSpinner>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererSpinner>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererSpinnerProtocol`
    @inlinable init<T: CellRendererSpinnerProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellRendererSpinnerProtocol>(_ other: T) -> CellRendererSpinnerRef { CellRendererSpinnerRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Returns a new cell renderer which will show a spinner to indicate
    /// activity.
    @inlinable init() {
            let result = gtk_cell_renderer_spinner_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// Renders a spinning animation in a cell
/// 
/// `GtkCellRendererSpinner` renders a spinning animation in a cell, very
/// similar to `GtkSpinner`. It can often be used as an alternative
/// to a `GtkCellRendererProgress` for displaying indefinite activity,
/// instead of actual progress.
/// 
/// To start the animation in a cell, set the `GtkCellRendererSpinner:active`
/// property to `true` and increment the `GtkCellRendererSpinner:pulse` property
/// at regular intervals. The usual way to set the cell renderer properties
/// for each cell is to bind them to columns in your tree model using e.g.
/// `gtk_tree_view_column_add_attribute()`.
///
/// The `CellRendererSpinner` type acts as a reference-counted owner of an underlying `GtkCellRendererSpinner` instance.
/// It provides the methods that can operate on this data type through `CellRendererSpinnerProtocol` conformance.
/// Use `CellRendererSpinner` as a strong reference or owner of a `GtkCellRendererSpinner` instance.
///
open class CellRendererSpinner: CellRenderer, CellRendererSpinnerProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererSpinner>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererSpinner>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererSpinner>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererSpinner>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererSpinner`.
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererSpinner>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererSpinnerProtocol`
    /// Will retain `GtkCellRendererSpinner`.
    /// - Parameter other: an instance of a related type that implements `CellRendererSpinnerProtocol`
    @inlinable public init<T: CellRendererSpinnerProtocol>(cellRendererSpinner other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Returns a new cell renderer which will show a spinner to indicate
    /// activity.
    @inlinable public init() {
            let result = gtk_cell_renderer_spinner_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CellRendererSpinnerPropertyName: String, PropertyNameProtocol {
    case active = "active"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editing = "editing"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case mode = "mode"
    /// Pulse of the spinner. Increment this value to draw the next frame of the
    /// spinner animation. Usually, you would update this value in a timeout.
    /// 
    /// By default, the `GtkSpinner` widget draws one full cycle of the animation,
    /// consisting of 12 frames, in 750 milliseconds.
    case pulse = "pulse"
    case sensitive = "sensitive"
    /// The `GtkIconSize` value that specifies the size of the rendered spinner.
    case size = "size"
    case visible = "visible"
    case width = "width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererSpinnerProtocol {
    /// Bind a `CellRendererSpinnerPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererSpinnerPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererSpinner property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererSpinnerPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererSpinner property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererSpinnerPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererSpinnerSignalName: String, SignalNameProtocol {
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyActive = "notify::active"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditing = "notify::editing"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyMode = "notify::mode"
    /// Pulse of the spinner. Increment this value to draw the next frame of the
    /// spinner animation. Usually, you would update this value in a timeout.
    /// 
    /// By default, the `GtkSpinner` widget draws one full cycle of the animation,
    /// consisting of 12 frames, in 750 milliseconds.
    case notifyPulse = "notify::pulse"
    case notifySensitive = "notify::sensitive"
    /// The `GtkIconSize` value that specifies the size of the rendered spinner.
    case notifySize = "notify::size"
    case notifyVisible = "notify::visible"
    case notifyWidth = "notify::width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

// MARK: CellRendererSpinner has no signals
// MARK: CellRendererSpinner Class: CellRendererSpinnerProtocol extension (methods and fields)
public extension CellRendererSpinnerProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererSpinner` instance.
    @inlinable var cell_renderer_spinner_ptr: UnsafeMutablePointer<GtkCellRendererSpinner>! { return ptr?.assumingMemoryBound(to: GtkCellRendererSpinner.self) }



}



// MARK: - CellRendererText Class

/// Renders text in a cell
/// 
/// A `GtkCellRendererText` renders a given text in its cell, using the font, color and
/// style information provided by its properties. The text will be ellipsized if it is
/// too long and the `GtkCellRendererText:ellipsize` property allows it.
/// 
/// If the `GtkCellRenderer:mode` is `GTK_CELL_RENDERER_MODE_EDITABLE`,
/// the `GtkCellRendererText` allows to edit its text using an entry.
///
/// The `CellRendererTextProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererText` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererText`.
/// Alternatively, use `CellRendererTextRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererTextProtocol: CellRendererProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererText` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererText` instance.
    var cell_renderer_text_ptr: UnsafeMutablePointer<GtkCellRendererText>! { get }

    /// Required Initialiser for types conforming to `CellRendererTextProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Renders text in a cell
/// 
/// A `GtkCellRendererText` renders a given text in its cell, using the font, color and
/// style information provided by its properties. The text will be ellipsized if it is
/// too long and the `GtkCellRendererText:ellipsize` property allows it.
/// 
/// If the `GtkCellRenderer:mode` is `GTK_CELL_RENDERER_MODE_EDITABLE`,
/// the `GtkCellRendererText` allows to edit its text using an entry.
///
/// The `CellRendererTextRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererText` instance.
/// It exposes methods that can operate on this data type through `CellRendererTextProtocol` conformance.
/// Use `CellRendererTextRef` only as an `unowned` reference to an existing `GtkCellRendererText` instance.
///
public struct CellRendererTextRef: CellRendererTextProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellRendererText` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_text_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererTextRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererText>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererText>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererText>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererText>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererTextProtocol`
    @inlinable init<T: CellRendererTextProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellRendererTextProtocol>(_ other: T) -> CellRendererTextRef { CellRendererTextRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererText`. Adjust how text is drawn using
    /// object properties. Object properties can be
    /// set globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`,
    /// you can bind a property to a value in a `GtkTreeModel`. For example,
    /// you can bind the “text” property on the cell renderer to a string
    /// value in the model, thus rendering a different string in each row
    /// of the `GtkTreeView`.
    @inlinable init() {
            let result = gtk_cell_renderer_text_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// Renders text in a cell
/// 
/// A `GtkCellRendererText` renders a given text in its cell, using the font, color and
/// style information provided by its properties. The text will be ellipsized if it is
/// too long and the `GtkCellRendererText:ellipsize` property allows it.
/// 
/// If the `GtkCellRenderer:mode` is `GTK_CELL_RENDERER_MODE_EDITABLE`,
/// the `GtkCellRendererText` allows to edit its text using an entry.
///
/// The `CellRendererText` type acts as a reference-counted owner of an underlying `GtkCellRendererText` instance.
/// It provides the methods that can operate on this data type through `CellRendererTextProtocol` conformance.
/// Use `CellRendererText` as a strong reference or owner of a `GtkCellRendererText` instance.
///
open class CellRendererText: CellRenderer, CellRendererTextProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererText>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererText>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererText>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererText>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererText`.
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererText>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererTextProtocol`
    /// Will retain `GtkCellRendererText`.
    /// - Parameter other: an instance of a related type that implements `CellRendererTextProtocol`
    @inlinable public init<T: CellRendererTextProtocol>(cellRendererText other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererText`. Adjust how text is drawn using
    /// object properties. Object properties can be
    /// set globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`,
    /// you can bind a property to a value in a `GtkTreeModel`. For example,
    /// you can bind the “text” property on the cell renderer to a string
    /// value in the model, thus rendering a different string in each row
    /// of the `GtkTreeView`.
    @inlinable public init() {
            let result = gtk_cell_renderer_text_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CellRendererTextPropertyName: String, PropertyNameProtocol {
    case alignSet = "align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case alignment = "alignment"
    case attributes = "attributes"
    case background = "background"
    /// Background color as a `GdkRGBA`
    case backgroundRgba = "background-rgba"
    case backgroundSet = "background-set"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editable = "editable"
    case editableSet = "editable-set"
    case editing = "editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case ellipsize = "ellipsize"
    case ellipsizeSet = "ellipsize-set"
    case family = "family"
    case familySet = "family-set"
    case font = "font"
    case fontDesc = "font-desc"
    case foreground = "foreground"
    /// Foreground color as a `GdkRGBA`
    case foregroundRgba = "foreground-rgba"
    case foregroundSet = "foreground-set"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case language = "language"
    case languageSet = "language-set"
    case markup = "markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case maxWidthChars = "max-width-chars"
    case mode = "mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case placeholderText = "placeholder-text"
    case rise = "rise"
    case riseSet = "rise-set"
    case scale = "scale"
    case scaleSet = "scale-set"
    case sensitive = "sensitive"
    case singleParagraphMode = "single-paragraph-mode"
    case size = "size"
    case sizePoints = "size-points"
    case sizeSet = "size-set"
    case stretch = "stretch"
    case stretchSet = "stretch-set"
    case strikethrough = "strikethrough"
    case strikethroughSet = "strikethrough-set"
    case style = "style"
    case styleSet = "style-set"
    case text = "text"
    case underline = "underline"
    case underlineSet = "underline-set"
    case variant = "variant"
    case variantSet = "variant-set"
    case visible = "visible"
    case weight = "weight"
    case weightSet = "weight-set"
    case width = "width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case widthChars = "width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case wrapMode = "wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case wrapWidth = "wrap-width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererTextProtocol {
    /// Bind a `CellRendererTextPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererTextPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererText property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererTextPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererText property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererTextPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererTextSignalName: String, SignalNameProtocol {
    /// This signal is emitted after `renderer` has been edited.
    /// 
    /// It is the responsibility of the application to update the model
    /// and store `new_text` at the position indicated by `path`.
    case edited = "edited"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyAlignSet = "notify::align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case notifyAlignment = "notify::alignment"
    case notifyAttributes = "notify::attributes"
    case notifyBackground = "notify::background"
    /// Background color as a `GdkRGBA`
    case notifyBackgroundRgba = "notify::background-rgba"
    case notifyBackgroundSet = "notify::background-set"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditable = "notify::editable"
    case notifyEditableSet = "notify::editable-set"
    case notifyEditing = "notify::editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case notifyEllipsize = "notify::ellipsize"
    case notifyEllipsizeSet = "notify::ellipsize-set"
    case notifyFamily = "notify::family"
    case notifyFamilySet = "notify::family-set"
    case notifyFont = "notify::font"
    case notifyFontDesc = "notify::font-desc"
    case notifyForeground = "notify::foreground"
    /// Foreground color as a `GdkRGBA`
    case notifyForegroundRgba = "notify::foreground-rgba"
    case notifyForegroundSet = "notify::foreground-set"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyLanguage = "notify::language"
    case notifyLanguageSet = "notify::language-set"
    case notifyMarkup = "notify::markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case notifyMaxWidthChars = "notify::max-width-chars"
    case notifyMode = "notify::mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case notifyPlaceholderText = "notify::placeholder-text"
    case notifyRise = "notify::rise"
    case notifyRiseSet = "notify::rise-set"
    case notifyScale = "notify::scale"
    case notifyScaleSet = "notify::scale-set"
    case notifySensitive = "notify::sensitive"
    case notifySingleParagraphMode = "notify::single-paragraph-mode"
    case notifySize = "notify::size"
    case notifySizePoints = "notify::size-points"
    case notifySizeSet = "notify::size-set"
    case notifyStretch = "notify::stretch"
    case notifyStretchSet = "notify::stretch-set"
    case notifyStrikethrough = "notify::strikethrough"
    case notifyStrikethroughSet = "notify::strikethrough-set"
    case notifyStyle = "notify::style"
    case notifyStyleSet = "notify::style-set"
    case notifyText = "notify::text"
    case notifyUnderline = "notify::underline"
    case notifyUnderlineSet = "notify::underline-set"
    case notifyVariant = "notify::variant"
    case notifyVariantSet = "notify::variant-set"
    case notifyVisible = "notify::visible"
    case notifyWeight = "notify::weight"
    case notifyWeightSet = "notify::weight-set"
    case notifyWidth = "notify::width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case notifyWidthChars = "notify::width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case notifyWrapMode = "notify::wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case notifyWrapWidth = "notify::wrap-width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

// MARK: CellRendererText signals
public extension CellRendererTextProtocol {
    /// Connect a Swift signal handler to the given, typed `CellRendererTextSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellRendererTextSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `CellRendererTextSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellRendererTextSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// This signal is emitted after `renderer` has been edited.
    /// 
    /// It is the responsibility of the application to update the model
    /// and store `new_text` at the position indicated by `path`.
    /// - Note: This represents the underlying `edited` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter path: the path identifying the edited cell
    /// - Parameter newText: the new text
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `edited` signal is emitted
    @discardableResult @inlinable func onEdited(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ path: String, _ newText: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, String, String), Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!, arg2.map({ String(cString: $0) })!))
            return output
        }
        return connect(
            signal: .edited,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `edited` signal for using the `connect(signal:)` methods
    static var editedSignal: CellRendererTextSignalName { .edited }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::align-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAlignSet` signal is emitted
    @discardableResult @inlinable func onNotifyAlignSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyAlignSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::align-set` signal for using the `connect(signal:)` methods
    static var notifyAlignSetSignal: CellRendererTextSignalName { .notifyAlignSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::alignment` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAlignment` signal is emitted
    @discardableResult @inlinable func onNotifyAlignment(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyAlignment,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::alignment` signal for using the `connect(signal:)` methods
    static var notifyAlignmentSignal: CellRendererTextSignalName { .notifyAlignment }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::attributes` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAttributes` signal is emitted
    @discardableResult @inlinable func onNotifyAttributes(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyAttributes,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::attributes` signal for using the `connect(signal:)` methods
    static var notifyAttributesSignal: CellRendererTextSignalName { .notifyAttributes }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::background` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyBackground` signal is emitted
    @discardableResult @inlinable func onNotifyBackground(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyBackground,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::background` signal for using the `connect(signal:)` methods
    static var notifyBackgroundSignal: CellRendererTextSignalName { .notifyBackground }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::background-rgba` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyBackgroundRgba` signal is emitted
    @discardableResult @inlinable func onNotifyBackgroundRgba(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyBackgroundRgba,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::background-rgba` signal for using the `connect(signal:)` methods
    static var notifyBackgroundRgbaSignal: CellRendererTextSignalName { .notifyBackgroundRgba }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::background-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyBackgroundSet` signal is emitted
    @discardableResult @inlinable func onNotifyBackgroundSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyBackgroundSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::background-set` signal for using the `connect(signal:)` methods
    static var notifyBackgroundSetSignal: CellRendererTextSignalName { .notifyBackgroundSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::editable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEditable` signal is emitted
    @discardableResult @inlinable func onNotifyEditable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyEditable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::editable` signal for using the `connect(signal:)` methods
    static var notifyEditableSignal: CellRendererTextSignalName { .notifyEditable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::editable-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEditableSet` signal is emitted
    @discardableResult @inlinable func onNotifyEditableSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyEditableSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::editable-set` signal for using the `connect(signal:)` methods
    static var notifyEditableSetSignal: CellRendererTextSignalName { .notifyEditableSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::ellipsize` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEllipsize` signal is emitted
    @discardableResult @inlinable func onNotifyEllipsize(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyEllipsize,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::ellipsize` signal for using the `connect(signal:)` methods
    static var notifyEllipsizeSignal: CellRendererTextSignalName { .notifyEllipsize }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::ellipsize-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEllipsizeSet` signal is emitted
    @discardableResult @inlinable func onNotifyEllipsizeSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyEllipsizeSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::ellipsize-set` signal for using the `connect(signal:)` methods
    static var notifyEllipsizeSetSignal: CellRendererTextSignalName { .notifyEllipsizeSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::family` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFamily` signal is emitted
    @discardableResult @inlinable func onNotifyFamily(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyFamily,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::family` signal for using the `connect(signal:)` methods
    static var notifyFamilySignal: CellRendererTextSignalName { .notifyFamily }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::family-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFamilySet` signal is emitted
    @discardableResult @inlinable func onNotifyFamilySet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyFamilySet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::family-set` signal for using the `connect(signal:)` methods
    static var notifyFamilySetSignal: CellRendererTextSignalName { .notifyFamilySet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::font` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFont` signal is emitted
    @discardableResult @inlinable func onNotifyFont(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyFont,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::font` signal for using the `connect(signal:)` methods
    static var notifyFontSignal: CellRendererTextSignalName { .notifyFont }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::font-desc` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFontDesc` signal is emitted
    @discardableResult @inlinable func onNotifyFontDesc(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyFontDesc,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::font-desc` signal for using the `connect(signal:)` methods
    static var notifyFontDescSignal: CellRendererTextSignalName { .notifyFontDesc }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::foreground` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyForeground` signal is emitted
    @discardableResult @inlinable func onNotifyForeground(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyForeground,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::foreground` signal for using the `connect(signal:)` methods
    static var notifyForegroundSignal: CellRendererTextSignalName { .notifyForeground }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::foreground-rgba` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyForegroundRgba` signal is emitted
    @discardableResult @inlinable func onNotifyForegroundRgba(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyForegroundRgba,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::foreground-rgba` signal for using the `connect(signal:)` methods
    static var notifyForegroundRgbaSignal: CellRendererTextSignalName { .notifyForegroundRgba }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::foreground-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyForegroundSet` signal is emitted
    @discardableResult @inlinable func onNotifyForegroundSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyForegroundSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::foreground-set` signal for using the `connect(signal:)` methods
    static var notifyForegroundSetSignal: CellRendererTextSignalName { .notifyForegroundSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::language` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyLanguage` signal is emitted
    @discardableResult @inlinable func onNotifyLanguage(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyLanguage,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::language` signal for using the `connect(signal:)` methods
    static var notifyLanguageSignal: CellRendererTextSignalName { .notifyLanguage }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::language-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyLanguageSet` signal is emitted
    @discardableResult @inlinable func onNotifyLanguageSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyLanguageSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::language-set` signal for using the `connect(signal:)` methods
    static var notifyLanguageSetSignal: CellRendererTextSignalName { .notifyLanguageSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::markup` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMarkup` signal is emitted
    @discardableResult @inlinable func onNotifyMarkup(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyMarkup,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::markup` signal for using the `connect(signal:)` methods
    static var notifyMarkupSignal: CellRendererTextSignalName { .notifyMarkup }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::max-width-chars` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMaxWidthChars` signal is emitted
    @discardableResult @inlinable func onNotifyMaxWidthChars(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyMaxWidthChars,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::max-width-chars` signal for using the `connect(signal:)` methods
    static var notifyMaxWidthCharsSignal: CellRendererTextSignalName { .notifyMaxWidthChars }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::placeholder-text` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPlaceholderText` signal is emitted
    @discardableResult @inlinable func onNotifyPlaceholderText(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyPlaceholderText,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::placeholder-text` signal for using the `connect(signal:)` methods
    static var notifyPlaceholderTextSignal: CellRendererTextSignalName { .notifyPlaceholderText }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::rise` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyRise` signal is emitted
    @discardableResult @inlinable func onNotifyRise(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyRise,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::rise` signal for using the `connect(signal:)` methods
    static var notifyRiseSignal: CellRendererTextSignalName { .notifyRise }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::rise-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyRiseSet` signal is emitted
    @discardableResult @inlinable func onNotifyRiseSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyRiseSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::rise-set` signal for using the `connect(signal:)` methods
    static var notifyRiseSetSignal: CellRendererTextSignalName { .notifyRiseSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::scale` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyScale` signal is emitted
    @discardableResult @inlinable func onNotifyScale(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyScale,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::scale` signal for using the `connect(signal:)` methods
    static var notifyScaleSignal: CellRendererTextSignalName { .notifyScale }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::scale-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyScaleSet` signal is emitted
    @discardableResult @inlinable func onNotifyScaleSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyScaleSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::scale-set` signal for using the `connect(signal:)` methods
    static var notifyScaleSetSignal: CellRendererTextSignalName { .notifyScaleSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::single-paragraph-mode` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySingleParagraphMode` signal is emitted
    @discardableResult @inlinable func onNotifySingleParagraphMode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifySingleParagraphMode,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::single-paragraph-mode` signal for using the `connect(signal:)` methods
    static var notifySingleParagraphModeSignal: CellRendererTextSignalName { .notifySingleParagraphMode }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::size` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySize` signal is emitted
    @discardableResult @inlinable func onNotifySize(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifySize,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::size` signal for using the `connect(signal:)` methods
    static var notifySizeSignal: CellRendererTextSignalName { .notifySize }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::size-points` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySizePoints` signal is emitted
    @discardableResult @inlinable func onNotifySizePoints(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifySizePoints,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::size-points` signal for using the `connect(signal:)` methods
    static var notifySizePointsSignal: CellRendererTextSignalName { .notifySizePoints }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::size-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySizeSet` signal is emitted
    @discardableResult @inlinable func onNotifySizeSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifySizeSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::size-set` signal for using the `connect(signal:)` methods
    static var notifySizeSetSignal: CellRendererTextSignalName { .notifySizeSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::stretch` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStretch` signal is emitted
    @discardableResult @inlinable func onNotifyStretch(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyStretch,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::stretch` signal for using the `connect(signal:)` methods
    static var notifyStretchSignal: CellRendererTextSignalName { .notifyStretch }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::stretch-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStretchSet` signal is emitted
    @discardableResult @inlinable func onNotifyStretchSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyStretchSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::stretch-set` signal for using the `connect(signal:)` methods
    static var notifyStretchSetSignal: CellRendererTextSignalName { .notifyStretchSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::strikethrough` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStrikethrough` signal is emitted
    @discardableResult @inlinable func onNotifyStrikethrough(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyStrikethrough,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::strikethrough` signal for using the `connect(signal:)` methods
    static var notifyStrikethroughSignal: CellRendererTextSignalName { .notifyStrikethrough }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::strikethrough-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStrikethroughSet` signal is emitted
    @discardableResult @inlinable func onNotifyStrikethroughSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyStrikethroughSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::strikethrough-set` signal for using the `connect(signal:)` methods
    static var notifyStrikethroughSetSignal: CellRendererTextSignalName { .notifyStrikethroughSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::style` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStyle` signal is emitted
    @discardableResult @inlinable func onNotifyStyle(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyStyle,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::style` signal for using the `connect(signal:)` methods
    static var notifyStyleSignal: CellRendererTextSignalName { .notifyStyle }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::style-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStyleSet` signal is emitted
    @discardableResult @inlinable func onNotifyStyleSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyStyleSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::style-set` signal for using the `connect(signal:)` methods
    static var notifyStyleSetSignal: CellRendererTextSignalName { .notifyStyleSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::text` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyText` signal is emitted
    @discardableResult @inlinable func onNotifyText(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyText,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::text` signal for using the `connect(signal:)` methods
    static var notifyTextSignal: CellRendererTextSignalName { .notifyText }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::underline` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyUnderline` signal is emitted
    @discardableResult @inlinable func onNotifyUnderline(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyUnderline,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::underline` signal for using the `connect(signal:)` methods
    static var notifyUnderlineSignal: CellRendererTextSignalName { .notifyUnderline }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::underline-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyUnderlineSet` signal is emitted
    @discardableResult @inlinable func onNotifyUnderlineSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyUnderlineSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::underline-set` signal for using the `connect(signal:)` methods
    static var notifyUnderlineSetSignal: CellRendererTextSignalName { .notifyUnderlineSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::variant` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyVariant` signal is emitted
    @discardableResult @inlinable func onNotifyVariant(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyVariant,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::variant` signal for using the `connect(signal:)` methods
    static var notifyVariantSignal: CellRendererTextSignalName { .notifyVariant }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::variant-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyVariantSet` signal is emitted
    @discardableResult @inlinable func onNotifyVariantSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyVariantSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::variant-set` signal for using the `connect(signal:)` methods
    static var notifyVariantSetSignal: CellRendererTextSignalName { .notifyVariantSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::weight` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWeight` signal is emitted
    @discardableResult @inlinable func onNotifyWeight(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyWeight,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::weight` signal for using the `connect(signal:)` methods
    static var notifyWeightSignal: CellRendererTextSignalName { .notifyWeight }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::weight-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWeightSet` signal is emitted
    @discardableResult @inlinable func onNotifyWeightSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyWeightSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::weight-set` signal for using the `connect(signal:)` methods
    static var notifyWeightSetSignal: CellRendererTextSignalName { .notifyWeightSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::width-chars` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWidthChars` signal is emitted
    @discardableResult @inlinable func onNotifyWidthChars(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyWidthChars,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::width-chars` signal for using the `connect(signal:)` methods
    static var notifyWidthCharsSignal: CellRendererTextSignalName { .notifyWidthChars }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::wrap-mode` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWrapMode` signal is emitted
    @discardableResult @inlinable func onNotifyWrapMode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyWrapMode,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::wrap-mode` signal for using the `connect(signal:)` methods
    static var notifyWrapModeSignal: CellRendererTextSignalName { .notifyWrapMode }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::wrap-width` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWrapWidth` signal is emitted
    @discardableResult @inlinable func onNotifyWrapWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererTextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererTextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyWrapWidth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::wrap-width` signal for using the `connect(signal:)` methods
    static var notifyWrapWidthSignal: CellRendererTextSignalName { .notifyWrapWidth }
    
}

// MARK: CellRendererText Class: CellRendererTextProtocol extension (methods and fields)
public extension CellRendererTextProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererText` instance.
    @inlinable var cell_renderer_text_ptr: UnsafeMutablePointer<GtkCellRendererText>! { return ptr?.assumingMemoryBound(to: GtkCellRendererText.self) }

    /// Sets the height of a renderer to explicitly be determined by the “font” and
    /// “y_pad” property set on it.  Further changes in these properties do not
    /// affect the height, so they must be accompanied by a subsequent call to this
    /// function.  Using this function is inflexible, and should really only be used
    /// if calculating the size of a cell is too slow (ie, a massive number of cells
    /// displayed).  If `number_of_rows` is -1, then the fixed height is unset, and
    /// the height is determined by the properties again.
    @inlinable func setFixedHeightFromFont(numberOfRows: Int) {
        
        gtk_cell_renderer_text_set_fixed_height_from_font(cell_renderer_text_ptr, gint(numberOfRows))
        
    }

    @inlinable var parent: GtkCellRenderer {
        get {
            let rv = cell_renderer_text_ptr.pointee.parent
    return rv
        }
    }

}



// MARK: - CellRendererToggle Class

/// Renders a toggle button in a cell
/// 
/// `GtkCellRendererToggle` renders a toggle button in a cell. The
/// button is drawn as a radio or a checkbutton, depending on the
/// `GtkCellRendererToggle:radio` property.
/// When activated, it emits the `GtkCellRendererToggle`toggled`` signal.
///
/// The `CellRendererToggleProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererToggle` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererToggle`.
/// Alternatively, use `CellRendererToggleRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererToggleProtocol: CellRendererProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererToggle` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererToggle` instance.
    var cell_renderer_toggle_ptr: UnsafeMutablePointer<GtkCellRendererToggle>! { get }

    /// Required Initialiser for types conforming to `CellRendererToggleProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Renders a toggle button in a cell
/// 
/// `GtkCellRendererToggle` renders a toggle button in a cell. The
/// button is drawn as a radio or a checkbutton, depending on the
/// `GtkCellRendererToggle:radio` property.
/// When activated, it emits the `GtkCellRendererToggle`toggled`` signal.
///
/// The `CellRendererToggleRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererToggle` instance.
/// It exposes methods that can operate on this data type through `CellRendererToggleProtocol` conformance.
/// Use `CellRendererToggleRef` only as an `unowned` reference to an existing `GtkCellRendererToggle` instance.
///
public struct CellRendererToggleRef: CellRendererToggleProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellRendererToggle` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_toggle_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererToggleRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererToggle>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererToggle>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererToggle>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererToggle>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererToggleProtocol`
    @inlinable init<T: CellRendererToggleProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellRendererToggleProtocol>(_ other: T) -> CellRendererToggleRef { CellRendererToggleRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererToggle`. Adjust rendering
    /// parameters using object properties. Object properties can be set
    /// globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`, you
    /// can bind a property to a value in a `GtkTreeModel`. For example, you
    /// can bind the “active” property on the cell renderer to a boolean value
    /// in the model, thus causing the check button to reflect the state of
    /// the model.
    @inlinable init() {
            let result = gtk_cell_renderer_toggle_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// Renders a toggle button in a cell
/// 
/// `GtkCellRendererToggle` renders a toggle button in a cell. The
/// button is drawn as a radio or a checkbutton, depending on the
/// `GtkCellRendererToggle:radio` property.
/// When activated, it emits the `GtkCellRendererToggle`toggled`` signal.
///
/// The `CellRendererToggle` type acts as a reference-counted owner of an underlying `GtkCellRendererToggle` instance.
/// It provides the methods that can operate on this data type through `CellRendererToggleProtocol` conformance.
/// Use `CellRendererToggle` as a strong reference or owner of a `GtkCellRendererToggle` instance.
///
open class CellRendererToggle: CellRenderer, CellRendererToggleProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererToggle>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererToggle>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererToggle>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererToggle>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererToggle`.
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererToggle>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererToggleProtocol`
    /// Will retain `GtkCellRendererToggle`.
    /// - Parameter other: an instance of a related type that implements `CellRendererToggleProtocol`
    @inlinable public init<T: CellRendererToggleProtocol>(cellRendererToggle other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererToggle`. Adjust rendering
    /// parameters using object properties. Object properties can be set
    /// globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`, you
    /// can bind a property to a value in a `GtkTreeModel`. For example, you
    /// can bind the “active” property on the cell renderer to a boolean value
    /// in the model, thus causing the check button to reflect the state of
    /// the model.
    @inlinable public init() {
            let result = gtk_cell_renderer_toggle_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CellRendererTogglePropertyName: String, PropertyNameProtocol {
    case activatable = "activatable"
    case active = "active"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editing = "editing"
    case height = "height"
    case inconsistent = "inconsistent"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case mode = "mode"
    case radio = "radio"
    case sensitive = "sensitive"
    case visible = "visible"
    case width = "width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererToggleProtocol {
    /// Bind a `CellRendererTogglePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererTogglePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererToggle property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererTogglePropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererToggle property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererTogglePropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererToggleSignalName: String, SignalNameProtocol {
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `toggled` signal is emitted when the cell is toggled.
    /// 
    /// It is the responsibility of the application to update the model
    /// with the correct value to store at `path`.  Often this is simply the
    /// opposite of the value currently stored at `path`.
    case toggled = "toggled"
    case notifyActivatable = "notify::activatable"
    case notifyActive = "notify::active"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditing = "notify::editing"
    case notifyHeight = "notify::height"
    case notifyInconsistent = "notify::inconsistent"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyMode = "notify::mode"
    case notifyRadio = "notify::radio"
    case notifySensitive = "notify::sensitive"
    case notifyVisible = "notify::visible"
    case notifyWidth = "notify::width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

// MARK: CellRendererToggle signals
public extension CellRendererToggleProtocol {
    /// Connect a Swift signal handler to the given, typed `CellRendererToggleSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellRendererToggleSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `CellRendererToggleSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellRendererToggleSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// The `toggled` signal is emitted when the cell is toggled.
    /// 
    /// It is the responsibility of the application to update the model
    /// with the correct value to store at `path`.  Often this is simply the
    /// opposite of the value currently stored at `path`.
    /// - Note: This represents the underlying `toggled` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter path: string representation of `GtkTreePath` describing the        event location
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `toggled` signal is emitted
    @discardableResult @inlinable func onToggled(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererToggleRef, _ path: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererToggleRef, String), Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererToggleRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!))
            return output
        }
        return connect(
            signal: .toggled,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `toggled` signal for using the `connect(signal:)` methods
    static var toggledSignal: CellRendererToggleSignalName { .toggled }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::activatable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActivatable` signal is emitted
    @discardableResult @inlinable func onNotifyActivatable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererToggleRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererToggleRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererToggleRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyActivatable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::activatable` signal for using the `connect(signal:)` methods
    static var notifyActivatableSignal: CellRendererToggleSignalName { .notifyActivatable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::active` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActive` signal is emitted
    @discardableResult @inlinable func onNotifyActive(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererToggleRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererToggleRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererToggleRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyActive,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::active` signal for using the `connect(signal:)` methods
    static var notifyActiveSignal: CellRendererToggleSignalName { .notifyActive }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::inconsistent` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyInconsistent` signal is emitted
    @discardableResult @inlinable func onNotifyInconsistent(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererToggleRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererToggleRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererToggleRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyInconsistent,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::inconsistent` signal for using the `connect(signal:)` methods
    static var notifyInconsistentSignal: CellRendererToggleSignalName { .notifyInconsistent }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::radio` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyRadio` signal is emitted
    @discardableResult @inlinable func onNotifyRadio(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererToggleRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CellRendererToggleRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CellRendererToggleRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyRadio,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::radio` signal for using the `connect(signal:)` methods
    static var notifyRadioSignal: CellRendererToggleSignalName { .notifyRadio }
    
}

// MARK: CellRendererToggle Class: CellRendererToggleProtocol extension (methods and fields)
public extension CellRendererToggleProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererToggle` instance.
    @inlinable var cell_renderer_toggle_ptr: UnsafeMutablePointer<GtkCellRendererToggle>! { return ptr?.assumingMemoryBound(to: GtkCellRendererToggle.self) }

    /// Returns whether the cell renderer is activatable. See
    /// `gtk_cell_renderer_toggle_set_activatable()`.
    @inlinable func getActivatable() -> Bool {
        let result = gtk_cell_renderer_toggle_get_activatable(cell_renderer_toggle_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns whether the cell renderer is active. See
    /// `gtk_cell_renderer_toggle_set_active()`.
    @inlinable func getActive() -> Bool {
        let result = gtk_cell_renderer_toggle_get_active(cell_renderer_toggle_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns whether we’re rendering radio toggles rather than checkboxes.
    @inlinable func getRadio() -> Bool {
        let result = gtk_cell_renderer_toggle_get_radio(cell_renderer_toggle_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Makes the cell renderer activatable.
    @inlinable func setActivatable(setting: Bool) {
        
        gtk_cell_renderer_toggle_set_activatable(cell_renderer_toggle_ptr, gboolean((setting) ? 1 : 0))
        
    }

    /// Activates or deactivates a cell renderer.
    @inlinable func setActive(setting: Bool) {
        
        gtk_cell_renderer_toggle_set_active(cell_renderer_toggle_ptr, gboolean((setting) ? 1 : 0))
        
    }

    /// If `radio` is `true`, the cell renderer renders a radio toggle
    /// (i.e. a toggle in a group of mutually-exclusive toggles).
    /// If `false`, it renders a check toggle (a standalone boolean option).
    /// This can be set globally for the cell renderer, or changed just
    /// before rendering each cell in the model (for `GtkTreeView`, you set
    /// up a per-row setting using `GtkTreeViewColumn` to associate model
    /// columns with cell renderer properties).
    @inlinable func set(radio: Bool) {
        
        gtk_cell_renderer_toggle_set_radio(cell_renderer_toggle_ptr, gboolean((radio) ? 1 : 0))
        
    }
    @inlinable var activatable: Bool {
        /// Returns whether the cell renderer is activatable. See
        /// `gtk_cell_renderer_toggle_set_activatable()`.
        get {
            let result = gtk_cell_renderer_toggle_get_activatable(cell_renderer_toggle_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Makes the cell renderer activatable.
        nonmutating set {
            gtk_cell_renderer_toggle_set_activatable(cell_renderer_toggle_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var active: Bool {
        /// Returns whether the cell renderer is active. See
        /// `gtk_cell_renderer_toggle_set_active()`.
        get {
            let result = gtk_cell_renderer_toggle_get_active(cell_renderer_toggle_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Activates or deactivates a cell renderer.
        nonmutating set {
            gtk_cell_renderer_toggle_set_active(cell_renderer_toggle_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var radio: Bool {
        /// Returns whether we’re rendering radio toggles rather than checkboxes.
        get {
            let result = gtk_cell_renderer_toggle_get_radio(cell_renderer_toggle_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// If `radio` is `true`, the cell renderer renders a radio toggle
        /// (i.e. a toggle in a group of mutually-exclusive toggles).
        /// If `false`, it renders a check toggle (a standalone boolean option).
        /// This can be set globally for the cell renderer, or changed just
        /// before rendering each cell in the model (for `GtkTreeView`, you set
        /// up a per-row setting using `GtkTreeViewColumn` to associate model
        /// columns with cell renderer properties).
        nonmutating set {
            gtk_cell_renderer_toggle_set_radio(cell_renderer_toggle_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - CellView Class

/// A widget displaying a single row of a GtkTreeModel
/// 
/// A `GtkCellView` displays a single row of a `GtkTreeModel` using a `GtkCellArea`
/// and `GtkCellAreaContext`. A `GtkCellAreaContext` can be provided to the
/// `GtkCellView` at construction time in order to keep the cellview in context
/// of a group of cell views, this ensures that the renderers displayed will
/// be properly aligned with each other (like the aligned cells in the menus
/// of `GtkComboBox`).
/// 
/// `GtkCellView` is `GtkOrientable` in order to decide in which orientation
/// the underlying `GtkCellAreaContext` should be allocated. Taking the `GtkComboBox`
/// menu as an example, cellviews should be oriented horizontally if the menus are
/// listed top-to-bottom and thus all share the same width but may have separate
/// individual heights (left-to-right menus should be allocated vertically since
/// they all share the same height but may have variable widths).
/// 
/// # CSS nodes
/// 
/// GtkCellView has a single CSS node with name cellview.
///
/// The `CellViewProtocol` protocol exposes the methods and properties of an underlying `GtkCellView` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellView`.
/// Alternatively, use `CellViewRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellViewProtocol: WidgetProtocol, CellLayoutProtocol, OrientableProtocol {
        /// Untyped pointer to the underlying `GtkCellView` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellView` instance.
    var cell_view_ptr: UnsafeMutablePointer<GtkCellView>! { get }

    /// Required Initialiser for types conforming to `CellViewProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A widget displaying a single row of a GtkTreeModel
/// 
/// A `GtkCellView` displays a single row of a `GtkTreeModel` using a `GtkCellArea`
/// and `GtkCellAreaContext`. A `GtkCellAreaContext` can be provided to the
/// `GtkCellView` at construction time in order to keep the cellview in context
/// of a group of cell views, this ensures that the renderers displayed will
/// be properly aligned with each other (like the aligned cells in the menus
/// of `GtkComboBox`).
/// 
/// `GtkCellView` is `GtkOrientable` in order to decide in which orientation
/// the underlying `GtkCellAreaContext` should be allocated. Taking the `GtkComboBox`
/// menu as an example, cellviews should be oriented horizontally if the menus are
/// listed top-to-bottom and thus all share the same width but may have separate
/// individual heights (left-to-right menus should be allocated vertically since
/// they all share the same height but may have variable widths).
/// 
/// # CSS nodes
/// 
/// GtkCellView has a single CSS node with name cellview.
///
/// The `CellViewRef` type acts as a lightweight Swift reference to an underlying `GtkCellView` instance.
/// It exposes methods that can operate on this data type through `CellViewProtocol` conformance.
/// Use `CellViewRef` only as an `unowned` reference to an existing `GtkCellView` instance.
///
public struct CellViewRef: CellViewProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellView` instance.
    /// For type-safe access, use the generated, typed pointer `cell_view_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellViewRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellView>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellView>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellView>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellView>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellViewProtocol`
    @inlinable init<T: CellViewProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellViewProtocol>(_ other: T) -> CellViewRef { CellViewRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellView` widget.
    @inlinable init() {
            let result = gtk_cell_view_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkCellView` widget with a specific `GtkCellArea`
    /// to layout cells and a specific `GtkCellAreaContext`.
    /// 
    /// Specifying the same context for a handful of cells lets
    /// the underlying area synchronize the geometry for those cells,
    /// in this way alignments with cellviews for other rows are
    /// possible.
    @inlinable init<CellAreaContextT: CellAreaContextProtocol, CellAreaT: CellAreaProtocol>(context area: CellAreaT, context: CellAreaContextT) {
            let result = gtk_cell_view_new_with_context(area.cell_area_ptr, context.cell_area_context_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `markup`. The text can be marked up with
    /// the [Pango text markup language](https://docs.gtk.org/Pango/pango_markup.html).
    @inlinable init(markup: UnsafePointer<CChar>!) {
            let result = gtk_cell_view_new_with_markup(markup)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `text`.
    @inlinable init(text: UnsafePointer<CChar>!) {
            let result = gtk_cell_view_new_with_text(text)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererPixbuf`
    /// to it, and makes it show `texture`.
    @inlinable init<GdkTextureT: Gdk.TextureProtocol>(texture: GdkTextureT) {
            let result = gtk_cell_view_new_with_texture(texture.texture_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkCellView` widget with a specific `GtkCellArea`
    /// to layout cells and a specific `GtkCellAreaContext`.
    /// 
    /// Specifying the same context for a handful of cells lets
    /// the underlying area synchronize the geometry for those cells,
    /// in this way alignments with cellviews for other rows are
    /// possible.
    @inlinable static func newWith<CellAreaContextT: CellAreaContextProtocol, CellAreaT: CellAreaProtocol>(context area: CellAreaT, context: CellAreaContextT) -> WidgetRef! {
            let result = gtk_cell_view_new_with_context(area.cell_area_ptr, context.cell_area_context_ptr)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `markup`. The text can be marked up with
    /// the [Pango text markup language](https://docs.gtk.org/Pango/pango_markup.html).
    @inlinable static func newWith(markup: UnsafePointer<CChar>!) -> WidgetRef! {
            let result = gtk_cell_view_new_with_markup(markup)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `text`.
    @inlinable static func newWith(text: UnsafePointer<CChar>!) -> WidgetRef! {
            let result = gtk_cell_view_new_with_text(text)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererPixbuf`
    /// to it, and makes it show `texture`.
    @inlinable static func newWith<GdkTextureT: Gdk.TextureProtocol>(texture: GdkTextureT) -> WidgetRef! {
            let result = gtk_cell_view_new_with_texture(texture.texture_ptr)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }
}

/// A widget displaying a single row of a GtkTreeModel
/// 
/// A `GtkCellView` displays a single row of a `GtkTreeModel` using a `GtkCellArea`
/// and `GtkCellAreaContext`. A `GtkCellAreaContext` can be provided to the
/// `GtkCellView` at construction time in order to keep the cellview in context
/// of a group of cell views, this ensures that the renderers displayed will
/// be properly aligned with each other (like the aligned cells in the menus
/// of `GtkComboBox`).
/// 
/// `GtkCellView` is `GtkOrientable` in order to decide in which orientation
/// the underlying `GtkCellAreaContext` should be allocated. Taking the `GtkComboBox`
/// menu as an example, cellviews should be oriented horizontally if the menus are
/// listed top-to-bottom and thus all share the same width but may have separate
/// individual heights (left-to-right menus should be allocated vertically since
/// they all share the same height but may have variable widths).
/// 
/// # CSS nodes
/// 
/// GtkCellView has a single CSS node with name cellview.
///
/// The `CellView` type acts as a reference-counted owner of an underlying `GtkCellView` instance.
/// It provides the methods that can operate on this data type through `CellViewProtocol` conformance.
/// Use `CellView` as a strong reference or owner of a `GtkCellView` instance.
///
open class CellView: Widget, CellViewProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellView>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellView>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellView>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellView>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellView`.
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellView>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellViewProtocol`
    /// Will retain `GtkCellView`.
    /// - Parameter other: an instance of a related type that implements `CellViewProtocol`
    @inlinable public init<T: CellViewProtocol>(cellView other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellView` widget.
    @inlinable public init() {
            let result = gtk_cell_view_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkCellView` widget with a specific `GtkCellArea`
    /// to layout cells and a specific `GtkCellAreaContext`.
    /// 
    /// Specifying the same context for a handful of cells lets
    /// the underlying area synchronize the geometry for those cells,
    /// in this way alignments with cellviews for other rows are
    /// possible.
    @inlinable public init<CellAreaContextT: CellAreaContextProtocol, CellAreaT: CellAreaProtocol>(context area: CellAreaT, context: CellAreaContextT) {
            let result = gtk_cell_view_new_with_context(area.cell_area_ptr, context.cell_area_context_ptr)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `markup`. The text can be marked up with
    /// the [Pango text markup language](https://docs.gtk.org/Pango/pango_markup.html).
    @inlinable public init(markup: UnsafePointer<CChar>!) {
            let result = gtk_cell_view_new_with_markup(markup)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `text`.
    @inlinable public init(text: UnsafePointer<CChar>!) {
            let result = gtk_cell_view_new_with_text(text)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererPixbuf`
    /// to it, and makes it show `texture`.
    @inlinable public init<GdkTextureT: Gdk.TextureProtocol>(texture: GdkTextureT) {
            let result = gtk_cell_view_new_with_texture(texture.texture_ptr)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkCellView` widget with a specific `GtkCellArea`
    /// to layout cells and a specific `GtkCellAreaContext`.
    /// 
    /// Specifying the same context for a handful of cells lets
    /// the underlying area synchronize the geometry for those cells,
    /// in this way alignments with cellviews for other rows are
    /// possible.
    @inlinable public static func newWith<CellAreaContextT: CellAreaContextProtocol, CellAreaT: CellAreaProtocol>(context area: CellAreaT, context: CellAreaContextT) -> Widget! {
            let result = gtk_cell_view_new_with_context(area.cell_area_ptr, context.cell_area_context_ptr)
        guard let rv = Widget(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `markup`. The text can be marked up with
    /// the [Pango text markup language](https://docs.gtk.org/Pango/pango_markup.html).
    @inlinable public static func newWith(markup: UnsafePointer<CChar>!) -> Widget! {
            let result = gtk_cell_view_new_with_markup(markup)
        guard let rv = Widget(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `text`.
    @inlinable public static func newWith(text: UnsafePointer<CChar>!) -> Widget! {
            let result = gtk_cell_view_new_with_text(text)
        guard let rv = Widget(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererPixbuf`
    /// to it, and makes it show `texture`.
    @inlinable public static func newWith<GdkTextureT: Gdk.TextureProtocol>(texture: GdkTextureT) -> Widget! {
            let result = gtk_cell_view_new_with_texture(texture.texture_ptr)
        guard let rv = Widget(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

}

public enum CellViewPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// The `GtkCellArea` rendering cells
    /// 
    /// If no area is specified when creating the cell view with `gtk_cell_view_new_with_context()`
    /// a horizontally oriented `GtkCellArea`Box will be used.
    /// 
    /// since 3.0
    case cellArea = "cell-area"
    /// The `GtkCellAreaContext` used to compute the geometry of the cell view.
    /// 
    /// A group of cell views can be assigned the same context in order to
    /// ensure the sizes and cell alignments match across all the views with
    /// the same context.
    /// 
    /// `GtkComboBox` menus uses this to assign the same context to all cell views
    /// in the menu items for a single menu (each submenu creates its own
    /// context since the size of each submenu does not depend on parent
    /// or sibling menus).
    /// 
    /// since 3.0
    case cellAreaContext = "cell-area-context"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether all cells should be draw as sensitive for this view regardless
    /// of the actual cell properties (used to make menus with submenus appear
    /// sensitive when the items in submenus might be insensitive).
    /// 
    /// since 3.0
    case drawSensitive = "draw-sensitive"
    /// Whether the view should request enough space to always fit
    /// the size of every row in the model (used by the combo box to
    /// ensure the combo box size doesn't change when different items
    /// are selected).
    /// 
    /// since 3.0
    case fitModel = "fit-model"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The model for cell view
    /// 
    /// since 2.10
    case model = "model"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension CellViewProtocol {
    /// Bind a `CellViewPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellViewPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellView property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellViewPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellView property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellViewPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellViewSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// The `GtkCellArea` rendering cells
    /// 
    /// If no area is specified when creating the cell view with `gtk_cell_view_new_with_context()`
    /// a horizontally oriented `GtkCellArea`Box will be used.
    /// 
    /// since 3.0
    case notifyCellArea = "notify::cell-area"
    /// The `GtkCellAreaContext` used to compute the geometry of the cell view.
    /// 
    /// A group of cell views can be assigned the same context in order to
    /// ensure the sizes and cell alignments match across all the views with
    /// the same context.
    /// 
    /// `GtkComboBox` menus uses this to assign the same context to all cell views
    /// in the menu items for a single menu (each submenu creates its own
    /// context since the size of each submenu does not depend on parent
    /// or sibling menus).
    /// 
    /// since 3.0
    case notifyCellAreaContext = "notify::cell-area-context"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether all cells should be draw as sensitive for this view regardless
    /// of the actual cell properties (used to make menus with submenus appear
    /// sensitive when the items in submenus might be insensitive).
    /// 
    /// since 3.0
    case notifyDrawSensitive = "notify::draw-sensitive"
    /// Whether the view should request enough space to always fit
    /// the size of every row in the model (used by the combo box to
    /// ensure the combo box size doesn't change when different items
    /// are selected).
    /// 
    /// since 3.0
    case notifyFitModel = "notify::fit-model"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The model for cell view
    /// 
    /// since 2.10
    case notifyModel = "notify::model"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: CellView has no signals
// MARK: CellView Class: CellViewProtocol extension (methods and fields)
public extension CellViewProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellView` instance.
    @inlinable var cell_view_ptr: UnsafeMutablePointer<GtkCellView>! { return ptr?.assumingMemoryBound(to: GtkCellView.self) }

    /// Returns a `GtkTreePath` referring to the currently
    /// displayed row. If no row is currently displayed,
    /// `nil` is returned.
    @inlinable func getDisplayedRow() -> TreePathRef! {
        let result = gtk_cell_view_get_displayed_row(cell_view_ptr)
        let rv = TreePathRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets whether `cell_view` is configured to draw all of its
    /// cells in a sensitive state.
    @inlinable func getDrawSensitive() -> Bool {
        let result = gtk_cell_view_get_draw_sensitive(cell_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets whether `cell_view` is configured to request space
    /// to fit the entire `GtkTreeModel`.
    @inlinable func getFitModel() -> Bool {
        let result = gtk_cell_view_get_fit_model(cell_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns the model for `cell_view`. If no model is used `nil` is
    /// returned.
    @inlinable func getModel() -> TreeModelRef! {
        let result = gtk_cell_view_get_model(cell_view_ptr)
        let rv = TreeModelRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Sets the row of the model that is currently displayed
    /// by the `GtkCellView`. If the path is unset, then the
    /// contents of the cellview “stick” at their last value;
    /// this is not normally a desired result, but may be
    /// a needed intermediate state if say, the model for
    /// the `GtkCellView` becomes temporarily empty.
    @inlinable func setDisplayedRow(path: TreePathRef? = nil) {
            
        gtk_cell_view_set_displayed_row(cell_view_ptr, path?.tree_path_ptr)
            
    }
    /// Sets the row of the model that is currently displayed
    /// by the `GtkCellView`. If the path is unset, then the
    /// contents of the cellview “stick” at their last value;
    /// this is not normally a desired result, but may be
    /// a needed intermediate state if say, the model for
    /// the `GtkCellView` becomes temporarily empty.
    @inlinable func setDisplayedRow<TreePathT: TreePathProtocol>(path: TreePathT?) {
        
        gtk_cell_view_set_displayed_row(cell_view_ptr, path?.tree_path_ptr)
        
    }

    /// Sets whether `cell_view` should draw all of its
    /// cells in a sensitive state, this is used by `GtkComboBox` menus
    /// to ensure that rows with insensitive cells that contain
    /// children appear sensitive in the parent menu item.
    @inlinable func set(drawSensitive: Bool) {
        
        gtk_cell_view_set_draw_sensitive(cell_view_ptr, gboolean((drawSensitive) ? 1 : 0))
        
    }

    /// Sets whether `cell_view` should request space to fit the entire `GtkTreeModel`.
    /// 
    /// This is used by `GtkComboBox` to ensure that the cell view displayed on
    /// the combo box’s button always gets enough space and does not resize
    /// when selection changes.
    @inlinable func set(fitModel: Bool) {
        
        gtk_cell_view_set_fit_model(cell_view_ptr, gboolean((fitModel) ? 1 : 0))
        
    }

    /// Sets the model for `cell_view`.  If `cell_view` already has a model
    /// set, it will remove it before setting the new model.  If `model` is
    /// `nil`, then it will unset the old model.
    @inlinable func set(model: TreeModelRef? = nil) {
            
        gtk_cell_view_set_model(cell_view_ptr, model?.tree_model_ptr)
            
    }
    /// Sets the model for `cell_view`.  If `cell_view` already has a model
    /// set, it will remove it before setting the new model.  If `model` is
    /// `nil`, then it will unset the old model.
    @inlinable func set<TreeModelT: TreeModelProtocol>(model: TreeModelT?) {
        
        gtk_cell_view_set_model(cell_view_ptr, model?.tree_model_ptr)
        
    }
    /// Returns a `GtkTreePath` referring to the currently
    /// displayed row. If no row is currently displayed,
    /// `nil` is returned.
    @inlinable var displayedRow: TreePathRef! {
        /// Returns a `GtkTreePath` referring to the currently
        /// displayed row. If no row is currently displayed,
        /// `nil` is returned.
        get {
            let result = gtk_cell_view_get_displayed_row(cell_view_ptr)
        let rv = TreePathRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets the row of the model that is currently displayed
        /// by the `GtkCellView`. If the path is unset, then the
        /// contents of the cellview “stick” at their last value;
        /// this is not normally a desired result, but may be
        /// a needed intermediate state if say, the model for
        /// the `GtkCellView` becomes temporarily empty.
        nonmutating set {
            gtk_cell_view_set_displayed_row(cell_view_ptr, UnsafeMutablePointer<GtkTreePath>(newValue?.tree_path_ptr))
        }
    }

    /// Gets whether `cell_view` is configured to draw all of its
    /// cells in a sensitive state.
    @inlinable var drawSensitive: Bool {
        /// Gets whether `cell_view` is configured to draw all of its
        /// cells in a sensitive state.
        get {
            let result = gtk_cell_view_get_draw_sensitive(cell_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether `cell_view` should draw all of its
        /// cells in a sensitive state, this is used by `GtkComboBox` menus
        /// to ensure that rows with insensitive cells that contain
        /// children appear sensitive in the parent menu item.
        nonmutating set {
            gtk_cell_view_set_draw_sensitive(cell_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets whether `cell_view` is configured to request space
    /// to fit the entire `GtkTreeModel`.
    @inlinable var fitModel: Bool {
        /// Gets whether `cell_view` is configured to request space
        /// to fit the entire `GtkTreeModel`.
        get {
            let result = gtk_cell_view_get_fit_model(cell_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether `cell_view` should request space to fit the entire `GtkTreeModel`.
        /// 
        /// This is used by `GtkComboBox` to ensure that the cell view displayed on
        /// the combo box’s button always gets enough space and does not resize
        /// when selection changes.
        nonmutating set {
            gtk_cell_view_set_fit_model(cell_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// The model for cell view
    /// 
    /// since 2.10
    @inlinable var model: TreeModelRef! {
        /// Returns the model for `cell_view`. If no model is used `nil` is
        /// returned.
        get {
            let result = gtk_cell_view_get_model(cell_view_ptr)
        let rv = TreeModelRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets the model for `cell_view`.  If `cell_view` already has a model
        /// set, it will remove it before setting the new model.  If `model` is
        /// `nil`, then it will unset the old model.
        nonmutating set {
            gtk_cell_view_set_model(cell_view_ptr, UnsafeMutablePointer<GtkTreeModel>(newValue?.tree_model_ptr))
        }
    }


}



// MARK: - CenterBox Class

/// `GtkCenterBox` arranges three children in a row, keeping the middle child
/// centered as well as possible.
/// 
/// ![An example GtkCenterBox](centerbox.png)
/// 
/// To add children to `GtkCenterBox`, use [method`Gtk.CenterBox.set_start_widget`],
/// [method`Gtk.CenterBox.set_center_widget`] and
/// [method`Gtk.CenterBox.set_end_widget`].
/// 
/// The sizing and positioning of children can be influenced with the
/// align and expand properties of the children.
/// 
/// # GtkCenterBox as GtkBuildable
/// 
/// The `GtkCenterBox` implementation of the `GtkBuildable` interface
/// supports placing children in the 3 positions by specifying “start”, “center”
/// or “end” as the “type” attribute of a &lt;child&gt; element.
/// 
/// # CSS nodes
/// 
/// `GtkCenterBox` uses a single CSS node with the name “box”,
/// 
/// The first child of the `GtkCenterBox` will be allocated depending on the
/// text direction, i.e. in left-to-right layouts it will be allocated on the
/// left and in right-to-left layouts on the right.
/// 
/// In vertical orientation, the nodes of the children are arranged from top to
/// bottom.
/// 
/// # Accessibility
/// 
/// `GtkCenterBox` uses the `GTK_ACCESSIBLE_ROLE_GROUP` role.
///
/// The `CenterBoxProtocol` protocol exposes the methods and properties of an underlying `GtkCenterBox` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CenterBox`.
/// Alternatively, use `CenterBoxRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CenterBoxProtocol: WidgetProtocol, OrientableProtocol {
        /// Untyped pointer to the underlying `GtkCenterBox` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCenterBox` instance.
    var center_box_ptr: UnsafeMutablePointer<GtkCenterBox>! { get }

    /// Required Initialiser for types conforming to `CenterBoxProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkCenterBox` arranges three children in a row, keeping the middle child
/// centered as well as possible.
/// 
/// ![An example GtkCenterBox](centerbox.png)
/// 
/// To add children to `GtkCenterBox`, use [method`Gtk.CenterBox.set_start_widget`],
/// [method`Gtk.CenterBox.set_center_widget`] and
/// [method`Gtk.CenterBox.set_end_widget`].
/// 
/// The sizing and positioning of children can be influenced with the
/// align and expand properties of the children.
/// 
/// # GtkCenterBox as GtkBuildable
/// 
/// The `GtkCenterBox` implementation of the `GtkBuildable` interface
/// supports placing children in the 3 positions by specifying “start”, “center”
/// or “end” as the “type” attribute of a &lt;child&gt; element.
/// 
/// # CSS nodes
/// 
/// `GtkCenterBox` uses a single CSS node with the name “box”,
/// 
/// The first child of the `GtkCenterBox` will be allocated depending on the
/// text direction, i.e. in left-to-right layouts it will be allocated on the
/// left and in right-to-left layouts on the right.
/// 
/// In vertical orientation, the nodes of the children are arranged from top to
/// bottom.
/// 
/// # Accessibility
/// 
/// `GtkCenterBox` uses the `GTK_ACCESSIBLE_ROLE_GROUP` role.
///
/// The `CenterBoxRef` type acts as a lightweight Swift reference to an underlying `GtkCenterBox` instance.
/// It exposes methods that can operate on this data type through `CenterBoxProtocol` conformance.
/// Use `CenterBoxRef` only as an `unowned` reference to an existing `GtkCenterBox` instance.
///
public struct CenterBoxRef: CenterBoxProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCenterBox` instance.
    /// For type-safe access, use the generated, typed pointer `center_box_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CenterBoxRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCenterBox>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCenterBox>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCenterBox>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCenterBox>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CenterBoxProtocol`
    @inlinable init<T: CenterBoxProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CenterBoxProtocol>(_ other: T) -> CenterBoxRef { CenterBoxRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCenterBox`.
    @inlinable init() {
            let result = gtk_center_box_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkCenterBox` arranges three children in a row, keeping the middle child
/// centered as well as possible.
/// 
/// ![An example GtkCenterBox](centerbox.png)
/// 
/// To add children to `GtkCenterBox`, use [method`Gtk.CenterBox.set_start_widget`],
/// [method`Gtk.CenterBox.set_center_widget`] and
/// [method`Gtk.CenterBox.set_end_widget`].
/// 
/// The sizing and positioning of children can be influenced with the
/// align and expand properties of the children.
/// 
/// # GtkCenterBox as GtkBuildable
/// 
/// The `GtkCenterBox` implementation of the `GtkBuildable` interface
/// supports placing children in the 3 positions by specifying “start”, “center”
/// or “end” as the “type” attribute of a &lt;child&gt; element.
/// 
/// # CSS nodes
/// 
/// `GtkCenterBox` uses a single CSS node with the name “box”,
/// 
/// The first child of the `GtkCenterBox` will be allocated depending on the
/// text direction, i.e. in left-to-right layouts it will be allocated on the
/// left and in right-to-left layouts on the right.
/// 
/// In vertical orientation, the nodes of the children are arranged from top to
/// bottom.
/// 
/// # Accessibility
/// 
/// `GtkCenterBox` uses the `GTK_ACCESSIBLE_ROLE_GROUP` role.
///
/// The `CenterBox` type acts as a reference-counted owner of an underlying `GtkCenterBox` instance.
/// It provides the methods that can operate on this data type through `CenterBoxProtocol` conformance.
/// Use `CenterBox` as a strong reference or owner of a `GtkCenterBox` instance.
///
open class CenterBox: Widget, CenterBoxProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCenterBox>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCenterBox>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCenterBox>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCenterBox>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCenterBox`.
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCenterBox>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CenterBoxProtocol`
    /// Will retain `GtkCenterBox`.
    /// - Parameter other: an instance of a related type that implements `CenterBoxProtocol`
    @inlinable public init<T: CenterBoxProtocol>(centerBox other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCenterBox`.
    @inlinable public init() {
            let result = gtk_center_box_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CenterBoxPropertyName: String, PropertyNameProtocol {
    /// The position of the baseline aligned widget if extra space is available.
    case baselinePosition = "baseline-position"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension CenterBoxProtocol {
    /// Bind a `CenterBoxPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CenterBoxPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CenterBox property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CenterBoxPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CenterBox property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CenterBoxPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CenterBoxSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// The position of the baseline aligned widget if extra space is available.
    case notifyBaselinePosition = "notify::baseline-position"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: CenterBox has no signals
// MARK: CenterBox Class: CenterBoxProtocol extension (methods and fields)
public extension CenterBoxProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCenterBox` instance.
    @inlinable var center_box_ptr: UnsafeMutablePointer<GtkCenterBox>! { return ptr?.assumingMemoryBound(to: GtkCenterBox.self) }

    /// Gets the value set by `gtk_center_box_set_baseline_position()`.
    @inlinable func getBaselinePosition() -> GtkBaselinePosition {
        let result = gtk_center_box_get_baseline_position(center_box_ptr)
        let rv = result
        return rv
    }

    /// Gets the center widget, or `nil` if there is none.
    @inlinable func getCenterWidget() -> WidgetRef! {
        let result = gtk_center_box_get_center_widget(center_box_ptr)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Gets the end widget, or `nil` if there is none.
    @inlinable func getEndWidget() -> WidgetRef! {
        let result = gtk_center_box_get_end_widget(center_box_ptr)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Gets the start widget, or `nil` if there is none.
    @inlinable func getStartWidget() -> WidgetRef! {
        let result = gtk_center_box_get_start_widget(center_box_ptr)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Sets the baseline position of a center box.
    /// 
    /// This affects only horizontal boxes with at least one baseline
    /// aligned child. If there is more vertical space available than
    /// requested, and the baseline is not allocated by the parent then
    /// `position` is used to allocate the baseline wrt. the extra space
    /// available.
    @inlinable func setBaseline(position: GtkBaselinePosition) {
        
        gtk_center_box_set_baseline_position(center_box_ptr, position)
        
    }

    /// Sets the center widget.
    /// 
    /// To remove the existing center widget, pas `nil`.
    @inlinable func setCenterWidget(child: WidgetRef? = nil) {
            
        gtk_center_box_set_center_widget(center_box_ptr, child?.widget_ptr)
            
    }
    /// Sets the center widget.
    /// 
    /// To remove the existing center widget, pas `nil`.
    @inlinable func setCenterWidget<WidgetT: WidgetProtocol>(child: WidgetT?) {
        
        gtk_center_box_set_center_widget(center_box_ptr, child?.widget_ptr)
        
    }

    /// Sets the end widget.
    /// 
    /// To remove the existing end widget, pass `nil`.
    @inlinable func setEndWidget(child: WidgetRef? = nil) {
            
        gtk_center_box_set_end_widget(center_box_ptr, child?.widget_ptr)
            
    }
    /// Sets the end widget.
    /// 
    /// To remove the existing end widget, pass `nil`.
    @inlinable func setEndWidget<WidgetT: WidgetProtocol>(child: WidgetT?) {
        
        gtk_center_box_set_end_widget(center_box_ptr, child?.widget_ptr)
        
    }

    /// Sets the start widget.
    /// 
    /// To remove the existing start widget, pass `nil`.
    @inlinable func setStartWidget(child: WidgetRef? = nil) {
            
        gtk_center_box_set_start_widget(center_box_ptr, child?.widget_ptr)
            
    }
    /// Sets the start widget.
    /// 
    /// To remove the existing start widget, pass `nil`.
    @inlinable func setStartWidget<WidgetT: WidgetProtocol>(child: WidgetT?) {
        
        gtk_center_box_set_start_widget(center_box_ptr, child?.widget_ptr)
        
    }
    /// Gets the value set by `gtk_center_box_set_baseline_position()`.
    @inlinable var baselinePosition: GtkBaselinePosition {
        /// Gets the value set by `gtk_center_box_set_baseline_position()`.
        get {
            let result = gtk_center_box_get_baseline_position(center_box_ptr)
        let rv = result
            return rv
        }
        /// Sets the baseline position of a center box.
        /// 
        /// This affects only horizontal boxes with at least one baseline
        /// aligned child. If there is more vertical space available than
        /// requested, and the baseline is not allocated by the parent then
        /// `position` is used to allocate the baseline wrt. the extra space
        /// available.
        nonmutating set {
            gtk_center_box_set_baseline_position(center_box_ptr, newValue)
        }
    }

    /// Gets the center widget, or `nil` if there is none.
    @inlinable var centerWidget: WidgetRef! {
        /// Gets the center widget, or `nil` if there is none.
        get {
            let result = gtk_center_box_get_center_widget(center_box_ptr)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
            return rv
        }
        /// Sets the center widget.
        /// 
        /// To remove the existing center widget, pas `nil`.
        nonmutating set {
            gtk_center_box_set_center_widget(center_box_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Gets the end widget, or `nil` if there is none.
    @inlinable var endWidget: WidgetRef! {
        /// Gets the end widget, or `nil` if there is none.
        get {
            let result = gtk_center_box_get_end_widget(center_box_ptr)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
            return rv
        }
        /// Sets the end widget.
        /// 
        /// To remove the existing end widget, pass `nil`.
        nonmutating set {
            gtk_center_box_set_end_widget(center_box_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Gets the start widget, or `nil` if there is none.
    @inlinable var startWidget: WidgetRef! {
        /// Gets the start widget, or `nil` if there is none.
        get {
            let result = gtk_center_box_get_start_widget(center_box_ptr)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
            return rv
        }
        /// Sets the start widget.
        /// 
        /// To remove the existing start widget, pass `nil`.
        nonmutating set {
            gtk_center_box_set_start_widget(center_box_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }


}



// MARK: - CenterLayout Class

/// `GtkCenterLayout` is a layout manager that manages up to three children.
/// 
/// The start widget is allocated at the start of the layout (left in
/// left-to-right locales and right in right-to-left ones), and the end
/// widget at the end.
/// 
/// The center widget is centered regarding the full width of the layout's.
///
/// The `CenterLayoutProtocol` protocol exposes the methods and properties of an underlying `GtkCenterLayout` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CenterLayout`.
/// Alternatively, use `CenterLayoutRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CenterLayoutProtocol: LayoutManagerProtocol {
        /// Untyped pointer to the underlying `GtkCenterLayout` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCenterLayout` instance.
    var center_layout_ptr: UnsafeMutablePointer<GtkCenterLayout>! { get }

    /// Required Initialiser for types conforming to `CenterLayoutProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkCenterLayout` is a layout manager that manages up to three children.
/// 
/// The start widget is allocated at the start of the layout (left in
/// left-to-right locales and right in right-to-left ones), and the end
/// widget at the end.
/// 
/// The center widget is centered regarding the full width of the layout's.
///
/// The `CenterLayoutRef` type acts as a lightweight Swift reference to an underlying `GtkCenterLayout` instance.
/// It exposes methods that can operate on this data type through `CenterLayoutProtocol` conformance.
/// Use `CenterLayoutRef` only as an `unowned` reference to an existing `GtkCenterLayout` instance.
///
public struct CenterLayoutRef: CenterLayoutProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCenterLayout` instance.
    /// For type-safe access, use the generated, typed pointer `center_layout_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CenterLayoutRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCenterLayout>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCenterLayout>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCenterLayout>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCenterLayout>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CenterLayoutProtocol`
    @inlinable init<T: CenterLayoutProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CenterLayoutProtocol>(_ other: T) -> CenterLayoutRef { CenterLayoutRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCenterLayout`.
    @inlinable init() {
            let result = gtk_center_layout_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkCenterLayout` is a layout manager that manages up to three children.
/// 
/// The start widget is allocated at the start of the layout (left in
/// left-to-right locales and right in right-to-left ones), and the end
/// widget at the end.
/// 
/// The center widget is centered regarding the full width of the layout's.
///
/// The `CenterLayout` type acts as a reference-counted owner of an underlying `GtkCenterLayout` instance.
/// It provides the methods that can operate on this data type through `CenterLayoutProtocol` conformance.
/// Use `CenterLayout` as a strong reference or owner of a `GtkCenterLayout` instance.
///
open class CenterLayout: LayoutManager, CenterLayoutProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCenterLayout>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCenterLayout>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCenterLayout>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCenterLayout>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCenterLayout`.
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCenterLayout>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CenterLayoutProtocol`
    /// Will retain `GtkCenterLayout`.
    /// - Parameter other: an instance of a related type that implements `CenterLayoutProtocol`
    @inlinable public init<T: CenterLayoutProtocol>(centerLayout other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCenterLayout`.
    @inlinable public init() {
            let result = gtk_center_layout_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no CenterLayout properties

public enum CenterLayoutSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: CenterLayout has no signals
// MARK: CenterLayout Class: CenterLayoutProtocol extension (methods and fields)
public extension CenterLayoutProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCenterLayout` instance.
    @inlinable var center_layout_ptr: UnsafeMutablePointer<GtkCenterLayout>! { return ptr?.assumingMemoryBound(to: GtkCenterLayout.self) }

    /// Returns the baseline position of the layout.
    @inlinable func getBaselinePosition() -> GtkBaselinePosition {
        let result = gtk_center_layout_get_baseline_position(center_layout_ptr)
        let rv = result
        return rv
    }

    /// Returns the center widget of the layout.
    @inlinable func getCenterWidget() -> WidgetRef! {
        let result = gtk_center_layout_get_center_widget(center_layout_ptr)
        let rv = WidgetRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns the end widget of the layout.
    @inlinable func getEndWidget() -> WidgetRef! {
        let result = gtk_center_layout_get_end_widget(center_layout_ptr)
        let rv = WidgetRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the current orienration of the layout manager.
    @inlinable func getOrientation() -> GtkOrientation {
        let result = gtk_center_layout_get_orientation(center_layout_ptr)
        let rv = result
        return rv
    }

    /// Returns the start widget fo the layout.
    @inlinable func getStartWidget() -> WidgetRef! {
        let result = gtk_center_layout_get_start_widget(center_layout_ptr)
        let rv = WidgetRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Sets the new baseline position of `self`
    @inlinable func set(baselinePosition: GtkBaselinePosition) {
        
        gtk_center_layout_set_baseline_position(center_layout_ptr, baselinePosition)
        
    }

    /// Sets the new center widget of `self`.
    /// 
    /// To remove the existing center widget, pass `nil`.
    @inlinable func setCenter(widget: WidgetRef? = nil) {
            
        gtk_center_layout_set_center_widget(center_layout_ptr, widget?.widget_ptr)
            
    }
    /// Sets the new center widget of `self`.
    /// 
    /// To remove the existing center widget, pass `nil`.
    @inlinable func setCenter<WidgetT: WidgetProtocol>(widget: WidgetT?) {
        
        gtk_center_layout_set_center_widget(center_layout_ptr, widget?.widget_ptr)
        
    }

    /// Sets the new end widget of `self`.
    /// 
    /// To remove the existing center widget, pass `nil`.
    @inlinable func setEnd(widget: WidgetRef? = nil) {
            
        gtk_center_layout_set_end_widget(center_layout_ptr, widget?.widget_ptr)
            
    }
    /// Sets the new end widget of `self`.
    /// 
    /// To remove the existing center widget, pass `nil`.
    @inlinable func setEnd<WidgetT: WidgetProtocol>(widget: WidgetT?) {
        
        gtk_center_layout_set_end_widget(center_layout_ptr, widget?.widget_ptr)
        
    }

    /// Sets the orientation of `self`.
    @inlinable func set(orientation: GtkOrientation) {
        
        gtk_center_layout_set_orientation(center_layout_ptr, orientation)
        
    }

    /// Sets the new start widget of `self`.
    /// 
    /// To remove the existing start widget, pass `nil`.
    @inlinable func setStart(widget: WidgetRef? = nil) {
            
        gtk_center_layout_set_start_widget(center_layout_ptr, widget?.widget_ptr)
            
    }
    /// Sets the new start widget of `self`.
    /// 
    /// To remove the existing start widget, pass `nil`.
    @inlinable func setStart<WidgetT: WidgetProtocol>(widget: WidgetT?) {
        
        gtk_center_layout_set_start_widget(center_layout_ptr, widget?.widget_ptr)
        
    }
    /// Returns the baseline position of the layout.
    @inlinable var baselinePosition: GtkBaselinePosition {
        /// Returns the baseline position of the layout.
        get {
            let result = gtk_center_layout_get_baseline_position(center_layout_ptr)
        let rv = result
            return rv
        }
        /// Sets the new baseline position of `self`
        nonmutating set {
            gtk_center_layout_set_baseline_position(center_layout_ptr, newValue)
        }
    }

    /// Returns the center widget of the layout.
    @inlinable var centerWidget: WidgetRef! {
        /// Returns the center widget of the layout.
        get {
            let result = gtk_center_layout_get_center_widget(center_layout_ptr)
        let rv = WidgetRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets the new center widget of `self`.
        /// 
        /// To remove the existing center widget, pass `nil`.
        nonmutating set {
            gtk_center_layout_set_center_widget(center_layout_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Returns the end widget of the layout.
    @inlinable var endWidget: WidgetRef! {
        /// Returns the end widget of the layout.
        get {
            let result = gtk_center_layout_get_end_widget(center_layout_ptr)
        let rv = WidgetRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets the new end widget of `self`.
        /// 
        /// To remove the existing center widget, pass `nil`.
        nonmutating set {
            gtk_center_layout_set_end_widget(center_layout_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Gets the current orienration of the layout manager.
    @inlinable var orientation: GtkOrientation {
        /// Gets the current orienration of the layout manager.
        get {
            let result = gtk_center_layout_get_orientation(center_layout_ptr)
        let rv = result
            return rv
        }
        /// Sets the orientation of `self`.
        nonmutating set {
            gtk_center_layout_set_orientation(center_layout_ptr, newValue)
        }
    }

    /// Returns the start widget fo the layout.
    @inlinable var startWidget: WidgetRef! {
        /// Returns the start widget fo the layout.
        get {
            let result = gtk_center_layout_get_start_widget(center_layout_ptr)
        let rv = WidgetRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets the new start widget of `self`.
        /// 
        /// To remove the existing start widget, pass `nil`.
        nonmutating set {
            gtk_center_layout_set_start_widget(center_layout_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }


}



// MARK: - CheckButton Class

/// A `GtkCheckButton` places a label next to an indicator.
/// 
/// ![Example GtkCheckButtons](check-button.png)
/// 
/// A `GtkCheckButton` is created by calling either [ctor`Gtk.CheckButton.new`]
/// or [ctor`Gtk.CheckButton.new_with_label`].
/// 
/// The state of a `GtkCheckButton` can be set specifically using
/// [method`Gtk.CheckButton.set_active`], and retrieved using
/// [method`Gtk.CheckButton.get_active`].
/// 
/// # Inconsistent state
/// 
/// In addition to "on" and "off", check buttons can be an
/// "in between" state that is neither on nor off. This can be used
/// e.g. when the user has selected a range of elements (such as some
/// text or spreadsheet cells) that are affected by a check button,
/// and the current values in that range are inconsistent.
/// 
/// To set a `GtkCheckButton` to inconsistent state, use
/// [method`Gtk.CheckButton.set_inconsistent`].
/// 
/// # Grouping
/// 
/// Check buttons can be grouped together, to form mutually exclusive
/// groups - only one of the buttons can be toggled at a time, and toggling
/// another one will switch the currently toggled one off.
/// 
/// Grouped check buttons use a different indicator, and are commonly referred
/// to as *radio buttons*.
/// 
/// ![Example GtkCheckButtons](radio-button.png)
/// 
/// To add a `GtkCheckButton` to a group, use [method`Gtk.CheckButton.set_group`].
/// 
/// # CSS nodes
/// 
/// ```
/// checkbutton[.text-button]
/// ├── check
/// ╰── [label]
/// ```
/// 
/// A `GtkCheckButton` has a main node with name checkbutton. If the
/// [property`Gtk.CheckButton:label`] or [property`Gtk.CheckButton:child`]
/// properties are set, it contains a child widget. The indicator node
/// is named check when no group is set, and radio if the checkbutton
/// is grouped together with other checkbuttons.
/// 
/// # Accessibility
/// 
/// `GtkCheckButton` uses the `GTK_ACCESSIBLE_ROLE_CHECKBOX` role.
///
/// The `CheckButtonProtocol` protocol exposes the methods and properties of an underlying `GtkCheckButton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CheckButton`.
/// Alternatively, use `CheckButtonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CheckButtonProtocol: WidgetProtocol, ActionableProtocol {
        /// Untyped pointer to the underlying `GtkCheckButton` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCheckButton` instance.
    var check_button_ptr: UnsafeMutablePointer<GtkCheckButton>! { get }

    /// Required Initialiser for types conforming to `CheckButtonProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkCheckButton` places a label next to an indicator.
/// 
/// ![Example GtkCheckButtons](check-button.png)
/// 
/// A `GtkCheckButton` is created by calling either [ctor`Gtk.CheckButton.new`]
/// or [ctor`Gtk.CheckButton.new_with_label`].
/// 
/// The state of a `GtkCheckButton` can be set specifically using
/// [method`Gtk.CheckButton.set_active`], and retrieved using
/// [method`Gtk.CheckButton.get_active`].
/// 
/// # Inconsistent state
/// 
/// In addition to "on" and "off", check buttons can be an
/// "in between" state that is neither on nor off. This can be used
/// e.g. when the user has selected a range of elements (such as some
/// text or spreadsheet cells) that are affected by a check button,
/// and the current values in that range are inconsistent.
/// 
/// To set a `GtkCheckButton` to inconsistent state, use
/// [method`Gtk.CheckButton.set_inconsistent`].
/// 
/// # Grouping
/// 
/// Check buttons can be grouped together, to form mutually exclusive
/// groups - only one of the buttons can be toggled at a time, and toggling
/// another one will switch the currently toggled one off.
/// 
/// Grouped check buttons use a different indicator, and are commonly referred
/// to as *radio buttons*.
/// 
/// ![Example GtkCheckButtons](radio-button.png)
/// 
/// To add a `GtkCheckButton` to a group, use [method`Gtk.CheckButton.set_group`].
/// 
/// # CSS nodes
/// 
/// ```
/// checkbutton[.text-button]
/// ├── check
/// ╰── [label]
/// ```
/// 
/// A `GtkCheckButton` has a main node with name checkbutton. If the
/// [property`Gtk.CheckButton:label`] or [property`Gtk.CheckButton:child`]
/// properties are set, it contains a child widget. The indicator node
/// is named check when no group is set, and radio if the checkbutton
/// is grouped together with other checkbuttons.
/// 
/// # Accessibility
/// 
/// `GtkCheckButton` uses the `GTK_ACCESSIBLE_ROLE_CHECKBOX` role.
///
/// The `CheckButtonRef` type acts as a lightweight Swift reference to an underlying `GtkCheckButton` instance.
/// It exposes methods that can operate on this data type through `CheckButtonProtocol` conformance.
/// Use `CheckButtonRef` only as an `unowned` reference to an existing `GtkCheckButton` instance.
///
public struct CheckButtonRef: CheckButtonProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCheckButton` instance.
    /// For type-safe access, use the generated, typed pointer `check_button_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CheckButtonRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCheckButton>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCheckButton>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCheckButton>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCheckButton>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CheckButtonProtocol`
    @inlinable init<T: CheckButtonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CheckButtonProtocol>(_ other: T) -> CheckButtonRef { CheckButtonRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCheckButton`.
    @inlinable init() {
            let result = gtk_check_button_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkCheckButton` with the given text.
    @inlinable init(label: UnsafePointer<CChar>? = nil) {
            let result = gtk_check_button_new_with_label(label)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkCheckButton` with the given text and a mnemonic.
    @inlinable init(mnemonic label: UnsafePointer<CChar>? = nil) {
            let result = gtk_check_button_new_with_mnemonic(label)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkCheckButton` with the given text.
    @inlinable static func newWith(label: UnsafePointer<CChar>? = nil) -> WidgetRef! {
            let result = gtk_check_button_new_with_label(label)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Creates a new `GtkCheckButton` with the given text and a mnemonic.
    @inlinable static func newWith(mnemonic label: UnsafePointer<CChar>? = nil) -> WidgetRef! {
            let result = gtk_check_button_new_with_mnemonic(label)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }
}

/// A `GtkCheckButton` places a label next to an indicator.
/// 
/// ![Example GtkCheckButtons](check-button.png)
/// 
/// A `GtkCheckButton` is created by calling either [ctor`Gtk.CheckButton.new`]
/// or [ctor`Gtk.CheckButton.new_with_label`].
/// 
/// The state of a `GtkCheckButton` can be set specifically using
/// [method`Gtk.CheckButton.set_active`], and retrieved using
/// [method`Gtk.CheckButton.get_active`].
/// 
/// # Inconsistent state
/// 
/// In addition to "on" and "off", check buttons can be an
/// "in between" state that is neither on nor off. This can be used
/// e.g. when the user has selected a range of elements (such as some
/// text or spreadsheet cells) that are affected by a check button,
/// and the current values in that range are inconsistent.
/// 
/// To set a `GtkCheckButton` to inconsistent state, use
/// [method`Gtk.CheckButton.set_inconsistent`].
/// 
/// # Grouping
/// 
/// Check buttons can be grouped together, to form mutually exclusive
/// groups - only one of the buttons can be toggled at a time, and toggling
/// another one will switch the currently toggled one off.
/// 
/// Grouped check buttons use a different indicator, and are commonly referred
/// to as *radio buttons*.
/// 
/// ![Example GtkCheckButtons](radio-button.png)
/// 
/// To add a `GtkCheckButton` to a group, use [method`Gtk.CheckButton.set_group`].
/// 
/// # CSS nodes
/// 
/// ```
/// checkbutton[.text-button]
/// ├── check
/// ╰── [label]
/// ```
/// 
/// A `GtkCheckButton` has a main node with name checkbutton. If the
/// [property`Gtk.CheckButton:label`] or [property`Gtk.CheckButton:child`]
/// properties are set, it contains a child widget. The indicator node
/// is named check when no group is set, and radio if the checkbutton
/// is grouped together with other checkbuttons.
/// 
/// # Accessibility
/// 
/// `GtkCheckButton` uses the `GTK_ACCESSIBLE_ROLE_CHECKBOX` role.
///
/// The `CheckButton` type acts as a reference-counted owner of an underlying `GtkCheckButton` instance.
/// It provides the methods that can operate on this data type through `CheckButtonProtocol` conformance.
/// Use `CheckButton` as a strong reference or owner of a `GtkCheckButton` instance.
///
open class CheckButton: Widget, CheckButtonProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCheckButton>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCheckButton>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCheckButton>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCheckButton>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCheckButton`.
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCheckButton>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CheckButtonProtocol`
    /// Will retain `GtkCheckButton`.
    /// - Parameter other: an instance of a related type that implements `CheckButtonProtocol`
    @inlinable public init<T: CheckButtonProtocol>(checkButton other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCheckButton`.
    @inlinable public init() {
            let result = gtk_check_button_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkCheckButton` with the given text.
    @inlinable public init(label: UnsafePointer<CChar>? = nil) {
            let result = gtk_check_button_new_with_label(label)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkCheckButton` with the given text and a mnemonic.
    @inlinable public init(mnemonic label: UnsafePointer<CChar>? = nil) {
            let result = gtk_check_button_new_with_mnemonic(label)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkCheckButton` with the given text.
    @inlinable public static func newWith(label: UnsafePointer<CChar>? = nil) -> Widget! {
            let result = gtk_check_button_new_with_label(label)
        guard let rv = Widget(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

    /// Creates a new `GtkCheckButton` with the given text and a mnemonic.
    @inlinable public static func newWith(mnemonic label: UnsafePointer<CChar>? = nil) -> Widget! {
            let result = gtk_check_button_new_with_mnemonic(label)
        guard let rv = Widget(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

}

public enum CheckButtonPropertyName: String, PropertyNameProtocol {
    /// If the check button is active.
    /// 
    /// Setting `active` to `true` will add the `:checked:` state to both
    /// the check button and the indicator CSS node.
    case active = "active"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// The child widget.
    case child = "child"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// The check button whose group this widget belongs to.
    case group = "group"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// If the check button is in an “in between” state.
    /// 
    /// The inconsistent state only affects visual appearance,
    /// not the semantics of the button.
    case inconsistent = "inconsistent"
    /// Text of the label inside the check button, if it contains a label widget.
    case label = "label"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// If set, an underline in the text indicates that the following
    /// character is to be used as mnemonic.
    case useUnderline = "use-underline"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension CheckButtonProtocol {
    /// Bind a `CheckButtonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CheckButtonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CheckButton property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CheckButtonPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CheckButton property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CheckButtonPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CheckButtonSignalName: String, SignalNameProtocol {
    /// Emitted to when the check button is activated.
    /// 
    /// The ``activate`` signal on `GtkCheckButton` is an action signal and
    /// emitting it causes the button to animate press then release.
    /// 
    /// Applications should never connect to this signal, but use the
    /// [signal`Gtk.CheckButton::toggled`] signal.
    case activate = "activate"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when the buttons's [property`Gtk.CheckButton:active`]
    /// property changes.
    case toggled = "toggled"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// If the check button is active.
    /// 
    /// Setting `active` to `true` will add the `:checked:` state to both
    /// the check button and the indicator CSS node.
    case notifyActive = "notify::active"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// The child widget.
    case notifyChild = "notify::child"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// The check button whose group this widget belongs to.
    case notifyGroup = "notify::group"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// If the check button is in an “in between” state.
    /// 
    /// The inconsistent state only affects visual appearance,
    /// not the semantics of the button.
    case notifyInconsistent = "notify::inconsistent"
    /// Text of the label inside the check button, if it contains a label widget.
    case notifyLabel = "notify::label"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// If set, an underline in the text indicates that the following
    /// character is to be used as mnemonic.
    case notifyUseUnderline = "notify::use-underline"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: CheckButton signals
public extension CheckButtonProtocol {
    /// Connect a Swift signal handler to the given, typed `CheckButtonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CheckButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `CheckButtonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CheckButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted to when the check button is activated.
    /// 
    /// The ``activate`` signal on `GtkCheckButton` is an action signal and
    /// emitting it causes the button to animate press then release.
    /// 
    /// Applications should never connect to this signal, but use the
    /// [signal`Gtk.CheckButton::toggled`] signal.
    /// - Note: This represents the underlying `activate` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `activate` signal is emitted
    @discardableResult @inlinable func onActivate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CheckButtonRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CheckButtonRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CheckButtonRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .activate,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `activate` signal for using the `connect(signal:)` methods
    static var activateSignal: CheckButtonSignalName { .activate }
    
    /// Emitted when the buttons's [property`Gtk.CheckButton:active`]
    /// property changes.
    /// - Note: This represents the underlying `toggled` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `toggled` signal is emitted
    @discardableResult @inlinable func onToggled(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CheckButtonRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CheckButtonRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CheckButtonRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .toggled,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `toggled` signal for using the `connect(signal:)` methods
    static var toggledSignal: CheckButtonSignalName { .toggled }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::active` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActive` signal is emitted
    @discardableResult @inlinable func onNotifyActive(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CheckButtonRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CheckButtonRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CheckButtonRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyActive,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::active` signal for using the `connect(signal:)` methods
    static var notifyActiveSignal: CheckButtonSignalName { .notifyActive }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::child` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyChild` signal is emitted
    @discardableResult @inlinable func onNotifyChild(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CheckButtonRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CheckButtonRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CheckButtonRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyChild,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::child` signal for using the `connect(signal:)` methods
    static var notifyChildSignal: CheckButtonSignalName { .notifyChild }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::group` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyGroup` signal is emitted
    @discardableResult @inlinable func onNotifyGroup(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CheckButtonRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CheckButtonRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CheckButtonRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyGroup,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::group` signal for using the `connect(signal:)` methods
    static var notifyGroupSignal: CheckButtonSignalName { .notifyGroup }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::inconsistent` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyInconsistent` signal is emitted
    @discardableResult @inlinable func onNotifyInconsistent(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CheckButtonRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CheckButtonRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CheckButtonRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyInconsistent,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::inconsistent` signal for using the `connect(signal:)` methods
    static var notifyInconsistentSignal: CheckButtonSignalName { .notifyInconsistent }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::label` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyLabel` signal is emitted
    @discardableResult @inlinable func onNotifyLabel(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CheckButtonRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CheckButtonRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CheckButtonRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyLabel,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::label` signal for using the `connect(signal:)` methods
    static var notifyLabelSignal: CheckButtonSignalName { .notifyLabel }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::use-underline` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyUseUnderline` signal is emitted
    @discardableResult @inlinable func onNotifyUseUnderline(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CheckButtonRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CheckButtonRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CheckButtonRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyUseUnderline,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::use-underline` signal for using the `connect(signal:)` methods
    static var notifyUseUnderlineSignal: CheckButtonSignalName { .notifyUseUnderline }
    
}

// MARK: CheckButton Class: CheckButtonProtocol extension (methods and fields)
public extension CheckButtonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCheckButton` instance.
    @inlinable var check_button_ptr: UnsafeMutablePointer<GtkCheckButton>! { return ptr?.assumingMemoryBound(to: GtkCheckButton.self) }

    /// Returns whether the check button is active.
    @inlinable func getActive() -> Bool {
        let result = gtk_check_button_get_active(check_button_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the child widget of `button` or `NULL` if [property`CheckButton:label`] is set.
    @inlinable func getChild() -> WidgetRef! {
        let result = gtk_check_button_get_child(check_button_ptr)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Returns whether the check button is in an inconsistent state.
    @inlinable func getInconsistent() -> Bool {
        let result = gtk_check_button_get_inconsistent(check_button_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns the label of the check button or `NULL` if [property`CheckButton:child`] is set.
    @inlinable func getLabel() -> String! {
        let result = gtk_check_button_get_label(check_button_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Returns whether underlines in the label indicate mnemonics.
    @inlinable func getUseUnderline() -> Bool {
        let result = gtk_check_button_get_use_underline(check_button_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Changes the check buttons active state.
    @inlinable func setActive(setting: Bool) {
        
        gtk_check_button_set_active(check_button_ptr, gboolean((setting) ? 1 : 0))
        
    }

    /// Sets the child widget of `button`.
    /// 
    /// Note that by using this API, you take full responsibility for setting
    /// up the proper accessibility label and description information for `button`.
    /// Most likely, you'll either set the accessibility label or description
    /// for `button` explicitly, or you'll set a labelled-by or described-by
    /// relations from `child` to `button`.
    @inlinable func set(child: WidgetRef? = nil) {
            
        gtk_check_button_set_child(check_button_ptr, child?.widget_ptr)
            
    }
    /// Sets the child widget of `button`.
    /// 
    /// Note that by using this API, you take full responsibility for setting
    /// up the proper accessibility label and description information for `button`.
    /// Most likely, you'll either set the accessibility label or description
    /// for `button` explicitly, or you'll set a labelled-by or described-by
    /// relations from `child` to `button`.
    @inlinable func set<WidgetT: WidgetProtocol>(child: WidgetT?) {
        
        gtk_check_button_set_child(check_button_ptr, child?.widget_ptr)
        
    }

    /// Adds `self` to the group of `group`.
    /// 
    /// In a group of multiple check buttons, only one button can be active
    /// at a time. The behavior of a checkbutton in a group is also commonly
    /// known as a *radio button*.
    /// 
    /// Setting the group of a check button also changes the css name of the
    /// indicator widget's CSS node to 'radio'.
    /// 
    /// Setting up groups in a cycle leads to undefined behavior.
    /// 
    /// Note that the same effect can be achieved via the [iface`Gtk.Actionable`]
    /// API, by using the same action with parameter type and state type 's'
    /// for all buttons in the group, and giving each button its own target
    /// value.
    @inlinable func set(group: CheckButtonRef? = nil) {
            
        gtk_check_button_set_group(check_button_ptr, group?.check_button_ptr)
            
    }
    /// Adds `self` to the group of `group`.
    /// 
    /// In a group of multiple check buttons, only one button can be active
    /// at a time. The behavior of a checkbutton in a group is also commonly
    /// known as a *radio button*.
    /// 
    /// Setting the group of a check button also changes the css name of the
    /// indicator widget's CSS node to 'radio'.
    /// 
    /// Setting up groups in a cycle leads to undefined behavior.
    /// 
    /// Note that the same effect can be achieved via the [iface`Gtk.Actionable`]
    /// API, by using the same action with parameter type and state type 's'
    /// for all buttons in the group, and giving each button its own target
    /// value.
    @inlinable func set<CheckButtonT: CheckButtonProtocol>(group: CheckButtonT?) {
        
        gtk_check_button_set_group(check_button_ptr, group?.check_button_ptr)
        
    }

    /// Sets the `GtkCheckButton` to inconsistent state.
    /// 
    /// You shoud turn off the inconsistent state again if the user checks
    /// the check button. This has to be done manually.
    @inlinable func set(inconsistent: Bool) {
        
        gtk_check_button_set_inconsistent(check_button_ptr, gboolean((inconsistent) ? 1 : 0))
        
    }

    /// Sets the text of `self`.
    /// 
    /// If [property`Gtk.CheckButton:use-underline`] is `true`, an underscore
    /// in `label` is interpreted as mnemonic indicator, see
    /// [method`Gtk.CheckButton.set_use_underline`] for details on this behavior.
    @inlinable func set(label: UnsafePointer<CChar>? = nil) {
        
        gtk_check_button_set_label(check_button_ptr, label)
        
    }

    /// Sets whether underlines in the label indicate mnemonics.
    /// 
    /// If `setting` is `true`, an underscore character in `self`'s label
    /// indicates a mnemonic accelerator key. This behavior is similar
    /// to [property`Gtk.Label:use-underline`].
    @inlinable func setUseUnderline(setting: Bool) {
        
        gtk_check_button_set_use_underline(check_button_ptr, gboolean((setting) ? 1 : 0))
        
    }
    /// If the check button is active.
    /// 
    /// Setting `active` to `true` will add the `:checked:` state to both
    /// the check button and the indicator CSS node.
    @inlinable var active: Bool {
        /// Returns whether the check button is active.
        get {
            let result = gtk_check_button_get_active(check_button_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Changes the check buttons active state.
        nonmutating set {
            gtk_check_button_set_active(check_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// The child widget.
    @inlinable var child: WidgetRef! {
        /// Gets the child widget of `button` or `NULL` if [property`CheckButton:label`] is set.
        get {
            let result = gtk_check_button_get_child(check_button_ptr)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
            return rv
        }
        /// Sets the child widget of `button`.
        /// 
        /// Note that by using this API, you take full responsibility for setting
        /// up the proper accessibility label and description information for `button`.
        /// Most likely, you'll either set the accessibility label or description
        /// for `button` explicitly, or you'll set a labelled-by or described-by
        /// relations from `child` to `button`.
        nonmutating set {
            gtk_check_button_set_child(check_button_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// If the check button is in an “in between” state.
    /// 
    /// The inconsistent state only affects visual appearance,
    /// not the semantics of the button.
    @inlinable var inconsistent: Bool {
        /// Returns whether the check button is in an inconsistent state.
        get {
            let result = gtk_check_button_get_inconsistent(check_button_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets the `GtkCheckButton` to inconsistent state.
        /// 
        /// You shoud turn off the inconsistent state again if the user checks
        /// the check button. This has to be done manually.
        nonmutating set {
            gtk_check_button_set_inconsistent(check_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Text of the label inside the check button, if it contains a label widget.
    @inlinable var label: String! {
        /// Returns the label of the check button or `NULL` if [property`CheckButton:child`] is set.
        get {
            let result = gtk_check_button_get_label(check_button_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
        /// Sets the text of `self`.
        /// 
        /// If [property`Gtk.CheckButton:use-underline`] is `true`, an underscore
        /// in `label` is interpreted as mnemonic indicator, see
        /// [method`Gtk.CheckButton.set_use_underline`] for details on this behavior.
        nonmutating set {
            gtk_check_button_set_label(check_button_ptr, newValue)
        }
    }

    /// Returns whether underlines in the label indicate mnemonics.
    @inlinable var useUnderline: Bool {
        /// Returns whether underlines in the label indicate mnemonics.
        get {
            let result = gtk_check_button_get_use_underline(check_button_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether underlines in the label indicate mnemonics.
        /// 
        /// If `setting` is `true`, an underscore character in `self`'s label
        /// indicates a mnemonic accelerator key. This behavior is similar
        /// to [property`Gtk.Label:use-underline`].
        nonmutating set {
            gtk_check_button_set_use_underline(check_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var parentInstance: GtkWidget {
        get {
            let rv = check_button_ptr.pointee.parent_instance
    return rv
        }
    }

}



// MARK: - ClosureExpression Class

/// An expression using a custom `GClosure` to compute the value from
/// its parameters.
///
/// The `ClosureExpressionProtocol` protocol exposes the methods and properties of an underlying `GtkClosureExpression` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ClosureExpression`.
/// Alternatively, use `ClosureExpressionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ClosureExpressionProtocol: ExpressionProtocol {
        /// Untyped pointer to the underlying `GtkClosureExpression` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkClosureExpression` instance.
    var closure_expression_ptr: UnsafeMutablePointer<GtkClosureExpression>! { get }

    /// Required Initialiser for types conforming to `ClosureExpressionProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// An expression using a custom `GClosure` to compute the value from
/// its parameters.
///
/// The `ClosureExpressionRef` type acts as a lightweight Swift reference to an underlying `GtkClosureExpression` instance.
/// It exposes methods that can operate on this data type through `ClosureExpressionProtocol` conformance.
/// Use `ClosureExpressionRef` only as an `unowned` reference to an existing `GtkClosureExpression` instance.
///
public struct ClosureExpressionRef: ClosureExpressionProtocol {
        /// Untyped pointer to the underlying `GtkClosureExpression` instance.
    /// For type-safe access, use the generated, typed pointer `closure_expression_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ClosureExpressionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkClosureExpression>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkClosureExpression>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkClosureExpression>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkClosureExpression>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ClosureExpressionProtocol`
    @inlinable init<T: ClosureExpressionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// An expression using a custom `GClosure` to compute the value from
/// its parameters.
///
/// The `ClosureExpression` type acts as a reference-counted owner of an underlying `GtkClosureExpression` instance.
/// It provides the methods that can operate on this data type through `ClosureExpressionProtocol` conformance.
/// Use `ClosureExpression` as a strong reference or owner of a `GtkClosureExpression` instance.
///
open class ClosureExpression: Expression, ClosureExpressionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkClosureExpression>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkClosureExpression>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkClosureExpression>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkClosureExpression>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkClosureExpression`.
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkClosureExpression>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ClosureExpressionProtocol`
    /// Will retain `GtkClosureExpression`.
    /// - Parameter other: an instance of a related type that implements `ClosureExpressionProtocol`
    @inlinable public init<T: ClosureExpressionProtocol>(closureExpression other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

// MARK: no ClosureExpression properties

// MARK: no ClosureExpression signals

// MARK: ClosureExpression has no signals
// MARK: ClosureExpression Class: ClosureExpressionProtocol extension (methods and fields)
public extension ClosureExpressionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkClosureExpression` instance.
    @inlinable var closure_expression_ptr: UnsafeMutablePointer<GtkClosureExpression>! { return ptr?.assumingMemoryBound(to: GtkClosureExpression.self) }



}



// MARK: - ColorButton Class

/// The `GtkColorButton` allows to open a color chooser dialog to change
/// the color.
/// 
/// ![An example GtkColorButton](color-button.png)
/// 
/// It is suitable widget for selecting a color in a preference dialog.
/// 
/// # CSS nodes
/// 
/// ```
/// colorbutton
/// ╰── button.color
///     ╰── [content]
/// ```
/// 
/// `GtkColorButton` has a single CSS node with name colorbutton which
/// contains a button node. To differentiate it from a plain `GtkButton`,
/// it gets the .color style class.
///
/// The `ColorButtonProtocol` protocol exposes the methods and properties of an underlying `GtkColorButton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColorButton`.
/// Alternatively, use `ColorButtonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ColorButtonProtocol: WidgetProtocol, ColorChooserProtocol {
        /// Untyped pointer to the underlying `GtkColorButton` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkColorButton` instance.
    var color_button_ptr: UnsafeMutablePointer<GtkColorButton>! { get }

    /// Required Initialiser for types conforming to `ColorButtonProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `GtkColorButton` allows to open a color chooser dialog to change
/// the color.
/// 
/// ![An example GtkColorButton](color-button.png)
/// 
/// It is suitable widget for selecting a color in a preference dialog.
/// 
/// # CSS nodes
/// 
/// ```
/// colorbutton
/// ╰── button.color
///     ╰── [content]
/// ```
/// 
/// `GtkColorButton` has a single CSS node with name colorbutton which
/// contains a button node. To differentiate it from a plain `GtkButton`,
/// it gets the .color style class.
///
/// The `ColorButtonRef` type acts as a lightweight Swift reference to an underlying `GtkColorButton` instance.
/// It exposes methods that can operate on this data type through `ColorButtonProtocol` conformance.
/// Use `ColorButtonRef` only as an `unowned` reference to an existing `GtkColorButton` instance.
///
public struct ColorButtonRef: ColorButtonProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkColorButton` instance.
    /// For type-safe access, use the generated, typed pointer `color_button_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ColorButtonRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkColorButton>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkColorButton>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkColorButton>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkColorButton>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ColorButtonProtocol`
    @inlinable init<T: ColorButtonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ColorButtonProtocol>(_ other: T) -> ColorButtonRef { ColorButtonRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new color button.
    /// 
    /// This returns a widget in the form of a small button containing
    /// a swatch representing the current selected color. When the button
    /// is clicked, a color chooser dialog will open, allowing the user
    /// to select a color. The swatch will be updated to reflect the new
    /// color when the user finishes.
    @inlinable init() {
            let result = gtk_color_button_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new color button showing the given color.
    @inlinable init<GdkRGBAT: Gdk.RGBAProtocol>(rgba: GdkRGBAT) {
            let result = gtk_color_button_new_with_rgba(rgba.rgba_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new color button showing the given color.
    @inlinable static func newWith<GdkRGBAT: Gdk.RGBAProtocol>(rgba: GdkRGBAT) -> WidgetRef! {
            let result = gtk_color_button_new_with_rgba(rgba.rgba_ptr)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }
}

/// The `GtkColorButton` allows to open a color chooser dialog to change
/// the color.
/// 
/// ![An example GtkColorButton](color-button.png)
/// 
/// It is suitable widget for selecting a color in a preference dialog.
/// 
/// # CSS nodes
/// 
/// ```
/// colorbutton
/// ╰── button.color
///     ╰── [content]
/// ```
/// 
/// `GtkColorButton` has a single CSS node with name colorbutton which
/// contains a button node. To differentiate it from a plain `GtkButton`,
/// it gets the .color style class.
///
/// The `ColorButton` type acts as a reference-counted owner of an underlying `GtkColorButton` instance.
/// It provides the methods that can operate on this data type through `ColorButtonProtocol` conformance.
/// Use `ColorButton` as a strong reference or owner of a `GtkColorButton` instance.
///
open class ColorButton: Widget, ColorButtonProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkColorButton>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkColorButton>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkColorButton>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkColorButton>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkColorButton`.
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkColorButton>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ColorButtonProtocol`
    /// Will retain `GtkColorButton`.
    /// - Parameter other: an instance of a related type that implements `ColorButtonProtocol`
    @inlinable public init<T: ColorButtonProtocol>(colorButton other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new color button.
    /// 
    /// This returns a widget in the form of a small button containing
    /// a swatch representing the current selected color. When the button
    /// is clicked, a color chooser dialog will open, allowing the user
    /// to select a color. The swatch will be updated to reflect the new
    /// color when the user finishes.
    @inlinable public init() {
            let result = gtk_color_button_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new color button showing the given color.
    @inlinable public init<GdkRGBAT: Gdk.RGBAProtocol>(rgba: GdkRGBAT) {
            let result = gtk_color_button_new_with_rgba(rgba.rgba_ptr)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new color button showing the given color.
    @inlinable public static func newWith<GdkRGBAT: Gdk.RGBAProtocol>(rgba: GdkRGBAT) -> Widget! {
            let result = gtk_color_button_new_with_rgba(rgba.rgba_ptr)
        guard let rv = Widget(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

}

public enum ColorButtonPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// Whether the color chooser dialog should be modal.
    case modal = "modal"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Whether the color chooser should open in editor mode.
    /// 
    /// This property should be used in cases where the palette
    /// in the editor would be redundant, such as when the color
    /// button is already part of a palette.
    case showEditor = "show-editor"
    /// The title of the color chooser dialog
    case title = "title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension ColorButtonProtocol {
    /// Bind a `ColorButtonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColorButtonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ColorButton property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ColorButtonPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ColorButton property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ColorButtonPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ColorButtonSignalName: String, SignalNameProtocol {
    /// Emitted to when the color button is activated.
    /// 
    /// The ``activate`` signal on `GtkMenuButton` is an action signal and
    /// emitting it causes the button to pop up its dialog.
    case activate = "activate"
    /// Emitted when the user selects a color.
    /// 
    /// When handling this signal, use [method`Gtk.ColorChooser.get_rgba`]
    /// to find out which color was just selected.
    /// 
    /// Note that this signal is only emitted when the user changes the color.
    /// If you need to react to programmatic color changes as well, use
    /// the notify`rgba` signal.
    case colorSet = "color-set"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// Whether the color chooser dialog should be modal.
    case notifyModal = "notify::modal"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Whether the color chooser should open in editor mode.
    /// 
    /// This property should be used in cases where the palette
    /// in the editor would be redundant, such as when the color
    /// button is already part of a palette.
    case notifyShowEditor = "notify::show-editor"
    /// The title of the color chooser dialog
    case notifyTitle = "notify::title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: ColorButton signals
public extension ColorButtonProtocol {
    /// Connect a Swift signal handler to the given, typed `ColorButtonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ColorButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `ColorButtonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ColorButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted to when the color button is activated.
    /// 
    /// The ``activate`` signal on `GtkMenuButton` is an action signal and
    /// emitting it causes the button to pop up its dialog.
    /// - Note: This represents the underlying `activate` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `activate` signal is emitted
    @discardableResult @inlinable func onActivate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColorButtonRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ColorButtonRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ColorButtonRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .activate,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `activate` signal for using the `connect(signal:)` methods
    static var activateSignal: ColorButtonSignalName { .activate }
    
    /// Emitted when the user selects a color.
    /// 
    /// When handling this signal, use [method`Gtk.ColorChooser.get_rgba`]
    /// to find out which color was just selected.
    /// 
    /// Note that this signal is only emitted when the user changes the color.
    /// If you need to react to programmatic color changes as well, use
    /// the notify`rgba` signal.
    /// - Note: This represents the underlying `color-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `colorSet` signal is emitted
    @discardableResult @inlinable func onColorSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColorButtonRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ColorButtonRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ColorButtonRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .colorSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `color-set` signal for using the `connect(signal:)` methods
    static var colorSetSignal: ColorButtonSignalName { .colorSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::modal` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyModal` signal is emitted
    @discardableResult @inlinable func onNotifyModal(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColorButtonRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ColorButtonRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ColorButtonRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyModal,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::modal` signal for using the `connect(signal:)` methods
    static var notifyModalSignal: ColorButtonSignalName { .notifyModal }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::show-editor` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyShowEditor` signal is emitted
    @discardableResult @inlinable func onNotifyShowEditor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColorButtonRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ColorButtonRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ColorButtonRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyShowEditor,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::show-editor` signal for using the `connect(signal:)` methods
    static var notifyShowEditorSignal: ColorButtonSignalName { .notifyShowEditor }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::title` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTitle` signal is emitted
    @discardableResult @inlinable func onNotifyTitle(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColorButtonRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ColorButtonRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ColorButtonRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyTitle,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::title` signal for using the `connect(signal:)` methods
    static var notifyTitleSignal: ColorButtonSignalName { .notifyTitle }
    
}

// MARK: ColorButton Class: ColorButtonProtocol extension (methods and fields)
public extension ColorButtonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColorButton` instance.
    @inlinable var color_button_ptr: UnsafeMutablePointer<GtkColorButton>! { return ptr?.assumingMemoryBound(to: GtkColorButton.self) }

    /// Gets whether the dialog is modal.
    @inlinable func getModal() -> Bool {
        let result = gtk_color_button_get_modal(color_button_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the title of the color chooser dialog.
    @inlinable func getTitle() -> String! {
        let result = gtk_color_button_get_title(color_button_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Sets whether the dialog should be modal.
    @inlinable func set(modal: Bool) {
        
        gtk_color_button_set_modal(color_button_ptr, gboolean((modal) ? 1 : 0))
        
    }

    /// Sets the title for the color chooser dialog.
    @inlinable func set(title: UnsafePointer<CChar>!) {
        
        gtk_color_button_set_title(color_button_ptr, title)
        
    }
    /// Whether the color chooser dialog should be modal.
    @inlinable var modal: Bool {
        /// Gets whether the dialog is modal.
        get {
            let result = gtk_color_button_get_modal(color_button_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether the dialog should be modal.
        nonmutating set {
            gtk_color_button_set_modal(color_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// The title of the color chooser dialog
    @inlinable var title: String! {
        /// Gets the title of the color chooser dialog.
        get {
            let result = gtk_color_button_get_title(color_button_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
        /// Sets the title for the color chooser dialog.
        nonmutating set {
            gtk_color_button_set_title(color_button_ptr, newValue)
        }
    }


}



// MARK: - ColorChooserDialog Class

/// A dialog for choosing a color.
/// 
/// ![An example GtkColorChooserDialog](colorchooser.png)
/// 
/// `GtkColorChooserDialog` implements the [iface`Gtk.ColorChooser`] interface
/// and does not provide much API of its own.
/// 
/// To create a `GtkColorChooserDialog`, use [ctor`Gtk.ColorChooserDialog.new`].
/// 
/// To change the initially selected color, use
/// [method`Gtk.ColorChooser.set_rgba`]. To get the selected color use
/// [method`Gtk.ColorChooser.get_rgba`].
///
/// The `ColorChooserDialogProtocol` protocol exposes the methods and properties of an underlying `GtkColorChooserDialog` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColorChooserDialog`.
/// Alternatively, use `ColorChooserDialogRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ColorChooserDialogProtocol: DialogProtocol, ColorChooserProtocol {
        /// Untyped pointer to the underlying `GtkColorChooserDialog` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkColorChooserDialog` instance.
    var color_chooser_dialog_ptr: UnsafeMutablePointer<GtkColorChooserDialog>! { get }

    /// Required Initialiser for types conforming to `ColorChooserDialogProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A dialog for choosing a color.
/// 
/// ![An example GtkColorChooserDialog](colorchooser.png)
/// 
/// `GtkColorChooserDialog` implements the [iface`Gtk.ColorChooser`] interface
/// and does not provide much API of its own.
/// 
/// To create a `GtkColorChooserDialog`, use [ctor`Gtk.ColorChooserDialog.new`].
/// 
/// To change the initially selected color, use
/// [method`Gtk.ColorChooser.set_rgba`]. To get the selected color use
/// [method`Gtk.ColorChooser.get_rgba`].
///
/// The `ColorChooserDialogRef` type acts as a lightweight Swift reference to an underlying `GtkColorChooserDialog` instance.
/// It exposes methods that can operate on this data type through `ColorChooserDialogProtocol` conformance.
/// Use `ColorChooserDialogRef` only as an `unowned` reference to an existing `GtkColorChooserDialog` instance.
///
public struct ColorChooserDialogRef: ColorChooserDialogProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkColorChooserDialog` instance.
    /// For type-safe access, use the generated, typed pointer `color_chooser_dialog_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ColorChooserDialogRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkColorChooserDialog>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkColorChooserDialog>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkColorChooserDialog>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkColorChooserDialog>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ColorChooserDialogProtocol`
    @inlinable init<T: ColorChooserDialogProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ColorChooserDialogProtocol>(_ other: T) -> ColorChooserDialogRef { ColorChooserDialogRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkColorChooserDialog`.
    @inlinable init<WindowT: WindowProtocol>( title: UnsafePointer<CChar>? = nil, parent: WindowT?) {
            let result = gtk_color_chooser_dialog_new(title, parent?.window_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// A dialog for choosing a color.
/// 
/// ![An example GtkColorChooserDialog](colorchooser.png)
/// 
/// `GtkColorChooserDialog` implements the [iface`Gtk.ColorChooser`] interface
/// and does not provide much API of its own.
/// 
/// To create a `GtkColorChooserDialog`, use [ctor`Gtk.ColorChooserDialog.new`].
/// 
/// To change the initially selected color, use
/// [method`Gtk.ColorChooser.set_rgba`]. To get the selected color use
/// [method`Gtk.ColorChooser.get_rgba`].
///
/// The `ColorChooserDialog` type acts as a reference-counted owner of an underlying `GtkColorChooserDialog` instance.
/// It provides the methods that can operate on this data type through `ColorChooserDialogProtocol` conformance.
/// Use `ColorChooserDialog` as a strong reference or owner of a `GtkColorChooserDialog` instance.
///
open class ColorChooserDialog: Dialog, ColorChooserDialogProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkColorChooserDialog>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkColorChooserDialog>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkColorChooserDialog>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkColorChooserDialog>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkColorChooserDialog`.
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkColorChooserDialog>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ColorChooserDialogProtocol`
    /// Will retain `GtkColorChooserDialog`.
    /// - Parameter other: an instance of a related type that implements `ColorChooserDialogProtocol`
    @inlinable public init<T: ColorChooserDialogProtocol>(colorChooserDialog other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkColorChooserDialog`.
    @inlinable public init<WindowT: WindowProtocol>( title: UnsafePointer<CChar>? = nil, parent: WindowT?) {
            let result = gtk_color_chooser_dialog_new(title, parent?.window_ptr)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ColorChooserDialogPropertyName: String, PropertyNameProtocol {
    /// The `GtkApplication` associated with the window.
    /// 
    /// The application will be kept alive for at least as long as it
    /// has any windows associated with it (see `g_application_hold()`
    /// for a way to keep it alive without windows).
    /// 
    /// Normally, the connection between the application and the window
    /// will remain until the window is destroyed, but you can explicitly
    /// remove it by setting the :application property to `nil`.
    case application = "application"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// The child widget.
    case child = "child"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the window should have a frame (also known as *decorations*).
    case decorated = "decorated"
    /// The default height of the window.
    case defaultHeight = "default-height"
    /// The default widget.
    case defaultWidget = "default-widget"
    /// The default width of the window.
    case defaultWidth = "default-width"
    /// Whether the window frame should have a close button.
    case deletable = "deletable"
    /// If this window should be destroyed when the parent is destroyed.
    case destroyWithParent = "destroy-with-parent"
    /// The display that will display this window.
    case display = "display"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether 'focus rectangles' are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input
    /// and should not be set by applications.
    case focusVisible = "focus-visible"
    /// The focus widget.
    case focusWidget = "focus-widget"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// Whether the window is fullscreen.
    /// 
    /// Setting this property is the equivalent of calling
    /// [method`Gtk.Window.fullscreen`] or [method`Gtk.Window.unfullscreen`];
    /// either operation is asynchronous, which means you will need to
    /// connect to the `notify` signal in order to know whether the
    /// operation was successful.
    case fullscreened = "fullscreened"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the window frame should handle F10 for activating
    /// menubars.
    case handleMenubarAccel = "handle-menubar-accel"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// If this window should be hidden when the users clicks the close button.
    case hideOnClose = "hide-on-close"
    /// Specifies the name of the themed icon to use as the window icon.
    /// 
    /// See [class`Gtk.IconTheme`] for more details.
    case iconName = "icon-name"
    /// Whether the toplevel is the currently active window.
    case isActive = "is-active"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// Whether the window is maximized.
    /// 
    /// Setting this property is the equivalent of calling
    /// [method`Gtk.Window.maximize`] or [method`Gtk.Window.unmaximize`];
    /// either operation is asynchronous, which means you will need to
    /// connect to the `notify` signal in order to know whether the
    /// operation was successful.
    case maximized = "maximized"
    /// Whether mnemonics are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input,
    /// and should not be set by applications.
    case mnemonicsVisible = "mnemonics-visible"
    /// If `true`, the window is modal.
    case modal = "modal"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// If `true`, users can resize the window.
    case resizable = "resizable"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    case showEditor = "show-editor"
    /// A write-only property for setting window's startup notification identifier.
    case startupId = "startup-id"
    /// The title of the window.
    case title = "title"
    /// The titlebar widget.
    case titlebar = "titlebar"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// The transient parent of the window.
    case transientFor = "transient-for"
    /// `true` if the dialog uses a headerbar for action buttons
    /// instead of the action-area.
    /// 
    /// For technical reasons, this property is declared as an integer
    /// property, but you should only set it to `true` or `false`.
    /// 
    /// ## Creating a dialog with headerbar
    /// 
    /// Builtin `GtkDialog` subclasses such as [class`Gtk.ColorChooserDialog`]
    /// set this property according to platform conventions (using the
    /// [property`Gtk.Settings:gtk-dialogs-use-header`] setting).
    /// 
    /// Here is how you can achieve the same:
    /// 
    /// ```c
    /// g_object_get (settings, "gtk-dialogs-use-header", &header, NULL);
    /// dialog = g_object_new (GTK_TYPE_DIALOG, header, TRUE, NULL);
    /// ```
    case useHeaderBar = "use-header-bar"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension ColorChooserDialogProtocol {
    /// Bind a `ColorChooserDialogPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColorChooserDialogPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ColorChooserDialog property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ColorChooserDialogPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ColorChooserDialog property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ColorChooserDialogPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ColorChooserDialogSignalName: String, SignalNameProtocol {
    /// Emitted when the user activates the default widget
    /// of `window`.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    case activateDefault = "activate-default"
    /// Emitted when the user activates the currently focused
    /// widget of `window`.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    case activateFocus = "activate-focus"
    /// Emitted when the user uses a keybinding to close the dialog.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default binding for this signal is the Escape key.
    case close = "close"
    /// Emitted when the user clicks on the close button of the window.
    case closeRequest = "close-request"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when the user enables or disables interactive debugging.
    /// 
    /// When `toggle` is `true`, interactive debugging is toggled on or off,
    /// when it is `false`, the debugger will be pointed at the widget
    /// under the pointer.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are Ctrl-Shift-I
    /// and Ctrl-Shift-D.
    case enableDebugging = "enable-debugging"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// emitted when the set of accelerators or mnemonics that
    /// are associated with `window` changes.
    case keysChanged = "keys-changed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when an action widget is clicked.
    /// 
    /// The signal is also emitted when the dialog receives a
    /// delete event, and when [method`Gtk.Dialog.response`] is called.
    /// On a delete event, the response ID is `GTK_RESPONSE_DELETE_EVENT`.
    /// Otherwise, it depends on which action widget was clicked.
    case response = "response"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// The `GtkApplication` associated with the window.
    /// 
    /// The application will be kept alive for at least as long as it
    /// has any windows associated with it (see `g_application_hold()`
    /// for a way to keep it alive without windows).
    /// 
    /// Normally, the connection between the application and the window
    /// will remain until the window is destroyed, but you can explicitly
    /// remove it by setting the :application property to `nil`.
    case notifyApplication = "notify::application"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// The child widget.
    case notifyChild = "notify::child"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the window should have a frame (also known as *decorations*).
    case notifyDecorated = "notify::decorated"
    /// The default height of the window.
    case notifyDefaultHeight = "notify::default-height"
    /// The default widget.
    case notifyDefaultWidget = "notify::default-widget"
    /// The default width of the window.
    case notifyDefaultWidth = "notify::default-width"
    /// Whether the window frame should have a close button.
    case notifyDeletable = "notify::deletable"
    /// If this window should be destroyed when the parent is destroyed.
    case notifyDestroyWithParent = "notify::destroy-with-parent"
    /// The display that will display this window.
    case notifyDisplay = "notify::display"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether 'focus rectangles' are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input
    /// and should not be set by applications.
    case notifyFocusVisible = "notify::focus-visible"
    /// The focus widget.
    case notifyFocusWidget = "notify::focus-widget"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// Whether the window is fullscreen.
    /// 
    /// Setting this property is the equivalent of calling
    /// [method`Gtk.Window.fullscreen`] or [method`Gtk.Window.unfullscreen`];
    /// either operation is asynchronous, which means you will need to
    /// connect to the `notify` signal in order to know whether the
    /// operation was successful.
    case notifyFullscreened = "notify::fullscreened"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the window frame should handle F10 for activating
    /// menubars.
    case notifyHandleMenubarAccel = "notify::handle-menubar-accel"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// If this window should be hidden when the users clicks the close button.
    case notifyHideOnClose = "notify::hide-on-close"
    /// Specifies the name of the themed icon to use as the window icon.
    /// 
    /// See [class`Gtk.IconTheme`] for more details.
    case notifyIconName = "notify::icon-name"
    /// Whether the toplevel is the currently active window.
    case notifyIsActive = "notify::is-active"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// Whether the window is maximized.
    /// 
    /// Setting this property is the equivalent of calling
    /// [method`Gtk.Window.maximize`] or [method`Gtk.Window.unmaximize`];
    /// either operation is asynchronous, which means you will need to
    /// connect to the `notify` signal in order to know whether the
    /// operation was successful.
    case notifyMaximized = "notify::maximized"
    /// Whether mnemonics are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input,
    /// and should not be set by applications.
    case notifyMnemonicsVisible = "notify::mnemonics-visible"
    /// If `true`, the window is modal.
    case notifyModal = "notify::modal"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// If `true`, users can resize the window.
    case notifyResizable = "notify::resizable"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    case notifyShowEditor = "notify::show-editor"
    /// A write-only property for setting window's startup notification identifier.
    case notifyStartupId = "notify::startup-id"
    /// The title of the window.
    case notifyTitle = "notify::title"
    /// The titlebar widget.
    case notifyTitlebar = "notify::titlebar"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// The transient parent of the window.
    case notifyTransientFor = "notify::transient-for"
    /// `true` if the dialog uses a headerbar for action buttons
    /// instead of the action-area.
    /// 
    /// For technical reasons, this property is declared as an integer
    /// property, but you should only set it to `true` or `false`.
    /// 
    /// ## Creating a dialog with headerbar
    /// 
    /// Builtin `GtkDialog` subclasses such as [class`Gtk.ColorChooserDialog`]
    /// set this property according to platform conventions (using the
    /// [property`Gtk.Settings:gtk-dialogs-use-header`] setting).
    /// 
    /// Here is how you can achieve the same:
    /// 
    /// ```c
    /// g_object_get (settings, "gtk-dialogs-use-header", &header, NULL);
    /// dialog = g_object_new (GTK_TYPE_DIALOG, header, TRUE, NULL);
    /// ```
    case notifyUseHeaderBar = "notify::use-header-bar"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: ColorChooserDialog has no signals
// MARK: ColorChooserDialog Class: ColorChooserDialogProtocol extension (methods and fields)
public extension ColorChooserDialogProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColorChooserDialog` instance.
    @inlinable var color_chooser_dialog_ptr: UnsafeMutablePointer<GtkColorChooserDialog>! { return ptr?.assumingMemoryBound(to: GtkColorChooserDialog.self) }



}



// MARK: - ColorChooserWidget Class

/// The `GtkColorChooserWidget` widget lets the user select a color.
/// 
/// By default, the chooser presents a predefined palette of colors,
/// plus a small number of settable custom colors. It is also possible
/// to select a different color with the single-color editor.
/// 
/// To enter the single-color editing mode, use the context menu of any
/// color of the palette, or use the '+' button to add a new custom color.
/// 
/// The chooser automatically remembers the last selection, as well
/// as custom colors.
/// 
/// To create a `GtkColorChooserWidget`, use [ctor`Gtk.ColorChooserWidget.new`].
/// 
/// To change the initially selected color, use
/// [method`Gtk.ColorChooser.set_rgba`]. To get the selected color use
/// [method`Gtk.ColorChooser.get_rgba`].
/// 
/// The `GtkColorChooserWidget` is used in the [class`Gtk.ColorChooserDialog`]
/// to provide a dialog for selecting colors.
/// 
/// # CSS names
/// 
/// `GtkColorChooserWidget` has a single CSS node with name colorchooser.
///
/// The `ColorChooserWidgetProtocol` protocol exposes the methods and properties of an underlying `GtkColorChooserWidget` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColorChooserWidget`.
/// Alternatively, use `ColorChooserWidgetRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ColorChooserWidgetProtocol: WidgetProtocol, ColorChooserProtocol {
        /// Untyped pointer to the underlying `GtkColorChooserWidget` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkColorChooserWidget` instance.
    var color_chooser_widget_ptr: UnsafeMutablePointer<GtkColorChooserWidget>! { get }

    /// Required Initialiser for types conforming to `ColorChooserWidgetProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `GtkColorChooserWidget` widget lets the user select a color.
/// 
/// By default, the chooser presents a predefined palette of colors,
/// plus a small number of settable custom colors. It is also possible
/// to select a different color with the single-color editor.
/// 
/// To enter the single-color editing mode, use the context menu of any
/// color of the palette, or use the '+' button to add a new custom color.
/// 
/// The chooser automatically remembers the last selection, as well
/// as custom colors.
/// 
/// To create a `GtkColorChooserWidget`, use [ctor`Gtk.ColorChooserWidget.new`].
/// 
/// To change the initially selected color, use
/// [method`Gtk.ColorChooser.set_rgba`]. To get the selected color use
/// [method`Gtk.ColorChooser.get_rgba`].
/// 
/// The `GtkColorChooserWidget` is used in the [class`Gtk.ColorChooserDialog`]
/// to provide a dialog for selecting colors.
/// 
/// # CSS names
/// 
/// `GtkColorChooserWidget` has a single CSS node with name colorchooser.
///
/// The `ColorChooserWidgetRef` type acts as a lightweight Swift reference to an underlying `GtkColorChooserWidget` instance.
/// It exposes methods that can operate on this data type through `ColorChooserWidgetProtocol` conformance.
/// Use `ColorChooserWidgetRef` only as an `unowned` reference to an existing `GtkColorChooserWidget` instance.
///
public struct ColorChooserWidgetRef: ColorChooserWidgetProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkColorChooserWidget` instance.
    /// For type-safe access, use the generated, typed pointer `color_chooser_widget_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ColorChooserWidgetRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkColorChooserWidget>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkColorChooserWidget>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkColorChooserWidget>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkColorChooserWidget>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ColorChooserWidgetProtocol`
    @inlinable init<T: ColorChooserWidgetProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ColorChooserWidgetProtocol>(_ other: T) -> ColorChooserWidgetRef { ColorChooserWidgetRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkColorChooserWidget`.
    @inlinable init() {
            let result = gtk_color_chooser_widget_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `GtkColorChooserWidget` widget lets the user select a color.
/// 
/// By default, the chooser presents a predefined palette of colors,
/// plus a small number of settable custom colors. It is also possible
/// to select a different color with the single-color editor.
/// 
/// To enter the single-color editing mode, use the context menu of any
/// color of the palette, or use the '+' button to add a new custom color.
/// 
/// The chooser automatically remembers the last selection, as well
/// as custom colors.
/// 
/// To create a `GtkColorChooserWidget`, use [ctor`Gtk.ColorChooserWidget.new`].
/// 
/// To change the initially selected color, use
/// [method`Gtk.ColorChooser.set_rgba`]. To get the selected color use
/// [method`Gtk.ColorChooser.get_rgba`].
/// 
/// The `GtkColorChooserWidget` is used in the [class`Gtk.ColorChooserDialog`]
/// to provide a dialog for selecting colors.
/// 
/// # CSS names
/// 
/// `GtkColorChooserWidget` has a single CSS node with name colorchooser.
///
/// The `ColorChooserWidget` type acts as a reference-counted owner of an underlying `GtkColorChooserWidget` instance.
/// It provides the methods that can operate on this data type through `ColorChooserWidgetProtocol` conformance.
/// Use `ColorChooserWidget` as a strong reference or owner of a `GtkColorChooserWidget` instance.
///
open class ColorChooserWidget: Widget, ColorChooserWidgetProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkColorChooserWidget>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkColorChooserWidget>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkColorChooserWidget>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkColorChooserWidget>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkColorChooserWidget`.
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkColorChooserWidget>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ColorChooserWidgetProtocol`
    /// Will retain `GtkColorChooserWidget`.
    /// - Parameter other: an instance of a related type that implements `ColorChooserWidgetProtocol`
    @inlinable public init<T: ColorChooserWidgetProtocol>(colorChooserWidget other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkColorChooserWidget`.
    @inlinable public init() {
            let result = gtk_color_chooser_widget_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ColorChooserWidgetPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// `true` when the color chooser is showing the single-color editor.
    /// 
    /// It can be set to switch the color chooser into single-color editing mode.
    case showEditor = "show-editor"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension ColorChooserWidgetProtocol {
    /// Bind a `ColorChooserWidgetPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColorChooserWidgetPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ColorChooserWidget property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ColorChooserWidgetPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ColorChooserWidget property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ColorChooserWidgetPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ColorChooserWidgetSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// `true` when the color chooser is showing the single-color editor.
    /// 
    /// It can be set to switch the color chooser into single-color editing mode.
    case notifyShowEditor = "notify::show-editor"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: ColorChooserWidget has no signals
// MARK: ColorChooserWidget Class: ColorChooserWidgetProtocol extension (methods and fields)
public extension ColorChooserWidgetProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColorChooserWidget` instance.
    @inlinable var color_chooser_widget_ptr: UnsafeMutablePointer<GtkColorChooserWidget>! { return ptr?.assumingMemoryBound(to: GtkColorChooserWidget.self) }



}



// MARK: - ColumnView Class

/// `GtkColumnView` presents a large dynamic list of items using multiple columns
/// with headers.
/// 
/// `GtkColumnView` uses the factories of its columns to generate a cell widget for
/// each column, for each visible item and displays them together as the row for
/// this item.
/// 
/// The [property`Gtk.ColumnView:show-row-separators`] and
/// [property`Gtk.ColumnView:show-column-separators`] properties offer a simple way
/// to display separators between the rows or columns.
/// 
/// `GtkColumnView` allows the user to select items according to the selection
/// characteristics of the model. For models that allow multiple selected items,
/// it is possible to turn on *rubberband selection*, using
/// [property`Gtk.ColumnView:enable-rubberband`].
/// 
/// The column view supports sorting that can be customized by the user by
/// clicking on column headers. To set this up, the `GtkSorter` returned by
/// [method`Gtk.ColumnView.get_sorter`] must be attached to a sort model for the
/// data that the view is showing, and the columns must have sorters attached to
/// them by calling [method`Gtk.ColumnViewColumn.set_sorter`]. The initial sort
/// order can be set with [method`Gtk.ColumnView.sort_by_column`].
/// 
/// The column view also supports interactive resizing and reordering of
/// columns, via Drag-and-Drop of the column headers. This can be enabled or
/// disabled with the [property`Gtk.ColumnView:reorderable`] and
/// [property`Gtk.ColumnViewColumn:resizable`] properties.
/// 
/// To learn more about the list widget framework, see the
/// [overview](section-list-widget.html).
/// 
/// # CSS nodes
/// 
/// ```
/// columnview[.column-separators][.rich-list][.navigation-sidebar][.data-table]
/// ├── header
/// │   ├── &lt;column header&gt;
/// ┊   ┊
/// │   ╰── &lt;column header&gt;
/// │
/// ├── listview
/// │
/// ┊
/// ╰── [rubberband]
/// ```
/// 
/// `GtkColumnView` uses a single CSS node named columnview. It may carry the
/// .column-separators style class, when [property`Gtk.ColumnView:show-column-separators`]
/// property is set. Header widgets appear below a node with name header.
/// The rows are contained in a `GtkListView` widget, so there is a listview
/// node with the same structure as for a standalone `GtkListView` widget.
/// If [property`Gtk.ColumnView:show-row-separators`] is set, it will be passed
/// on to the list view, causing its CSS node to carry the .separators style class.
/// For rubberband selection, a node with name rubberband is used.
/// 
/// The main columnview node may also carry style classes to select
/// the style of [list presentation](section-list-widget.html`list-styles`):
/// .rich-list, .navigation-sidebar or .data-table.
/// 
/// # Accessibility
/// 
/// `GtkColumnView` uses the `GTK_ACCESSIBLE_ROLE_TREE_GRID` role, header title
/// widgets are using the `GTK_ACCESSIBLE_ROLE_COLUMN_HEADER` role. The row widgets
/// are using the `GTK_ACCESSIBLE_ROLE_ROW` role, and individual cells are using
/// the `GTK_ACCESSIBLE_ROLE_GRID_CELL` role
///
/// The `ColumnViewProtocol` protocol exposes the methods and properties of an underlying `GtkColumnView` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColumnView`.
/// Alternatively, use `ColumnViewRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ColumnViewProtocol: WidgetProtocol, ScrollableProtocol {
        /// Untyped pointer to the underlying `GtkColumnView` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkColumnView` instance.
    var column_view_ptr: UnsafeMutablePointer<GtkColumnView>! { get }

    /// Required Initialiser for types conforming to `ColumnViewProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkColumnView` presents a large dynamic list of items using multiple columns
/// with headers.
/// 
/// `GtkColumnView` uses the factories of its columns to generate a cell widget for
/// each column, for each visible item and displays them together as the row for
/// this item.
/// 
/// The [property`Gtk.ColumnView:show-row-separators`] and
/// [property`Gtk.ColumnView:show-column-separators`] properties offer a simple way
/// to display separators between the rows or columns.
/// 
/// `GtkColumnView` allows the user to select items according to the selection
/// characteristics of the model. For models that allow multiple selected items,
/// it is possible to turn on *rubberband selection*, using
/// [property`Gtk.ColumnView:enable-rubberband`].
/// 
/// The column view supports sorting that can be customized by the user by
/// clicking on column headers. To set this up, the `GtkSorter` returned by
/// [method`Gtk.ColumnView.get_sorter`] must be attached to a sort model for the
/// data that the view is showing, and the columns must have sorters attached to
/// them by calling [method`Gtk.ColumnViewColumn.set_sorter`]. The initial sort
/// order can be set with [method`Gtk.ColumnView.sort_by_column`].
/// 
/// The column view also supports interactive resizing and reordering of
/// columns, via Drag-and-Drop of the column headers. This can be enabled or
/// disabled with the [property`Gtk.ColumnView:reorderable`] and
/// [property`Gtk.ColumnViewColumn:resizable`] properties.
/// 
/// To learn more about the list widget framework, see the
/// [overview](section-list-widget.html).
/// 
/// # CSS nodes
/// 
/// ```
/// columnview[.column-separators][.rich-list][.navigation-sidebar][.data-table]
/// ├── header
/// │   ├── &lt;column header&gt;
/// ┊   ┊
/// │   ╰── &lt;column header&gt;
/// │
/// ├── listview
/// │
/// ┊
/// ╰── [rubberband]
/// ```
/// 
/// `GtkColumnView` uses a single CSS node named columnview. It may carry the
/// .column-separators style class, when [property`Gtk.ColumnView:show-column-separators`]
/// property is set. Header widgets appear below a node with name header.
/// The rows are contained in a `GtkListView` widget, so there is a listview
/// node with the same structure as for a standalone `GtkListView` widget.
/// If [property`Gtk.ColumnView:show-row-separators`] is set, it will be passed
/// on to the list view, causing its CSS node to carry the .separators style class.
/// For rubberband selection, a node with name rubberband is used.
/// 
/// The main columnview node may also carry style classes to select
/// the style of [list presentation](section-list-widget.html`list-styles`):
/// .rich-list, .navigation-sidebar or .data-table.
/// 
/// # Accessibility
/// 
/// `GtkColumnView` uses the `GTK_ACCESSIBLE_ROLE_TREE_GRID` role, header title
/// widgets are using the `GTK_ACCESSIBLE_ROLE_COLUMN_HEADER` role. The row widgets
/// are using the `GTK_ACCESSIBLE_ROLE_ROW` role, and individual cells are using
/// the `GTK_ACCESSIBLE_ROLE_GRID_CELL` role
///
/// The `ColumnViewRef` type acts as a lightweight Swift reference to an underlying `GtkColumnView` instance.
/// It exposes methods that can operate on this data type through `ColumnViewProtocol` conformance.
/// Use `ColumnViewRef` only as an `unowned` reference to an existing `GtkColumnView` instance.
///
public struct ColumnViewRef: ColumnViewProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkColumnView` instance.
    /// For type-safe access, use the generated, typed pointer `column_view_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ColumnViewRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkColumnView>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkColumnView>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkColumnView>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkColumnView>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ColumnViewProtocol`
    @inlinable init<T: ColumnViewProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ColumnViewProtocol>(_ other: T) -> ColumnViewRef { ColumnViewRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkColumnView`.
    /// 
    /// You most likely want to call [method`Gtk.ColumnView.append_column`]
    /// to add columns next.
    @inlinable init<SelectionModelT: SelectionModelProtocol>( model: SelectionModelT?) {
            let result = gtk_column_view_new(model?.selection_model_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkColumnView` presents a large dynamic list of items using multiple columns
/// with headers.
/// 
/// `GtkColumnView` uses the factories of its columns to generate a cell widget for
/// each column, for each visible item and displays them together as the row for
/// this item.
/// 
/// The [property`Gtk.ColumnView:show-row-separators`] and
/// [property`Gtk.ColumnView:show-column-separators`] properties offer a simple way
/// to display separators between the rows or columns.
/// 
/// `GtkColumnView` allows the user to select items according to the selection
/// characteristics of the model. For models that allow multiple selected items,
/// it is possible to turn on *rubberband selection*, using
/// [property`Gtk.ColumnView:enable-rubberband`].
/// 
/// The column view supports sorting that can be customized by the user by
/// clicking on column headers. To set this up, the `GtkSorter` returned by
/// [method`Gtk.ColumnView.get_sorter`] must be attached to a sort model for the
/// data that the view is showing, and the columns must have sorters attached to
/// them by calling [method`Gtk.ColumnViewColumn.set_sorter`]. The initial sort
/// order can be set with [method`Gtk.ColumnView.sort_by_column`].
/// 
/// The column view also supports interactive resizing and reordering of
/// columns, via Drag-and-Drop of the column headers. This can be enabled or
/// disabled with the [property`Gtk.ColumnView:reorderable`] and
/// [property`Gtk.ColumnViewColumn:resizable`] properties.
/// 
/// To learn more about the list widget framework, see the
/// [overview](section-list-widget.html).
/// 
/// # CSS nodes
/// 
/// ```
/// columnview[.column-separators][.rich-list][.navigation-sidebar][.data-table]
/// ├── header
/// │   ├── &lt;column header&gt;
/// ┊   ┊
/// │   ╰── &lt;column header&gt;
/// │
/// ├── listview
/// │
/// ┊
/// ╰── [rubberband]
/// ```
/// 
/// `GtkColumnView` uses a single CSS node named columnview. It may carry the
/// .column-separators style class, when [property`Gtk.ColumnView:show-column-separators`]
/// property is set. Header widgets appear below a node with name header.
/// The rows are contained in a `GtkListView` widget, so there is a listview
/// node with the same structure as for a standalone `GtkListView` widget.
/// If [property`Gtk.ColumnView:show-row-separators`] is set, it will be passed
/// on to the list view, causing its CSS node to carry the .separators style class.
/// For rubberband selection, a node with name rubberband is used.
/// 
/// The main columnview node may also carry style classes to select
/// the style of [list presentation](section-list-widget.html`list-styles`):
/// .rich-list, .navigation-sidebar or .data-table.
/// 
/// # Accessibility
/// 
/// `GtkColumnView` uses the `GTK_ACCESSIBLE_ROLE_TREE_GRID` role, header title
/// widgets are using the `GTK_ACCESSIBLE_ROLE_COLUMN_HEADER` role. The row widgets
/// are using the `GTK_ACCESSIBLE_ROLE_ROW` role, and individual cells are using
/// the `GTK_ACCESSIBLE_ROLE_GRID_CELL` role
///
/// The `ColumnView` type acts as a reference-counted owner of an underlying `GtkColumnView` instance.
/// It provides the methods that can operate on this data type through `ColumnViewProtocol` conformance.
/// Use `ColumnView` as a strong reference or owner of a `GtkColumnView` instance.
///
open class ColumnView: Widget, ColumnViewProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkColumnView>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkColumnView>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkColumnView>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkColumnView>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkColumnView`.
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkColumnView>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ColumnViewProtocol`
    /// Will retain `GtkColumnView`.
    /// - Parameter other: an instance of a related type that implements `ColumnViewProtocol`
    @inlinable public init<T: ColumnViewProtocol>(columnView other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkColumnView`.
    /// 
    /// You most likely want to call [method`Gtk.ColumnView.append_column`]
    /// to add columns next.
    @inlinable public init<SelectionModelT: SelectionModelProtocol>( model: SelectionModelT?) {
            let result = gtk_column_view_new(model?.selection_model_ptr)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ColumnViewPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// The list of columns.
    case columns = "columns"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Allow rubberband selection.
    case enableRubberband = "enable-rubberband"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// Model for the items displayed.
    case model = "model"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// Whether columns are reorderable.
    case reorderable = "reorderable"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Show separators between columns.
    case showColumnSeparators = "show-column-separators"
    /// Show separators between rows.
    case showRowSeparators = "show-row-separators"
    /// Activate rows on single click and select them on hover.
    case singleClickActivate = "single-click-activate"
    /// Sorter with the sorting choices of the user.
    case sorter = "sorter"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension ColumnViewProtocol {
    /// Bind a `ColumnViewPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColumnViewPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ColumnView property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ColumnViewPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ColumnView property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ColumnViewPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ColumnViewSignalName: String, SignalNameProtocol {
    /// Emitted when a row has been activated by the user, usually via activating
    /// the GtkListBase|list.activate-item action.
    /// 
    /// This allows for a convenient way to handle activation in a columnview.
    /// See [method`Gtk.ListItem.set_activatable`] for details on how to use this
    /// signal.
    case activate = "activate"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// The list of columns.
    case notifyColumns = "notify::columns"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Allow rubberband selection.
    case notifyEnableRubberband = "notify::enable-rubberband"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// Model for the items displayed.
    case notifyModel = "notify::model"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// Whether columns are reorderable.
    case notifyReorderable = "notify::reorderable"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Show separators between columns.
    case notifyShowColumnSeparators = "notify::show-column-separators"
    /// Show separators between rows.
    case notifyShowRowSeparators = "notify::show-row-separators"
    /// Activate rows on single click and select them on hover.
    case notifySingleClickActivate = "notify::single-click-activate"
    /// Sorter with the sorting choices of the user.
    case notifySorter = "notify::sorter"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: ColumnView signals
public extension ColumnViewProtocol {
    /// Connect a Swift signal handler to the given, typed `ColumnViewSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ColumnViewSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `ColumnViewSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ColumnViewSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when a row has been activated by the user, usually via activating
    /// the GtkListBase|list.activate-item action.
    /// 
    /// This allows for a convenient way to handle activation in a columnview.
    /// See [method`Gtk.ListItem.set_activatable`] for details on how to use this
    /// signal.
    /// - Note: This represents the underlying `activate` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter position: position of item to activate
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `activate` signal is emitted
    @discardableResult @inlinable func onActivate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColumnViewRef, _ position: UInt) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ColumnViewRef, UInt), Void>
        let cCallback: @convention(c) (gpointer, guint, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ColumnViewRef(raw: unownedSelf), UInt(arg1)))
            return output
        }
        return connect(
            signal: .activate,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `activate` signal for using the `connect(signal:)` methods
    static var activateSignal: ColumnViewSignalName { .activate }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::columns` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyColumns` signal is emitted
    @discardableResult @inlinable func onNotifyColumns(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColumnViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ColumnViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ColumnViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyColumns,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::columns` signal for using the `connect(signal:)` methods
    static var notifyColumnsSignal: ColumnViewSignalName { .notifyColumns }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::enable-rubberband` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEnableRubberband` signal is emitted
    @discardableResult @inlinable func onNotifyEnableRubberband(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColumnViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ColumnViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ColumnViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyEnableRubberband,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::enable-rubberband` signal for using the `connect(signal:)` methods
    static var notifyEnableRubberbandSignal: ColumnViewSignalName { .notifyEnableRubberband }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::model` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyModel` signal is emitted
    @discardableResult @inlinable func onNotifyModel(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColumnViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ColumnViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ColumnViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyModel,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::model` signal for using the `connect(signal:)` methods
    static var notifyModelSignal: ColumnViewSignalName { .notifyModel }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::reorderable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyReorderable` signal is emitted
    @discardableResult @inlinable func onNotifyReorderable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColumnViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ColumnViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ColumnViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyReorderable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::reorderable` signal for using the `connect(signal:)` methods
    static var notifyReorderableSignal: ColumnViewSignalName { .notifyReorderable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::show-column-separators` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyShowColumnSeparators` signal is emitted
    @discardableResult @inlinable func onNotifyShowColumnSeparators(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColumnViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ColumnViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ColumnViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyShowColumnSeparators,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::show-column-separators` signal for using the `connect(signal:)` methods
    static var notifyShowColumnSeparatorsSignal: ColumnViewSignalName { .notifyShowColumnSeparators }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::show-row-separators` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyShowRowSeparators` signal is emitted
    @discardableResult @inlinable func onNotifyShowRowSeparators(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColumnViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ColumnViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ColumnViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyShowRowSeparators,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::show-row-separators` signal for using the `connect(signal:)` methods
    static var notifyShowRowSeparatorsSignal: ColumnViewSignalName { .notifyShowRowSeparators }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::single-click-activate` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySingleClickActivate` signal is emitted
    @discardableResult @inlinable func onNotifySingleClickActivate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColumnViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ColumnViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ColumnViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifySingleClickActivate,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::single-click-activate` signal for using the `connect(signal:)` methods
    static var notifySingleClickActivateSignal: ColumnViewSignalName { .notifySingleClickActivate }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::sorter` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySorter` signal is emitted
    @discardableResult @inlinable func onNotifySorter(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColumnViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ColumnViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ColumnViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifySorter,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::sorter` signal for using the `connect(signal:)` methods
    static var notifySorterSignal: ColumnViewSignalName { .notifySorter }
    
}

// MARK: ColumnView Class: ColumnViewProtocol extension (methods and fields)
public extension ColumnViewProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColumnView` instance.
    @inlinable var column_view_ptr: UnsafeMutablePointer<GtkColumnView>! { return ptr?.assumingMemoryBound(to: GtkColumnView.self) }

    /// Appends the `column` to the end of the columns in `self`.
    @inlinable func append<ColumnViewColumnT: ColumnViewColumnProtocol>(column: ColumnViewColumnT) {
        
        gtk_column_view_append_column(column_view_ptr, column.column_view_column_ptr)
        
    }

    /// Gets the list of columns in this column view.
    /// 
    /// This list is constant over the lifetime of `self` and can be used to
    /// monitor changes to the columns of `self` by connecting to the
    /// `items-changed` signal.
    @inlinable func getColumns() -> GIO.ListModelRef! {
        let result = gtk_column_view_get_columns(column_view_ptr)
        let rv = GIO.ListModelRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns whether rows can be selected by dragging with the mouse.
    @inlinable func getEnableRubberband() -> Bool {
        let result = gtk_column_view_get_enable_rubberband(column_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the model that's currently used to read the items displayed.
    @inlinable func getModel() -> SelectionModelRef! {
        let result = gtk_column_view_get_model(column_view_ptr)
        let rv = SelectionModelRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns whether columns are reorderable.
    @inlinable func getReorderable() -> Bool {
        let result = gtk_column_view_get_reorderable(column_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns whether the list should show separators
    /// between columns.
    @inlinable func getShowColumnSeparators() -> Bool {
        let result = gtk_column_view_get_show_column_separators(column_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns whether the list should show separators
    /// between rows.
    @inlinable func getShowRowSeparators() -> Bool {
        let result = gtk_column_view_get_show_row_separators(column_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns whether rows will be activated on single click and
    /// selected on hover.
    @inlinable func getSingleClickActivate() -> Bool {
        let result = gtk_column_view_get_single_click_activate(column_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns a special sorter that reflects the users sorting
    /// choices in the column view.
    /// 
    /// To allow users to customizable sorting by clicking on column
    /// headers, this sorter needs to be set on the sort model underneath
    /// the model that is displayed by the view.
    /// 
    /// See [method`Gtk.ColumnViewColumn.set_sorter`] for setting up
    /// per-column sorting.
    /// 
    /// Here is an example:
    /// ```c
    /// gtk_column_view_column_set_sorter (column, sorter);
    /// gtk_column_view_append_column (view, column);
    /// sorter = g_object_ref (gtk_column_view_get_sorter (view)));
    /// model = gtk_sort_list_model_new (store, sorter);
    /// selection = gtk_no_selection_new (model);
    /// gtk_column_view_set_model (view, selection);
    /// ```
    @inlinable func getSorter() -> SorterRef! {
        let result = gtk_column_view_get_sorter(column_view_ptr)
        let rv = SorterRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Inserts a column at the given position in the columns of `self`.
    /// 
    /// If `column` is already a column of `self`, it will be repositioned.
    @inlinable func insertColumn<ColumnViewColumnT: ColumnViewColumnProtocol>(position: Int, column: ColumnViewColumnT) {
        
        gtk_column_view_insert_column(column_view_ptr, guint(position), column.column_view_column_ptr)
        
    }

    /// Removes the `column` from the list of columns of `self`.
    @inlinable func remove<ColumnViewColumnT: ColumnViewColumnProtocol>(column: ColumnViewColumnT) {
        
        gtk_column_view_remove_column(column_view_ptr, column.column_view_column_ptr)
        
    }

    /// Sets whether selections can be changed by dragging with the mouse.
    @inlinable func set(enableRubberband: Bool) {
        
        gtk_column_view_set_enable_rubberband(column_view_ptr, gboolean((enableRubberband) ? 1 : 0))
        
    }

    /// Sets the model to use.
    /// 
    /// This must be a [iface`Gtk.SelectionModel`].
    @inlinable func set(model: SelectionModelRef? = nil) {
            
        gtk_column_view_set_model(column_view_ptr, model?.selection_model_ptr)
            
    }
    /// Sets the model to use.
    /// 
    /// This must be a [iface`Gtk.SelectionModel`].
    @inlinable func set<SelectionModelT: SelectionModelProtocol>(model: SelectionModelT?) {
        
        gtk_column_view_set_model(column_view_ptr, model?.selection_model_ptr)
        
    }

    /// Sets whether columns should be reorderable by dragging.
    @inlinable func set(reorderable: Bool) {
        
        gtk_column_view_set_reorderable(column_view_ptr, gboolean((reorderable) ? 1 : 0))
        
    }

    /// Sets whether the list should show separators
    /// between columns.
    @inlinable func set(showColumnSeparators: Bool) {
        
        gtk_column_view_set_show_column_separators(column_view_ptr, gboolean((showColumnSeparators) ? 1 : 0))
        
    }

    /// Sets whether the list should show separators
    /// between rows.
    @inlinable func set(showRowSeparators: Bool) {
        
        gtk_column_view_set_show_row_separators(column_view_ptr, gboolean((showRowSeparators) ? 1 : 0))
        
    }

    /// Sets whether rows should be activated on single click and
    /// selected on hover.
    @inlinable func set(singleClickActivate: Bool) {
        
        gtk_column_view_set_single_click_activate(column_view_ptr, gboolean((singleClickActivate) ? 1 : 0))
        
    }

    /// Sets the sorting of the view.
    /// 
    /// This function should be used to set up the initial sorting.
    /// At runtime, users can change the sorting of a column view
    /// by clicking on the list headers.
    /// 
    /// This call only has an effect if the sorter returned by
    /// [method`Gtk.ColumnView.get_sorter`] is set on a sort model,
    /// and [method`Gtk.ColumnViewColumn.set_sorter`] has been called
    /// on `column` to associate a sorter with the column.
    /// 
    /// If `column` is `nil`, the view will be unsorted.
    @inlinable func sortBy(column: ColumnViewColumnRef? = nil, direction: GtkSortType) {
            
        gtk_column_view_sort_by_column(column_view_ptr, column?.column_view_column_ptr, direction)
            
    }
    /// Sets the sorting of the view.
    /// 
    /// This function should be used to set up the initial sorting.
    /// At runtime, users can change the sorting of a column view
    /// by clicking on the list headers.
    /// 
    /// This call only has an effect if the sorter returned by
    /// [method`Gtk.ColumnView.get_sorter`] is set on a sort model,
    /// and [method`Gtk.ColumnViewColumn.set_sorter`] has been called
    /// on `column` to associate a sorter with the column.
    /// 
    /// If `column` is `nil`, the view will be unsorted.
    @inlinable func sortBy<ColumnViewColumnT: ColumnViewColumnProtocol>(column: ColumnViewColumnT?, direction: GtkSortType) {
        
        gtk_column_view_sort_by_column(column_view_ptr, column?.column_view_column_ptr, direction)
        
    }
    /// The list of columns.
    @inlinable var columns: GIO.ListModelRef! {
        /// Gets the list of columns in this column view.
        /// 
        /// This list is constant over the lifetime of `self` and can be used to
        /// monitor changes to the columns of `self` by connecting to the
        /// `items-changed` signal.
        get {
            let result = gtk_column_view_get_columns(column_view_ptr)
        let rv = GIO.ListModelRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Returns whether rows can be selected by dragging with the mouse.
    @inlinable var enableRubberband: Bool {
        /// Returns whether rows can be selected by dragging with the mouse.
        get {
            let result = gtk_column_view_get_enable_rubberband(column_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether selections can be changed by dragging with the mouse.
        nonmutating set {
            gtk_column_view_set_enable_rubberband(column_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Model for the items displayed.
    @inlinable var model: SelectionModelRef! {
        /// Gets the model that's currently used to read the items displayed.
        get {
            let result = gtk_column_view_get_model(column_view_ptr)
        let rv = SelectionModelRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets the model to use.
        /// 
        /// This must be a [iface`Gtk.SelectionModel`].
        nonmutating set {
            gtk_column_view_set_model(column_view_ptr, UnsafeMutablePointer<GtkSelectionModel>(newValue?.selection_model_ptr))
        }
    }

    /// Whether columns are reorderable.
    @inlinable var reorderable: Bool {
        /// Returns whether columns are reorderable.
        get {
            let result = gtk_column_view_get_reorderable(column_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether columns should be reorderable by dragging.
        nonmutating set {
            gtk_column_view_set_reorderable(column_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether the list should show separators
    /// between columns.
    @inlinable var showColumnSeparators: Bool {
        /// Returns whether the list should show separators
        /// between columns.
        get {
            let result = gtk_column_view_get_show_column_separators(column_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether the list should show separators
        /// between columns.
        nonmutating set {
            gtk_column_view_set_show_column_separators(column_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether the list should show separators
    /// between rows.
    @inlinable var showRowSeparators: Bool {
        /// Returns whether the list should show separators
        /// between rows.
        get {
            let result = gtk_column_view_get_show_row_separators(column_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether the list should show separators
        /// between rows.
        nonmutating set {
            gtk_column_view_set_show_row_separators(column_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether rows will be activated on single click and
    /// selected on hover.
    @inlinable var singleClickActivate: Bool {
        /// Returns whether rows will be activated on single click and
        /// selected on hover.
        get {
            let result = gtk_column_view_get_single_click_activate(column_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether rows should be activated on single click and
        /// selected on hover.
        nonmutating set {
            gtk_column_view_set_single_click_activate(column_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Sorter with the sorting choices of the user.
    @inlinable var sorter: SorterRef! {
        /// Returns a special sorter that reflects the users sorting
        /// choices in the column view.
        /// 
        /// To allow users to customizable sorting by clicking on column
        /// headers, this sorter needs to be set on the sort model underneath
        /// the model that is displayed by the view.
        /// 
        /// See [method`Gtk.ColumnViewColumn.set_sorter`] for setting up
        /// per-column sorting.
        /// 
        /// Here is an example:
        /// ```c
        /// gtk_column_view_column_set_sorter (column, sorter);
        /// gtk_column_view_append_column (view, column);
        /// sorter = g_object_ref (gtk_column_view_get_sorter (view)));
        /// model = gtk_sort_list_model_new (store, sorter);
        /// selection = gtk_no_selection_new (model);
        /// gtk_column_view_set_model (view, selection);
        /// ```
        get {
            let result = gtk_column_view_get_sorter(column_view_ptr)
        let rv = SorterRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }


}



// MARK: - ColumnViewColumn Class

/// `GtkColumnViewColumn` represents the columns being added to `GtkColumnView`.
/// 
/// The main ingredient for a `GtkColumnViewColumn` is the `GtkListItemFactory`
/// that tells the columnview how to create cells for this column from items in
/// the model.
/// 
/// Columns have a title, and can optionally have a header menu set
/// with [method`Gtk.ColumnViewColumn.set_header_menu`].
/// 
/// A sorter can be associated with a column using
/// [method`Gtk.ColumnViewColumn.set_sorter`], to let users influence sorting
/// by clicking on the column header.
///
/// The `ColumnViewColumnProtocol` protocol exposes the methods and properties of an underlying `GtkColumnViewColumn` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColumnViewColumn`.
/// Alternatively, use `ColumnViewColumnRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ColumnViewColumnProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkColumnViewColumn` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkColumnViewColumn` instance.
    var column_view_column_ptr: UnsafeMutablePointer<GtkColumnViewColumn>! { get }

    /// Required Initialiser for types conforming to `ColumnViewColumnProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkColumnViewColumn` represents the columns being added to `GtkColumnView`.
/// 
/// The main ingredient for a `GtkColumnViewColumn` is the `GtkListItemFactory`
/// that tells the columnview how to create cells for this column from items in
/// the model.
/// 
/// Columns have a title, and can optionally have a header menu set
/// with [method`Gtk.ColumnViewColumn.set_header_menu`].
/// 
/// A sorter can be associated with a column using
/// [method`Gtk.ColumnViewColumn.set_sorter`], to let users influence sorting
/// by clicking on the column header.
///
/// The `ColumnViewColumnRef` type acts as a lightweight Swift reference to an underlying `GtkColumnViewColumn` instance.
/// It exposes methods that can operate on this data type through `ColumnViewColumnProtocol` conformance.
/// Use `ColumnViewColumnRef` only as an `unowned` reference to an existing `GtkColumnViewColumn` instance.
///
public struct ColumnViewColumnRef: ColumnViewColumnProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkColumnViewColumn` instance.
    /// For type-safe access, use the generated, typed pointer `column_view_column_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ColumnViewColumnRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkColumnViewColumn>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkColumnViewColumn>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkColumnViewColumn>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkColumnViewColumn>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ColumnViewColumnProtocol`
    @inlinable init<T: ColumnViewColumnProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ColumnViewColumnProtocol>(_ other: T) -> ColumnViewColumnRef { ColumnViewColumnRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkColumnViewColumn` that uses the given `factory` for
    /// mapping items to widgets.
    /// 
    /// You most likely want to call [method`Gtk.ColumnView.append_column`] next.
    /// 
    /// The function takes ownership of the argument, so you can write code like:
    /// 
    /// ```c
    /// column = gtk_column_view_column_new (`_("Name")`,
    ///   gtk_builder_list_item_factory_new_from_resource ("/name.ui"));
    /// ```
    @inlinable init<ListItemFactoryT: ListItemFactoryProtocol>( title: UnsafePointer<CChar>? = nil, factory: ListItemFactoryT?) {
            let result = gtk_column_view_column_new(title, factory?.list_item_factory_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkColumnViewColumn` represents the columns being added to `GtkColumnView`.
/// 
/// The main ingredient for a `GtkColumnViewColumn` is the `GtkListItemFactory`
/// that tells the columnview how to create cells for this column from items in
/// the model.
/// 
/// Columns have a title, and can optionally have a header menu set
/// with [method`Gtk.ColumnViewColumn.set_header_menu`].
/// 
/// A sorter can be associated with a column using
/// [method`Gtk.ColumnViewColumn.set_sorter`], to let users influence sorting
/// by clicking on the column header.
///
/// The `ColumnViewColumn` type acts as a reference-counted owner of an underlying `GtkColumnViewColumn` instance.
/// It provides the methods that can operate on this data type through `ColumnViewColumnProtocol` conformance.
/// Use `ColumnViewColumn` as a strong reference or owner of a `GtkColumnViewColumn` instance.
///
open class ColumnViewColumn: GLibObject.Object, ColumnViewColumnProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkColumnViewColumn>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkColumnViewColumn>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkColumnViewColumn>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkColumnViewColumn>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkColumnViewColumn`.
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkColumnViewColumn>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ColumnViewColumnProtocol`
    /// Will retain `GtkColumnViewColumn`.
    /// - Parameter other: an instance of a related type that implements `ColumnViewColumnProtocol`
    @inlinable public init<T: ColumnViewColumnProtocol>(columnViewColumn other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkColumnViewColumn` that uses the given `factory` for
    /// mapping items to widgets.
    /// 
    /// You most likely want to call [method`Gtk.ColumnView.append_column`] next.
    /// 
    /// The function takes ownership of the argument, so you can write code like:
    /// 
    /// ```c
    /// column = gtk_column_view_column_new (`_("Name")`,
    ///   gtk_builder_list_item_factory_new_from_resource ("/name.ui"));
    /// ```
    @inlinable public init<ListItemFactoryT: ListItemFactoryProtocol>( title: UnsafePointer<CChar>? = nil, factory: ListItemFactoryT?) {
            let result = gtk_column_view_column_new(title, factory?.list_item_factory_ptr)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ColumnViewColumnPropertyName: String, PropertyNameProtocol {
    /// The `GtkColumnView` this column is a part of.
    case columnView = "column-view"
    /// Column gets share of extra width allocated to the view.
    case expand = "expand"
    /// Factory for populating list items.
    case factory = "factory"
    /// If not -1, this is the width that the column is allocated,
    /// regardless of the size of its content.
    case fixedWidth = "fixed-width"
    /// Menu model used to create the context menu for the column header.
    case headerMenu = "header-menu"
    /// Whether this column is resizable.
    case resizable = "resizable"
    /// Sorter for sorting items according to this column.
    case sorter = "sorter"
    /// Title displayed in the header.
    case title = "title"
    /// Whether this column is visible.
    case visible = "visible"
}

public extension ColumnViewColumnProtocol {
    /// Bind a `ColumnViewColumnPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColumnViewColumnPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ColumnViewColumn property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ColumnViewColumnPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ColumnViewColumn property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ColumnViewColumnPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ColumnViewColumnSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `GtkColumnView` this column is a part of.
    case notifyColumnView = "notify::column-view"
    /// Column gets share of extra width allocated to the view.
    case notifyExpand = "notify::expand"
    /// Factory for populating list items.
    case notifyFactory = "notify::factory"
    /// If not -1, this is the width that the column is allocated,
    /// regardless of the size of its content.
    case notifyFixedWidth = "notify::fixed-width"
    /// Menu model used to create the context menu for the column header.
    case notifyHeaderMenu = "notify::header-menu"
    /// Whether this column is resizable.
    case notifyResizable = "notify::resizable"
    /// Sorter for sorting items according to this column.
    case notifySorter = "notify::sorter"
    /// Title displayed in the header.
    case notifyTitle = "notify::title"
    /// Whether this column is visible.
    case notifyVisible = "notify::visible"
}

// MARK: ColumnViewColumn has no signals
// MARK: ColumnViewColumn Class: ColumnViewColumnProtocol extension (methods and fields)
public extension ColumnViewColumnProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColumnViewColumn` instance.
    @inlinable var column_view_column_ptr: UnsafeMutablePointer<GtkColumnViewColumn>! { return ptr?.assumingMemoryBound(to: GtkColumnViewColumn.self) }

    /// Gets the column view that's currently displaying this column.
    /// 
    /// If `self` has not been added to a column view yet, `nil` is returned.
    @inlinable func getColumnView() -> ColumnViewRef! {
        let result = gtk_column_view_column_get_column_view(column_view_column_ptr)
        let rv = ColumnViewRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns whether this column should expand.
    @inlinable func getExpand() -> Bool {
        let result = gtk_column_view_column_get_expand(column_view_column_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the factory that's currently used to populate list items for
    /// this column.
    @inlinable func getFactory() -> ListItemFactoryRef! {
        let result = gtk_column_view_column_get_factory(column_view_column_ptr)
        let rv = ListItemFactoryRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the fixed width of the column.
    @inlinable func getFixedWidth() -> Int {
        let result = gtk_column_view_column_get_fixed_width(column_view_column_ptr)
        let rv = Int(result)
        return rv
    }

    /// Gets the menu model that is used to create the context menu
    /// for the column header.
    @inlinable func getHeaderMenu() -> GIO.MenuModelRef! {
        let result = gtk_column_view_column_get_header_menu(column_view_column_ptr)
        let rv = GIO.MenuModelRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns whether this column is resizable.
    @inlinable func getResizable() -> Bool {
        let result = gtk_column_view_column_get_resizable(column_view_column_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns the sorter that is associated with the column.
    @inlinable func getSorter() -> SorterRef! {
        let result = gtk_column_view_column_get_sorter(column_view_column_ptr)
        let rv = SorterRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns the title set with `gtk_column_view_column_set_title()`.
    @inlinable func getTitle() -> String! {
        let result = gtk_column_view_column_get_title(column_view_column_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Returns whether this column is visible.
    @inlinable func getVisible() -> Bool {
        let result = gtk_column_view_column_get_visible(column_view_column_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Sets the column to take available extra space.
    /// 
    /// The extra space is shared equally amongst all columns that
    /// have the expand set to `true`.
    @inlinable func set(expand: Bool) {
        
        gtk_column_view_column_set_expand(column_view_column_ptr, gboolean((expand) ? 1 : 0))
        
    }

    /// Sets the `GtkListItemFactory` to use for populating list items for this
    /// column.
    @inlinable func set(factory: ListItemFactoryRef? = nil) {
            
        gtk_column_view_column_set_factory(column_view_column_ptr, factory?.list_item_factory_ptr)
            
    }
    /// Sets the `GtkListItemFactory` to use for populating list items for this
    /// column.
    @inlinable func set<ListItemFactoryT: ListItemFactoryProtocol>(factory: ListItemFactoryT?) {
        
        gtk_column_view_column_set_factory(column_view_column_ptr, factory?.list_item_factory_ptr)
        
    }

    /// If `fixed_width` is not -1, sets the fixed width of `column`;
    /// otherwise unsets it.
    /// 
    /// Setting a fixed width overrides the automatically calculated
    /// width. Interactive resizing also sets the “fixed-width” property.
    @inlinable func set(fixedWidth: Int) {
        
        gtk_column_view_column_set_fixed_width(column_view_column_ptr, gint(fixedWidth))
        
    }

    /// Sets the menu model that is used to create the context menu
    /// for the column header.
    @inlinable func setHeader(menu: GIO.MenuModelRef? = nil) {
            
        gtk_column_view_column_set_header_menu(column_view_column_ptr, menu?.menu_model_ptr)
            
    }
    /// Sets the menu model that is used to create the context menu
    /// for the column header.
    @inlinable func setHeader<GioMenuModelT: GIO.MenuModelProtocol>(menu: GioMenuModelT?) {
        
        gtk_column_view_column_set_header_menu(column_view_column_ptr, menu?.menu_model_ptr)
        
    }

    /// Sets whether this column should be resizable by dragging.
    @inlinable func set(resizable: Bool) {
        
        gtk_column_view_column_set_resizable(column_view_column_ptr, gboolean((resizable) ? 1 : 0))
        
    }

    /// Associates a sorter with the column.
    /// 
    /// If `sorter` is `nil`, the column will not let users change
    /// the sorting by clicking on its header.
    /// 
    /// This sorter can be made active by clicking on the column
    /// header, or by calling [method`Gtk.ColumnView.sort_by_column`].
    /// 
    /// See [method`Gtk.ColumnView.get_sorter`] for the necessary steps
    /// for setting up customizable sorting for [class`Gtk.ColumnView`].
    @inlinable func set(sorter: SorterRef? = nil) {
            
        gtk_column_view_column_set_sorter(column_view_column_ptr, sorter?.sorter_ptr)
            
    }
    /// Associates a sorter with the column.
    /// 
    /// If `sorter` is `nil`, the column will not let users change
    /// the sorting by clicking on its header.
    /// 
    /// This sorter can be made active by clicking on the column
    /// header, or by calling [method`Gtk.ColumnView.sort_by_column`].
    /// 
    /// See [method`Gtk.ColumnView.get_sorter`] for the necessary steps
    /// for setting up customizable sorting for [class`Gtk.ColumnView`].
    @inlinable func set<SorterT: SorterProtocol>(sorter: SorterT?) {
        
        gtk_column_view_column_set_sorter(column_view_column_ptr, sorter?.sorter_ptr)
        
    }

    /// Sets the title of this column.
    /// 
    /// The title is displayed in the header of a `GtkColumnView`
    /// for this column and is therefore user-facing text that should
    /// be translated.
    @inlinable func set(title: UnsafePointer<CChar>? = nil) {
        
        gtk_column_view_column_set_title(column_view_column_ptr, title)
        
    }

    /// Sets whether this column should be visible in views.
    @inlinable func set(visible: Bool) {
        
        gtk_column_view_column_set_visible(column_view_column_ptr, gboolean((visible) ? 1 : 0))
        
    }
    /// Gets the column view that's currently displaying this column.
    /// 
    /// If `self` has not been added to a column view yet, `nil` is returned.
    @inlinable var columnView: ColumnViewRef! {
        /// Gets the column view that's currently displaying this column.
        /// 
        /// If `self` has not been added to a column view yet, `nil` is returned.
        get {
            let result = gtk_column_view_column_get_column_view(column_view_column_ptr)
        let rv = ColumnViewRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Column gets share of extra width allocated to the view.
    @inlinable var expand: Bool {
        /// Returns whether this column should expand.
        get {
            let result = gtk_column_view_column_get_expand(column_view_column_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets the column to take available extra space.
        /// 
        /// The extra space is shared equally amongst all columns that
        /// have the expand set to `true`.
        nonmutating set {
            gtk_column_view_column_set_expand(column_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Factory for populating list items.
    @inlinable var factory: ListItemFactoryRef! {
        /// Gets the factory that's currently used to populate list items for
        /// this column.
        get {
            let result = gtk_column_view_column_get_factory(column_view_column_ptr)
        let rv = ListItemFactoryRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets the `GtkListItemFactory` to use for populating list items for this
        /// column.
        nonmutating set {
            gtk_column_view_column_set_factory(column_view_column_ptr, UnsafeMutablePointer<GtkListItemFactory>(newValue?.list_item_factory_ptr))
        }
    }

    /// Gets the fixed width of the column.
    @inlinable var fixedWidth: Int {
        /// Gets the fixed width of the column.
        get {
            let result = gtk_column_view_column_get_fixed_width(column_view_column_ptr)
        let rv = Int(result)
            return rv
        }
        /// If `fixed_width` is not -1, sets the fixed width of `column`;
        /// otherwise unsets it.
        /// 
        /// Setting a fixed width overrides the automatically calculated
        /// width. Interactive resizing also sets the “fixed-width” property.
        nonmutating set {
            gtk_column_view_column_set_fixed_width(column_view_column_ptr, gint(newValue))
        }
    }

    /// Gets the menu model that is used to create the context menu
    /// for the column header.
    @inlinable var headerMenu: GIO.MenuModelRef! {
        /// Gets the menu model that is used to create the context menu
        /// for the column header.
        get {
            let result = gtk_column_view_column_get_header_menu(column_view_column_ptr)
        let rv = GIO.MenuModelRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets the menu model that is used to create the context menu
        /// for the column header.
        nonmutating set {
            gtk_column_view_column_set_header_menu(column_view_column_ptr, UnsafeMutablePointer<GMenuModel>(newValue?.menu_model_ptr))
        }
    }

    /// Whether this column is resizable.
    @inlinable var resizable: Bool {
        /// Returns whether this column is resizable.
        get {
            let result = gtk_column_view_column_get_resizable(column_view_column_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether this column should be resizable by dragging.
        nonmutating set {
            gtk_column_view_column_set_resizable(column_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Sorter for sorting items according to this column.
    @inlinable var sorter: SorterRef! {
        /// Returns the sorter that is associated with the column.
        get {
            let result = gtk_column_view_column_get_sorter(column_view_column_ptr)
        let rv = SorterRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Associates a sorter with the column.
        /// 
        /// If `sorter` is `nil`, the column will not let users change
        /// the sorting by clicking on its header.
        /// 
        /// This sorter can be made active by clicking on the column
        /// header, or by calling [method`Gtk.ColumnView.sort_by_column`].
        /// 
        /// See [method`Gtk.ColumnView.get_sorter`] for the necessary steps
        /// for setting up customizable sorting for [class`Gtk.ColumnView`].
        nonmutating set {
            gtk_column_view_column_set_sorter(column_view_column_ptr, UnsafeMutablePointer<GtkSorter>(newValue?.sorter_ptr))
        }
    }

    /// Title displayed in the header.
    @inlinable var title: String! {
        /// Returns the title set with `gtk_column_view_column_set_title()`.
        get {
            let result = gtk_column_view_column_get_title(column_view_column_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
        /// Sets the title of this column.
        /// 
        /// The title is displayed in the header of a `GtkColumnView`
        /// for this column and is therefore user-facing text that should
        /// be translated.
        nonmutating set {
            gtk_column_view_column_set_title(column_view_column_ptr, newValue)
        }
    }

    /// Whether this column is visible.
    @inlinable var visible: Bool {
        /// Returns whether this column is visible.
        get {
            let result = gtk_column_view_column_get_visible(column_view_column_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether this column should be visible in views.
        nonmutating set {
            gtk_column_view_column_set_visible(column_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - ComboBox Class

/// A `GtkComboBox` is a widget that allows the user to choose from a list of
/// valid choices.
/// 
/// ![An example GtkComboBox](combo-box.png)
/// 
/// The `GtkComboBox` displays the selected choice; when activated, the
/// `GtkComboBox` displays a popup which allows the user to make a new choice.
/// 
/// The `GtkComboBox` uses the model-view pattern; the list of valid choices
/// is specified in the form of a tree model, and the display of the choices
/// can be adapted to the data in the model by using cell renderers, as you
/// would in a tree view. This is possible since `GtkComboBox` implements the
/// [iface`Gtk.CellLayout`] interface. The tree model holding the valid
/// choices is not restricted to a flat list, it can be a real tree, and the
/// popup will reflect the tree structure.
/// 
/// To allow the user to enter values not in the model, the
/// [property`Gtk.ComboBox:has-entry`] property allows the `GtkComboBox` to
/// contain a [class`Gtk.Entry`]. This entry can be accessed by calling
/// [method`Gtk.ComboBox.get_child`] on the combo box.
/// 
/// For a simple list of textual choices, the model-view API of `GtkComboBox`
/// can be a bit overwhelming. In this case, [class`Gtk.ComboBoxText`] offers
/// a simple alternative. Both `GtkComboBox` and `GtkComboBoxText` can contain
/// an entry.
/// 
/// ## CSS nodes
/// 
/// ```
/// combobox
/// ├── box.linked
/// │   ╰── button.combo
/// │       ╰── box
/// │           ├── cellview
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A normal combobox contains a box with the .linked class, a button
/// with the .combo class and inside those buttons, there are a cellview and
/// an arrow.
/// 
/// ```
/// combobox
/// ├── box.linked
/// │   ├── entry.combo
/// │   ╰── button.combo
/// │       ╰── box
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A `GtkComboBox` with an entry has a single CSS node with name combobox.
/// It contains a box with the .linked class. That box contains an entry and
/// a button, both with the .combo class added. The button also contains another
/// node with name arrow.
/// 
/// # Accessibility
/// 
/// `GtkComboBox` uses the `GTK_ACCESSIBLE_ROLE_COMBO_BOX` role.
///
/// The `ComboBoxProtocol` protocol exposes the methods and properties of an underlying `GtkComboBox` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ComboBox`.
/// Alternatively, use `ComboBoxRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ComboBoxProtocol: WidgetProtocol, CellEditableProtocol, CellLayoutProtocol {
        /// Untyped pointer to the underlying `GtkComboBox` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkComboBox` instance.
    var combo_box_ptr: UnsafeMutablePointer<GtkComboBox>! { get }

    /// Required Initialiser for types conforming to `ComboBoxProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkComboBox` is a widget that allows the user to choose from a list of
/// valid choices.
/// 
/// ![An example GtkComboBox](combo-box.png)
/// 
/// The `GtkComboBox` displays the selected choice; when activated, the
/// `GtkComboBox` displays a popup which allows the user to make a new choice.
/// 
/// The `GtkComboBox` uses the model-view pattern; the list of valid choices
/// is specified in the form of a tree model, and the display of the choices
/// can be adapted to the data in the model by using cell renderers, as you
/// would in a tree view. This is possible since `GtkComboBox` implements the
/// [iface`Gtk.CellLayout`] interface. The tree model holding the valid
/// choices is not restricted to a flat list, it can be a real tree, and the
/// popup will reflect the tree structure.
/// 
/// To allow the user to enter values not in the model, the
/// [property`Gtk.ComboBox:has-entry`] property allows the `GtkComboBox` to
/// contain a [class`Gtk.Entry`]. This entry can be accessed by calling
/// [method`Gtk.ComboBox.get_child`] on the combo box.
/// 
/// For a simple list of textual choices, the model-view API of `GtkComboBox`
/// can be a bit overwhelming. In this case, [class`Gtk.ComboBoxText`] offers
/// a simple alternative. Both `GtkComboBox` and `GtkComboBoxText` can contain
/// an entry.
/// 
/// ## CSS nodes
/// 
/// ```
/// combobox
/// ├── box.linked
/// │   ╰── button.combo
/// │       ╰── box
/// │           ├── cellview
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A normal combobox contains a box with the .linked class, a button
/// with the .combo class and inside those buttons, there are a cellview and
/// an arrow.
/// 
/// ```
/// combobox
/// ├── box.linked
/// │   ├── entry.combo
/// │   ╰── button.combo
/// │       ╰── box
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A `GtkComboBox` with an entry has a single CSS node with name combobox.
/// It contains a box with the .linked class. That box contains an entry and
/// a button, both with the .combo class added. The button also contains another
/// node with name arrow.
/// 
/// # Accessibility
/// 
/// `GtkComboBox` uses the `GTK_ACCESSIBLE_ROLE_COMBO_BOX` role.
///
/// The `ComboBoxRef` type acts as a lightweight Swift reference to an underlying `GtkComboBox` instance.
/// It exposes methods that can operate on this data type through `ComboBoxProtocol` conformance.
/// Use `ComboBoxRef` only as an `unowned` reference to an existing `GtkComboBox` instance.
///
public struct ComboBoxRef: ComboBoxProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkComboBox` instance.
    /// For type-safe access, use the generated, typed pointer `combo_box_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ComboBoxRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkComboBox>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkComboBox>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkComboBox>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkComboBox>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ComboBoxProtocol`
    @inlinable init<T: ComboBoxProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ComboBoxProtocol>(_ other: T) -> ComboBoxRef { ComboBoxRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new empty `GtkComboBox`.
    @inlinable init() {
            let result = gtk_combo_box_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkComboBox` with a model.
    @inlinable init<TreeModelT: TreeModelProtocol>(model: TreeModelT) {
            let result = gtk_combo_box_new_with_model(model.tree_model_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new empty `GtkComboBox` with an entry and a model.
    /// 
    /// See also [ctor`Gtk.ComboBox.new_with_entry`].
    @inlinable init<TreeModelT: TreeModelProtocol>(modelAndEntry model: TreeModelT) {
            let result = gtk_combo_box_new_with_model_and_entry(model.tree_model_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new empty `GtkComboBox` with an entry.
    /// 
    /// In order to use a combo box with entry, you need to tell it
    /// which column of the model contains the text for the entry
    /// by calling [method`Gtk.ComboBox.set_entry_text_column`].
    @inlinable static func newWithEntry() -> WidgetRef! {
            let result = gtk_combo_box_new_with_entry()
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Creates a new `GtkComboBox` with a model.
    @inlinable static func newWith<TreeModelT: TreeModelProtocol>(model: TreeModelT) -> WidgetRef! {
            let result = gtk_combo_box_new_with_model(model.tree_model_ptr)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Creates a new empty `GtkComboBox` with an entry and a model.
    /// 
    /// See also [ctor`Gtk.ComboBox.new_with_entry`].
    @inlinable static func newWith<TreeModelT: TreeModelProtocol>(modelAndEntry model: TreeModelT) -> WidgetRef! {
            let result = gtk_combo_box_new_with_model_and_entry(model.tree_model_ptr)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }
}

/// A `GtkComboBox` is a widget that allows the user to choose from a list of
/// valid choices.
/// 
/// ![An example GtkComboBox](combo-box.png)
/// 
/// The `GtkComboBox` displays the selected choice; when activated, the
/// `GtkComboBox` displays a popup which allows the user to make a new choice.
/// 
/// The `GtkComboBox` uses the model-view pattern; the list of valid choices
/// is specified in the form of a tree model, and the display of the choices
/// can be adapted to the data in the model by using cell renderers, as you
/// would in a tree view. This is possible since `GtkComboBox` implements the
/// [iface`Gtk.CellLayout`] interface. The tree model holding the valid
/// choices is not restricted to a flat list, it can be a real tree, and the
/// popup will reflect the tree structure.
/// 
/// To allow the user to enter values not in the model, the
/// [property`Gtk.ComboBox:has-entry`] property allows the `GtkComboBox` to
/// contain a [class`Gtk.Entry`]. This entry can be accessed by calling
/// [method`Gtk.ComboBox.get_child`] on the combo box.
/// 
/// For a simple list of textual choices, the model-view API of `GtkComboBox`
/// can be a bit overwhelming. In this case, [class`Gtk.ComboBoxText`] offers
/// a simple alternative. Both `GtkComboBox` and `GtkComboBoxText` can contain
/// an entry.
/// 
/// ## CSS nodes
/// 
/// ```
/// combobox
/// ├── box.linked
/// │   ╰── button.combo
/// │       ╰── box
/// │           ├── cellview
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A normal combobox contains a box with the .linked class, a button
/// with the .combo class and inside those buttons, there are a cellview and
/// an arrow.
/// 
/// ```
/// combobox
/// ├── box.linked
/// │   ├── entry.combo
/// │   ╰── button.combo
/// │       ╰── box
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A `GtkComboBox` with an entry has a single CSS node with name combobox.
/// It contains a box with the .linked class. That box contains an entry and
/// a button, both with the .combo class added. The button also contains another
/// node with name arrow.
/// 
/// # Accessibility
/// 
/// `GtkComboBox` uses the `GTK_ACCESSIBLE_ROLE_COMBO_BOX` role.
///
/// The `ComboBox` type acts as a reference-counted owner of an underlying `GtkComboBox` instance.
/// It provides the methods that can operate on this data type through `ComboBoxProtocol` conformance.
/// Use `ComboBox` as a strong reference or owner of a `GtkComboBox` instance.
///
open class ComboBox: Widget, ComboBoxProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkComboBox>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkComboBox>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkComboBox>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkComboBox>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkComboBox`.
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkComboBox>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ComboBoxProtocol`
    /// Will retain `GtkComboBox`.
    /// - Parameter other: an instance of a related type that implements `ComboBoxProtocol`
    @inlinable public init<T: ComboBoxProtocol>(comboBox other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new empty `GtkComboBox`.
    @inlinable public init() {
            let result = gtk_combo_box_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkComboBox` with a model.
    @inlinable public init<TreeModelT: TreeModelProtocol>(model: TreeModelT) {
            let result = gtk_combo_box_new_with_model(model.tree_model_ptr)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new empty `GtkComboBox` with an entry and a model.
    /// 
    /// See also [ctor`Gtk.ComboBox.new_with_entry`].
    @inlinable public init<TreeModelT: TreeModelProtocol>(modelAndEntry model: TreeModelT) {
            let result = gtk_combo_box_new_with_model_and_entry(model.tree_model_ptr)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new empty `GtkComboBox` with an entry.
    /// 
    /// In order to use a combo box with entry, you need to tell it
    /// which column of the model contains the text for the entry
    /// by calling [method`Gtk.ComboBox.set_entry_text_column`].
    @inlinable public static func newWithEntry() -> Widget! {
            let result = gtk_combo_box_new_with_entry()
        guard let rv = Widget(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

    /// Creates a new `GtkComboBox` with a model.
    @inlinable public static func newWith<TreeModelT: TreeModelProtocol>(model: TreeModelT) -> Widget! {
            let result = gtk_combo_box_new_with_model(model.tree_model_ptr)
        guard let rv = Widget(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

    /// Creates a new empty `GtkComboBox` with an entry and a model.
    /// 
    /// See also [ctor`Gtk.ComboBox.new_with_entry`].
    @inlinable public static func newWith<TreeModelT: TreeModelProtocol>(modelAndEntry model: TreeModelT) -> Widget! {
            let result = gtk_combo_box_new_with_model_and_entry(model.tree_model_ptr)
        guard let rv = Widget(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

}

public enum ComboBoxPropertyName: String, PropertyNameProtocol {
    /// The item which is currently active.
    /// 
    /// If the model is a non-flat treemodel, and the active item is not an
    /// immediate child of the root of the tree, this property has the value
    /// `gtk_tree_path_get_indices (path)[0]`, where `path` is the
    /// [struct`Gtk.TreePath`] of the active item.
    case active = "active"
    /// The value of the ID column of the active row.
    case activeId = "active-id"
    /// Whether the dropdown button is sensitive when
    /// the model is empty.
    case buttonSensitivity = "button-sensitivity"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// The child widget.
    case child = "child"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// The model column to associate with strings from the entry.
    /// 
    /// This is property only relevant if the combo was created with
    /// [property`Gtk.ComboBox:has-entry`] is `true`.
    case entryTextColumn = "entry-text-column"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the combo box has an entry.
    case hasEntry = "has-entry"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// The `has-frame` property controls whether a frame is drawn around the entry.
    case hasFrame = "has-frame"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The model column that provides string IDs for the values
    /// in the model, if != -1.
    case idColumn = "id-column"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The model from which the combo box takes its values.
    case model = "model"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the popup's width should be a fixed width matching the
    /// allocated width of the combo box.
    case popupFixedWidth = "popup-fixed-width"
    /// Whether the combo boxes dropdown is popped up.
    /// 
    /// Note that this property is mainly useful, because
    /// it allows you to connect to notify`popup-shown`.
    case popupShown = "popup-shown"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension ComboBoxProtocol {
    /// Bind a `ComboBoxPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ComboBoxPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ComboBox property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ComboBoxPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ComboBox property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ComboBoxPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ComboBoxSignalName: String, SignalNameProtocol {
    /// Emitted to when the combo box is activated.
    /// 
    /// The ``activate`` signal on `GtkComboBox` is an action signal and
    /// emitting it causes the combo box to pop up its dropdown.
    case activate = "activate"
    /// Emitted when the active item is changed.
    /// 
    /// The can be due to the user selecting a different item from the list,
    /// or due to a call to [method`Gtk.ComboBox.set_active_iter`]. It will
    /// also be emitted while typing into the entry of a combo box with an entry.
    case changed = "changed"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted to allow changing how the text in a combo box's entry is displayed.
    /// 
    /// See [property`Gtk.ComboBox:has-entry`].
    /// 
    /// Connect a signal handler which returns an allocated string representing
    /// `path`. That string will then be used to set the text in the combo box's
    /// entry. The default signal handler uses the text from the
    /// [property`Gtk.ComboBox:entry-text-column`] model column.
    /// 
    /// Here's an example signal handler which fetches data from the model and
    /// displays it in the entry.
    /// ```c
    /// static char *
    /// format_entry_text_callback (GtkComboBox *combo,
    ///                             const char *path,
    ///                             gpointer     user_data)
    /// {
    ///   GtkTreeIter iter;
    ///   GtkTreeModel model;
    ///   double       value;
    /// 
    ///   model = gtk_combo_box_get_model (combo);
    /// 
    ///   gtk_tree_model_get_iter_from_string (model, &iter, path);
    ///   gtk_tree_model_get (model, &iter,
    ///                       THE_DOUBLE_VALUE_COLUMN, &value,
    ///                       -1);
    /// 
    ///   return g_strdup_printf ("`g`", value);
    /// }
    /// ```
    case formatEntryText = "format-entry-text"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted to move the active selection.
    /// 
    /// This is an [keybinding signal](class.SignalAction.html).
    case moveActive = "move-active"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted to popdown the combo box list.
    /// 
    /// This is an [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are Alt+Up and Escape.
    case popdown = "popdown"
    /// Emitted to popup the combo box list.
    /// 
    /// This is an [keybinding signal](class.SignalAction.html).
    /// 
    /// The default binding for this signal is Alt+Down.
    case popup = "popup"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// The item which is currently active.
    /// 
    /// If the model is a non-flat treemodel, and the active item is not an
    /// immediate child of the root of the tree, this property has the value
    /// `gtk_tree_path_get_indices (path)[0]`, where `path` is the
    /// [struct`Gtk.TreePath`] of the active item.
    case notifyActive = "notify::active"
    /// The value of the ID column of the active row.
    case notifyActiveId = "notify::active-id"
    /// Whether the dropdown button is sensitive when
    /// the model is empty.
    case notifyButtonSensitivity = "notify::button-sensitivity"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// The child widget.
    case notifyChild = "notify::child"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// The model column to associate with strings from the entry.
    /// 
    /// This is property only relevant if the combo was created with
    /// [property`Gtk.ComboBox:has-entry`] is `true`.
    case notifyEntryTextColumn = "notify::entry-text-column"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the combo box has an entry.
    case notifyHasEntry = "notify::has-entry"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// The `has-frame` property controls whether a frame is drawn around the entry.
    case notifyHasFrame = "notify::has-frame"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The model column that provides string IDs for the values
    /// in the model, if != -1.
    case notifyIdColumn = "notify::id-column"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The model from which the combo box takes its values.
    case notifyModel = "notify::model"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the popup's width should be a fixed width matching the
    /// allocated width of the combo box.
    case notifyPopupFixedWidth = "notify::popup-fixed-width"
    /// Whether the combo boxes dropdown is popped up.
    /// 
    /// Note that this property is mainly useful, because
    /// it allows you to connect to notify`popup-shown`.
    case notifyPopupShown = "notify::popup-shown"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: ComboBox signals
public extension ComboBoxProtocol {
    /// Connect a Swift signal handler to the given, typed `ComboBoxSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ComboBoxSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `ComboBoxSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ComboBoxSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted to when the combo box is activated.
    /// 
    /// The ``activate`` signal on `GtkComboBox` is an action signal and
    /// emitting it causes the combo box to pop up its dropdown.
    /// - Note: This represents the underlying `activate` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `activate` signal is emitted
    @discardableResult @inlinable func onActivate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ComboBoxRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ComboBoxRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .activate,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `activate` signal for using the `connect(signal:)` methods
    static var activateSignal: ComboBoxSignalName { .activate }
    
    /// Emitted when the active item is changed.
    /// 
    /// The can be due to the user selecting a different item from the list,
    /// or due to a call to [method`Gtk.ComboBox.set_active_iter`]. It will
    /// also be emitted while typing into the entry of a combo box with an entry.
    /// - Note: This represents the underlying `changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `changed` signal is emitted
    @discardableResult @inlinable func onChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ComboBoxRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ComboBoxRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .changed,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `changed` signal for using the `connect(signal:)` methods
    static var changedSignal: ComboBoxSignalName { .changed }
    
    /// Emitted to allow changing how the text in a combo box's entry is displayed.
    /// 
    /// See [property`Gtk.ComboBox:has-entry`].
    /// 
    /// Connect a signal handler which returns an allocated string representing
    /// `path`. That string will then be used to set the text in the combo box's
    /// entry. The default signal handler uses the text from the
    /// [property`Gtk.ComboBox:entry-text-column`] model column.
    /// 
    /// Here's an example signal handler which fetches data from the model and
    /// displays it in the entry.
    /// ```c
    /// static char *
    /// format_entry_text_callback (GtkComboBox *combo,
    ///                             const char *path,
    ///                             gpointer     user_data)
    /// {
    ///   GtkTreeIter iter;
    ///   GtkTreeModel model;
    ///   double       value;
    /// 
    ///   model = gtk_combo_box_get_model (combo);
    /// 
    ///   gtk_tree_model_get_iter_from_string (model, &iter, path);
    ///   gtk_tree_model_get (model, &iter,
    ///                       THE_DOUBLE_VALUE_COLUMN, &value,
    ///                       -1);
    /// 
    ///   return g_strdup_printf ("`g`", value);
    /// }
    /// ```
    /// - Note: This represents the underlying `format-entry-text` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter path: the [struct`Gtk.TreePath`] string from the combo box's current model   to format text for
    /// - Parameter handler: a newly allocated string representing `path`   for the current `GtkComboBox` model.
    /// Run the given callback whenever the `formatEntryText` signal is emitted
    @discardableResult @inlinable func onFormatEntryText(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ path: String) -> String ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ComboBoxRef, String), String>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> UnsafeMutablePointer<gchar>? = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call((ComboBoxRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!))
                let length = output.utf8CString.count
                let buffer = UnsafeMutablePointer<gchar>.allocate(capacity: length)
                buffer.initialize(from: output, count: length)
                return buffer
        }
        return connect(
            signal: .formatEntryText,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `format-entry-text` signal for using the `connect(signal:)` methods
    static var formatEntryTextSignal: ComboBoxSignalName { .formatEntryText }
    
    /// Emitted to move the active selection.
    /// 
    /// This is an [keybinding signal](class.SignalAction.html).
    /// - Note: This represents the underlying `move-active` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter scrollType: a `GtkScrollType`
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `moveActive` signal is emitted
    @discardableResult @inlinable func onMoveActive(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ scrollType: ScrollType) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ComboBoxRef, ScrollType), Void>
        let cCallback: @convention(c) (gpointer, UInt32, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ComboBoxRef(raw: unownedSelf), ScrollType(arg1)))
            return output
        }
        return connect(
            signal: .moveActive,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `move-active` signal for using the `connect(signal:)` methods
    static var moveActiveSignal: ComboBoxSignalName { .moveActive }
    
    /// Emitted to popdown the combo box list.
    /// 
    /// This is an [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are Alt+Up and Escape.
    /// - Note: This represents the underlying `popdown` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `popdown` signal is emitted
    @discardableResult @inlinable func onPopdown(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ComboBoxRef), Bool>
        let cCallback: @convention(c) (gpointer, gpointer) -> gboolean = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call((ComboBoxRef(raw: unownedSelf)))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .popdown,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `popdown` signal for using the `connect(signal:)` methods
    static var popdownSignal: ComboBoxSignalName { .popdown }
    
    /// Emitted to popup the combo box list.
    /// 
    /// This is an [keybinding signal](class.SignalAction.html).
    /// 
    /// The default binding for this signal is Alt+Down.
    /// - Note: This represents the underlying `popup` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `popup` signal is emitted
    @discardableResult @inlinable func onPopup(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ComboBoxRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ComboBoxRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .popup,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `popup` signal for using the `connect(signal:)` methods
    static var popupSignal: ComboBoxSignalName { .popup }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::active` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActive` signal is emitted
    @discardableResult @inlinable func onNotifyActive(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ComboBoxRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ComboBoxRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyActive,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::active` signal for using the `connect(signal:)` methods
    static var notifyActiveSignal: ComboBoxSignalName { .notifyActive }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::active-id` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActiveId` signal is emitted
    @discardableResult @inlinable func onNotifyActiveId(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ComboBoxRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ComboBoxRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyActiveId,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::active-id` signal for using the `connect(signal:)` methods
    static var notifyActiveIdSignal: ComboBoxSignalName { .notifyActiveId }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::button-sensitivity` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyButtonSensitivity` signal is emitted
    @discardableResult @inlinable func onNotifyButtonSensitivity(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ComboBoxRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ComboBoxRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyButtonSensitivity,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::button-sensitivity` signal for using the `connect(signal:)` methods
    static var notifyButtonSensitivitySignal: ComboBoxSignalName { .notifyButtonSensitivity }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::child` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyChild` signal is emitted
    @discardableResult @inlinable func onNotifyChild(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ComboBoxRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ComboBoxRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyChild,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::child` signal for using the `connect(signal:)` methods
    static var notifyChildSignal: ComboBoxSignalName { .notifyChild }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::entry-text-column` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEntryTextColumn` signal is emitted
    @discardableResult @inlinable func onNotifyEntryTextColumn(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ComboBoxRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ComboBoxRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyEntryTextColumn,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::entry-text-column` signal for using the `connect(signal:)` methods
    static var notifyEntryTextColumnSignal: ComboBoxSignalName { .notifyEntryTextColumn }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::has-entry` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHasEntry` signal is emitted
    @discardableResult @inlinable func onNotifyHasEntry(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ComboBoxRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ComboBoxRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyHasEntry,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::has-entry` signal for using the `connect(signal:)` methods
    static var notifyHasEntrySignal: ComboBoxSignalName { .notifyHasEntry }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::has-frame` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHasFrame` signal is emitted
    @discardableResult @inlinable func onNotifyHasFrame(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ComboBoxRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ComboBoxRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyHasFrame,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::has-frame` signal for using the `connect(signal:)` methods
    static var notifyHasFrameSignal: ComboBoxSignalName { .notifyHasFrame }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::id-column` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyIdColumn` signal is emitted
    @discardableResult @inlinable func onNotifyIdColumn(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ComboBoxRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ComboBoxRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyIdColumn,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::id-column` signal for using the `connect(signal:)` methods
    static var notifyIdColumnSignal: ComboBoxSignalName { .notifyIdColumn }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::model` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyModel` signal is emitted
    @discardableResult @inlinable func onNotifyModel(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ComboBoxRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ComboBoxRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyModel,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::model` signal for using the `connect(signal:)` methods
    static var notifyModelSignal: ComboBoxSignalName { .notifyModel }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::popup-fixed-width` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPopupFixedWidth` signal is emitted
    @discardableResult @inlinable func onNotifyPopupFixedWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ComboBoxRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ComboBoxRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyPopupFixedWidth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::popup-fixed-width` signal for using the `connect(signal:)` methods
    static var notifyPopupFixedWidthSignal: ComboBoxSignalName { .notifyPopupFixedWidth }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::popup-shown` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPopupShown` signal is emitted
    @discardableResult @inlinable func onNotifyPopupShown(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ComboBoxRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ComboBoxRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyPopupShown,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::popup-shown` signal for using the `connect(signal:)` methods
    static var notifyPopupShownSignal: ComboBoxSignalName { .notifyPopupShown }
    
}

// MARK: ComboBox Class: ComboBoxProtocol extension (methods and fields)
public extension ComboBoxProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkComboBox` instance.
    @inlinable var combo_box_ptr: UnsafeMutablePointer<GtkComboBox>! { return ptr?.assumingMemoryBound(to: GtkComboBox.self) }

    /// Returns the index of the currently active item.
    /// 
    /// If the model is a non-flat treemodel, and the active item is not
    /// an immediate child of the root of the tree, this function returns
    /// `gtk_tree_path_get_indices (path)[0]`, where `path` is the
    /// [struct`Gtk.TreePath`] of the active item.
    @inlinable func getActive() -> Int {
        let result = gtk_combo_box_get_active(combo_box_ptr)
        let rv = Int(result)
        return rv
    }

    /// Returns the ID of the active row of `combo_box`.
    /// 
    /// This value is taken from the active row and the column specified
    /// by the [property`Gtk.ComboBox:id-column`] property of `combo_box`
    /// (see [method`Gtk.ComboBox.set_id_column`]).
    /// 
    /// The returned value is an interned string which means that you can
    /// compare the pointer by value to other interned strings and that you
    /// must not free it.
    /// 
    /// If the [property`Gtk.ComboBox:id-column`] property of `combo_box` is
    /// not set, or if no row is active, or if the active row has a `nil`
    /// ID value, then `nil` is returned.
    @inlinable func getActiveId() -> String! {
        let result = gtk_combo_box_get_active_id(combo_box_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Sets `iter` to point to the currently active item.
    /// 
    /// If no item is active, `iter` is left unchanged.
    @inlinable func getActive<TreeIterT: TreeIterProtocol>(iter: TreeIterT) -> Bool {
        let result = gtk_combo_box_get_active_iter(combo_box_ptr, iter.tree_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns whether the combo box sets the dropdown button
    /// sensitive or not when there are no items in the model.
    @inlinable func getButtonSensitivity() -> GtkSensitivityType {
        let result = gtk_combo_box_get_button_sensitivity(combo_box_ptr)
        let rv = result
        return rv
    }

    /// Gets the child widget of `combo_box`.
    @inlinable func getChild() -> WidgetRef! {
        let result = gtk_combo_box_get_child(combo_box_ptr)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Returns the column which `combo_box` is using to get the strings
    /// from to display in the internal entry.
    @inlinable func getEntryTextColumn() -> Int {
        let result = gtk_combo_box_get_entry_text_column(combo_box_ptr)
        let rv = Int(result)
        return rv
    }

    /// Returns whether the combo box has an entry.
    @inlinable func getHasEntry() -> Bool {
        let result = gtk_combo_box_get_has_entry(combo_box_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns the column which `combo_box` is using to get string IDs
    /// for values from.
    @inlinable func getIdColumn() -> Int {
        let result = gtk_combo_box_get_id_column(combo_box_ptr)
        let rv = Int(result)
        return rv
    }

    /// Returns the `GtkTreeModel` of `combo_box`.
    @inlinable func getModel() -> TreeModelRef! {
        let result = gtk_combo_box_get_model(combo_box_ptr)
        let rv = TreeModelRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets whether the popup uses a fixed width.
    @inlinable func getPopupFixedWidth() -> Bool {
        let result = gtk_combo_box_get_popup_fixed_width(combo_box_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns the current row separator function.
    @inlinable func getRowSeparatorFunc() -> GtkTreeViewRowSeparatorFunc! {
        let result = gtk_combo_box_get_row_separator_func(combo_box_ptr)
        let rv = result
        return rv
    }

    /// Hides the menu or dropdown list of `combo_box`.
    /// 
    /// This function is mostly intended for use by accessibility technologies;
    /// applications should have little use for it.
    @inlinable func popdown() {
        
        gtk_combo_box_popdown(combo_box_ptr)
        
    }

    /// Pops up the menu or dropdown list of `combo_box`.
    /// 
    /// This function is mostly intended for use by accessibility technologies;
    /// applications should have little use for it.
    /// 
    /// Before calling this, `combo_box` must be mapped, or nothing will happen.
    @inlinable func popup() {
        
        gtk_combo_box_popup(combo_box_ptr)
        
    }

    /// Pops up the menu of `combo_box`.
    /// 
    /// Note that currently this does not do anything with the device, as it was
    /// previously only used for list-mode combo boxes, and those were removed
    /// in GTK 4. However, it is retained in case similar functionality is added
    /// back later.
    @inlinable func popupFor<GdkDeviceT: Gdk.DeviceProtocol>(device: GdkDeviceT) {
        
        gtk_combo_box_popup_for_device(combo_box_ptr, device.device_ptr)
        
    }

    /// Sets the active item of `combo_box` to be the item at `index`.
    @inlinable func setActive(index: Int) {
        
        gtk_combo_box_set_active(combo_box_ptr, gint(index))
        
    }

    /// Changes the active row of `combo_box` to the one that has an ID equal to
    /// `active_id`.
    /// 
    /// If `active_id` is `nil`, the active row is unset. Rows having
    /// a `nil` ID string cannot be made active by this function.
    /// 
    /// If the [property`Gtk.ComboBox:id-column`] property of `combo_box` is
    /// unset or if no row has the given ID then the function does nothing
    /// and returns `false`.
    @inlinable func set(activeId: UnsafePointer<CChar>? = nil) -> Bool {
        let result = gtk_combo_box_set_active_id(combo_box_ptr, activeId)
        let rv = ((result) != 0)
        return rv
    }

    /// Sets the current active item to be the one referenced by `iter`.
    /// 
    /// If `iter` is `nil`, the active item is unset.
    @inlinable func setActive(iter: TreeIterRef? = nil) {
            
        gtk_combo_box_set_active_iter(combo_box_ptr, iter?.tree_iter_ptr)
            
    }
    /// Sets the current active item to be the one referenced by `iter`.
    /// 
    /// If `iter` is `nil`, the active item is unset.
    @inlinable func setActive<TreeIterT: TreeIterProtocol>(iter: TreeIterT?) {
        
        gtk_combo_box_set_active_iter(combo_box_ptr, iter?.tree_iter_ptr)
        
    }

    /// Sets whether the dropdown button of the combo box should update
    /// its sensitivity depending on the model contents.
    @inlinable func setButton(sensitivity: GtkSensitivityType) {
        
        gtk_combo_box_set_button_sensitivity(combo_box_ptr, sensitivity)
        
    }

    /// Sets the child widget of `combo_box`.
    @inlinable func set(child: WidgetRef? = nil) {
            
        gtk_combo_box_set_child(combo_box_ptr, child?.widget_ptr)
            
    }
    /// Sets the child widget of `combo_box`.
    @inlinable func set<WidgetT: WidgetProtocol>(child: WidgetT?) {
        
        gtk_combo_box_set_child(combo_box_ptr, child?.widget_ptr)
        
    }

    /// Sets the model column which `combo_box` should use to get strings
    /// from to be `text_column`.
    /// 
    /// For this column no separate
    /// [class`Gtk.CellRenderer`] is needed.
    /// 
    /// The column `text_column` in the model of `combo_box` must be of
    /// type `G_TYPE_STRING`.
    /// 
    /// This is only relevant if `combo_box` has been created with
    /// [property`Gtk.ComboBox:has-entry`] as `true`.
    @inlinable func setEntry(textColumn: Int) {
        
        gtk_combo_box_set_entry_text_column(combo_box_ptr, gint(textColumn))
        
    }

    /// Sets the model column which `combo_box` should use to get string IDs
    /// for values from.
    /// 
    /// The column `id_column` in the model of `combo_box` must be of type
    /// `G_TYPE_STRING`.
    @inlinable func set(idColumn: Int) {
        
        gtk_combo_box_set_id_column(combo_box_ptr, gint(idColumn))
        
    }

    /// Sets the model used by `combo_box` to be `model`.
    /// 
    /// Will unset a previously set model (if applicable). If model is `nil`,
    /// then it will unset the model.
    /// 
    /// Note that this function does not clear the cell renderers, you have to
    /// call [method`Gtk.CellLayout.clear`] yourself if you need to set up different
    /// cell renderers for the new model.
    @inlinable func set(model: TreeModelRef? = nil) {
            
        gtk_combo_box_set_model(combo_box_ptr, model?.tree_model_ptr)
            
    }
    /// Sets the model used by `combo_box` to be `model`.
    /// 
    /// Will unset a previously set model (if applicable). If model is `nil`,
    /// then it will unset the model.
    /// 
    /// Note that this function does not clear the cell renderers, you have to
    /// call [method`Gtk.CellLayout.clear`] yourself if you need to set up different
    /// cell renderers for the new model.
    @inlinable func set<TreeModelT: TreeModelProtocol>(model: TreeModelT?) {
        
        gtk_combo_box_set_model(combo_box_ptr, model?.tree_model_ptr)
        
    }

    /// Specifies whether the popup’s width should be a fixed width.
    /// 
    /// If `fixed` is `true`, the popup's width is set to match the
    /// allocated width of the combo box.
    @inlinable func setPopupFixedWidth(fixed: Bool) {
        
        gtk_combo_box_set_popup_fixed_width(combo_box_ptr, gboolean((fixed) ? 1 : 0))
        
    }

    /// Sets the row separator function, which is used to determine
    /// whether a row should be drawn as a separator.
    /// 
    /// If the row separator function is `nil`, no separators are drawn.
    /// This is the default value.
    @inlinable func setRowSeparatorFunc(`func`: GtkTreeViewRowSeparatorFunc? = nil, data: gpointer? = nil, destroy: GDestroyNotify? = nil) {
        
        gtk_combo_box_set_row_separator_func(combo_box_ptr, `func`, data, destroy)
        
    }
    /// The item which is currently active.
    /// 
    /// If the model is a non-flat treemodel, and the active item is not an
    /// immediate child of the root of the tree, this property has the value
    /// `gtk_tree_path_get_indices (path)[0]`, where `path` is the
    /// [struct`Gtk.TreePath`] of the active item.
    @inlinable var active: Int {
        /// Returns the index of the currently active item.
        /// 
        /// If the model is a non-flat treemodel, and the active item is not
        /// an immediate child of the root of the tree, this function returns
        /// `gtk_tree_path_get_indices (path)[0]`, where `path` is the
        /// [struct`Gtk.TreePath`] of the active item.
        get {
            let result = gtk_combo_box_get_active(combo_box_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the active item of `combo_box` to be the item at `index`.
        nonmutating set {
            gtk_combo_box_set_active(combo_box_ptr, gint(newValue))
        }
    }

    /// Returns the ID of the active row of `combo_box`.
    /// 
    /// This value is taken from the active row and the column specified
    /// by the [property`Gtk.ComboBox:id-column`] property of `combo_box`
    /// (see [method`Gtk.ComboBox.set_id_column`]).
    /// 
    /// The returned value is an interned string which means that you can
    /// compare the pointer by value to other interned strings and that you
    /// must not free it.
    /// 
    /// If the [property`Gtk.ComboBox:id-column`] property of `combo_box` is
    /// not set, or if no row is active, or if the active row has a `nil`
    /// ID value, then `nil` is returned.
    @inlinable var activeId: String! {
        /// Returns the ID of the active row of `combo_box`.
        /// 
        /// This value is taken from the active row and the column specified
        /// by the [property`Gtk.ComboBox:id-column`] property of `combo_box`
        /// (see [method`Gtk.ComboBox.set_id_column`]).
        /// 
        /// The returned value is an interned string which means that you can
        /// compare the pointer by value to other interned strings and that you
        /// must not free it.
        /// 
        /// If the [property`Gtk.ComboBox:id-column`] property of `combo_box` is
        /// not set, or if no row is active, or if the active row has a `nil`
        /// ID value, then `nil` is returned.
        get {
            let result = gtk_combo_box_get_active_id(combo_box_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
        /// Changes the active row of `combo_box` to the one that has an ID equal to
        /// `active_id`.
        /// 
        /// If `active_id` is `nil`, the active row is unset. Rows having
        /// a `nil` ID string cannot be made active by this function.
        /// 
        /// If the [property`Gtk.ComboBox:id-column`] property of `combo_box` is
        /// unset or if no row has the given ID then the function does nothing
        /// and returns `false`.
        nonmutating set {
            _ = gtk_combo_box_set_active_id(combo_box_ptr, newValue)
        }
    }

    /// Returns whether the combo box sets the dropdown button
    /// sensitive or not when there are no items in the model.
    @inlinable var buttonSensitivity: GtkSensitivityType {
        /// Returns whether the combo box sets the dropdown button
        /// sensitive or not when there are no items in the model.
        get {
            let result = gtk_combo_box_get_button_sensitivity(combo_box_ptr)
        let rv = result
            return rv
        }
        /// Sets whether the dropdown button of the combo box should update
        /// its sensitivity depending on the model contents.
        nonmutating set {
            gtk_combo_box_set_button_sensitivity(combo_box_ptr, newValue)
        }
    }

    /// The child widget.
    @inlinable var child: WidgetRef! {
        /// Gets the child widget of `combo_box`.
        get {
            let result = gtk_combo_box_get_child(combo_box_ptr)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
            return rv
        }
        /// Sets the child widget of `combo_box`.
        nonmutating set {
            gtk_combo_box_set_child(combo_box_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Returns the column which `combo_box` is using to get the strings
    /// from to display in the internal entry.
    @inlinable var entryTextColumn: Int {
        /// Returns the column which `combo_box` is using to get the strings
        /// from to display in the internal entry.
        get {
            let result = gtk_combo_box_get_entry_text_column(combo_box_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the model column which `combo_box` should use to get strings
        /// from to be `text_column`.
        /// 
        /// For this column no separate
        /// [class`Gtk.CellRenderer`] is needed.
        /// 
        /// The column `text_column` in the model of `combo_box` must be of
        /// type `G_TYPE_STRING`.
        /// 
        /// This is only relevant if `combo_box` has been created with
        /// [property`Gtk.ComboBox:has-entry`] as `true`.
        nonmutating set {
            gtk_combo_box_set_entry_text_column(combo_box_ptr, gint(newValue))
        }
    }

    /// Returns whether the combo box has an entry.
    @inlinable var hasEntry: Bool {
        /// Returns whether the combo box has an entry.
        get {
            let result = gtk_combo_box_get_has_entry(combo_box_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// Returns the column which `combo_box` is using to get string IDs
    /// for values from.
    @inlinable var idColumn: Int {
        /// Returns the column which `combo_box` is using to get string IDs
        /// for values from.
        get {
            let result = gtk_combo_box_get_id_column(combo_box_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the model column which `combo_box` should use to get string IDs
        /// for values from.
        /// 
        /// The column `id_column` in the model of `combo_box` must be of type
        /// `G_TYPE_STRING`.
        nonmutating set {
            gtk_combo_box_set_id_column(combo_box_ptr, gint(newValue))
        }
    }

    /// The model from which the combo box takes its values.
    @inlinable var model: TreeModelRef! {
        /// Returns the `GtkTreeModel` of `combo_box`.
        get {
            let result = gtk_combo_box_get_model(combo_box_ptr)
        let rv = TreeModelRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets the model used by `combo_box` to be `model`.
        /// 
        /// Will unset a previously set model (if applicable). If model is `nil`,
        /// then it will unset the model.
        /// 
        /// Note that this function does not clear the cell renderers, you have to
        /// call [method`Gtk.CellLayout.clear`] yourself if you need to set up different
        /// cell renderers for the new model.
        nonmutating set {
            gtk_combo_box_set_model(combo_box_ptr, UnsafeMutablePointer<GtkTreeModel>(newValue?.tree_model_ptr))
        }
    }

    /// Gets whether the popup uses a fixed width.
    @inlinable var popupFixedWidth: Bool {
        /// Gets whether the popup uses a fixed width.
        get {
            let result = gtk_combo_box_get_popup_fixed_width(combo_box_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Specifies whether the popup’s width should be a fixed width.
        /// 
        /// If `fixed` is `true`, the popup's width is set to match the
        /// allocated width of the combo box.
        nonmutating set {
            gtk_combo_box_set_popup_fixed_width(combo_box_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns the current row separator function.
    @inlinable var rowSeparatorFunc: GtkTreeViewRowSeparatorFunc! {
        /// Returns the current row separator function.
        get {
            let result = gtk_combo_box_get_row_separator_func(combo_box_ptr)
        let rv = result
            return rv
        }
    }

    @inlinable var parentInstance: GtkWidget {
        get {
            let rv = combo_box_ptr.pointee.parent_instance
    return rv
        }
    }

}



// MARK: - ComboBoxText Class

/// A `GtkComboBoxText` is a simple variant of `GtkComboBox` for text-only
/// use cases.
/// 
/// ![An example GtkComboBoxText](combo-box-text.png)
/// 
/// `GtkComboBoxText` hides the model-view complexity of `GtkComboBox`.
/// 
/// To create a `GtkComboBoxText`, use [ctor`Gtk.ComboBoxText.new`] or
/// [ctor`Gtk.ComboBoxText.new_with_entry`].
/// 
/// You can add items to a `GtkComboBoxText` with
/// [method`Gtk.ComboBoxText.append_text`],
/// [method`Gtk.ComboBoxText.insert_text`] or
/// [method`Gtk.ComboBoxText.prepend_text`] and remove options with
/// [method`Gtk.ComboBoxText.remove`].
/// 
/// If the `GtkComboBoxText` contains an entry (via the
/// [property`Gtk.ComboBox:has-entry`] property), its contents can be retrieved
/// using [method`Gtk.ComboBoxText.get_active_text`].
/// 
/// You should not call [method`Gtk.ComboBox.set_model`] or attempt to pack more
/// cells into this combo box via its [iface`Gtk.CellLayout`] interface.
/// 
/// # GtkComboBoxText as GtkBuildable
/// 
/// The `GtkComboBoxText` implementation of the `GtkBuildable` interface supports
/// adding items directly using the &lt;items&gt; element and specifying &lt;item&gt;
/// elements for each item. Each &lt;item&gt; element can specify the “id”
/// corresponding to the appended text and also supports the regular
/// translation attributes “translatable”, “context” and “comments”.
/// 
/// Here is a UI definition fragment specifying `GtkComboBoxText` items:
/// ```xml
/// &lt;object class="GtkComboBoxText"&gt;
///   &lt;items&gt;
///     &lt;item translatable="yes" id="factory"&gt;Factory&lt;/item&gt;
///     &lt;item translatable="yes" id="home"&gt;Home&lt;/item&gt;
///     &lt;item translatable="yes" id="subway"&gt;Subway&lt;/item&gt;
///   &lt;/items&gt;
/// &lt;/object&gt;
/// ```
/// 
/// # CSS nodes
/// 
/// ```
/// combobox
/// ╰── box.linked
///     ├── entry.combo
///     ├── button.combo
///     ╰── window.popup
/// ```
/// 
/// `GtkComboBoxText` has a single CSS node with name combobox. It adds
/// the style class .combo to the main CSS nodes of its entry and button
/// children, and the .linked class to the node of its internal box.
///
/// The `ComboBoxTextProtocol` protocol exposes the methods and properties of an underlying `GtkComboBoxText` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ComboBoxText`.
/// Alternatively, use `ComboBoxTextRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ComboBoxTextProtocol: ComboBoxProtocol {
        /// Untyped pointer to the underlying `GtkComboBoxText` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkComboBoxText` instance.
    var combo_box_text_ptr: UnsafeMutablePointer<GtkComboBoxText>! { get }

    /// Required Initialiser for types conforming to `ComboBoxTextProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkComboBoxText` is a simple variant of `GtkComboBox` for text-only
/// use cases.
/// 
/// ![An example GtkComboBoxText](combo-box-text.png)
/// 
/// `GtkComboBoxText` hides the model-view complexity of `GtkComboBox`.
/// 
/// To create a `GtkComboBoxText`, use [ctor`Gtk.ComboBoxText.new`] or
/// [ctor`Gtk.ComboBoxText.new_with_entry`].
/// 
/// You can add items to a `GtkComboBoxText` with
/// [method`Gtk.ComboBoxText.append_text`],
/// [method`Gtk.ComboBoxText.insert_text`] or
/// [method`Gtk.ComboBoxText.prepend_text`] and remove options with
/// [method`Gtk.ComboBoxText.remove`].
/// 
/// If the `GtkComboBoxText` contains an entry (via the
/// [property`Gtk.ComboBox:has-entry`] property), its contents can be retrieved
/// using [method`Gtk.ComboBoxText.get_active_text`].
/// 
/// You should not call [method`Gtk.ComboBox.set_model`] or attempt to pack more
/// cells into this combo box via its [iface`Gtk.CellLayout`] interface.
/// 
/// # GtkComboBoxText as GtkBuildable
/// 
/// The `GtkComboBoxText` implementation of the `GtkBuildable` interface supports
/// adding items directly using the &lt;items&gt; element and specifying &lt;item&gt;
/// elements for each item. Each &lt;item&gt; element can specify the “id”
/// corresponding to the appended text and also supports the regular
/// translation attributes “translatable”, “context” and “comments”.
/// 
/// Here is a UI definition fragment specifying `GtkComboBoxText` items:
/// ```xml
/// &lt;object class="GtkComboBoxText"&gt;
///   &lt;items&gt;
///     &lt;item translatable="yes" id="factory"&gt;Factory&lt;/item&gt;
///     &lt;item translatable="yes" id="home"&gt;Home&lt;/item&gt;
///     &lt;item translatable="yes" id="subway"&gt;Subway&lt;/item&gt;
///   &lt;/items&gt;
/// &lt;/object&gt;
/// ```
/// 
/// # CSS nodes
/// 
/// ```
/// combobox
/// ╰── box.linked
///     ├── entry.combo
///     ├── button.combo
///     ╰── window.popup
/// ```
/// 
/// `GtkComboBoxText` has a single CSS node with name combobox. It adds
/// the style class .combo to the main CSS nodes of its entry and button
/// children, and the .linked class to the node of its internal box.
///
/// The `ComboBoxTextRef` type acts as a lightweight Swift reference to an underlying `GtkComboBoxText` instance.
/// It exposes methods that can operate on this data type through `ComboBoxTextProtocol` conformance.
/// Use `ComboBoxTextRef` only as an `unowned` reference to an existing `GtkComboBoxText` instance.
///
public struct ComboBoxTextRef: ComboBoxTextProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkComboBoxText` instance.
    /// For type-safe access, use the generated, typed pointer `combo_box_text_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ComboBoxTextRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkComboBoxText>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkComboBoxText>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkComboBoxText>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkComboBoxText>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ComboBoxTextProtocol`
    @inlinable init<T: ComboBoxTextProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ComboBoxTextProtocol>(_ other: T) -> ComboBoxTextRef { ComboBoxTextRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkComboBoxText`.
    @inlinable init() {
            let result = gtk_combo_box_text_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkComboBoxText` with an entry.
    @inlinable static func comboBoxTextNewWithEntry() -> WidgetRef! {
            let result = gtk_combo_box_text_new_with_entry()
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }
}

/// A `GtkComboBoxText` is a simple variant of `GtkComboBox` for text-only
/// use cases.
/// 
/// ![An example GtkComboBoxText](combo-box-text.png)
/// 
/// `GtkComboBoxText` hides the model-view complexity of `GtkComboBox`.
/// 
/// To create a `GtkComboBoxText`, use [ctor`Gtk.ComboBoxText.new`] or
/// [ctor`Gtk.ComboBoxText.new_with_entry`].
/// 
/// You can add items to a `GtkComboBoxText` with
/// [method`Gtk.ComboBoxText.append_text`],
/// [method`Gtk.ComboBoxText.insert_text`] or
/// [method`Gtk.ComboBoxText.prepend_text`] and remove options with
/// [method`Gtk.ComboBoxText.remove`].
/// 
/// If the `GtkComboBoxText` contains an entry (via the
/// [property`Gtk.ComboBox:has-entry`] property), its contents can be retrieved
/// using [method`Gtk.ComboBoxText.get_active_text`].
/// 
/// You should not call [method`Gtk.ComboBox.set_model`] or attempt to pack more
/// cells into this combo box via its [iface`Gtk.CellLayout`] interface.
/// 
/// # GtkComboBoxText as GtkBuildable
/// 
/// The `GtkComboBoxText` implementation of the `GtkBuildable` interface supports
/// adding items directly using the &lt;items&gt; element and specifying &lt;item&gt;
/// elements for each item. Each &lt;item&gt; element can specify the “id”
/// corresponding to the appended text and also supports the regular
/// translation attributes “translatable”, “context” and “comments”.
/// 
/// Here is a UI definition fragment specifying `GtkComboBoxText` items:
/// ```xml
/// &lt;object class="GtkComboBoxText"&gt;
///   &lt;items&gt;
///     &lt;item translatable="yes" id="factory"&gt;Factory&lt;/item&gt;
///     &lt;item translatable="yes" id="home"&gt;Home&lt;/item&gt;
///     &lt;item translatable="yes" id="subway"&gt;Subway&lt;/item&gt;
///   &lt;/items&gt;
/// &lt;/object&gt;
/// ```
/// 
/// # CSS nodes
/// 
/// ```
/// combobox
/// ╰── box.linked
///     ├── entry.combo
///     ├── button.combo
///     ╰── window.popup
/// ```
/// 
/// `GtkComboBoxText` has a single CSS node with name combobox. It adds
/// the style class .combo to the main CSS nodes of its entry and button
/// children, and the .linked class to the node of its internal box.
///
/// The `ComboBoxText` type acts as a reference-counted owner of an underlying `GtkComboBoxText` instance.
/// It provides the methods that can operate on this data type through `ComboBoxTextProtocol` conformance.
/// Use `ComboBoxText` as a strong reference or owner of a `GtkComboBoxText` instance.
///
open class ComboBoxText: ComboBox, ComboBoxTextProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkComboBoxText>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkComboBoxText>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkComboBoxText>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkComboBoxText>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkComboBoxText`.
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkComboBoxText>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ComboBoxTextProtocol`
    /// Will retain `GtkComboBoxText`.
    /// - Parameter other: an instance of a related type that implements `ComboBoxTextProtocol`
    @inlinable public init<T: ComboBoxTextProtocol>(comboBoxText other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkComboBoxText`.
    @inlinable override public init() {
            let result = gtk_combo_box_text_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkComboBoxText` with an entry.
    @inlinable public static func comboBoxTextNewWithEntry() -> Widget! {
            let result = gtk_combo_box_text_new_with_entry()
        guard let rv = Widget(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

}

public enum ComboBoxTextPropertyName: String, PropertyNameProtocol {
    /// The item which is currently active.
    /// 
    /// If the model is a non-flat treemodel, and the active item is not an
    /// immediate child of the root of the tree, this property has the value
    /// `gtk_tree_path_get_indices (path)[0]`, where `path` is the
    /// [struct`Gtk.TreePath`] of the active item.
    case active = "active"
    /// The value of the ID column of the active row.
    case activeId = "active-id"
    /// Whether the dropdown button is sensitive when
    /// the model is empty.
    case buttonSensitivity = "button-sensitivity"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// The child widget.
    case child = "child"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// The model column to associate with strings from the entry.
    /// 
    /// This is property only relevant if the combo was created with
    /// [property`Gtk.ComboBox:has-entry`] is `true`.
    case entryTextColumn = "entry-text-column"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the combo box has an entry.
    case hasEntry = "has-entry"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// The `has-frame` property controls whether a frame is drawn around the entry.
    case hasFrame = "has-frame"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The model column that provides string IDs for the values
    /// in the model, if != -1.
    case idColumn = "id-column"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The model from which the combo box takes its values.
    case model = "model"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the popup's width should be a fixed width matching the
    /// allocated width of the combo box.
    case popupFixedWidth = "popup-fixed-width"
    /// Whether the combo boxes dropdown is popped up.
    /// 
    /// Note that this property is mainly useful, because
    /// it allows you to connect to notify`popup-shown`.
    case popupShown = "popup-shown"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension ComboBoxTextProtocol {
    /// Bind a `ComboBoxTextPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ComboBoxTextPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ComboBoxText property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ComboBoxTextPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ComboBoxText property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ComboBoxTextPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ComboBoxTextSignalName: String, SignalNameProtocol {
    /// Emitted to when the combo box is activated.
    /// 
    /// The ``activate`` signal on `GtkComboBox` is an action signal and
    /// emitting it causes the combo box to pop up its dropdown.
    case activate = "activate"
    /// Emitted when the active item is changed.
    /// 
    /// The can be due to the user selecting a different item from the list,
    /// or due to a call to [method`Gtk.ComboBox.set_active_iter`]. It will
    /// also be emitted while typing into the entry of a combo box with an entry.
    case changed = "changed"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted to allow changing how the text in a combo box's entry is displayed.
    /// 
    /// See [property`Gtk.ComboBox:has-entry`].
    /// 
    /// Connect a signal handler which returns an allocated string representing
    /// `path`. That string will then be used to set the text in the combo box's
    /// entry. The default signal handler uses the text from the
    /// [property`Gtk.ComboBox:entry-text-column`] model column.
    /// 
    /// Here's an example signal handler which fetches data from the model and
    /// displays it in the entry.
    /// ```c
    /// static char *
    /// format_entry_text_callback (GtkComboBox *combo,
    ///                             const char *path,
    ///                             gpointer     user_data)
    /// {
    ///   GtkTreeIter iter;
    ///   GtkTreeModel model;
    ///   double       value;
    /// 
    ///   model = gtk_combo_box_get_model (combo);
    /// 
    ///   gtk_tree_model_get_iter_from_string (model, &iter, path);
    ///   gtk_tree_model_get (model, &iter,
    ///                       THE_DOUBLE_VALUE_COLUMN, &value,
    ///                       -1);
    /// 
    ///   return g_strdup_printf ("`g`", value);
    /// }
    /// ```
    case formatEntryText = "format-entry-text"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted to move the active selection.
    /// 
    /// This is an [keybinding signal](class.SignalAction.html).
    case moveActive = "move-active"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted to popdown the combo box list.
    /// 
    /// This is an [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are Alt+Up and Escape.
    case popdown = "popdown"
    /// Emitted to popup the combo box list.
    /// 
    /// This is an [keybinding signal](class.SignalAction.html).
    /// 
    /// The default binding for this signal is Alt+Down.
    case popup = "popup"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// The item which is currently active.
    /// 
    /// If the model is a non-flat treemodel, and the active item is not an
    /// immediate child of the root of the tree, this property has the value
    /// `gtk_tree_path_get_indices (path)[0]`, where `path` is the
    /// [struct`Gtk.TreePath`] of the active item.
    case notifyActive = "notify::active"
    /// The value of the ID column of the active row.
    case notifyActiveId = "notify::active-id"
    /// Whether the dropdown button is sensitive when
    /// the model is empty.
    case notifyButtonSensitivity = "notify::button-sensitivity"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// The child widget.
    case notifyChild = "notify::child"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// The model column to associate with strings from the entry.
    /// 
    /// This is property only relevant if the combo was created with
    /// [property`Gtk.ComboBox:has-entry`] is `true`.
    case notifyEntryTextColumn = "notify::entry-text-column"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the combo box has an entry.
    case notifyHasEntry = "notify::has-entry"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// The `has-frame` property controls whether a frame is drawn around the entry.
    case notifyHasFrame = "notify::has-frame"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The model column that provides string IDs for the values
    /// in the model, if != -1.
    case notifyIdColumn = "notify::id-column"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The model from which the combo box takes its values.
    case notifyModel = "notify::model"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the popup's width should be a fixed width matching the
    /// allocated width of the combo box.
    case notifyPopupFixedWidth = "notify::popup-fixed-width"
    /// Whether the combo boxes dropdown is popped up.
    /// 
    /// Note that this property is mainly useful, because
    /// it allows you to connect to notify`popup-shown`.
    case notifyPopupShown = "notify::popup-shown"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: ComboBoxText has no signals
// MARK: ComboBoxText Class: ComboBoxTextProtocol extension (methods and fields)
public extension ComboBoxTextProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkComboBoxText` instance.
    @inlinable var combo_box_text_ptr: UnsafeMutablePointer<GtkComboBoxText>! { return ptr?.assumingMemoryBound(to: GtkComboBoxText.self) }

    /// Appends `text` to the list of strings stored in `combo_box`.
    /// 
    /// If `id` is non-`nil` then it is used as the ID of the row.
    /// 
    /// This is the same as calling [method`Gtk.ComboBoxText.insert`]
    /// with a position of -1.
    @inlinable func append(id: UnsafePointer<CChar>? = nil, text: UnsafePointer<CChar>!) {
        
        gtk_combo_box_text_append(combo_box_text_ptr, id, text)
        
    }

    /// Appends `text` to the list of strings stored in `combo_box`.
    /// 
    /// This is the same as calling [method`Gtk.ComboBoxText.insert_text`]
    /// with a position of -1.
    @inlinable func append(text: UnsafePointer<CChar>!) {
        
        gtk_combo_box_text_append_text(combo_box_text_ptr, text)
        
    }

    /// Returns the currently active string in `combo_box`.
    /// 
    /// If no row is currently selected, `nil` is returned.
    /// If `combo_box` contains an entry, this function will
    /// return its contents (which will not necessarily
    /// be an item from the list).
    @inlinable func getActiveText() -> String! {
        let result = gtk_combo_box_text_get_active_text(combo_box_text_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Inserts `text` at `position` in the list of strings stored in `combo_box`.
    /// 
    /// If `id` is non-`nil` then it is used as the ID of the row.
    /// See [property`Gtk.ComboBox:id-column`].
    /// 
    /// If `position` is negative then `text` is appended.
    @inlinable func insert(position: Int, id: UnsafePointer<CChar>? = nil, text: UnsafePointer<CChar>!) {
        
        gtk_combo_box_text_insert(combo_box_text_ptr, gint(position), id, text)
        
    }

    /// Inserts `text` at `position` in the list of strings stored in `combo_box`.
    /// 
    /// If `position` is negative then `text` is appended.
    /// 
    /// This is the same as calling [method`Gtk.ComboBoxText.insert`]
    /// with a `nil` ID string.
    @inlinable func insertText(position: Int, text: UnsafePointer<CChar>!) {
        
        gtk_combo_box_text_insert_text(combo_box_text_ptr, gint(position), text)
        
    }

    /// Prepends `text` to the list of strings stored in `combo_box`.
    /// 
    /// If `id` is non-`nil` then it is used as the ID of the row.
    /// 
    /// This is the same as calling [method`Gtk.ComboBoxText.insert`]
    /// with a position of 0.
    @inlinable func prepend(id: UnsafePointer<CChar>? = nil, text: UnsafePointer<CChar>!) {
        
        gtk_combo_box_text_prepend(combo_box_text_ptr, id, text)
        
    }

    /// Prepends `text` to the list of strings stored in `combo_box`.
    /// 
    /// This is the same as calling [method`Gtk.ComboBoxText.insert_text`]
    /// with a position of 0.
    @inlinable func prepend(text: UnsafePointer<CChar>!) {
        
        gtk_combo_box_text_prepend_text(combo_box_text_ptr, text)
        
    }

    /// Removes the string at `position` from `combo_box`.
    @inlinable func remove(position: Int) {
        
        gtk_combo_box_text_remove(combo_box_text_ptr, gint(position))
        
    }

    /// Removes all the text entries from the combo box.
    @inlinable func removeAll() {
        
        gtk_combo_box_text_remove_all(combo_box_text_ptr)
        
    }
    /// Returns the currently active string in `combo_box`.
    /// 
    /// If no row is currently selected, `nil` is returned.
    /// If `combo_box` contains an entry, this function will
    /// return its contents (which will not necessarily
    /// be an item from the list).
    @inlinable var activeText: String! {
        /// Returns the currently active string in `combo_box`.
        /// 
        /// If no row is currently selected, `nil` is returned.
        /// If `combo_box` contains an entry, this function will
        /// return its contents (which will not necessarily
        /// be an item from the list).
        get {
            let result = gtk_combo_box_text_get_active_text(combo_box_text_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }


}



// MARK: - ConstantExpression Class

/// A constant value in a `GtkExpression`.
///
/// The `ConstantExpressionProtocol` protocol exposes the methods and properties of an underlying `GtkConstantExpression` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ConstantExpression`.
/// Alternatively, use `ConstantExpressionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ConstantExpressionProtocol: ExpressionProtocol {
        /// Untyped pointer to the underlying `GtkConstantExpression` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstantExpression` instance.
    var constant_expression_ptr: UnsafeMutablePointer<GtkConstantExpression>! { get }

    /// Required Initialiser for types conforming to `ConstantExpressionProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A constant value in a `GtkExpression`.
///
/// The `ConstantExpressionRef` type acts as a lightweight Swift reference to an underlying `GtkConstantExpression` instance.
/// It exposes methods that can operate on this data type through `ConstantExpressionProtocol` conformance.
/// Use `ConstantExpressionRef` only as an `unowned` reference to an existing `GtkConstantExpression` instance.
///
public struct ConstantExpressionRef: ConstantExpressionProtocol {
        /// Untyped pointer to the underlying `GtkConstantExpression` instance.
    /// For type-safe access, use the generated, typed pointer `constant_expression_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstantExpressionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstantExpression>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstantExpression>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstantExpression>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstantExpression>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstantExpressionProtocol`
    @inlinable init<T: ConstantExpressionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// A constant value in a `GtkExpression`.
///
/// The `ConstantExpression` type acts as a reference-counted owner of an underlying `GtkConstantExpression` instance.
/// It provides the methods that can operate on this data type through `ConstantExpressionProtocol` conformance.
/// Use `ConstantExpression` as a strong reference or owner of a `GtkConstantExpression` instance.
///
open class ConstantExpression: Expression, ConstantExpressionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkConstantExpression>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkConstantExpression>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkConstantExpression>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkConstantExpression>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkConstantExpression`.
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkConstantExpression>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ConstantExpressionProtocol`
    /// Will retain `GtkConstantExpression`.
    /// - Parameter other: an instance of a related type that implements `ConstantExpressionProtocol`
    @inlinable public init<T: ConstantExpressionProtocol>(constantExpression other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

// MARK: no ConstantExpression properties

// MARK: no ConstantExpression signals

// MARK: ConstantExpression has no signals
// MARK: ConstantExpression Class: ConstantExpressionProtocol extension (methods and fields)
public extension ConstantExpressionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstantExpression` instance.
    @inlinable var constant_expression_ptr: UnsafeMutablePointer<GtkConstantExpression>! { return ptr?.assumingMemoryBound(to: GtkConstantExpression.self) }

    /// Gets the value that a constant expression evaluates to.
    @inlinable func getValue() -> GLibObject.ValueRef! {
        let result = gtk_constant_expression_get_value(expression_ptr)
        let rv = GLibObject.ValueRef(gconstpointer: gconstpointer(result))
        return rv
    }
    /// Gets the value that a constant expression evaluates to.
    @inlinable var value: GLibObject.ValueRef! {
        /// Gets the value that a constant expression evaluates to.
        get {
            let result = gtk_constant_expression_get_value(expression_ptr)
        let rv = GLibObject.ValueRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }


}



// MARK: - Constraint Class

/// `GtkConstraint` describes a constraint between attributes of two widgets,
///  expressed as a linear equation.
/// 
/// The typical equation for a constraint is:
/// 
/// ```
///   target.target_attr = source.source_attr × multiplier + constant
/// ```
/// 
/// Each `GtkConstraint` is part of a system that will be solved by a
/// [class`Gtk.ConstraintLayout`] in order to allocate and position each
/// child widget or guide.
/// 
/// The source and target, as well as their attributes, of a `GtkConstraint`
/// instance are immutable after creation.
///
/// The `ConstraintProtocol` protocol exposes the methods and properties of an underlying `GtkConstraint` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Constraint`.
/// Alternatively, use `ConstraintRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ConstraintProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkConstraint` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstraint` instance.
    var constraint_ptr: UnsafeMutablePointer<GtkConstraint>! { get }

    /// Required Initialiser for types conforming to `ConstraintProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkConstraint` describes a constraint between attributes of two widgets,
///  expressed as a linear equation.
/// 
/// The typical equation for a constraint is:
/// 
/// ```
///   target.target_attr = source.source_attr × multiplier + constant
/// ```
/// 
/// Each `GtkConstraint` is part of a system that will be solved by a
/// [class`Gtk.ConstraintLayout`] in order to allocate and position each
/// child widget or guide.
/// 
/// The source and target, as well as their attributes, of a `GtkConstraint`
/// instance are immutable after creation.
///
/// The `ConstraintRef` type acts as a lightweight Swift reference to an underlying `GtkConstraint` instance.
/// It exposes methods that can operate on this data type through `ConstraintProtocol` conformance.
/// Use `ConstraintRef` only as an `unowned` reference to an existing `GtkConstraint` instance.
///
public struct ConstraintRef: ConstraintProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkConstraint` instance.
    /// For type-safe access, use the generated, typed pointer `constraint_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstraintRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstraint>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstraint>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstraint>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstraint>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstraintProtocol`
    @inlinable init<T: ConstraintProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ConstraintProtocol>(_ other: T) -> ConstraintRef { ConstraintRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new constraint representing a relation between a layout
    /// attribute on a source and a layout attribute on a target.
    @inlinable init<ConstraintTargetT: ConstraintTargetProtocol>( target: ConstraintTargetT?, targetAttribute: GtkConstraintAttribute, relation: GtkConstraintRelation, source: ConstraintTargetT?, sourceAttribute: GtkConstraintAttribute, multiplier: CDouble, constant: CDouble, strength: Int) {
            let result = gtk_constraint_new(target?.constraint_target_ptr, targetAttribute, relation, source?.constraint_target_ptr, sourceAttribute, multiplier, constant, gint(strength))
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new constraint representing a relation between a layout
    /// attribute on a target and a constant value.
    @inlinable init<ConstraintTargetT: ConstraintTargetProtocol>(constant target: ConstraintTargetT?, targetAttribute: GtkConstraintAttribute, relation: GtkConstraintRelation, constant: CDouble, strength: Int) {
            let result = gtk_constraint_new_constant(target?.constraint_target_ptr, targetAttribute, relation, constant, gint(strength))
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new constraint representing a relation between a layout
    /// attribute on a target and a constant value.
    @inlinable static func new<ConstraintTargetT: ConstraintTargetProtocol>(constant target: ConstraintTargetT?, targetAttribute: GtkConstraintAttribute, relation: GtkConstraintRelation, constant: CDouble, strength: Int) -> ConstraintRef! {
            let result = gtk_constraint_new_constant(target?.constraint_target_ptr, targetAttribute, relation, constant, gint(strength))
        guard let rv = ConstraintRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }
}

/// `GtkConstraint` describes a constraint between attributes of two widgets,
///  expressed as a linear equation.
/// 
/// The typical equation for a constraint is:
/// 
/// ```
///   target.target_attr = source.source_attr × multiplier + constant
/// ```
/// 
/// Each `GtkConstraint` is part of a system that will be solved by a
/// [class`Gtk.ConstraintLayout`] in order to allocate and position each
/// child widget or guide.
/// 
/// The source and target, as well as their attributes, of a `GtkConstraint`
/// instance are immutable after creation.
///
/// The `Constraint` type acts as a reference-counted owner of an underlying `GtkConstraint` instance.
/// It provides the methods that can operate on this data type through `ConstraintProtocol` conformance.
/// Use `Constraint` as a strong reference or owner of a `GtkConstraint` instance.
///
open class Constraint: GLibObject.Object, ConstraintProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkConstraint>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkConstraint>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkConstraint>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkConstraint>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkConstraint`.
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkConstraint>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ConstraintProtocol`
    /// Will retain `GtkConstraint`.
    /// - Parameter other: an instance of a related type that implements `ConstraintProtocol`
    @inlinable public init<T: ConstraintProtocol>(constraint other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new constraint representing a relation between a layout
    /// attribute on a source and a layout attribute on a target.
    @inlinable public init<ConstraintTargetT: ConstraintTargetProtocol>( target: ConstraintTargetT?, targetAttribute: GtkConstraintAttribute, relation: GtkConstraintRelation, source: ConstraintTargetT?, sourceAttribute: GtkConstraintAttribute, multiplier: CDouble, constant: CDouble, strength: Int) {
            let result = gtk_constraint_new(target?.constraint_target_ptr, targetAttribute, relation, source?.constraint_target_ptr, sourceAttribute, multiplier, constant, gint(strength))
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new constraint representing a relation between a layout
    /// attribute on a target and a constant value.
    @inlinable public init<ConstraintTargetT: ConstraintTargetProtocol>(constant target: ConstraintTargetT?, targetAttribute: GtkConstraintAttribute, relation: GtkConstraintRelation, constant: CDouble, strength: Int) {
            let result = gtk_constraint_new_constant(target?.constraint_target_ptr, targetAttribute, relation, constant, gint(strength))
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new constraint representing a relation between a layout
    /// attribute on a target and a constant value.
    @inlinable public static func new<ConstraintTargetT: ConstraintTargetProtocol>(constant target: ConstraintTargetT?, targetAttribute: GtkConstraintAttribute, relation: GtkConstraintRelation, constant: CDouble, strength: Int) -> Constraint! {
            let result = gtk_constraint_new_constant(target?.constraint_target_ptr, targetAttribute, relation, constant, gint(strength))
        guard let rv = Constraint(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

}

public enum ConstraintPropertyName: String, PropertyNameProtocol {
    /// The constant value to be added to the [property`Gtk.Constraint:source-attribute`].
    case constant = "constant"
    /// The multiplication factor to be applied to
    /// the [property`Gtk.Constraint:source-attribute`].
    case multiplier = "multiplier"
    /// The order relation between the terms of the constraint.
    case relation = "relation"
    /// The source of the constraint.
    /// 
    /// The constraint will set the [property`Gtk.Constraint:target-attribute`]
    /// property of the target using the [property`Gtk.Constraint:source-attribute`]
    /// property of the source.
    case source = "source"
    /// The attribute of the [property`Gtk.Constraint:source`] read by the
    /// constraint.
    case sourceAttribute = "source-attribute"
    /// The strength of the constraint.
    /// 
    /// The strength can be expressed either using one of the symbolic values
    /// of the [enum`Gtk.ConstraintStrength`] enumeration, or any positive integer
    /// value.
    case strength = "strength"
    /// The target of the constraint.
    /// 
    /// The constraint will set the [property`Gtk.Constraint:target-attribute`]
    /// property of the target using the [property`Gtk.Constraint:source-attribute`]
    /// property of the source widget.
    case target = "target"
    /// The attribute of the [property`Gtk.Constraint:target`] set by the constraint.
    case targetAttribute = "target-attribute"
}

public extension ConstraintProtocol {
    /// Bind a `ConstraintPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ConstraintPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Constraint property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ConstraintPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Constraint property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ConstraintPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ConstraintSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The constant value to be added to the [property`Gtk.Constraint:source-attribute`].
    case notifyConstant = "notify::constant"
    /// The multiplication factor to be applied to
    /// the [property`Gtk.Constraint:source-attribute`].
    case notifyMultiplier = "notify::multiplier"
    /// The order relation between the terms of the constraint.
    case notifyRelation = "notify::relation"
    /// The source of the constraint.
    /// 
    /// The constraint will set the [property`Gtk.Constraint:target-attribute`]
    /// property of the target using the [property`Gtk.Constraint:source-attribute`]
    /// property of the source.
    case notifySource = "notify::source"
    /// The attribute of the [property`Gtk.Constraint:source`] read by the
    /// constraint.
    case notifySourceAttribute = "notify::source-attribute"
    /// The strength of the constraint.
    /// 
    /// The strength can be expressed either using one of the symbolic values
    /// of the [enum`Gtk.ConstraintStrength`] enumeration, or any positive integer
    /// value.
    case notifyStrength = "notify::strength"
    /// The target of the constraint.
    /// 
    /// The constraint will set the [property`Gtk.Constraint:target-attribute`]
    /// property of the target using the [property`Gtk.Constraint:source-attribute`]
    /// property of the source widget.
    case notifyTarget = "notify::target"
    /// The attribute of the [property`Gtk.Constraint:target`] set by the constraint.
    case notifyTargetAttribute = "notify::target-attribute"
}

// MARK: Constraint has no signals
// MARK: Constraint Class: ConstraintProtocol extension (methods and fields)
public extension ConstraintProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstraint` instance.
    @inlinable var constraint_ptr: UnsafeMutablePointer<GtkConstraint>! { return ptr?.assumingMemoryBound(to: GtkConstraint.self) }

    /// Retrieves the constant factor added to the source attributes' value.
    @inlinable func getConstant() -> CDouble {
        let result = gtk_constraint_get_constant(constraint_ptr)
        let rv = result
        return rv
    }

    /// Retrieves the multiplication factor applied to the source
    /// attribute's value.
    @inlinable func getMultiplier() -> CDouble {
        let result = gtk_constraint_get_multiplier(constraint_ptr)
        let rv = result
        return rv
    }

    /// The order relation between the terms of the constraint.
    @inlinable func getRelation() -> GtkConstraintRelation {
        let result = gtk_constraint_get_relation(constraint_ptr)
        let rv = result
        return rv
    }

    /// Retrieves the [iface`Gtk.ConstraintTarget`] used as the source for the
    /// constraint.
    /// 
    /// If the source is set to `NULL` at creation, the constraint will use
    /// the widget using the [class`Gtk.ConstraintLayout`] as the source.
    @inlinable func getSource() -> ConstraintTargetRef! {
        let result = gtk_constraint_get_source(constraint_ptr)
        let rv = ConstraintTargetRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Retrieves the attribute of the source to be read by the constraint.
    @inlinable func getSourceAttribute() -> GtkConstraintAttribute {
        let result = gtk_constraint_get_source_attribute(constraint_ptr)
        let rv = result
        return rv
    }

    /// Retrieves the strength of the constraint.
    @inlinable func getStrength() -> Int {
        let result = gtk_constraint_get_strength(constraint_ptr)
        let rv = Int(result)
        return rv
    }

    /// Retrieves the [iface`Gtk.ConstraintTarget`] used as the target for
    /// the constraint.
    /// 
    /// If the targe is set to `NULL` at creation, the constraint will use
    /// the widget using the [class`Gtk.ConstraintLayout`] as the target.
    @inlinable func getTarget() -> ConstraintTargetRef! {
        let result = gtk_constraint_get_target(constraint_ptr)
        let rv = ConstraintTargetRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Retrieves the attribute of the target to be set by the constraint.
    @inlinable func getTargetAttribute() -> GtkConstraintAttribute {
        let result = gtk_constraint_get_target_attribute(constraint_ptr)
        let rv = result
        return rv
    }
    /// The constant value to be added to the [property`Gtk.Constraint:source-attribute`].
    @inlinable var constant: CDouble {
        /// Retrieves the constant factor added to the source attributes' value.
        get {
            let result = gtk_constraint_get_constant(constraint_ptr)
        let rv = result
            return rv
        }
    }

    /// Checks whether the constraint is attached to a [class`Gtk.ConstraintLayout`],
    /// and it is contributing to the layout.
    @inlinable var isAttached: Bool {
        /// Checks whether the constraint is attached to a [class`Gtk.ConstraintLayout`],
        /// and it is contributing to the layout.
        get {
            let result = gtk_constraint_is_attached(constraint_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// Checks whether the constraint describes a relation between an attribute
    /// on the [property`Gtk.Constraint:target`] and a constant value.
    @inlinable var isConstant: Bool {
        /// Checks whether the constraint describes a relation between an attribute
        /// on the [property`Gtk.Constraint:target`] and a constant value.
        get {
            let result = gtk_constraint_is_constant(constraint_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// Checks whether the constraint is a required relation for solving the
    /// constraint layout.
    @inlinable var isRequired: Bool {
        /// Checks whether the constraint is a required relation for solving the
        /// constraint layout.
        get {
            let result = gtk_constraint_is_required(constraint_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// The multiplication factor to be applied to
    /// the [property`Gtk.Constraint:source-attribute`].
    @inlinable var multiplier: CDouble {
        /// Retrieves the multiplication factor applied to the source
        /// attribute's value.
        get {
            let result = gtk_constraint_get_multiplier(constraint_ptr)
        let rv = result
            return rv
        }
    }

    /// The order relation between the terms of the constraint.
    @inlinable var relation: GtkConstraintRelation {
        /// The order relation between the terms of the constraint.
        get {
            let result = gtk_constraint_get_relation(constraint_ptr)
        let rv = result
            return rv
        }
    }

    /// The source of the constraint.
    /// 
    /// The constraint will set the [property`Gtk.Constraint:target-attribute`]
    /// property of the target using the [property`Gtk.Constraint:source-attribute`]
    /// property of the source.
    @inlinable var source: ConstraintTargetRef! {
        /// Retrieves the [iface`Gtk.ConstraintTarget`] used as the source for the
        /// constraint.
        /// 
        /// If the source is set to `NULL` at creation, the constraint will use
        /// the widget using the [class`Gtk.ConstraintLayout`] as the source.
        get {
            let result = gtk_constraint_get_source(constraint_ptr)
        let rv = ConstraintTargetRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Retrieves the attribute of the source to be read by the constraint.
    @inlinable var sourceAttribute: GtkConstraintAttribute {
        /// Retrieves the attribute of the source to be read by the constraint.
        get {
            let result = gtk_constraint_get_source_attribute(constraint_ptr)
        let rv = result
            return rv
        }
    }

    /// The strength of the constraint.
    /// 
    /// The strength can be expressed either using one of the symbolic values
    /// of the [enum`Gtk.ConstraintStrength`] enumeration, or any positive integer
    /// value.
    @inlinable var strength: Int {
        /// Retrieves the strength of the constraint.
        get {
            let result = gtk_constraint_get_strength(constraint_ptr)
        let rv = Int(result)
            return rv
        }
    }

    /// The target of the constraint.
    /// 
    /// The constraint will set the [property`Gtk.Constraint:target-attribute`]
    /// property of the target using the [property`Gtk.Constraint:source-attribute`]
    /// property of the source widget.
    @inlinable var target: ConstraintTargetRef! {
        /// Retrieves the [iface`Gtk.ConstraintTarget`] used as the target for
        /// the constraint.
        /// 
        /// If the targe is set to `NULL` at creation, the constraint will use
        /// the widget using the [class`Gtk.ConstraintLayout`] as the target.
        get {
            let result = gtk_constraint_get_target(constraint_ptr)
        let rv = ConstraintTargetRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Retrieves the attribute of the target to be set by the constraint.
    @inlinable var targetAttribute: GtkConstraintAttribute {
        /// Retrieves the attribute of the target to be set by the constraint.
        get {
            let result = gtk_constraint_get_target_attribute(constraint_ptr)
        let rv = result
            return rv
        }
    }


}



// MARK: - ConstraintGuide Class

/// A `GtkConstraintGuide` is an invisible layout element in a
/// `GtkConstraintLayout`.
/// 
/// The `GtkConstraintLayout` treats guides like widgets. They
/// can be used as the source or target of a `GtkConstraint`.
/// 
/// Guides have a minimum, maximum and natural size. Depending
/// on the constraints that are applied, they can act like a
/// guideline that widgets can be aligned to, or like *flexible
/// space*.
/// 
/// Unlike a `GtkWidget`, a `GtkConstraintGuide` will not be drawn.
///
/// The `ConstraintGuideProtocol` protocol exposes the methods and properties of an underlying `GtkConstraintGuide` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ConstraintGuide`.
/// Alternatively, use `ConstraintGuideRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ConstraintGuideProtocol: GLibObject.ObjectProtocol, ConstraintTargetProtocol {
        /// Untyped pointer to the underlying `GtkConstraintGuide` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstraintGuide` instance.
    var constraint_guide_ptr: UnsafeMutablePointer<GtkConstraintGuide>! { get }

    /// Required Initialiser for types conforming to `ConstraintGuideProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkConstraintGuide` is an invisible layout element in a
/// `GtkConstraintLayout`.
/// 
/// The `GtkConstraintLayout` treats guides like widgets. They
/// can be used as the source or target of a `GtkConstraint`.
/// 
/// Guides have a minimum, maximum and natural size. Depending
/// on the constraints that are applied, they can act like a
/// guideline that widgets can be aligned to, or like *flexible
/// space*.
/// 
/// Unlike a `GtkWidget`, a `GtkConstraintGuide` will not be drawn.
///
/// The `ConstraintGuideRef` type acts as a lightweight Swift reference to an underlying `GtkConstraintGuide` instance.
/// It exposes methods that can operate on this data type through `ConstraintGuideProtocol` conformance.
/// Use `ConstraintGuideRef` only as an `unowned` reference to an existing `GtkConstraintGuide` instance.
///
public struct ConstraintGuideRef: ConstraintGuideProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkConstraintGuide` instance.
    /// For type-safe access, use the generated, typed pointer `constraint_guide_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstraintGuideRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstraintGuide>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstraintGuide>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstraintGuide>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstraintGuide>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstraintGuideProtocol`
    @inlinable init<T: ConstraintGuideProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ConstraintGuideProtocol>(_ other: T) -> ConstraintGuideRef { ConstraintGuideRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkConstraintGuide` object.
    @inlinable init() {
            let result = gtk_constraint_guide_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// A `GtkConstraintGuide` is an invisible layout element in a
/// `GtkConstraintLayout`.
/// 
/// The `GtkConstraintLayout` treats guides like widgets. They
/// can be used as the source or target of a `GtkConstraint`.
/// 
/// Guides have a minimum, maximum and natural size. Depending
/// on the constraints that are applied, they can act like a
/// guideline that widgets can be aligned to, or like *flexible
/// space*.
/// 
/// Unlike a `GtkWidget`, a `GtkConstraintGuide` will not be drawn.
///
/// The `ConstraintGuide` type acts as a reference-counted owner of an underlying `GtkConstraintGuide` instance.
/// It provides the methods that can operate on this data type through `ConstraintGuideProtocol` conformance.
/// Use `ConstraintGuide` as a strong reference or owner of a `GtkConstraintGuide` instance.
///
open class ConstraintGuide: GLibObject.Object, ConstraintGuideProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkConstraintGuide>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkConstraintGuide>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkConstraintGuide>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkConstraintGuide>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkConstraintGuide`.
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkConstraintGuide>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ConstraintGuideProtocol`
    /// Will retain `GtkConstraintGuide`.
    /// - Parameter other: an instance of a related type that implements `ConstraintGuideProtocol`
    @inlinable public init<T: ConstraintGuideProtocol>(constraintGuide other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkConstraintGuide` object.
    @inlinable public init() {
            let result = gtk_constraint_guide_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ConstraintGuidePropertyName: String, PropertyNameProtocol {
    /// The maximum height of the guide.
    case maxHeight = "max-height"
    /// The maximum width of the guide.
    case maxWidth = "max-width"
    /// The minimum height of the guide.
    case minHeight = "min-height"
    /// The minimum width of the guide.
    case minWidth = "min-width"
    /// A name that identifies the `GtkConstraintGuide`, for debugging.
    case name = "name"
    /// The preferred, or natural, height of the guide.
    case natHeight = "nat-height"
    /// The preferred, or natural, width of the guide.
    case natWidth = "nat-width"
    /// The `GtkConstraintStrength` to be used for the constraint on
    /// the natural size of the guide.
    case strength = "strength"
}

public extension ConstraintGuideProtocol {
    /// Bind a `ConstraintGuidePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ConstraintGuidePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ConstraintGuide property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ConstraintGuidePropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ConstraintGuide property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ConstraintGuidePropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ConstraintGuideSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The maximum height of the guide.
    case notifyMaxHeight = "notify::max-height"
    /// The maximum width of the guide.
    case notifyMaxWidth = "notify::max-width"
    /// The minimum height of the guide.
    case notifyMinHeight = "notify::min-height"
    /// The minimum width of the guide.
    case notifyMinWidth = "notify::min-width"
    /// A name that identifies the `GtkConstraintGuide`, for debugging.
    case notifyName = "notify::name"
    /// The preferred, or natural, height of the guide.
    case notifyNatHeight = "notify::nat-height"
    /// The preferred, or natural, width of the guide.
    case notifyNatWidth = "notify::nat-width"
    /// The `GtkConstraintStrength` to be used for the constraint on
    /// the natural size of the guide.
    case notifyStrength = "notify::strength"
}

// MARK: ConstraintGuide has no signals
// MARK: ConstraintGuide Class: ConstraintGuideProtocol extension (methods and fields)
public extension ConstraintGuideProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstraintGuide` instance.
    @inlinable var constraint_guide_ptr: UnsafeMutablePointer<GtkConstraintGuide>! { return ptr?.assumingMemoryBound(to: GtkConstraintGuide.self) }

    /// Gets the maximum size of `guide`.
    @inlinable func getMaxSize(width: UnsafeMutablePointer<gint>! = nil, height: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_constraint_guide_get_max_size(constraint_guide_ptr, width, height)
        
    }

    /// Gets the minimum size of `guide`.
    @inlinable func getMinSize(width: UnsafeMutablePointer<gint>! = nil, height: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_constraint_guide_get_min_size(constraint_guide_ptr, width, height)
        
    }

    /// Retrieves the name set using `gtk_constraint_guide_set_name()`.
    @inlinable func getName() -> String! {
        let result = gtk_constraint_guide_get_name(constraint_guide_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets the natural size of `guide`.
    @inlinable func getNatSize(width: UnsafeMutablePointer<gint>! = nil, height: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_constraint_guide_get_nat_size(constraint_guide_ptr, width, height)
        
    }

    /// Retrieves the strength set using `gtk_constraint_guide_set_strength()`.
    @inlinable func getStrength() -> GtkConstraintStrength {
        let result = gtk_constraint_guide_get_strength(constraint_guide_ptr)
        let rv = result
        return rv
    }

    /// Sets the maximum size of `guide`.
    /// 
    /// If `guide` is attached to a `GtkConstraintLayout`,
    /// the constraints will be updated to reflect the new size.
    @inlinable func setMaxSize(width: Int, height: Int) {
        
        gtk_constraint_guide_set_max_size(constraint_guide_ptr, gint(width), gint(height))
        
    }

    /// Sets the minimum size of `guide`.
    /// 
    /// If `guide` is attached to a `GtkConstraintLayout`,
    /// the constraints will be updated to reflect the new size.
    @inlinable func setMinSize(width: Int, height: Int) {
        
        gtk_constraint_guide_set_min_size(constraint_guide_ptr, gint(width), gint(height))
        
    }

    /// Sets a name for the given `GtkConstraintGuide`.
    /// 
    /// The name is useful for debugging purposes.
    @inlinable func set(name: UnsafePointer<CChar>? = nil) {
        
        gtk_constraint_guide_set_name(constraint_guide_ptr, name)
        
    }

    /// Sets the natural size of `guide`.
    /// 
    /// If `guide` is attached to a `GtkConstraintLayout`,
    /// the constraints will be updated to reflect the new size.
    @inlinable func setNatSize(width: Int, height: Int) {
        
        gtk_constraint_guide_set_nat_size(constraint_guide_ptr, gint(width), gint(height))
        
    }

    /// Sets the strength of the constraint on the natural size of the
    /// given `GtkConstraintGuide`.
    @inlinable func set(strength: GtkConstraintStrength) {
        
        gtk_constraint_guide_set_strength(constraint_guide_ptr, strength)
        
    }
    /// A name that identifies the `GtkConstraintGuide`, for debugging.
    @inlinable var name: String! {
        /// Retrieves the name set using `gtk_constraint_guide_set_name()`.
        get {
            let result = gtk_constraint_guide_get_name(constraint_guide_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
        /// Sets a name for the given `GtkConstraintGuide`.
        /// 
        /// The name is useful for debugging purposes.
        nonmutating set {
            gtk_constraint_guide_set_name(constraint_guide_ptr, newValue)
        }
    }

    /// The `GtkConstraintStrength` to be used for the constraint on
    /// the natural size of the guide.
    @inlinable var strength: GtkConstraintStrength {
        /// Retrieves the strength set using `gtk_constraint_guide_set_strength()`.
        get {
            let result = gtk_constraint_guide_get_strength(constraint_guide_ptr)
        let rv = result
            return rv
        }
        /// Sets the strength of the constraint on the natural size of the
        /// given `GtkConstraintGuide`.
        nonmutating set {
            gtk_constraint_guide_set_strength(constraint_guide_ptr, newValue)
        }
    }


}



// MARK: - ConstraintLayout Class

/// A layout manager using constraints to describe relations between widgets.
/// 
/// `GtkConstraintLayout` is a layout manager that uses relations between
/// widget attributes, expressed via [class`Gtk.Constraint`] instances, to
/// measure and allocate widgets.
/// 
/// ### How do constraints work
/// 
/// Constraints are objects defining the relationship between attributes
/// of a widget; you can read the description of the [class`Gtk.Constraint`]
/// class to have a more in depth definition.
/// 
/// By taking multiple constraints and applying them to the children of
/// a widget using `GtkConstraintLayout`, it's possible to describe
/// complex layout policies; each constraint applied to a child or to the parent
/// widgets contributes to the full description of the layout, in terms of
/// parameters for resolving the value of each attribute.
/// 
/// It is important to note that a layout is defined by the totality of
/// constraints; removing a child, or a constraint, from an existing layout
/// without changing the remaining constraints may result in an unstable
/// or unsolvable layout.
/// 
/// Constraints have an implicit "reading order"; you should start describing
/// each edge of each child, as well as their relationship with the parent
/// container, from the top left (or top right, in RTL languages), horizontally
/// first, and then vertically.
/// 
/// A constraint-based layout with too few constraints can become "unstable",
/// that is: have more than one solution. The behavior of an unstable layout
/// is undefined.
/// 
/// A constraint-based layout with conflicting constraints may be unsolvable,
/// and lead to an unstable layout. You can use the [property`Gtk.Constraint:strength`]
/// property of [class`Gtk.Constraint`] to "nudge" the layout towards a solution.
/// 
/// ### GtkConstraintLayout as GtkBuildable
/// 
/// `GtkConstraintLayout` implements the [iface`Gtk.Buildable`] interface and
/// has a custom "constraints" element which allows describing constraints in
/// a [class`Gtk.Builder`] UI file.
/// 
/// An example of a UI definition fragment specifying a constraint:
/// 
/// ```xml
///   &lt;object class="GtkConstraintLayout"&gt;
///     &lt;constraints&gt;
///       &lt;constraint target="button" target-attribute="start"
///                   relation="eq"
///                   source="super" source-attribute="start"
///                   constant="12"
///                   strength="required" /&gt;
///       &lt;constraint target="button" target-attribute="width"
///                   relation="ge"
///                   constant="250"
///                   strength="strong" /&gt;
///     &lt;/constraints&gt;
///   &lt;/object&gt;
/// ```
/// 
/// The definition above will add two constraints to the GtkConstraintLayout:
/// 
///  - a required constraint between the leading edge of "button" and
///    the leading edge of the widget using the constraint layout, plus
///    12 pixels
///  - a strong, constant constraint making the width of "button" greater
///    than, or equal to 250 pixels
/// 
/// The "target" and "target-attribute" attributes are required.
/// 
/// The "source" and "source-attribute" attributes of the "constraint"
/// element are optional; if they are not specified, the constraint is
/// assumed to be a constant.
/// 
/// The "relation" attribute is optional; if not specified, the constraint
/// is assumed to be an equality.
/// 
/// The "strength" attribute is optional; if not specified, the constraint
/// is assumed to be required.
/// 
/// The "source" and "target" attributes can be set to "super" to indicate
/// that the constraint target is the widget using the GtkConstraintLayout.
/// 
/// There can be "constant" and "multiplier" attributes.
/// 
/// Additionally, the "constraints" element can also contain a description
/// of the `GtkConstraintGuides` used by the layout:
/// 
/// ```xml
///   &lt;constraints&gt;
///     &lt;guide min-width="100" max-width="500" name="hspace"/&gt;
///     &lt;guide min-height="64" nat-height="128" name="vspace" strength="strong"/&gt;
///   &lt;/constraints&gt;
/// ```
/// 
/// The "guide" element has the following optional attributes:
/// 
///   - "min-width", "nat-width", and "max-width", describe the minimum,
///     natural, and maximum width of the guide, respectively
///   - "min-height", "nat-height", and "max-height", describe the minimum,
///     natural, and maximum height of the guide, respectively
///   - "strength" describes the strength of the constraint on the natural
///     size of the guide; if not specified, the constraint is assumed to
///     have a medium strength
///   - "name" describes a name for the guide, useful when debugging
/// 
/// ### Using the Visual Format Language
/// 
/// Complex constraints can be described using a compact syntax called VFL,
/// or *Visual Format Language*.
/// 
/// The Visual Format Language describes all the constraints on a row or
/// column, typically starting from the leading edge towards the trailing
/// one. Each element of the layout is composed by "views", which identify
/// a [iface`Gtk.ConstraintTarget`].
/// 
/// For instance:
/// 
/// ```
///   [button]-[textField]
/// ```
/// 
/// Describes a constraint that binds the trailing edge of "button" to the
/// leading edge of "textField", leaving a default space between the two.
/// 
/// Using VFL is also possible to specify predicates that describe constraints
/// on attributes like width and height:
/// 
/// ```
///   // Width must be greater than, or equal to 50
///   [`button(>=50)`]
/// 
///   // Width of button1 must be equal to width of button2
///   [`button1(==button2)`]
/// ```
/// 
/// The default orientation for a VFL description is horizontal, unless
/// otherwise specified:
/// 
/// ```
///   // horizontal orientation, default attribute: width
///   H:[`button(>=150)`]
/// 
///   // vertical orientation, default attribute: height
///   V:[`button1(==button2)`]
/// ```
/// 
/// It's also possible to specify multiple predicates, as well as their
/// strength:
/// 
/// ```
///   // minimum width of button must be 150
///   // natural width of button can be 250
///   [`button(>=150@required, ==250@medium)`]
/// ```
/// 
/// Finally, it's also possible to use simple arithmetic operators:
/// 
/// ```
///   // width of button1 must be equal to width of button2
///   // divided by 2 plus 12
///   [`button1(button2 / 2 + 12)`]
/// ```
///
/// The `ConstraintLayoutProtocol` protocol exposes the methods and properties of an underlying `GtkConstraintLayout` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ConstraintLayout`.
/// Alternatively, use `ConstraintLayoutRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ConstraintLayoutProtocol: LayoutManagerProtocol, BuildableProtocol {
        /// Untyped pointer to the underlying `GtkConstraintLayout` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstraintLayout` instance.
    var constraint_layout_ptr: UnsafeMutablePointer<GtkConstraintLayout>! { get }

    /// Required Initialiser for types conforming to `ConstraintLayoutProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A layout manager using constraints to describe relations between widgets.
/// 
/// `GtkConstraintLayout` is a layout manager that uses relations between
/// widget attributes, expressed via [class`Gtk.Constraint`] instances, to
/// measure and allocate widgets.
/// 
/// ### How do constraints work
/// 
/// Constraints are objects defining the relationship between attributes
/// of a widget; you can read the description of the [class`Gtk.Constraint`]
/// class to have a more in depth definition.
/// 
/// By taking multiple constraints and applying them to the children of
/// a widget using `GtkConstraintLayout`, it's possible to describe
/// complex layout policies; each constraint applied to a child or to the parent
/// widgets contributes to the full description of the layout, in terms of
/// parameters for resolving the value of each attribute.
/// 
/// It is important to note that a layout is defined by the totality of
/// constraints; removing a child, or a constraint, from an existing layout
/// without changing the remaining constraints may result in an unstable
/// or unsolvable layout.
/// 
/// Constraints have an implicit "reading order"; you should start describing
/// each edge of each child, as well as their relationship with the parent
/// container, from the top left (or top right, in RTL languages), horizontally
/// first, and then vertically.
/// 
/// A constraint-based layout with too few constraints can become "unstable",
/// that is: have more than one solution. The behavior of an unstable layout
/// is undefined.
/// 
/// A constraint-based layout with conflicting constraints may be unsolvable,
/// and lead to an unstable layout. You can use the [property`Gtk.Constraint:strength`]
/// property of [class`Gtk.Constraint`] to "nudge" the layout towards a solution.
/// 
/// ### GtkConstraintLayout as GtkBuildable
/// 
/// `GtkConstraintLayout` implements the [iface`Gtk.Buildable`] interface and
/// has a custom "constraints" element which allows describing constraints in
/// a [class`Gtk.Builder`] UI file.
/// 
/// An example of a UI definition fragment specifying a constraint:
/// 
/// ```xml
///   &lt;object class="GtkConstraintLayout"&gt;
///     &lt;constraints&gt;
///       &lt;constraint target="button" target-attribute="start"
///                   relation="eq"
///                   source="super" source-attribute="start"
///                   constant="12"
///                   strength="required" /&gt;
///       &lt;constraint target="button" target-attribute="width"
///                   relation="ge"
///                   constant="250"
///                   strength="strong" /&gt;
///     &lt;/constraints&gt;
///   &lt;/object&gt;
/// ```
/// 
/// The definition above will add two constraints to the GtkConstraintLayout:
/// 
///  - a required constraint between the leading edge of "button" and
///    the leading edge of the widget using the constraint layout, plus
///    12 pixels
///  - a strong, constant constraint making the width of "button" greater
///    than, or equal to 250 pixels
/// 
/// The "target" and "target-attribute" attributes are required.
/// 
/// The "source" and "source-attribute" attributes of the "constraint"
/// element are optional; if they are not specified, the constraint is
/// assumed to be a constant.
/// 
/// The "relation" attribute is optional; if not specified, the constraint
/// is assumed to be an equality.
/// 
/// The "strength" attribute is optional; if not specified, the constraint
/// is assumed to be required.
/// 
/// The "source" and "target" attributes can be set to "super" to indicate
/// that the constraint target is the widget using the GtkConstraintLayout.
/// 
/// There can be "constant" and "multiplier" attributes.
/// 
/// Additionally, the "constraints" element can also contain a description
/// of the `GtkConstraintGuides` used by the layout:
/// 
/// ```xml
///   &lt;constraints&gt;
///     &lt;guide min-width="100" max-width="500" name="hspace"/&gt;
///     &lt;guide min-height="64" nat-height="128" name="vspace" strength="strong"/&gt;
///   &lt;/constraints&gt;
/// ```
/// 
/// The "guide" element has the following optional attributes:
/// 
///   - "min-width", "nat-width", and "max-width", describe the minimum,
///     natural, and maximum width of the guide, respectively
///   - "min-height", "nat-height", and "max-height", describe the minimum,
///     natural, and maximum height of the guide, respectively
///   - "strength" describes the strength of the constraint on the natural
///     size of the guide; if not specified, the constraint is assumed to
///     have a medium strength
///   - "name" describes a name for the guide, useful when debugging
/// 
/// ### Using the Visual Format Language
/// 
/// Complex constraints can be described using a compact syntax called VFL,
/// or *Visual Format Language*.
/// 
/// The Visual Format Language describes all the constraints on a row or
/// column, typically starting from the leading edge towards the trailing
/// one. Each element of the layout is composed by "views", which identify
/// a [iface`Gtk.ConstraintTarget`].
/// 
/// For instance:
/// 
/// ```
///   [button]-[textField]
/// ```
/// 
/// Describes a constraint that binds the trailing edge of "button" to the
/// leading edge of "textField", leaving a default space between the two.
/// 
/// Using VFL is also possible to specify predicates that describe constraints
/// on attributes like width and height:
/// 
/// ```
///   // Width must be greater than, or equal to 50
///   [`button(>=50)`]
/// 
///   // Width of button1 must be equal to width of button2
///   [`button1(==button2)`]
/// ```
/// 
/// The default orientation for a VFL description is horizontal, unless
/// otherwise specified:
/// 
/// ```
///   // horizontal orientation, default attribute: width
///   H:[`button(>=150)`]
/// 
///   // vertical orientation, default attribute: height
///   V:[`button1(==button2)`]
/// ```
/// 
/// It's also possible to specify multiple predicates, as well as their
/// strength:
/// 
/// ```
///   // minimum width of button must be 150
///   // natural width of button can be 250
///   [`button(>=150@required, ==250@medium)`]
/// ```
/// 
/// Finally, it's also possible to use simple arithmetic operators:
/// 
/// ```
///   // width of button1 must be equal to width of button2
///   // divided by 2 plus 12
///   [`button1(button2 / 2 + 12)`]
/// ```
///
/// The `ConstraintLayoutRef` type acts as a lightweight Swift reference to an underlying `GtkConstraintLayout` instance.
/// It exposes methods that can operate on this data type through `ConstraintLayoutProtocol` conformance.
/// Use `ConstraintLayoutRef` only as an `unowned` reference to an existing `GtkConstraintLayout` instance.
///
public struct ConstraintLayoutRef: ConstraintLayoutProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkConstraintLayout` instance.
    /// For type-safe access, use the generated, typed pointer `constraint_layout_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstraintLayoutRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstraintLayout>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstraintLayout>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstraintLayout>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstraintLayout>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstraintLayoutProtocol`
    @inlinable init<T: ConstraintLayoutProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ConstraintLayoutProtocol>(_ other: T) -> ConstraintLayoutRef { ConstraintLayoutRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkConstraintLayout` layout manager.
    @inlinable init() {
            let result = gtk_constraint_layout_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// A layout manager using constraints to describe relations between widgets.
/// 
/// `GtkConstraintLayout` is a layout manager that uses relations between
/// widget attributes, expressed via [class`Gtk.Constraint`] instances, to
/// measure and allocate widgets.
/// 
/// ### How do constraints work
/// 
/// Constraints are objects defining the relationship between attributes
/// of a widget; you can read the description of the [class`Gtk.Constraint`]
/// class to have a more in depth definition.
/// 
/// By taking multiple constraints and applying them to the children of
/// a widget using `GtkConstraintLayout`, it's possible to describe
/// complex layout policies; each constraint applied to a child or to the parent
/// widgets contributes to the full description of the layout, in terms of
/// parameters for resolving the value of each attribute.
/// 
/// It is important to note that a layout is defined by the totality of
/// constraints; removing a child, or a constraint, from an existing layout
/// without changing the remaining constraints may result in an unstable
/// or unsolvable layout.
/// 
/// Constraints have an implicit "reading order"; you should start describing
/// each edge of each child, as well as their relationship with the parent
/// container, from the top left (or top right, in RTL languages), horizontally
/// first, and then vertically.
/// 
/// A constraint-based layout with too few constraints can become "unstable",
/// that is: have more than one solution. The behavior of an unstable layout
/// is undefined.
/// 
/// A constraint-based layout with conflicting constraints may be unsolvable,
/// and lead to an unstable layout. You can use the [property`Gtk.Constraint:strength`]
/// property of [class`Gtk.Constraint`] to "nudge" the layout towards a solution.
/// 
/// ### GtkConstraintLayout as GtkBuildable
/// 
/// `GtkConstraintLayout` implements the [iface`Gtk.Buildable`] interface and
/// has a custom "constraints" element which allows describing constraints in
/// a [class`Gtk.Builder`] UI file.
/// 
/// An example of a UI definition fragment specifying a constraint:
/// 
/// ```xml
///   &lt;object class="GtkConstraintLayout"&gt;
///     &lt;constraints&gt;
///       &lt;constraint target="button" target-attribute="start"
///                   relation="eq"
///                   source="super" source-attribute="start"
///                   constant="12"
///                   strength="required" /&gt;
///       &lt;constraint target="button" target-attribute="width"
///                   relation="ge"
///                   constant="250"
///                   strength="strong" /&gt;
///     &lt;/constraints&gt;
///   &lt;/object&gt;
/// ```
/// 
/// The definition above will add two constraints to the GtkConstraintLayout:
/// 
///  - a required constraint between the leading edge of "button" and
///    the leading edge of the widget using the constraint layout, plus
///    12 pixels
///  - a strong, constant constraint making the width of "button" greater
///    than, or equal to 250 pixels
/// 
/// The "target" and "target-attribute" attributes are required.
/// 
/// The "source" and "source-attribute" attributes of the "constraint"
/// element are optional; if they are not specified, the constraint is
/// assumed to be a constant.
/// 
/// The "relation" attribute is optional; if not specified, the constraint
/// is assumed to be an equality.
/// 
/// The "strength" attribute is optional; if not specified, the constraint
/// is assumed to be required.
/// 
/// The "source" and "target" attributes can be set to "super" to indicate
/// that the constraint target is the widget using the GtkConstraintLayout.
/// 
/// There can be "constant" and "multiplier" attributes.
/// 
/// Additionally, the "constraints" element can also contain a description
/// of the `GtkConstraintGuides` used by the layout:
/// 
/// ```xml
///   &lt;constraints&gt;
///     &lt;guide min-width="100" max-width="500" name="hspace"/&gt;
///     &lt;guide min-height="64" nat-height="128" name="vspace" strength="strong"/&gt;
///   &lt;/constraints&gt;
/// ```
/// 
/// The "guide" element has the following optional attributes:
/// 
///   - "min-width", "nat-width", and "max-width", describe the minimum,
///     natural, and maximum width of the guide, respectively
///   - "min-height", "nat-height", and "max-height", describe the minimum,
///     natural, and maximum height of the guide, respectively
///   - "strength" describes the strength of the constraint on the natural
///     size of the guide; if not specified, the constraint is assumed to
///     have a medium strength
///   - "name" describes a name for the guide, useful when debugging
/// 
/// ### Using the Visual Format Language
/// 
/// Complex constraints can be described using a compact syntax called VFL,
/// or *Visual Format Language*.
/// 
/// The Visual Format Language describes all the constraints on a row or
/// column, typically starting from the leading edge towards the trailing
/// one. Each element of the layout is composed by "views", which identify
/// a [iface`Gtk.ConstraintTarget`].
/// 
/// For instance:
/// 
/// ```
///   [button]-[textField]
/// ```
/// 
/// Describes a constraint that binds the trailing edge of "button" to the
/// leading edge of "textField", leaving a default space between the two.
/// 
/// Using VFL is also possible to specify predicates that describe constraints
/// on attributes like width and height:
/// 
/// ```
///   // Width must be greater than, or equal to 50
///   [`button(>=50)`]
/// 
///   // Width of button1 must be equal to width of button2
///   [`button1(==button2)`]
/// ```
/// 
/// The default orientation for a VFL description is horizontal, unless
/// otherwise specified:
/// 
/// ```
///   // horizontal orientation, default attribute: width
///   H:[`button(>=150)`]
/// 
///   // vertical orientation, default attribute: height
///   V:[`button1(==button2)`]
/// ```
/// 
/// It's also possible to specify multiple predicates, as well as their
/// strength:
/// 
/// ```
///   // minimum width of button must be 150
///   // natural width of button can be 250
///   [`button(>=150@required, ==250@medium)`]
/// ```
/// 
/// Finally, it's also possible to use simple arithmetic operators:
/// 
/// ```
///   // width of button1 must be equal to width of button2
///   // divided by 2 plus 12
///   [`button1(button2 / 2 + 12)`]
/// ```
///
/// The `ConstraintLayout` type acts as a reference-counted owner of an underlying `GtkConstraintLayout` instance.
/// It provides the methods that can operate on this data type through `ConstraintLayoutProtocol` conformance.
/// Use `ConstraintLayout` as a strong reference or owner of a `GtkConstraintLayout` instance.
///
open class ConstraintLayout: LayoutManager, ConstraintLayoutProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkConstraintLayout>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkConstraintLayout>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkConstraintLayout>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkConstraintLayout>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkConstraintLayout`.
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkConstraintLayout>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ConstraintLayoutProtocol`
    /// Will retain `GtkConstraintLayout`.
    /// - Parameter other: an instance of a related type that implements `ConstraintLayoutProtocol`
    @inlinable public init<T: ConstraintLayoutProtocol>(constraintLayout other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkConstraintLayout` layout manager.
    @inlinable public init() {
            let result = gtk_constraint_layout_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no ConstraintLayout properties

public enum ConstraintLayoutSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: ConstraintLayout has no signals
// MARK: ConstraintLayout Class: ConstraintLayoutProtocol extension (methods and fields)
public extension ConstraintLayoutProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstraintLayout` instance.
    @inlinable var constraint_layout_ptr: UnsafeMutablePointer<GtkConstraintLayout>! { return ptr?.assumingMemoryBound(to: GtkConstraintLayout.self) }

    /// Adds a constraint to the layout manager.
    /// 
    /// The [property`Gtk.Constraint:source`] and [property`Gtk.Constraint:target`]
    /// properties of `constraint` can be:
    /// 
    ///  - set to `NULL` to indicate that the constraint refers to the
    ///    widget using `layout`
    ///  - set to the [class`Gtk.Widget`] using `layout`
    ///  - set to a child of the [class`Gtk.Widget`] using `layout`
    ///  - set to a [class`Gtk.ConstraintGuide`] that is part of `layout`
    /// 
    /// The `layout` acquires the ownership of `constraint` after calling
    /// this function.
    @inlinable func add<ConstraintT: ConstraintProtocol>(constraint: ConstraintT) {
        
        gtk_constraint_layout_add_constraint(constraint_layout_ptr, constraint.constraint_ptr)
        
    }


    // *** addConstraintsFromDescription() is not available because it has a varargs (...) parameter!


    /// Creates a list of constraints from a VFL description.
    /// 
    /// The Visual Format Language, VFL, is based on Apple's AutoLayout [VFL](https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html).
    /// 
    /// The `views` dictionary is used to match [iface`Gtk.ConstraintTarget`]
    /// instances to the symbolic view name inside the VFL.
    /// 
    /// The VFL grammar is:
    /// 
    /// ```
    ///        &lt;visualFormatString&gt; = (&lt;orientation&gt;)?
    ///                               (&lt;superview&gt;&lt;connection&gt;)?
    ///                               &lt;view&gt;`(<connection><view>)`*
    ///                               (&lt;connection&gt;&lt;superview&gt;)?
    ///               &lt;orientation&gt; = 'H' | 'V'
    ///                 &lt;superview&gt; = '|'
    ///                &lt;connection&gt; = '' | '-' &lt;predicateList&gt; '-' | '-'
    ///             &lt;predicateList&gt; = &lt;simplePredicate&gt; | &lt;predicateListWithParens&gt;
    ///           &lt;simplePredicate&gt; = &lt;metricName&gt; | &lt;positiveNumber&gt;
    ///   &lt;predicateListWithParens&gt; = '(' &lt;predicate&gt; (',' &lt;predicate&gt;)* ')'
    ///                 &lt;predicate&gt; = (&lt;relation&gt;)? &lt;objectOfPredicate&gt; (&lt;operatorList&gt;)? ('@' &lt;priority&gt;)?
    ///                  &lt;relation&gt; = '==' | '&lt;=' | '&gt;='
    ///         &lt;objectOfPredicate&gt; = &lt;constant&gt; | &lt;viewName&gt; | ('.' &lt;attributeName&gt;)?
    ///                  &lt;priority&gt; = &lt;positiveNumber&gt; | 'required' | 'strong' | 'medium' | 'weak'
    ///                  &lt;constant&gt; = &lt;number&gt;
    ///              &lt;operatorList&gt; = (&lt;multiplyOperator&gt;)? (&lt;addOperator&gt;)?
    ///          &lt;multiplyOperator&gt; = [ '*' | '/' ] &lt;positiveNumber&gt;
    ///               &lt;addOperator&gt; = [ '+' | '-' ] &lt;positiveNumber&gt;
    ///                  &lt;viewName&gt; = [A-Za-z_]([A-Za-z0-9_]*) // A C identifier
    ///                &lt;metricName&gt; = [A-Za-z_]([A-Za-z0-9_]*) // A C identifier
    ///             &lt;attributeName&gt; = 'top' | 'bottom' | 'left' | 'right' | 'width' | 'height' |
    ///                               'start' | 'end' | 'centerX' | 'centerY' | 'baseline'
    ///            &lt;positiveNumber&gt; // A positive real number parseable by `g_ascii_strtod()`
    ///                    &lt;number&gt; // A real number parseable by `g_ascii_strtod()`
    /// ```
    /// 
    /// **Note**: The VFL grammar used by GTK is slightly different than the one
    /// defined by Apple, as it can use symbolic values for the constraint's
    /// strength instead of numeric values; additionally, GTK allows adding
    /// simple arithmetic operations inside predicates.
    /// 
    /// Examples of VFL descriptions are:
    /// 
    /// ```
    ///   // Default spacing
    ///   [button]-[textField]
    /// 
    ///   // Width constraint
    ///   [`button(>=50)`]
    /// 
    ///   // Connection to super view
    ///   |-50-[purpleBox]-50-|
    /// 
    ///   // Vertical layout
    ///   V:[topField]-10-[bottomField]
    /// 
    ///   // Flush views
    ///   [maroonView](#blueView)
    /// 
    ///   // Priority
    ///   [`button(100@strong)`]
    /// 
    ///   // Equal widths
    ///   [`button1(==button2)`]
    /// 
    ///   // Multiple predicates
    ///   [`flexibleButton(>=70,<=100)`]
    /// 
    ///   // A complete line of layout
    ///   |-[find]-[findNext]-[`findField(>=20)`]-|
    /// 
    ///   // Operators
    ///   [`button1(button2 / 3 + 50)`]
    /// 
    ///   // Named attributes
    ///   [`button1(==button2.height)`]
    /// ```
    @inlinable func addConstraintsFromDescriptionv<GLibHashTableT: GLib.HashTableProtocol>(lines: UnsafePointer<UnsafePointer<CChar>?>!, nLines: Int, hspacing: Int, vspacing: Int, views: GLibHashTableT) throws -> GLib.ListRef! {
        var error: UnsafeMutablePointer<GError>?
        let result = gtk_constraint_layout_add_constraints_from_descriptionv(constraint_layout_ptr, lines, gsize(nLines), gint(hspacing), gint(vspacing), views.hash_table_ptr, &error)
        if let error = error { throw GLibError(error) }
        let rv = GLib.ListRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Adds a guide to `layout`.
    /// 
    /// A guide can be used as the source or target of constraints,
    /// like a widget, but it is not visible.
    /// 
    /// The `layout` acquires the ownership of `guide` after calling
    /// this function.
    @inlinable func add<ConstraintGuideT: ConstraintGuideProtocol>(guide: ConstraintGuideT) {
        
        gtk_constraint_layout_add_guide(constraint_layout_ptr, guide.constraint_guide_ptr)
        
    }

    /// Returns a `GListModel` to track the constraints that are
    /// part of the layout.
    /// 
    /// Calling this function will enable extra internal bookkeeping
    /// to track constraints and emit signals on the returned listmodel.
    /// It may slow down operations a lot.
    /// 
    /// Applications should try hard to avoid calling this function
    /// because of the slowdowns.
    @inlinable func observeConstraints() -> GIO.ListModelRef! {
        let result = gtk_constraint_layout_observe_constraints(constraint_layout_ptr)
        let rv = GIO.ListModelRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns a `GListModel` to track the guides that are
    /// part of the layout.
    /// 
    /// Calling this function will enable extra internal bookkeeping
    /// to track guides and emit signals on the returned listmodel.
    /// It may slow down operations a lot.
    /// 
    /// Applications should try hard to avoid calling this function
    /// because of the slowdowns.
    @inlinable func observeGuides() -> GIO.ListModelRef! {
        let result = gtk_constraint_layout_observe_guides(constraint_layout_ptr)
        let rv = GIO.ListModelRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Removes all constraints from the layout manager.
    @inlinable func removeAllConstraints() {
        
        gtk_constraint_layout_remove_all_constraints(constraint_layout_ptr)
        
    }

    /// Removes `constraint` from the layout manager,
    /// so that it no longer influences the layout.
    @inlinable func remove<ConstraintT: ConstraintProtocol>(constraint: ConstraintT) {
        
        gtk_constraint_layout_remove_constraint(constraint_layout_ptr, constraint.constraint_ptr)
        
    }

    /// Removes `guide` from the layout manager,
    /// so that it no longer influences the layout.
    @inlinable func remove<ConstraintGuideT: ConstraintGuideProtocol>(guide: ConstraintGuideT) {
        
        gtk_constraint_layout_remove_guide(constraint_layout_ptr, guide.constraint_guide_ptr)
        
    }


}



// MARK: - ConstraintLayoutChild Class

/// `GtkLayoutChild` subclass for children in a `GtkConstraintLayout`.
///
/// The `ConstraintLayoutChildProtocol` protocol exposes the methods and properties of an underlying `GtkConstraintLayoutChild` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ConstraintLayoutChild`.
/// Alternatively, use `ConstraintLayoutChildRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ConstraintLayoutChildProtocol: LayoutChildProtocol {
        /// Untyped pointer to the underlying `GtkConstraintLayoutChild` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstraintLayoutChild` instance.
    var constraint_layout_child_ptr: UnsafeMutablePointer<GtkConstraintLayoutChild>! { get }

    /// Required Initialiser for types conforming to `ConstraintLayoutChildProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkLayoutChild` subclass for children in a `GtkConstraintLayout`.
///
/// The `ConstraintLayoutChildRef` type acts as a lightweight Swift reference to an underlying `GtkConstraintLayoutChild` instance.
/// It exposes methods that can operate on this data type through `ConstraintLayoutChildProtocol` conformance.
/// Use `ConstraintLayoutChildRef` only as an `unowned` reference to an existing `GtkConstraintLayoutChild` instance.
///
public struct ConstraintLayoutChildRef: ConstraintLayoutChildProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkConstraintLayoutChild` instance.
    /// For type-safe access, use the generated, typed pointer `constraint_layout_child_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstraintLayoutChildRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstraintLayoutChild>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstraintLayoutChild>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstraintLayoutChild>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstraintLayoutChild>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstraintLayoutChildProtocol`
    @inlinable init<T: ConstraintLayoutChildProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ConstraintLayoutChildProtocol>(_ other: T) -> ConstraintLayoutChildRef { ConstraintLayoutChildRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// `GtkLayoutChild` subclass for children in a `GtkConstraintLayout`.
///
/// The `ConstraintLayoutChild` type acts as a reference-counted owner of an underlying `GtkConstraintLayoutChild` instance.
/// It provides the methods that can operate on this data type through `ConstraintLayoutChildProtocol` conformance.
/// Use `ConstraintLayoutChild` as a strong reference or owner of a `GtkConstraintLayoutChild` instance.
///
open class ConstraintLayoutChild: LayoutChild, ConstraintLayoutChildProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkConstraintLayoutChild>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkConstraintLayoutChild>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkConstraintLayoutChild>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkConstraintLayoutChild>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkConstraintLayoutChild`.
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkConstraintLayoutChild>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ConstraintLayoutChildProtocol`
    /// Will retain `GtkConstraintLayoutChild`.
    /// - Parameter other: an instance of a related type that implements `ConstraintLayoutChildProtocol`
    @inlinable public init<T: ConstraintLayoutChildProtocol>(constraintLayoutChild other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum ConstraintLayoutChildPropertyName: String, PropertyNameProtocol {
    /// The widget that is associated to the `GtkLayoutChild` instance.
    case childWidget = "child-widget"
    /// The layout manager that created the `GtkLayoutChild` instance.
    case layoutManager = "layout-manager"
}

public extension ConstraintLayoutChildProtocol {
    /// Bind a `ConstraintLayoutChildPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ConstraintLayoutChildPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ConstraintLayoutChild property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ConstraintLayoutChildPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ConstraintLayoutChild property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ConstraintLayoutChildPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ConstraintLayoutChildSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The widget that is associated to the `GtkLayoutChild` instance.
    case notifyChildWidget = "notify::child-widget"
    /// The layout manager that created the `GtkLayoutChild` instance.
    case notifyLayoutManager = "notify::layout-manager"
}

// MARK: ConstraintLayoutChild has no signals
// MARK: ConstraintLayoutChild Class: ConstraintLayoutChildProtocol extension (methods and fields)
public extension ConstraintLayoutChildProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstraintLayoutChild` instance.
    @inlinable var constraint_layout_child_ptr: UnsafeMutablePointer<GtkConstraintLayoutChild>! { return ptr?.assumingMemoryBound(to: GtkConstraintLayoutChild.self) }



}



// MARK: - CssProvider Class

/// `GtkCssProvider` is an object implementing the `GtkStyleProvider` interface
/// for CSS.
/// 
/// It is able to parse CSS-like input in order to style widgets.
/// 
/// An application can make GTK parse a specific CSS style sheet by calling
/// [method`Gtk.CssProvider.load_from_file`] or
/// [method`Gtk.CssProvider.load_from_resource`]
/// and adding the provider with [method`Gtk.StyleContext.add_provider`] or
/// [func`Gtk.StyleContext.add_provider_for_display`].
/// 
/// In addition, certain files will be read when GTK is initialized.
/// First, the file `$XDG_CONFIG_HOME/gtk-4.0/gtk.css` is loaded if it
/// exists. Then, GTK loads the first existing file among
/// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// `$HOME/.themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk-VARIANT.css` and
/// `DATADIR/share/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// where `THEME` is the name of the current theme (see the
/// [property`Gtk.Settings:gtk-theme-name`] setting), `VARIANT` is the
/// variant to load (see the
/// [property`Gtk.Settings:gtk-application-prefer-dark-theme`] setting),
/// `DATADIR` is the prefix configured when GTK was compiled (unless
/// overridden by the `GTK_DATA_PREFIX` environment variable), and
/// `VERSION` is the GTK version number. If no file is found for the
/// current version, GTK tries older versions all the way back to 4.0.
/// 
/// To track errors while loading CSS, connect to the
/// [signal`Gtk.CssProvider::parsing-error`] signal.
///
/// The `CssProviderProtocol` protocol exposes the methods and properties of an underlying `GtkCssProvider` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CssProvider`.
/// Alternatively, use `CssProviderRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CssProviderProtocol: GLibObject.ObjectProtocol, StyleProviderProtocol {
        /// Untyped pointer to the underlying `GtkCssProvider` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCssProvider` instance.
    var css_provider_ptr: UnsafeMutablePointer<GtkCssProvider>! { get }

    /// Required Initialiser for types conforming to `CssProviderProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkCssProvider` is an object implementing the `GtkStyleProvider` interface
/// for CSS.
/// 
/// It is able to parse CSS-like input in order to style widgets.
/// 
/// An application can make GTK parse a specific CSS style sheet by calling
/// [method`Gtk.CssProvider.load_from_file`] or
/// [method`Gtk.CssProvider.load_from_resource`]
/// and adding the provider with [method`Gtk.StyleContext.add_provider`] or
/// [func`Gtk.StyleContext.add_provider_for_display`].
/// 
/// In addition, certain files will be read when GTK is initialized.
/// First, the file `$XDG_CONFIG_HOME/gtk-4.0/gtk.css` is loaded if it
/// exists. Then, GTK loads the first existing file among
/// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// `$HOME/.themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk-VARIANT.css` and
/// `DATADIR/share/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// where `THEME` is the name of the current theme (see the
/// [property`Gtk.Settings:gtk-theme-name`] setting), `VARIANT` is the
/// variant to load (see the
/// [property`Gtk.Settings:gtk-application-prefer-dark-theme`] setting),
/// `DATADIR` is the prefix configured when GTK was compiled (unless
/// overridden by the `GTK_DATA_PREFIX` environment variable), and
/// `VERSION` is the GTK version number. If no file is found for the
/// current version, GTK tries older versions all the way back to 4.0.
/// 
/// To track errors while loading CSS, connect to the
/// [signal`Gtk.CssProvider::parsing-error`] signal.
///
/// The `CssProviderRef` type acts as a lightweight Swift reference to an underlying `GtkCssProvider` instance.
/// It exposes methods that can operate on this data type through `CssProviderProtocol` conformance.
/// Use `CssProviderRef` only as an `unowned` reference to an existing `GtkCssProvider` instance.
///
public struct CssProviderRef: CssProviderProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCssProvider` instance.
    /// For type-safe access, use the generated, typed pointer `css_provider_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CssProviderRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCssProvider>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCssProvider>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCssProvider>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCssProvider>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CssProviderProtocol`
    @inlinable init<T: CssProviderProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CssProviderProtocol>(_ other: T) -> CssProviderRef { CssProviderRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Returns a newly created `GtkCssProvider`.
    @inlinable init() {
            let result = gtk_css_provider_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkCssProvider` is an object implementing the `GtkStyleProvider` interface
/// for CSS.
/// 
/// It is able to parse CSS-like input in order to style widgets.
/// 
/// An application can make GTK parse a specific CSS style sheet by calling
/// [method`Gtk.CssProvider.load_from_file`] or
/// [method`Gtk.CssProvider.load_from_resource`]
/// and adding the provider with [method`Gtk.StyleContext.add_provider`] or
/// [func`Gtk.StyleContext.add_provider_for_display`].
/// 
/// In addition, certain files will be read when GTK is initialized.
/// First, the file `$XDG_CONFIG_HOME/gtk-4.0/gtk.css` is loaded if it
/// exists. Then, GTK loads the first existing file among
/// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// `$HOME/.themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk-VARIANT.css` and
/// `DATADIR/share/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// where `THEME` is the name of the current theme (see the
/// [property`Gtk.Settings:gtk-theme-name`] setting), `VARIANT` is the
/// variant to load (see the
/// [property`Gtk.Settings:gtk-application-prefer-dark-theme`] setting),
/// `DATADIR` is the prefix configured when GTK was compiled (unless
/// overridden by the `GTK_DATA_PREFIX` environment variable), and
/// `VERSION` is the GTK version number. If no file is found for the
/// current version, GTK tries older versions all the way back to 4.0.
/// 
/// To track errors while loading CSS, connect to the
/// [signal`Gtk.CssProvider::parsing-error`] signal.
///
/// The `CssProvider` type acts as a reference-counted owner of an underlying `GtkCssProvider` instance.
/// It provides the methods that can operate on this data type through `CssProviderProtocol` conformance.
/// Use `CssProvider` as a strong reference or owner of a `GtkCssProvider` instance.
///
open class CssProvider: GLibObject.Object, CssProviderProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCssProvider>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCssProvider>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCssProvider>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCssProvider>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCssProvider`.
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCssProvider>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CssProviderProtocol`
    /// Will retain `GtkCssProvider`.
    /// - Parameter other: an instance of a related type that implements `CssProviderProtocol`
    @inlinable public init<T: CssProviderProtocol>(cssProvider other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Returns a newly created `GtkCssProvider`.
    @inlinable public init() {
            let result = gtk_css_provider_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no CssProvider properties

public enum CssProviderSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Signals that a parsing error occurred.
    /// 
    /// The `path`, `line` and `position` describe the actual location of
    /// the error as accurately as possible.
    /// 
    /// Parsing errors are never fatal, so the parsing will resume after
    /// the error. Errors may however cause parts of the given data or
    /// even all of it to not be parsed at all. So it is a useful idea
    /// to check that the parsing succeeds by connecting to this signal.
    /// 
    /// Note that this signal may be emitted at any time as the css provider
    /// may opt to defer parsing parts or all of the input to a later time
    /// than when a loading function was called.
    case parsingError = "parsing-error"

}

// MARK: CssProvider signals
public extension CssProviderProtocol {
    /// Connect a Swift signal handler to the given, typed `CssProviderSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CssProviderSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `CssProviderSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CssProviderSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Signals that a parsing error occurred.
    /// 
    /// The `path`, `line` and `position` describe the actual location of
    /// the error as accurately as possible.
    /// 
    /// Parsing errors are never fatal, so the parsing will resume after
    /// the error. Errors may however cause parts of the given data or
    /// even all of it to not be parsed at all. So it is a useful idea
    /// to check that the parsing succeeds by connecting to this signal.
    /// 
    /// Note that this signal may be emitted at any time as the css provider
    /// may opt to defer parsing parts or all of the input to a later time
    /// than when a loading function was called.
    /// - Note: This represents the underlying `parsing-error` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter section: section the error happened in
    /// - Parameter error: The parsing error
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `parsingError` signal is emitted
    @discardableResult @inlinable func onParsingError(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CssProviderRef, _ section: CssSectionRef, _ error: GLib.ErrorRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(CssProviderRef, CssSectionRef, GLib.ErrorRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((CssProviderRef(raw: unownedSelf), CssSectionRef(raw: arg1), GLib.ErrorRef(raw: arg2)))
            return output
        }
        return connect(
            signal: .parsingError,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `parsing-error` signal for using the `connect(signal:)` methods
    static var parsingErrorSignal: CssProviderSignalName { .parsingError }
    
    
}

// MARK: CssProvider Class: CssProviderProtocol extension (methods and fields)
public extension CssProviderProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCssProvider` instance.
    @inlinable var css_provider_ptr: UnsafeMutablePointer<GtkCssProvider>! { return ptr?.assumingMemoryBound(to: GtkCssProvider.self) }

    /// Loads `data` into `css_provider`.
    /// 
    /// This clears any previously loaded information.
    @inlinable func load(from data: UnsafePointer<CChar>!, length: gssize) {
        
        gtk_css_provider_load_from_data(css_provider_ptr, data, length)
        
    }

    /// Loads the data contained in `file` into `css_provider`.
    /// 
    /// This clears any previously loaded information.
    @inlinable func load<GIOFileT: GIO.FileProtocol>(from file: GIOFileT) {
        
        gtk_css_provider_load_from_file(css_provider_ptr, file.file_ptr)
        
    }

    /// Loads the data contained in `path` into `css_provider`.
    /// 
    /// This clears any previously loaded information.
    @inlinable func load(from path: UnsafePointer<CChar>!) {
        
        gtk_css_provider_load_from_path(css_provider_ptr, path)
        
    }

    /// Loads the data contained in the resource at `resource_path` into
    /// the `css_provider`.
    /// 
    /// This clears any previously loaded information.
    @inlinable func loadFromResource(resourcePath: UnsafePointer<CChar>!) {
        
        gtk_css_provider_load_from_resource(css_provider_ptr, resourcePath)
        
    }

    /// Loads a theme from the usual theme paths.
    /// 
    /// The actual process of finding the theme might change between
    /// releases, but it is guaranteed that this function uses the same
    /// mechanism to load the theme that GTK uses for loading its own theme.
    @inlinable func loadNamed(name: UnsafePointer<CChar>!, variant: UnsafePointer<CChar>? = nil) {
        
        gtk_css_provider_load_named(css_provider_ptr, name, variant)
        
    }

    /// Converts the `provider` into a string representation in CSS
    /// format.
    /// 
    /// Using [method`Gtk.CssProvider.load_from_data`] with the return
    /// value from this function on a new provider created with
    /// [ctor`Gtk.CssProvider.new`] will basically create a duplicate
    /// of this `provider`.
    @inlinable func toString() -> String! {
        let result = gtk_css_provider_to_string(css_provider_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    @inlinable var parentInstance: GObject {
        get {
            let rv = css_provider_ptr.pointee.parent_instance
    return rv
        }
    }

}



// MARK: - CustomFilter Class

/// `GtkCustomFilter` determines whether to include items with a callback.
///
/// The `CustomFilterProtocol` protocol exposes the methods and properties of an underlying `GtkCustomFilter` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CustomFilter`.
/// Alternatively, use `CustomFilterRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CustomFilterProtocol: FilterProtocol {
        /// Untyped pointer to the underlying `GtkCustomFilter` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCustomFilter` instance.
    var custom_filter_ptr: UnsafeMutablePointer<GtkCustomFilter>! { get }

    /// Required Initialiser for types conforming to `CustomFilterProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkCustomFilter` determines whether to include items with a callback.
///
/// The `CustomFilterRef` type acts as a lightweight Swift reference to an underlying `GtkCustomFilter` instance.
/// It exposes methods that can operate on this data type through `CustomFilterProtocol` conformance.
/// Use `CustomFilterRef` only as an `unowned` reference to an existing `GtkCustomFilter` instance.
///
public struct CustomFilterRef: CustomFilterProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCustomFilter` instance.
    /// For type-safe access, use the generated, typed pointer `custom_filter_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CustomFilterRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCustomFilter>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCustomFilter>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCustomFilter>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCustomFilter>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CustomFilterProtocol`
    @inlinable init<T: CustomFilterProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CustomFilterProtocol>(_ other: T) -> CustomFilterRef { CustomFilterRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new filter using the given `match_func` to filter
    /// items.
    /// 
    /// If `match_func` is `nil`, the filter matches all items.
    /// 
    /// If the filter func changes its filtering behavior,
    /// `gtk_filter_changed()` needs to be called.
    @inlinable init( matchFunc: GtkCustomFilterFunc? = nil, userData: gpointer? = nil, userDestroy: GDestroyNotify?) {
            let result = gtk_custom_filter_new(matchFunc, userData, userDestroy)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkCustomFilter` determines whether to include items with a callback.
///
/// The `CustomFilter` type acts as a reference-counted owner of an underlying `GtkCustomFilter` instance.
/// It provides the methods that can operate on this data type through `CustomFilterProtocol` conformance.
/// Use `CustomFilter` as a strong reference or owner of a `GtkCustomFilter` instance.
///
open class CustomFilter: Filter, CustomFilterProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCustomFilter>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCustomFilter>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCustomFilter>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCustomFilter>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCustomFilter`.
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCustomFilter>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CustomFilterProtocol`
    /// Will retain `GtkCustomFilter`.
    /// - Parameter other: an instance of a related type that implements `CustomFilterProtocol`
    @inlinable public init<T: CustomFilterProtocol>(customFilter other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new filter using the given `match_func` to filter
    /// items.
    /// 
    /// If `match_func` is `nil`, the filter matches all items.
    /// 
    /// If the filter func changes its filtering behavior,
    /// `gtk_filter_changed()` needs to be called.
    @inlinable public init( matchFunc: GtkCustomFilterFunc? = nil, userData: gpointer? = nil, userDestroy: GDestroyNotify?) {
            let result = gtk_custom_filter_new(matchFunc, userData, userDestroy)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no CustomFilter properties

public enum CustomFilterSignalName: String, SignalNameProtocol {
    /// Emitted whenever the filter changed.
    /// 
    /// Users of the filter should then check items again via
    /// [method`Gtk.Filter.match`].
    /// 
    /// `GtkFilterListModel` handles this signal automatically.
    /// 
    /// Depending on the `change` parameter, not all items need
    /// to be checked, but only some. Refer to the [enum`Gtk.FilterChange`]
    /// documentation for details.
    case changed = "changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: CustomFilter has no signals
// MARK: CustomFilter Class: CustomFilterProtocol extension (methods and fields)
public extension CustomFilterProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCustomFilter` instance.
    @inlinable var custom_filter_ptr: UnsafeMutablePointer<GtkCustomFilter>! { return ptr?.assumingMemoryBound(to: GtkCustomFilter.self) }

    /// Sets the function used for filtering items.
    /// 
    /// If `match_func` is `nil`, the filter matches all items.
    /// 
    /// If the filter func changes its filtering behavior,
    /// `gtk_filter_changed()` needs to be called.
    /// 
    /// If a previous function was set, its `user_destroy` will be
    /// called now.
    @inlinable func setFilterFunc(matchFunc: GtkCustomFilterFunc? = nil, userData: gpointer? = nil, userDestroy: GDestroyNotify?) {
        
        gtk_custom_filter_set_filter_func(custom_filter_ptr, matchFunc, userData, userDestroy)
        
    }


}



// MARK: - CustomLayout Class

/// `GtkCustomLayout` uses closures for size negotiation.
/// 
/// A `GtkCustomLayout `uses closures matching to the old `GtkWidget`
/// virtual functions for size negotiation, as a convenience API to
/// ease the porting towards the corresponding `GtkLayoutManager
/// virtual functions.
///
/// The `CustomLayoutProtocol` protocol exposes the methods and properties of an underlying `GtkCustomLayout` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CustomLayout`.
/// Alternatively, use `CustomLayoutRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CustomLayoutProtocol: LayoutManagerProtocol {
        /// Untyped pointer to the underlying `GtkCustomLayout` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCustomLayout` instance.
    var custom_layout_ptr: UnsafeMutablePointer<GtkCustomLayout>! { get }

    /// Required Initialiser for types conforming to `CustomLayoutProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkCustomLayout` uses closures for size negotiation.
/// 
/// A `GtkCustomLayout `uses closures matching to the old `GtkWidget`
/// virtual functions for size negotiation, as a convenience API to
/// ease the porting towards the corresponding `GtkLayoutManager
/// virtual functions.
///
/// The `CustomLayoutRef` type acts as a lightweight Swift reference to an underlying `GtkCustomLayout` instance.
/// It exposes methods that can operate on this data type through `CustomLayoutProtocol` conformance.
/// Use `CustomLayoutRef` only as an `unowned` reference to an existing `GtkCustomLayout` instance.
///
public struct CustomLayoutRef: CustomLayoutProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCustomLayout` instance.
    /// For type-safe access, use the generated, typed pointer `custom_layout_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CustomLayoutRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCustomLayout>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCustomLayout>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCustomLayout>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCustomLayout>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CustomLayoutProtocol`
    @inlinable init<T: CustomLayoutProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CustomLayoutProtocol>(_ other: T) -> CustomLayoutRef { CustomLayoutRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new legacy layout manager.
    /// 
    /// Legacy layout managers map to the old `GtkWidget` size negotiation
    /// virtual functions, and are meant to be used during the transition
    /// from layout containers to layout manager delegates.
    @inlinable init( requestMode: GtkCustomRequestModeFunc? = nil, measure: GtkCustomMeasureFunc?, allocate: GtkCustomAllocateFunc?) {
            let result = gtk_custom_layout_new(requestMode, measure, allocate)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkCustomLayout` uses closures for size negotiation.
/// 
/// A `GtkCustomLayout `uses closures matching to the old `GtkWidget`
/// virtual functions for size negotiation, as a convenience API to
/// ease the porting towards the corresponding `GtkLayoutManager
/// virtual functions.
///
/// The `CustomLayout` type acts as a reference-counted owner of an underlying `GtkCustomLayout` instance.
/// It provides the methods that can operate on this data type through `CustomLayoutProtocol` conformance.
/// Use `CustomLayout` as a strong reference or owner of a `GtkCustomLayout` instance.
///
open class CustomLayout: LayoutManager, CustomLayoutProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCustomLayout>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCustomLayout>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCustomLayout>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCustomLayout>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCustomLayout`.
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCustomLayout>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CustomLayoutProtocol`
    /// Will retain `GtkCustomLayout`.
    /// - Parameter other: an instance of a related type that implements `CustomLayoutProtocol`
    @inlinable public init<T: CustomLayoutProtocol>(customLayout other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new legacy layout manager.
    /// 
    /// Legacy layout managers map to the old `GtkWidget` size negotiation
    /// virtual functions, and are meant to be used during the transition
    /// from layout containers to layout manager delegates.
    @inlinable public init( requestMode: GtkCustomRequestModeFunc? = nil, measure: GtkCustomMeasureFunc?, allocate: GtkCustomAllocateFunc?) {
            let result = gtk_custom_layout_new(requestMode, measure, allocate)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no CustomLayout properties

public enum CustomLayoutSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: CustomLayout has no signals
// MARK: CustomLayout Class: CustomLayoutProtocol extension (methods and fields)
public extension CustomLayoutProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCustomLayout` instance.
    @inlinable var custom_layout_ptr: UnsafeMutablePointer<GtkCustomLayout>! { return ptr?.assumingMemoryBound(to: GtkCustomLayout.self) }



}



// MARK: - CustomSorter Class

/// `GtkCustomSorter` is a `GtkSorter` implementation that sorts via a callback
/// function.
///
/// The `CustomSorterProtocol` protocol exposes the methods and properties of an underlying `GtkCustomSorter` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CustomSorter`.
/// Alternatively, use `CustomSorterRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CustomSorterProtocol: SorterProtocol {
        /// Untyped pointer to the underlying `GtkCustomSorter` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCustomSorter` instance.
    var custom_sorter_ptr: UnsafeMutablePointer<GtkCustomSorter>! { get }

    /// Required Initialiser for types conforming to `CustomSorterProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkCustomSorter` is a `GtkSorter` implementation that sorts via a callback
/// function.
///
/// The `CustomSorterRef` type acts as a lightweight Swift reference to an underlying `GtkCustomSorter` instance.
/// It exposes methods that can operate on this data type through `CustomSorterProtocol` conformance.
/// Use `CustomSorterRef` only as an `unowned` reference to an existing `GtkCustomSorter` instance.
///
public struct CustomSorterRef: CustomSorterProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCustomSorter` instance.
    /// For type-safe access, use the generated, typed pointer `custom_sorter_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CustomSorterRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCustomSorter>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCustomSorter>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCustomSorter>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCustomSorter>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CustomSorterProtocol`
    @inlinable init<T: CustomSorterProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CustomSorterProtocol>(_ other: T) -> CustomSorterRef { CustomSorterRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkSorter` that works by calling
    /// `sort_func` to compare items.
    /// 
    /// If `sort_func` is `nil`, all items are considered equal.
    @inlinable init( sortFunc: GCompareDataFunc? = nil, userData: gpointer? = nil, userDestroy: GDestroyNotify? = nil) {
            let result = gtk_custom_sorter_new(sortFunc, userData, userDestroy)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkCustomSorter` is a `GtkSorter` implementation that sorts via a callback
/// function.
///
/// The `CustomSorter` type acts as a reference-counted owner of an underlying `GtkCustomSorter` instance.
/// It provides the methods that can operate on this data type through `CustomSorterProtocol` conformance.
/// Use `CustomSorter` as a strong reference or owner of a `GtkCustomSorter` instance.
///
open class CustomSorter: Sorter, CustomSorterProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCustomSorter>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCustomSorter>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCustomSorter>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCustomSorter>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCustomSorter`.
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCustomSorter>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CustomSorterProtocol`
    /// Will retain `GtkCustomSorter`.
    /// - Parameter other: an instance of a related type that implements `CustomSorterProtocol`
    @inlinable public init<T: CustomSorterProtocol>(customSorter other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkSorter` that works by calling
    /// `sort_func` to compare items.
    /// 
    /// If `sort_func` is `nil`, all items are considered equal.
    @inlinable public init( sortFunc: GCompareDataFunc? = nil, userData: gpointer? = nil, userDestroy: GDestroyNotify? = nil) {
            let result = gtk_custom_sorter_new(sortFunc, userData, userDestroy)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no CustomSorter properties

public enum CustomSorterSignalName: String, SignalNameProtocol {
    /// Emitted whenever the sorter changed.
    /// 
    /// Users of the sorter should then update the sort order
    /// again via `gtk_sorter_compare()`.
    /// 
    /// [class`Gtk.SortListModel`] handles this signal automatically.
    /// 
    /// Depending on the `change` parameter, it may be possible to update
    /// the sort order without a full resorting. Refer to the
    /// [enum`Gtk.SorterChange`] documentation for details.
    case changed = "changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: CustomSorter has no signals
// MARK: CustomSorter Class: CustomSorterProtocol extension (methods and fields)
public extension CustomSorterProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCustomSorter` instance.
    @inlinable var custom_sorter_ptr: UnsafeMutablePointer<GtkCustomSorter>! { return ptr?.assumingMemoryBound(to: GtkCustomSorter.self) }

    /// Sets (or unsets) the function used for sorting items.
    /// 
    /// If `sort_func` is `nil`, all items are considered equal.
    /// 
    /// If the sort func changes its sorting behavior,
    /// `gtk_sorter_changed()` needs to be called.
    /// 
    /// If a previous function was set, its `user_destroy` will be
    /// called now.
    @inlinable func set(sortFunc: GCompareDataFunc? = nil, userData: gpointer? = nil, userDestroy: GDestroyNotify?) {
        
        gtk_custom_sorter_set_sort_func(custom_sorter_ptr, sortFunc, userData, userDestroy)
        
    }


}



