import CGLib
import CCairo
import CPango
import CGraphene
import CGdkPixbuf
import CGdk
import CGsk
import CGtk
import GLib
import GLibObject
import GIO
import Graphene
import Pango
import Cairo
import PangoCairo
import GdkPixBuf
import Gdk
import Gsk

/// Metatype/GType declaration for TextBuffer
public extension TextBufferClassRef {
    
    /// This getter returns the GLib type identifier registered for `TextBuffer`
    static var metatypeReference: GType { gtk_text_buffer_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkTextBufferClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkTextBufferClass.self) }
    
    static var metatype: GtkTextBufferClass? { metatypePointer?.pointee } 
    
    static var wrapper: TextBufferClassRef? { TextBufferClassRef(metatypePointer) }
    
    
}

// MARK: - TextBufferClass Record

/// The class structure for `GtkTextBuffer`.
///
/// The `TextBufferClassProtocol` protocol exposes the methods and properties of an underlying `GtkTextBufferClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextBufferClass`.
/// Alternatively, use `TextBufferClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextBufferClassProtocol {
        /// Untyped pointer to the underlying `GtkTextBufferClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTextBufferClass` instance.
    var _ptr: UnsafeMutablePointer<GtkTextBufferClass>! { get }

    /// Required Initialiser for types conforming to `TextBufferClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The class structure for `GtkTextBuffer`.
///
/// The `TextBufferClassRef` type acts as a lightweight Swift reference to an underlying `GtkTextBufferClass` instance.
/// It exposes methods that can operate on this data type through `TextBufferClassProtocol` conformance.
/// Use `TextBufferClassRef` only as an `unowned` reference to an existing `GtkTextBufferClass` instance.
///
public struct TextBufferClassRef: TextBufferClassProtocol {
        /// Untyped pointer to the underlying `GtkTextBufferClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextBufferClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTextBufferClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTextBufferClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTextBufferClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTextBufferClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextBufferClassProtocol`
    @inlinable init<T: TextBufferClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: TextBufferClass Record: TextBufferClassProtocol extension (methods and fields)
public extension TextBufferClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextBufferClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkTextBufferClass>! { return ptr?.assumingMemoryBound(to: GtkTextBufferClass.self) }


    /// The object class structure needs to be the first.
    @inlinable var parentClass: GObjectClass {
        /// The object class structure needs to be the first.
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var insertText is unavailable because insert_text is void

    // var insertPaintable is unavailable because insert_paintable is void

    // var insertChildAnchor is unavailable because insert_child_anchor is void

    // var deleteRange is unavailable because delete_range is void

    // var changed is unavailable because changed is void

    // var modifiedChanged is unavailable because modified_changed is void

    // var markSet is unavailable because mark_set is void

    // var markDeleted is unavailable because mark_deleted is void

    // var applyTag is unavailable because apply_tag is void

    // var removeTag is unavailable because remove_tag is void

    // var beginUserAction is unavailable because begin_user_action is void

    // var endUserAction is unavailable because end_user_action is void

    // var pasteDone is unavailable because paste_done is void

    // var undo is unavailable because undo is void

    // var redo is unavailable because redo is void

    // var GtkReserved1 is unavailable because _gtk_reserved1 is void

    // var GtkReserved2 is unavailable because _gtk_reserved2 is void

    // var GtkReserved3 is unavailable because _gtk_reserved3 is void

    // var GtkReserved4 is unavailable because _gtk_reserved4 is void

}



/// Metatype/GType declaration for TextChildAnchor
public extension TextChildAnchorClassRef {
    
    /// This getter returns the GLib type identifier registered for `TextChildAnchor`
    static var metatypeReference: GType { gtk_text_child_anchor_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkTextChildAnchorClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkTextChildAnchorClass.self) }
    
    static var metatype: GtkTextChildAnchorClass? { metatypePointer?.pointee } 
    
    static var wrapper: TextChildAnchorClassRef? { TextChildAnchorClassRef(metatypePointer) }
    
    
}

// MARK: - TextChildAnchorClass Record


///
/// The `TextChildAnchorClassProtocol` protocol exposes the methods and properties of an underlying `GtkTextChildAnchorClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextChildAnchorClass`.
/// Alternatively, use `TextChildAnchorClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextChildAnchorClassProtocol {
        /// Untyped pointer to the underlying `GtkTextChildAnchorClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTextChildAnchorClass` instance.
    var _ptr: UnsafeMutablePointer<GtkTextChildAnchorClass>! { get }

    /// Required Initialiser for types conforming to `TextChildAnchorClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `TextChildAnchorClassRef` type acts as a lightweight Swift reference to an underlying `GtkTextChildAnchorClass` instance.
/// It exposes methods that can operate on this data type through `TextChildAnchorClassProtocol` conformance.
/// Use `TextChildAnchorClassRef` only as an `unowned` reference to an existing `GtkTextChildAnchorClass` instance.
///
public struct TextChildAnchorClassRef: TextChildAnchorClassProtocol {
        /// Untyped pointer to the underlying `GtkTextChildAnchorClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextChildAnchorClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTextChildAnchorClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTextChildAnchorClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTextChildAnchorClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTextChildAnchorClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextChildAnchorClassProtocol`
    @inlinable init<T: TextChildAnchorClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: TextChildAnchorClass Record: TextChildAnchorClassProtocol extension (methods and fields)
public extension TextChildAnchorClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextChildAnchorClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkTextChildAnchorClass>! { return ptr?.assumingMemoryBound(to: GtkTextChildAnchorClass.self) }


    @inlinable var parentClass: GObjectClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var GtkReserved1 is unavailable because _gtk_reserved1 is void

    // var GtkReserved2 is unavailable because _gtk_reserved2 is void

    // var GtkReserved3 is unavailable because _gtk_reserved3 is void

    // var GtkReserved4 is unavailable because _gtk_reserved4 is void

}



// MARK: - TextIter Record

/// An iterator for the contents of a `GtkTextBuffer`.
/// 
/// You may wish to begin by reading the
/// [text widget conceptual overview](section-text-widget.html),
/// which gives an overview of all the objects and data types
/// related to the text widget and how they work together.
///
/// The `TextIterProtocol` protocol exposes the methods and properties of an underlying `GtkTextIter` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextIter`.
/// Alternatively, use `TextIterRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextIterProtocol {
        /// Untyped pointer to the underlying `GtkTextIter` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTextIter` instance.
    var text_iter_ptr: UnsafeMutablePointer<GtkTextIter>! { get }

    /// Required Initialiser for types conforming to `TextIterProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// An iterator for the contents of a `GtkTextBuffer`.
/// 
/// You may wish to begin by reading the
/// [text widget conceptual overview](section-text-widget.html),
/// which gives an overview of all the objects and data types
/// related to the text widget and how they work together.
///
/// The `TextIterRef` type acts as a lightweight Swift reference to an underlying `GtkTextIter` instance.
/// It exposes methods that can operate on this data type through `TextIterProtocol` conformance.
/// Use `TextIterRef` only as an `unowned` reference to an existing `GtkTextIter` instance.
///
public struct TextIterRef: TextIterProtocol {
        /// Untyped pointer to the underlying `GtkTextIter` instance.
    /// For type-safe access, use the generated, typed pointer `text_iter_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextIterRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTextIter>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTextIter>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTextIter>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTextIter>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextIterProtocol`
    @inlinable init<T: TextIterProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextIterProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextIterProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextIterProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextIterProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextIterProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// An iterator for the contents of a `GtkTextBuffer`.
/// 
/// You may wish to begin by reading the
/// [text widget conceptual overview](section-text-widget.html),
/// which gives an overview of all the objects and data types
/// related to the text widget and how they work together.
///
/// The `TextIter` type acts as an owner of an underlying `GtkTextIter` instance.
/// It provides the methods that can operate on this data type through `TextIterProtocol` conformance.
/// Use `TextIter` as a strong reference or owner of a `GtkTextIter` instance.
///
open class TextIter: TextIterProtocol {
        /// Untyped pointer to the underlying `GtkTextIter` instance.
    /// For type-safe access, use the generated, typed pointer `text_iter_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextIter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTextIter>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextIter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTextIter>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextIter` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextIter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextIter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTextIter>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextIter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTextIter>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GtkTextIter` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `TextIter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTextIter>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GtkTextIter, cannot ref(text_iter_ptr)
    }

    /// Reference intialiser for a related type that implements `TextIterProtocol`
    /// `GtkTextIter` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `TextIterProtocol`
    @inlinable public init<T: TextIterProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GtkTextIter, cannot ref(text_iter_ptr)
    }

    /// Do-nothing destructor for `GtkTextIter`.
    deinit {
        // no reference counting for GtkTextIter, cannot unref(text_iter_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextIterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextIterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GtkTextIter, cannot ref(text_iter_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextIterProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextIterProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GtkTextIter, cannot ref(text_iter_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextIterProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextIterProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GtkTextIter, cannot ref(text_iter_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextIterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextIterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GtkTextIter, cannot ref(text_iter_ptr)
    }



}

// MARK: no TextIter properties

// MARK: no TextIter signals

// MARK: TextIter has no signals
// MARK: TextIter Record: TextIterProtocol extension (methods and fields)
public extension TextIterProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextIter` instance.
    @inlinable var text_iter_ptr: UnsafeMutablePointer<GtkTextIter>! { return ptr?.assumingMemoryBound(to: GtkTextIter.self) }

    /// Assigns the value of `other` to `iter`.
    /// 
    /// This function is not useful in applications, because
    /// iterators can be assigned with `GtkTextIter i = j;`.
    /// 
    /// The function is used by language bindings.
    @inlinable func assign<TextIterT: TextIterProtocol>(other: TextIterT) {
        
        gtk_text_iter_assign(text_iter_ptr, other.text_iter_ptr)
        
    }

    /// Moves backward by one character offset.
    /// 
    /// Returns `true` if movement was possible; if `iter` was the first
    /// in the buffer (character offset 0), this function returns `false`
    /// for convenience when writing loops.
    @inlinable func backwardChar() -> Bool {
        let result = gtk_text_iter_backward_char(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves `count` characters backward, if possible.
    /// 
    /// If `count` would move past the start or end of the buffer, moves
    /// to the start or end of the buffer.
    /// 
    /// The return value indicates whether the iterator moved
    /// onto a dereferenceable position; if the iterator didn’t move, or
    /// moved onto the end iterator, then `false` is returned. If `count` is 0,
    /// the function does nothing and returns `false`.
    @inlinable func backwardChars(count: Int) -> Bool {
        let result = gtk_text_iter_backward_chars(text_iter_ptr, gint(count))
        let rv = ((result) != 0)
        return rv
    }

    /// Like `gtk_text_iter_forward_cursor_position()`, but moves backward.
    @inlinable func backwardCursorPosition() -> Bool {
        let result = gtk_text_iter_backward_cursor_position(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves up to `count` cursor positions.
    /// 
    /// See [method`Gtk.TextIter.forward_cursor_position`] for details.
    @inlinable func backwardCursorPositions(count: Int) -> Bool {
        let result = gtk_text_iter_backward_cursor_positions(text_iter_ptr, gint(count))
        let rv = ((result) != 0)
        return rv
    }

    /// Same as `gtk_text_iter_forward_find_char()`,
    /// but goes backward from `iter`.
    @inlinable func backwardFindChar(pred: @escaping GtkTextCharPredicate, userData: gpointer? = nil, limit: TextIterRef? = nil) -> Bool {
            let result = gtk_text_iter_backward_find_char(text_iter_ptr, pred, userData, limit?.text_iter_ptr)
        let rv = ((result) != 0)
            return rv
    }
    /// Same as `gtk_text_iter_forward_find_char()`,
    /// but goes backward from `iter`.
    @inlinable func backwardFindChar<TextIterT: TextIterProtocol>(pred: @escaping GtkTextCharPredicate, userData: gpointer? = nil, limit: TextIterT?) -> Bool {
        let result = gtk_text_iter_backward_find_char(text_iter_ptr, pred, userData, limit?.text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves `iter` to the start of the previous line.
    /// 
    /// Returns `true` if `iter` could be moved; i.e. if `iter` was at
    /// character offset 0, this function returns `false`. Therefore,
    /// if `iter` was already on line 0, but not at the start of the line,
    /// `iter` is snapped to the start of the line and the function returns
    /// `true`. (Note that this implies that
    /// in a loop calling this function, the line number may not change on
    /// every iteration, if your first iteration is on line 0.)
    @inlinable func backwardLine() -> Bool {
        let result = gtk_text_iter_backward_line(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves `count` lines backward, if possible.
    /// 
    /// If `count` would move past the start or end of the buffer, moves to
    /// the start or end of the buffer.
    /// 
    /// The return value indicates whether the iterator moved
    /// onto a dereferenceable position; if the iterator didn’t move, or
    /// moved onto the end iterator, then `false` is returned. If `count` is 0,
    /// the function does nothing and returns `false`. If `count` is negative,
    /// moves forward by 0 - `count` lines.
    @inlinable func backwardLines(count: Int) -> Bool {
        let result = gtk_text_iter_backward_lines(text_iter_ptr, gint(count))
        let rv = ((result) != 0)
        return rv
    }

    /// Same as `gtk_text_iter_forward_search()`, but moves backward.
    /// 
    /// `match_end` will never be set to a `GtkTextIter` located after `iter`,
    /// even if there is a possible `match_start` before or at `iter`.
    @inlinable func backwardSearch(str: UnsafePointer<CChar>!, flags: TextSearchFlags, matchStart: TextIterRef? = nil, matchEnd: TextIterRef? = nil, limit: TextIterRef? = nil) -> Bool {
            let result = gtk_text_iter_backward_search(text_iter_ptr, str, flags.value, matchStart?.text_iter_ptr, matchEnd?.text_iter_ptr, limit?.text_iter_ptr)
        let rv = ((result) != 0)
            return rv
    }
    /// Same as `gtk_text_iter_forward_search()`, but moves backward.
    /// 
    /// `match_end` will never be set to a `GtkTextIter` located after `iter`,
    /// even if there is a possible `match_start` before or at `iter`.
    @inlinable func backwardSearch<TextIterT: TextIterProtocol>(str: UnsafePointer<CChar>!, flags: TextSearchFlags, matchStart: TextIterT?, matchEnd: TextIterT?, limit: TextIterT?) -> Bool {
        let result = gtk_text_iter_backward_search(text_iter_ptr, str, flags.value, matchStart?.text_iter_ptr, matchEnd?.text_iter_ptr, limit?.text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves backward to the previous sentence start.
    /// 
    /// If `iter` is already at the start of a sentence, moves backward
    /// to the next one.
    /// 
    /// Sentence boundaries are determined by Pango and should
    /// be correct for nearly any language.
    @inlinable func backwardSentenceStart() -> Bool {
        let result = gtk_text_iter_backward_sentence_start(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Calls `gtk_text_iter_backward_sentence_start()` up to `count` times.
    /// 
    /// If `count` is negative, moves forward instead of backward.
    @inlinable func backwardSentenceStarts(count: Int) -> Bool {
        let result = gtk_text_iter_backward_sentence_starts(text_iter_ptr, gint(count))
        let rv = ((result) != 0)
        return rv
    }

    /// Moves backward to the next toggle (on or off) of the
    /// `tag`, or to the next toggle of any tag if
    /// `tag` is `nil`.
    /// 
    /// If no matching tag toggles are found,
    /// returns `false`, otherwise `true`. Does not return toggles
    /// located at `iter`, only toggles before `iter`. Sets `iter`
    /// to the location of the toggle, or the start of the buffer
    /// if no toggle is found.
    @inlinable func backwardToTagToggle(tag: TextTagRef? = nil) -> Bool {
            let result = gtk_text_iter_backward_to_tag_toggle(text_iter_ptr, tag?.text_tag_ptr)
        let rv = ((result) != 0)
            return rv
    }
    /// Moves backward to the next toggle (on or off) of the
    /// `tag`, or to the next toggle of any tag if
    /// `tag` is `nil`.
    /// 
    /// If no matching tag toggles are found,
    /// returns `false`, otherwise `true`. Does not return toggles
    /// located at `iter`, only toggles before `iter`. Sets `iter`
    /// to the location of the toggle, or the start of the buffer
    /// if no toggle is found.
    @inlinable func backwardToTagToggle<TextTagT: TextTagProtocol>(tag: TextTagT?) -> Bool {
        let result = gtk_text_iter_backward_to_tag_toggle(text_iter_ptr, tag?.text_tag_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves `iter` forward to the previous visible cursor position.
    /// 
    /// See [method`Gtk.TextIter.backward_cursor_position`] for details.
    @inlinable func backwardVisibleCursorPosition() -> Bool {
        let result = gtk_text_iter_backward_visible_cursor_position(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves up to `count` visible cursor positions.
    /// 
    /// See [method`Gtk.TextIter.backward_cursor_position`] for details.
    @inlinable func backwardVisibleCursorPositions(count: Int) -> Bool {
        let result = gtk_text_iter_backward_visible_cursor_positions(text_iter_ptr, gint(count))
        let rv = ((result) != 0)
        return rv
    }

    /// Moves `iter` to the start of the previous visible line.
    /// 
    /// Returns `true` if
    /// `iter` could be moved; i.e. if `iter` was at character offset 0, this
    /// function returns `false`. Therefore if `iter` was already on line 0,
    /// but not at the start of the line, `iter` is snapped to the start of
    /// the line and the function returns `true`. (Note that this implies that
    /// in a loop calling this function, the line number may not change on
    /// every iteration, if your first iteration is on line 0.)
    @inlinable func backwardVisibleLine() -> Bool {
        let result = gtk_text_iter_backward_visible_line(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves `count` visible lines backward, if possible.
    /// 
    /// If `count` would move past the start or end of the buffer, moves to
    /// the start or end of the buffer.
    /// 
    /// The return value indicates whether the iterator moved
    /// onto a dereferenceable position; if the iterator didn’t move, or
    /// moved onto the end iterator, then `false` is returned. If `count` is 0,
    /// the function does nothing and returns `false`. If `count` is negative,
    /// moves forward by 0 - `count` lines.
    @inlinable func backwardVisibleLines(count: Int) -> Bool {
        let result = gtk_text_iter_backward_visible_lines(text_iter_ptr, gint(count))
        let rv = ((result) != 0)
        return rv
    }

    /// Moves backward to the previous visible word start.
    /// 
    /// If `iter` is currently on a word start, moves backward to the
    /// next one after that.
    /// 
    /// Word breaks are determined by Pango and should be correct
    /// for nearly any language.
    @inlinable func backwardVisibleWordStart() -> Bool {
        let result = gtk_text_iter_backward_visible_word_start(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Calls `gtk_text_iter_backward_visible_word_start()` up to `count` times.
    @inlinable func backwardVisibleWordStarts(count: Int) -> Bool {
        let result = gtk_text_iter_backward_visible_word_starts(text_iter_ptr, gint(count))
        let rv = ((result) != 0)
        return rv
    }

    /// Moves backward to the previous word start.
    /// 
    /// If `iter` is currently on a word start, moves backward to the
    /// next one after that.
    /// 
    /// Word breaks are determined by Pango and should be correct
    /// for nearly any language
    @inlinable func backwardWordStart() -> Bool {
        let result = gtk_text_iter_backward_word_start(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Calls `gtk_text_iter_backward_word_start()` up to `count` times.
    @inlinable func backwardWordStarts(count: Int) -> Bool {
        let result = gtk_text_iter_backward_word_starts(text_iter_ptr, gint(count))
        let rv = ((result) != 0)
        return rv
    }

    /// Considering the default editability of the buffer, and tags that
    /// affect editability, determines whether text inserted at `iter` would
    /// be editable.
    /// 
    /// If text inserted at `iter` would be editable then the
    /// user should be allowed to insert text at `iter`.
    /// [method`Gtk.TextBuffer.insert_interactive`] uses this function
    /// to decide whether insertions are allowed at a given position.
    @inlinable func canInsert(defaultEditability: Bool) -> Bool {
        let result = gtk_text_iter_can_insert(text_iter_ptr, gboolean((defaultEditability) ? 1 : 0))
        let rv = ((result) != 0)
        return rv
    }

    /// A `qsort()`-style function that returns negative if `lhs` is less than
    /// `rhs`, positive if `lhs` is greater than `rhs`, and 0 if they’re equal.
    /// 
    /// Ordering is in character offset order, i.e. the first character
    /// in the buffer is less than the second character in the buffer.
    @inlinable func compare<TextIterT: TextIterProtocol>(rhs: TextIterT) -> Int {
        let result = gtk_text_iter_compare(text_iter_ptr, rhs.text_iter_ptr)
        let rv = Int(result)
        return rv
    }

    /// Creates a dynamically-allocated copy of an iterator.
    /// 
    /// This function is not useful in applications, because
    /// iterators can be copied with a simple assignment
    /// (`GtkTextIter i = j;`).
    /// 
    /// The function is used by language bindings.
    @inlinable func copy() -> TextIterRef! {
        let result = gtk_text_iter_copy(text_iter_ptr)
        guard let rv = TextIterRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Returns whether the character at `iter` is within an editable region
    /// of text.
    /// 
    /// Non-editable text is “locked” and can’t be changed by the
    /// user via `GtkTextView`. If no tags applied to this text affect
    /// editability, `default_setting` will be returned.
    /// 
    /// You don’t want to use this function to decide whether text can be
    /// inserted at `iter`, because for insertion you don’t want to know
    /// whether the char at `iter` is inside an editable range, you want to
    /// know whether a new character inserted at `iter` would be inside an
    /// editable range. Use [method`Gtk.TextIter.can_insert`] to handle this
    /// case.
    @inlinable func editable(defaultSetting: Bool) -> Bool {
        let result = gtk_text_iter_editable(text_iter_ptr, gboolean((defaultSetting) ? 1 : 0))
        let rv = ((result) != 0)
        return rv
    }

    /// Returns `true` if `iter` points to the start of the paragraph
    /// delimiter characters for a line.
    /// 
    /// Delimiters will be either a newline, a carriage return, a carriage
    /// return followed by a newline, or a Unicode paragraph separator
    /// character.
    /// 
    /// Note that an iterator pointing to the \n of a \r\n pair will not be
    /// counted as the end of a line, the line ends before the \r. The end
    /// iterator is considered to be at the end of a line, even though there
    /// are no paragraph delimiter chars there.
    @inlinable func endsLine() -> Bool {
        let result = gtk_text_iter_ends_line(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Determines whether `iter` ends a sentence.
    /// 
    /// Sentence boundaries are determined by Pango and should
    /// be correct for nearly any language.
    @inlinable func endsSentence() -> Bool {
        let result = gtk_text_iter_ends_sentence(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns `true` if `tag` is toggled off at exactly this point.
    /// 
    /// If `tag` is `nil`, returns `true` if any tag is toggled off at this point.
    /// 
    /// Note that if this function returns `true`, it means that
    /// `iter` is at the end of the tagged range, but that the character
    /// at `iter` is outside the tagged range. In other words,
    /// unlike [method`Gtk.TextIter.starts_tag`], if this function
    /// returns `true`, [method`Gtk.TextIter.has_tag`] will return
    /// `false` for the same parameters.
    @inlinable func ends(tag: TextTagRef? = nil) -> Bool {
            let result = gtk_text_iter_ends_tag(text_iter_ptr, tag?.text_tag_ptr)
        let rv = ((result) != 0)
            return rv
    }
    /// Returns `true` if `tag` is toggled off at exactly this point.
    /// 
    /// If `tag` is `nil`, returns `true` if any tag is toggled off at this point.
    /// 
    /// Note that if this function returns `true`, it means that
    /// `iter` is at the end of the tagged range, but that the character
    /// at `iter` is outside the tagged range. In other words,
    /// unlike [method`Gtk.TextIter.starts_tag`], if this function
    /// returns `true`, [method`Gtk.TextIter.has_tag`] will return
    /// `false` for the same parameters.
    @inlinable func ends<TextTagT: TextTagProtocol>(tag: TextTagT?) -> Bool {
        let result = gtk_text_iter_ends_tag(text_iter_ptr, tag?.text_tag_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Determines whether `iter` ends a natural-language word.
    /// 
    /// Word breaks are determined by Pango and should be correct
    /// for nearly any language.
    @inlinable func endsWord() -> Bool {
        let result = gtk_text_iter_ends_word(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Tests whether two iterators are equal, using the fastest possible
    /// mechanism.
    /// 
    /// This function is very fast; you can expect it to perform
    /// better than e.g. getting the character offset for each
    /// iterator and comparing the offsets yourself. Also, it’s a
    /// bit faster than [method`Gtk.TextIter.compare`].
    @inlinable func equal<TextIterT: TextIterProtocol>(rhs: TextIterT) -> Bool {
        let result = gtk_text_iter_equal(text_iter_ptr, rhs.text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves `iter` forward by one character offset.
    /// 
    /// Note that images embedded in the buffer occupy 1 character slot, so
    /// this function may actually move onto an image instead of a character,
    /// if you have images in your buffer. If `iter` is the end iterator or
    /// one character before it, `iter` will now point at the end iterator,
    /// and this function returns `false` for convenience when writing loops.
    @inlinable func forwardChar() -> Bool {
        let result = gtk_text_iter_forward_char(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves `count` characters if possible.
    /// 
    /// If `count` would move past the start or end of the buffer,
    /// moves to the start or end of the buffer.
    /// 
    /// The return value indicates whether the new position of
    /// `iter` is different from its original position, and dereferenceable
    /// (the last iterator in the buffer is not dereferenceable). If `count`
    /// is 0, the function does nothing and returns `false`.
    @inlinable func forwardChars(count: Int) -> Bool {
        let result = gtk_text_iter_forward_chars(text_iter_ptr, gint(count))
        let rv = ((result) != 0)
        return rv
    }

    /// Moves `iter` forward by a single cursor position.
    /// 
    /// Cursor positions are (unsurprisingly) positions where the
    /// cursor can appear. Perhaps surprisingly, there may not be
    /// a cursor position between all characters. The most common
    /// example for European languages would be a carriage return/newline
    /// sequence.
    /// 
    /// For some Unicode characters, the equivalent of say the letter “a”
    /// with an accent mark will be represented as two characters, first
    /// the letter then a "combining mark" that causes the accent to be
    /// rendered; so the cursor can’t go between those two characters.
    /// 
    /// See also the [struct`Pango.LogAttr`] struct and the [func`Pango.break`]
    /// function.
    @inlinable func forwardCursorPosition() -> Bool {
        let result = gtk_text_iter_forward_cursor_position(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves up to `count` cursor positions.
    /// 
    /// See [method`Gtk.TextIter.forward_cursor_position`] for details.
    @inlinable func forwardCursorPositions(count: Int) -> Bool {
        let result = gtk_text_iter_forward_cursor_positions(text_iter_ptr, gint(count))
        let rv = ((result) != 0)
        return rv
    }

    /// Advances `iter`, calling `pred` on each character.
    /// 
    /// If `pred` returns `true`, returns `true` and stops scanning.
    /// If `pred` never returns `true`, `iter` is set to `limit` if
    /// `limit` is non-`nil`, otherwise to the end iterator.
    @inlinable func forwardFindChar(pred: @escaping GtkTextCharPredicate, userData: gpointer? = nil, limit: TextIterRef? = nil) -> Bool {
            let result = gtk_text_iter_forward_find_char(text_iter_ptr, pred, userData, limit?.text_iter_ptr)
        let rv = ((result) != 0)
            return rv
    }
    /// Advances `iter`, calling `pred` on each character.
    /// 
    /// If `pred` returns `true`, returns `true` and stops scanning.
    /// If `pred` never returns `true`, `iter` is set to `limit` if
    /// `limit` is non-`nil`, otherwise to the end iterator.
    @inlinable func forwardFindChar<TextIterT: TextIterProtocol>(pred: @escaping GtkTextCharPredicate, userData: gpointer? = nil, limit: TextIterT?) -> Bool {
        let result = gtk_text_iter_forward_find_char(text_iter_ptr, pred, userData, limit?.text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves `iter` to the start of the next line.
    /// 
    /// If the iter is already on the last line of the buffer,
    /// moves the iter to the end of the current line. If after
    /// the operation, the iter is at the end of the buffer and not
    /// dereferenceable, returns `false`. Otherwise, returns `true`.
    @inlinable func forwardLine() -> Bool {
        let result = gtk_text_iter_forward_line(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves `count` lines forward, if possible.
    /// 
    /// If `count` would move past the start or end of the buffer, moves to
    /// the start or end of the buffer.
    /// 
    /// The return value indicates whether the iterator moved
    /// onto a dereferenceable position; if the iterator didn’t move, or
    /// moved onto the end iterator, then `false` is returned. If `count` is 0,
    /// the function does nothing and returns `false`. If `count` is negative,
    /// moves backward by 0 - `count` lines.
    @inlinable func forwardLines(count: Int) -> Bool {
        let result = gtk_text_iter_forward_lines(text_iter_ptr, gint(count))
        let rv = ((result) != 0)
        return rv
    }

    /// Searches forward for `str`.
    /// 
    /// Any match is returned by setting `match_start` to the first character
    /// of the match and `match_end` to the first character after the match.
    /// The search will not continue past `limit`. Note that a search is a
    /// linear or `O(n)` operation, so you may wish to use `limit` to avoid
    /// locking up your UI on large buffers.
    /// 
    /// `match_start` will never be set to a `GtkTextIter` located before `iter`,
    /// even if there is a possible `match_end` after or at `iter`.
    @inlinable func forwardSearch(str: UnsafePointer<CChar>!, flags: TextSearchFlags, matchStart: TextIterRef? = nil, matchEnd: TextIterRef? = nil, limit: TextIterRef? = nil) -> Bool {
            let result = gtk_text_iter_forward_search(text_iter_ptr, str, flags.value, matchStart?.text_iter_ptr, matchEnd?.text_iter_ptr, limit?.text_iter_ptr)
        let rv = ((result) != 0)
            return rv
    }
    /// Searches forward for `str`.
    /// 
    /// Any match is returned by setting `match_start` to the first character
    /// of the match and `match_end` to the first character after the match.
    /// The search will not continue past `limit`. Note that a search is a
    /// linear or `O(n)` operation, so you may wish to use `limit` to avoid
    /// locking up your UI on large buffers.
    /// 
    /// `match_start` will never be set to a `GtkTextIter` located before `iter`,
    /// even if there is a possible `match_end` after or at `iter`.
    @inlinable func forwardSearch<TextIterT: TextIterProtocol>(str: UnsafePointer<CChar>!, flags: TextSearchFlags, matchStart: TextIterT?, matchEnd: TextIterT?, limit: TextIterT?) -> Bool {
        let result = gtk_text_iter_forward_search(text_iter_ptr, str, flags.value, matchStart?.text_iter_ptr, matchEnd?.text_iter_ptr, limit?.text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves forward to the next sentence end.
    /// 
    /// If `iter` is at the end of a sentence, moves to the next
    /// end of sentence.
    /// 
    /// Sentence boundaries are determined by Pango and should
    /// be correct for nearly any language.
    @inlinable func forwardSentenceEnd() -> Bool {
        let result = gtk_text_iter_forward_sentence_end(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Calls `gtk_text_iter_forward_sentence_end()` `count` times.
    /// 
    /// If `count` is negative, moves backward instead of forward.
    @inlinable func forwardSentenceEnds(count: Int) -> Bool {
        let result = gtk_text_iter_forward_sentence_ends(text_iter_ptr, gint(count))
        let rv = ((result) != 0)
        return rv
    }

    /// Moves `iter` forward to the “end iterator”, which points
    /// one past the last valid character in the buffer.
    /// 
    /// `gtk_text_iter_get_char()` called on the end iterator
    /// returns 0, which is convenient for writing loops.
    @inlinable func forwardToEnd() {
        
        gtk_text_iter_forward_to_end(text_iter_ptr)
        
    }

    /// Moves the iterator to point to the paragraph delimiter characters.
    /// 
    /// The possible characters are either a newline, a carriage return,
    /// a carriage return/newline in sequence, or the Unicode paragraph
    /// separator character.
    /// 
    /// If the iterator is already at the paragraph delimiter
    /// characters, moves to the paragraph delimiter characters for the
    /// next line. If `iter` is on the last line in the buffer, which does
    /// not end in paragraph delimiters, moves to the end iterator (end of
    /// the last line), and returns `false`.
    @inlinable func forwardToLineEnd() -> Bool {
        let result = gtk_text_iter_forward_to_line_end(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves forward to the next toggle (on or off) of the
    /// `tag`, or to the next toggle of any tag if
    /// `tag` is `nil`.
    /// 
    /// If no matching tag toggles are found,
    /// returns `false`, otherwise `true`. Does not return toggles
    /// located at `iter`, only toggles after `iter`. Sets `iter` to
    /// the location of the toggle, or to the end of the buffer
    /// if no toggle is found.
    @inlinable func forwardToTagToggle(tag: TextTagRef? = nil) -> Bool {
            let result = gtk_text_iter_forward_to_tag_toggle(text_iter_ptr, tag?.text_tag_ptr)
        let rv = ((result) != 0)
            return rv
    }
    /// Moves forward to the next toggle (on or off) of the
    /// `tag`, or to the next toggle of any tag if
    /// `tag` is `nil`.
    /// 
    /// If no matching tag toggles are found,
    /// returns `false`, otherwise `true`. Does not return toggles
    /// located at `iter`, only toggles after `iter`. Sets `iter` to
    /// the location of the toggle, or to the end of the buffer
    /// if no toggle is found.
    @inlinable func forwardToTagToggle<TextTagT: TextTagProtocol>(tag: TextTagT?) -> Bool {
        let result = gtk_text_iter_forward_to_tag_toggle(text_iter_ptr, tag?.text_tag_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves `iter` forward to the next visible cursor position.
    /// 
    /// See [method`Gtk.TextIter.forward_cursor_position`] for details.
    @inlinable func forwardVisibleCursorPosition() -> Bool {
        let result = gtk_text_iter_forward_visible_cursor_position(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves up to `count` visible cursor positions.
    /// 
    /// See [method`Gtk.TextIter.forward_cursor_position`] for details.
    @inlinable func forwardVisibleCursorPositions(count: Int) -> Bool {
        let result = gtk_text_iter_forward_visible_cursor_positions(text_iter_ptr, gint(count))
        let rv = ((result) != 0)
        return rv
    }

    /// Moves `iter` to the start of the next visible line.
    /// 
    /// Returns `true` if there
    /// was a next line to move to, and `false` if `iter` was simply moved to
    /// the end of the buffer and is now not dereferenceable, or if `iter` was
    /// already at the end of the buffer.
    @inlinable func forwardVisibleLine() -> Bool {
        let result = gtk_text_iter_forward_visible_line(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves `count` visible lines forward, if possible.
    /// 
    /// If `count` would move past the start or end of the buffer, moves to
    /// the start or end of the buffer.
    /// 
    /// The return value indicates whether the iterator moved
    /// onto a dereferenceable position; if the iterator didn’t move, or
    /// moved onto the end iterator, then `false` is returned. If `count` is 0,
    /// the function does nothing and returns `false`. If `count` is negative,
    /// moves backward by 0 - `count` lines.
    @inlinable func forwardVisibleLines(count: Int) -> Bool {
        let result = gtk_text_iter_forward_visible_lines(text_iter_ptr, gint(count))
        let rv = ((result) != 0)
        return rv
    }

    /// Moves forward to the next visible word end.
    /// 
    /// If `iter` is currently on a word end, moves forward to the
    /// next one after that.
    /// 
    /// Word breaks are determined by Pango and should be correct
    /// for nearly any language
    @inlinable func forwardVisibleWordEnd() -> Bool {
        let result = gtk_text_iter_forward_visible_word_end(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Calls `gtk_text_iter_forward_visible_word_end()` up to `count` times.
    @inlinable func forwardVisibleWordEnds(count: Int) -> Bool {
        let result = gtk_text_iter_forward_visible_word_ends(text_iter_ptr, gint(count))
        let rv = ((result) != 0)
        return rv
    }

    /// Moves forward to the next word end.
    /// 
    /// If `iter` is currently on a word end, moves forward to the
    /// next one after that.
    /// 
    /// Word breaks are determined by Pango and should be correct
    /// for nearly any language.
    @inlinable func forwardWordEnd() -> Bool {
        let result = gtk_text_iter_forward_word_end(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Calls `gtk_text_iter_forward_word_end()` up to `count` times.
    @inlinable func forwardWordEnds(count: Int) -> Bool {
        let result = gtk_text_iter_forward_word_ends(text_iter_ptr, gint(count))
        let rv = ((result) != 0)
        return rv
    }

    /// Free an iterator allocated on the heap.
    /// 
    /// This function is intended for use in language bindings,
    /// and is not especially useful for applications, because
    /// iterators can simply be allocated on the stack.
    @inlinable func free() {
        
        gtk_text_iter_free(text_iter_ptr)
        
    }

    /// Returns the `GtkTextBuffer` this iterator is associated with.
    @inlinable func getBuffer() -> TextBufferRef! {
        let result = gtk_text_iter_get_buffer(text_iter_ptr)
        let rv = TextBufferRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns the number of bytes in the line containing `iter`,
    /// including the paragraph delimiters.
    @inlinable func getBytesInLine() -> Int {
        let result = gtk_text_iter_get_bytes_in_line(text_iter_ptr)
        let rv = Int(result)
        return rv
    }

    /// The Unicode character at this iterator is returned.
    /// 
    /// Equivalent to operator* on a C++ iterator. If the element at
    /// this iterator is a non-character element, such as an image
    /// embedded in the buffer, the Unicode “unknown” character 0xFFFC
    /// is returned. If invoked on the end iterator, zero is returned;
    /// zero is not a valid Unicode character.
    /// 
    /// So you can write a loop which ends when this function returns 0.
    @inlinable func getChar() -> gunichar {
        let result = gtk_text_iter_get_char(text_iter_ptr)
        let rv = result
        return rv
    }

    /// Returns the number of characters in the line containing `iter`,
    /// including the paragraph delimiters.
    @inlinable func getCharsInLine() -> Int {
        let result = gtk_text_iter_get_chars_in_line(text_iter_ptr)
        let rv = Int(result)
        return rv
    }

    /// If the location at `iter` contains a child anchor, the
    /// anchor is returned.
    /// 
    /// Otherwise, `nil` is returned.
    @inlinable func getChildAnchor() -> TextChildAnchorRef! {
        let result = gtk_text_iter_get_child_anchor(text_iter_ptr)
        let rv = TextChildAnchorRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns the language in effect at `iter`.
    /// 
    /// If no tags affecting language apply to `iter`, the return
    /// value is identical to that of [func`Gtk.get_default_language`].
    @inlinable func getLanguage() -> Pango.LanguageRef! {
        let result = gtk_text_iter_get_language(text_iter_ptr)
        let rv = Pango.LanguageRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns the line number containing the iterator.
    /// 
    /// Lines in a `GtkTextBuffer` are numbered beginning
    /// with 0 for the first line in the buffer.
    @inlinable func getLine() -> Int {
        let result = gtk_text_iter_get_line(text_iter_ptr)
        let rv = Int(result)
        return rv
    }

    /// Returns the byte index of the iterator, counting
    /// from the start of a newline-terminated line.
    /// 
    /// Remember that `GtkTextBuffer` encodes text in
    /// UTF-8, and that characters can require a variable
    /// number of bytes to represent.
    @inlinable func getLineIndex() -> Int {
        let result = gtk_text_iter_get_line_index(text_iter_ptr)
        let rv = Int(result)
        return rv
    }

    /// Returns the character offset of the iterator,
    /// counting from the start of a newline-terminated line.
    /// 
    /// The first character on the line has offset 0.
    @inlinable func getLineOffset() -> Int {
        let result = gtk_text_iter_get_line_offset(text_iter_ptr)
        let rv = Int(result)
        return rv
    }

    /// Returns a list of all `GtkTextMark` at this location.
    /// 
    /// Because marks are not iterable (they don’t take up any "space"
    /// in the buffer, they are just marks in between iterable locations),
    /// multiple marks can exist in the same place.
    /// 
    /// The returned list is not in any meaningful order.
    @inlinable func getMarks() -> GLib.SListRef! {
        let result = gtk_text_iter_get_marks(text_iter_ptr)
        let rv = GLib.SListRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns the character offset of an iterator.
    /// 
    /// Each character in a `GtkTextBuffer` has an offset,
    /// starting with 0 for the first character in the buffer.
    /// Use [method`Gtk`,TextBuffer.get_iter_at_offset] to convert
    /// an offset back into an iterator.
    @inlinable func getOffset() -> Int {
        let result = gtk_text_iter_get_offset(text_iter_ptr)
        let rv = Int(result)
        return rv
    }

    /// If the element at `iter` is a paintable, the paintable is returned.
    /// 
    /// Otherwise, `nil` is returned.
    @inlinable func getPaintable() -> Gdk.PaintableRef! {
        let result = gtk_text_iter_get_paintable(text_iter_ptr)
        let rv = Gdk.PaintableRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns the text in the given range.
    /// 
    /// A “slice” is an array of characters encoded in UTF-8 format,
    /// including the Unicode “unknown” character 0xFFFC for iterable
    /// non-character elements in the buffer, such as images.
    /// Because images are encoded in the slice, byte and
    /// character offsets in the returned array will correspond to byte
    /// offsets in the text buffer. Note that 0xFFFC can occur in normal
    /// text as well, so it is not a reliable indicator that a paintable or
    /// widget is in the buffer.
    @inlinable func getSlice<TextIterT: TextIterProtocol>(end: TextIterT) -> String! {
        let result = gtk_text_iter_get_slice(text_iter_ptr, end.text_iter_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Returns a list of tags that apply to `iter`, in ascending order of
    /// priority.
    /// 
    /// The highest-priority tags are last.
    /// 
    /// The `GtkTextTag`s in the list don’t have a reference added,
    /// but you have to free the list itself.
    @inlinable func getTags() -> GLib.SListRef! {
        let result = gtk_text_iter_get_tags(text_iter_ptr)
        let rv = GLib.SListRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns text in the given range.
    /// 
    /// If the range
    /// contains non-text elements such as images, the character and byte
    /// offsets in the returned string will not correspond to character and
    /// byte offsets in the buffer. If you want offsets to correspond, see
    /// [method`Gtk.TextIter.get_slice`].
    @inlinable func getText<TextIterT: TextIterProtocol>(end: TextIterT) -> String! {
        let result = gtk_text_iter_get_text(text_iter_ptr, end.text_iter_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Returns a list of `GtkTextTag` that are toggled on or off at this
    /// point.
    /// 
    /// If `toggled_on` is `true`, the list contains tags that are
    /// toggled on. If a tag is toggled on at `iter`, then some non-empty
    /// range of characters following `iter` has that tag applied to it.  If
    /// a tag is toggled off, then some non-empty range following `iter`
    /// does not have the tag applied to it.
    @inlinable func getToggledTags(toggledOn: Bool) -> GLib.SListRef! {
        let result = gtk_text_iter_get_toggled_tags(text_iter_ptr, gboolean((toggledOn) ? 1 : 0))
        let rv = GLib.SListRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns the number of bytes from the start of the
    /// line to the given `iter`, not counting bytes that
    /// are invisible due to tags with the “invisible” flag
    /// toggled on.
    @inlinable func getVisibleLineIndex() -> Int {
        let result = gtk_text_iter_get_visible_line_index(text_iter_ptr)
        let rv = Int(result)
        return rv
    }

    /// Returns the offset in characters from the start of the
    /// line to the given `iter`, not counting characters that
    /// are invisible due to tags with the “invisible” flag
    /// toggled on.
    @inlinable func getVisibleLineOffset() -> Int {
        let result = gtk_text_iter_get_visible_line_offset(text_iter_ptr)
        let rv = Int(result)
        return rv
    }

    /// Returns visible text in the given range.
    /// 
    /// Like [method`Gtk.TextIter.get_slice`], but invisible text
    /// is not included. Invisible text is usually invisible because
    /// a `GtkTextTag` with the “invisible” attribute turned on has
    /// been applied to it.
    @inlinable func getVisibleSlice<TextIterT: TextIterProtocol>(end: TextIterT) -> String! {
        let result = gtk_text_iter_get_visible_slice(text_iter_ptr, end.text_iter_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Returns visible text in the given range.
    /// 
    /// Like [method`Gtk.TextIter.get_text`], but invisible text
    /// is not included. Invisible text is usually invisible because
    /// a `GtkTextTag` with the “invisible” attribute turned on has
    /// been applied to it.
    @inlinable func getVisibleText<TextIterT: TextIterProtocol>(end: TextIterT) -> String! {
        let result = gtk_text_iter_get_visible_text(text_iter_ptr, end.text_iter_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Returns `true` if `iter` points to a character that is part
    /// of a range tagged with `tag`.
    /// 
    /// See also [method`Gtk.TextIter.starts_tag`] and
    /// [method`Gtk.TextIter.ends_tag`].
    @inlinable func has<TextTagT: TextTagProtocol>(tag: TextTagT) -> Bool {
        let result = gtk_text_iter_has_tag(text_iter_ptr, tag.text_tag_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Checks whether `iter` falls in the range [`start`, `end`).
    /// 
    /// `start` and `end` must be in ascending order.
    @inlinable func inRange<TextIterT: TextIterProtocol>(start: TextIterT, end: TextIterT) -> Bool {
        let result = gtk_text_iter_in_range(text_iter_ptr, start.text_iter_ptr, end.text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Determines whether `iter` is inside a sentence (as opposed to in
    /// between two sentences, e.g. after a period and before the first
    /// letter of the next sentence).
    /// 
    /// Sentence boundaries are determined by Pango and should be correct
    /// for nearly any language.
    @inlinable func insideSentence() -> Bool {
        let result = gtk_text_iter_inside_sentence(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Determines whether the character pointed by `iter` is part of a
    /// natural-language word (as opposed to say inside some whitespace).
    /// 
    /// Word breaks are determined by Pango and should be correct
    /// for nearly any language.
    /// 
    /// Note that if [method`Gtk.TextIter.starts_word`] returns `true`,
    /// then this function returns `true` too, since `iter` points to
    /// the first character of the word.
    @inlinable func insideWord() -> Bool {
        let result = gtk_text_iter_inside_word(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Swaps the value of `first` and `second` if `second` comes before
    /// `first` in the buffer.
    /// 
    /// That is, ensures that `first` and `second` are in sequence.
    /// Most text buffer functions that take a range call this
    /// automatically on your behalf, so there’s no real reason to
    /// call it yourself in those cases. There are some exceptions,
    /// such as [method`Gtk.TextIter.in_range`], that expect a
    /// pre-sorted range.
    @inlinable func order<TextIterT: TextIterProtocol>(second: TextIterT) {
        
        gtk_text_iter_order(text_iter_ptr, second.text_iter_ptr)
        
    }

    /// Moves iterator `iter` to the start of the line `line_number`.
    /// 
    /// If `line_number` is negative or larger than or equal to the number of lines
    /// in the buffer, moves `iter` to the start of the last line in the buffer.
    @inlinable func setLine(lineNumber: Int) {
        
        gtk_text_iter_set_line(text_iter_ptr, gint(lineNumber))
        
    }

    /// Same as `gtk_text_iter_set_line_offset()`, but works with a
    /// byte index. The given byte index must be at
    /// the start of a character, it can’t be in the middle of a UTF-8
    /// encoded character.
    @inlinable func setLineIndex(byteOnLine: Int) {
        
        gtk_text_iter_set_line_index(text_iter_ptr, gint(byteOnLine))
        
    }

    /// Moves `iter` within a line, to a new character (not byte) offset.
    /// 
    /// The given character offset must be less than or equal to the number
    /// of characters in the line; if equal, `iter` moves to the start of the
    /// next line. See [method`Gtk.TextIter.set_line_index`] if you have a byte
    /// index rather than a character offset.
    @inlinable func setLineOffset(charOnLine: Int) {
        
        gtk_text_iter_set_line_offset(text_iter_ptr, gint(charOnLine))
        
    }

    /// Sets `iter` to point to `char_offset`.
    /// 
    /// `char_offset` counts from the start
    /// of the entire text buffer, starting with 0.
    @inlinable func setOffset(charOffset: Int) {
        
        gtk_text_iter_set_offset(text_iter_ptr, gint(charOffset))
        
    }

    /// Like `gtk_text_iter_set_line_index()`, but the index is in visible
    /// bytes, i.e. text with a tag making it invisible is not counted
    /// in the index.
    @inlinable func setVisibleLineIndex(byteOnLine: Int) {
        
        gtk_text_iter_set_visible_line_index(text_iter_ptr, gint(byteOnLine))
        
    }

    /// Like `gtk_text_iter_set_line_offset()`, but the offset is in visible
    /// characters, i.e. text with a tag making it invisible is not
    /// counted in the offset.
    @inlinable func setVisibleLineOffset(charOnLine: Int) {
        
        gtk_text_iter_set_visible_line_offset(text_iter_ptr, gint(charOnLine))
        
    }

    /// Returns `true` if `iter` begins a paragraph.
    /// 
    /// This is the case if [method`Gtk.TextIter.get_line_offset`]
    /// would return 0. However this function is potentially more
    /// efficient than [method`Gtk.TextIter.get_line_offset`], because
    /// it doesn’t have to compute the offset, it just has to see
    /// whether it’s 0.
    @inlinable func startsLine() -> Bool {
        let result = gtk_text_iter_starts_line(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Determines whether `iter` begins a sentence.
    /// 
    /// Sentence boundaries are determined by Pango and
    /// should be correct for nearly any language.
    @inlinable func startsSentence() -> Bool {
        let result = gtk_text_iter_starts_sentence(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns `true` if `tag` is toggled on at exactly this point.
    /// 
    /// If `tag` is `nil`, returns `true` if any tag is toggled on at this point.
    /// 
    /// Note that if this function returns `true`, it means that
    /// `iter` is at the beginning of the tagged range, and that the
    /// character at `iter` is inside the tagged range. In other
    /// words, unlike [method`Gtk.TextIter.ends_tag`], if
    /// this function returns `true`, [method`Gtk.TextIter.has_tag`
    /// will also return `true` for the same parameters.
    @inlinable func starts(tag: TextTagRef? = nil) -> Bool {
            let result = gtk_text_iter_starts_tag(text_iter_ptr, tag?.text_tag_ptr)
        let rv = ((result) != 0)
            return rv
    }
    /// Returns `true` if `tag` is toggled on at exactly this point.
    /// 
    /// If `tag` is `nil`, returns `true` if any tag is toggled on at this point.
    /// 
    /// Note that if this function returns `true`, it means that
    /// `iter` is at the beginning of the tagged range, and that the
    /// character at `iter` is inside the tagged range. In other
    /// words, unlike [method`Gtk.TextIter.ends_tag`], if
    /// this function returns `true`, [method`Gtk.TextIter.has_tag`
    /// will also return `true` for the same parameters.
    @inlinable func starts<TextTagT: TextTagProtocol>(tag: TextTagT?) -> Bool {
        let result = gtk_text_iter_starts_tag(text_iter_ptr, tag?.text_tag_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Determines whether `iter` begins a natural-language word.
    /// 
    /// Word breaks are determined by Pango and should be correct
    /// for nearly any language.
    @inlinable func startsWord() -> Bool {
        let result = gtk_text_iter_starts_word(text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets whether a range with `tag` applied to it begins
    /// or ends at `iter`.
    /// 
    /// This is equivalent to (`gtk_text_iter_starts_tag()` ||
    /// `gtk_text_iter_ends_tag()`)
    @inlinable func toggles(tag: TextTagRef? = nil) -> Bool {
            let result = gtk_text_iter_toggles_tag(text_iter_ptr, tag?.text_tag_ptr)
        let rv = ((result) != 0)
            return rv
    }
    /// Gets whether a range with `tag` applied to it begins
    /// or ends at `iter`.
    /// 
    /// This is equivalent to (`gtk_text_iter_starts_tag()` ||
    /// `gtk_text_iter_ends_tag()`)
    @inlinable func toggles<TextTagT: TextTagProtocol>(tag: TextTagT?) -> Bool {
        let result = gtk_text_iter_toggles_tag(text_iter_ptr, tag?.text_tag_ptr)
        let rv = ((result) != 0)
        return rv
    }
    /// Returns the `GtkTextBuffer` this iterator is associated with.
    @inlinable var buffer: TextBufferRef! {
        /// Returns the `GtkTextBuffer` this iterator is associated with.
        get {
            let result = gtk_text_iter_get_buffer(text_iter_ptr)
        let rv = TextBufferRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Returns the number of bytes in the line containing `iter`,
    /// including the paragraph delimiters.
    @inlinable var bytesInLine: Int {
        /// Returns the number of bytes in the line containing `iter`,
        /// including the paragraph delimiters.
        get {
            let result = gtk_text_iter_get_bytes_in_line(text_iter_ptr)
        let rv = Int(result)
            return rv
        }
    }

    /// The Unicode character at this iterator is returned.
    /// 
    /// Equivalent to operator* on a C++ iterator. If the element at
    /// this iterator is a non-character element, such as an image
    /// embedded in the buffer, the Unicode “unknown” character 0xFFFC
    /// is returned. If invoked on the end iterator, zero is returned;
    /// zero is not a valid Unicode character.
    /// 
    /// So you can write a loop which ends when this function returns 0.
    @inlinable var char: gunichar {
        /// The Unicode character at this iterator is returned.
        /// 
        /// Equivalent to operator* on a C++ iterator. If the element at
        /// this iterator is a non-character element, such as an image
        /// embedded in the buffer, the Unicode “unknown” character 0xFFFC
        /// is returned. If invoked on the end iterator, zero is returned;
        /// zero is not a valid Unicode character.
        /// 
        /// So you can write a loop which ends when this function returns 0.
        get {
            let result = gtk_text_iter_get_char(text_iter_ptr)
        let rv = result
            return rv
        }
    }

    /// Returns the number of characters in the line containing `iter`,
    /// including the paragraph delimiters.
    @inlinable var charsInLine: Int {
        /// Returns the number of characters in the line containing `iter`,
        /// including the paragraph delimiters.
        get {
            let result = gtk_text_iter_get_chars_in_line(text_iter_ptr)
        let rv = Int(result)
            return rv
        }
    }

    /// If the location at `iter` contains a child anchor, the
    /// anchor is returned.
    /// 
    /// Otherwise, `nil` is returned.
    @inlinable var childAnchor: TextChildAnchorRef! {
        /// If the location at `iter` contains a child anchor, the
        /// anchor is returned.
        /// 
        /// Otherwise, `nil` is returned.
        get {
            let result = gtk_text_iter_get_child_anchor(text_iter_ptr)
        let rv = TextChildAnchorRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Determine if `iter` is at a cursor position.
    /// 
    /// See [method`Gtk.TextIter.forward_cursor_position`] or
    /// [struct`Pango.LogAttr`] or [func`Pango.break`] for details
    /// on what a cursor position is.
    @inlinable var isCursorPosition: Bool {
        /// Determine if `iter` is at a cursor position.
        /// 
        /// See [method`Gtk.TextIter.forward_cursor_position`] or
        /// [struct`Pango.LogAttr`] or [func`Pango.break`] for details
        /// on what a cursor position is.
        get {
            let result = gtk_text_iter_is_cursor_position(text_iter_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// Returns `true` if `iter` is the end iterator.
    /// 
    /// This means it is one past the last dereferenceable iterator
    /// in the buffer. `gtk_text_iter_is_end()` is the most efficient
    /// way to check whether an iterator is the end iterator.
    @inlinable var isEnd: Bool {
        /// Returns `true` if `iter` is the end iterator.
        /// 
        /// This means it is one past the last dereferenceable iterator
        /// in the buffer. `gtk_text_iter_is_end()` is the most efficient
        /// way to check whether an iterator is the end iterator.
        get {
            let result = gtk_text_iter_is_end(text_iter_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// Returns `true` if `iter` is the first iterator in the buffer.
    @inlinable var isStart: Bool {
        /// Returns `true` if `iter` is the first iterator in the buffer.
        get {
            let result = gtk_text_iter_is_start(text_iter_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// Returns the language in effect at `iter`.
    /// 
    /// If no tags affecting language apply to `iter`, the return
    /// value is identical to that of [func`Gtk.get_default_language`].
    @inlinable var language: Pango.LanguageRef! {
        /// Returns the language in effect at `iter`.
        /// 
        /// If no tags affecting language apply to `iter`, the return
        /// value is identical to that of [func`Gtk.get_default_language`].
        get {
            let result = gtk_text_iter_get_language(text_iter_ptr)
        let rv = Pango.LanguageRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Returns the line number containing the iterator.
    /// 
    /// Lines in a `GtkTextBuffer` are numbered beginning
    /// with 0 for the first line in the buffer.
    @inlinable var line: Int {
        /// Returns the line number containing the iterator.
        /// 
        /// Lines in a `GtkTextBuffer` are numbered beginning
        /// with 0 for the first line in the buffer.
        get {
            let result = gtk_text_iter_get_line(text_iter_ptr)
        let rv = Int(result)
            return rv
        }
        /// Moves iterator `iter` to the start of the line `line_number`.
        /// 
        /// If `line_number` is negative or larger than or equal to the number of lines
        /// in the buffer, moves `iter` to the start of the last line in the buffer.
        nonmutating set {
            gtk_text_iter_set_line(text_iter_ptr, gint(newValue))
        }
    }

    /// Returns the byte index of the iterator, counting
    /// from the start of a newline-terminated line.
    /// 
    /// Remember that `GtkTextBuffer` encodes text in
    /// UTF-8, and that characters can require a variable
    /// number of bytes to represent.
    @inlinable var lineIndex: Int {
        /// Returns the byte index of the iterator, counting
        /// from the start of a newline-terminated line.
        /// 
        /// Remember that `GtkTextBuffer` encodes text in
        /// UTF-8, and that characters can require a variable
        /// number of bytes to represent.
        get {
            let result = gtk_text_iter_get_line_index(text_iter_ptr)
        let rv = Int(result)
            return rv
        }
        /// Same as `gtk_text_iter_set_line_offset()`, but works with a
        /// byte index. The given byte index must be at
        /// the start of a character, it can’t be in the middle of a UTF-8
        /// encoded character.
        nonmutating set {
            gtk_text_iter_set_line_index(text_iter_ptr, gint(newValue))
        }
    }

    /// Returns the character offset of the iterator,
    /// counting from the start of a newline-terminated line.
    /// 
    /// The first character on the line has offset 0.
    @inlinable var lineOffset: Int {
        /// Returns the character offset of the iterator,
        /// counting from the start of a newline-terminated line.
        /// 
        /// The first character on the line has offset 0.
        get {
            let result = gtk_text_iter_get_line_offset(text_iter_ptr)
        let rv = Int(result)
            return rv
        }
        /// Moves `iter` within a line, to a new character (not byte) offset.
        /// 
        /// The given character offset must be less than or equal to the number
        /// of characters in the line; if equal, `iter` moves to the start of the
        /// next line. See [method`Gtk.TextIter.set_line_index`] if you have a byte
        /// index rather than a character offset.
        nonmutating set {
            gtk_text_iter_set_line_offset(text_iter_ptr, gint(newValue))
        }
    }

    /// Returns a list of all `GtkTextMark` at this location.
    /// 
    /// Because marks are not iterable (they don’t take up any "space"
    /// in the buffer, they are just marks in between iterable locations),
    /// multiple marks can exist in the same place.
    /// 
    /// The returned list is not in any meaningful order.
    @inlinable var marks: GLib.SListRef! {
        /// Returns a list of all `GtkTextMark` at this location.
        /// 
        /// Because marks are not iterable (they don’t take up any "space"
        /// in the buffer, they are just marks in between iterable locations),
        /// multiple marks can exist in the same place.
        /// 
        /// The returned list is not in any meaningful order.
        get {
            let result = gtk_text_iter_get_marks(text_iter_ptr)
        let rv = GLib.SListRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Returns the character offset of an iterator.
    /// 
    /// Each character in a `GtkTextBuffer` has an offset,
    /// starting with 0 for the first character in the buffer.
    /// Use [method`Gtk`,TextBuffer.get_iter_at_offset] to convert
    /// an offset back into an iterator.
    @inlinable var offset: Int {
        /// Returns the character offset of an iterator.
        /// 
        /// Each character in a `GtkTextBuffer` has an offset,
        /// starting with 0 for the first character in the buffer.
        /// Use [method`Gtk`,TextBuffer.get_iter_at_offset] to convert
        /// an offset back into an iterator.
        get {
            let result = gtk_text_iter_get_offset(text_iter_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets `iter` to point to `char_offset`.
        /// 
        /// `char_offset` counts from the start
        /// of the entire text buffer, starting with 0.
        nonmutating set {
            gtk_text_iter_set_offset(text_iter_ptr, gint(newValue))
        }
    }

    /// If the element at `iter` is a paintable, the paintable is returned.
    /// 
    /// Otherwise, `nil` is returned.
    @inlinable var paintable: Gdk.PaintableRef! {
        /// If the element at `iter` is a paintable, the paintable is returned.
        /// 
        /// Otherwise, `nil` is returned.
        get {
            let result = gtk_text_iter_get_paintable(text_iter_ptr)
        let rv = Gdk.PaintableRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Returns a list of tags that apply to `iter`, in ascending order of
    /// priority.
    /// 
    /// The highest-priority tags are last.
    /// 
    /// The `GtkTextTag`s in the list don’t have a reference added,
    /// but you have to free the list itself.
    @inlinable var tags: GLib.SListRef! {
        /// Returns a list of tags that apply to `iter`, in ascending order of
        /// priority.
        /// 
        /// The highest-priority tags are last.
        /// 
        /// The `GtkTextTag`s in the list don’t have a reference added,
        /// but you have to free the list itself.
        get {
            let result = gtk_text_iter_get_tags(text_iter_ptr)
        let rv = GLib.SListRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Returns the number of bytes from the start of the
    /// line to the given `iter`, not counting bytes that
    /// are invisible due to tags with the “invisible” flag
    /// toggled on.
    @inlinable var visibleLineIndex: Int {
        /// Returns the number of bytes from the start of the
        /// line to the given `iter`, not counting bytes that
        /// are invisible due to tags with the “invisible” flag
        /// toggled on.
        get {
            let result = gtk_text_iter_get_visible_line_index(text_iter_ptr)
        let rv = Int(result)
            return rv
        }
        /// Like `gtk_text_iter_set_line_index()`, but the index is in visible
        /// bytes, i.e. text with a tag making it invisible is not counted
        /// in the index.
        nonmutating set {
            gtk_text_iter_set_visible_line_index(text_iter_ptr, gint(newValue))
        }
    }

    /// Returns the offset in characters from the start of the
    /// line to the given `iter`, not counting characters that
    /// are invisible due to tags with the “invisible” flag
    /// toggled on.
    @inlinable var visibleLineOffset: Int {
        /// Returns the offset in characters from the start of the
        /// line to the given `iter`, not counting characters that
        /// are invisible due to tags with the “invisible” flag
        /// toggled on.
        get {
            let result = gtk_text_iter_get_visible_line_offset(text_iter_ptr)
        let rv = Int(result)
            return rv
        }
        /// Like `gtk_text_iter_set_line_offset()`, but the offset is in visible
        /// characters, i.e. text with a tag making it invisible is not
        /// counted in the offset.
        nonmutating set {
            gtk_text_iter_set_visible_line_offset(text_iter_ptr, gint(newValue))
        }
    }

    // var dummy1 is unavailable because dummy1 is private

    // var dummy2 is unavailable because dummy2 is private

    // var dummy3 is unavailable because dummy3 is private

    // var dummy4 is unavailable because dummy4 is private

    // var dummy5 is unavailable because dummy5 is private

    // var dummy6 is unavailable because dummy6 is private

    // var dummy7 is unavailable because dummy7 is private

    // var dummy8 is unavailable because dummy8 is private

    // var dummy9 is unavailable because dummy9 is private

    // var dummy10 is unavailable because dummy10 is private

    // var dummy11 is unavailable because dummy11 is private

    // var dummy12 is unavailable because dummy12 is private

    // var dummy13 is unavailable because dummy13 is private

    // var dummy14 is unavailable because dummy14 is private

}



/// Metatype/GType declaration for TextMark
public extension TextMarkClassRef {
    
    /// This getter returns the GLib type identifier registered for `TextMark`
    static var metatypeReference: GType { gtk_text_mark_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkTextMarkClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkTextMarkClass.self) }
    
    static var metatype: GtkTextMarkClass? { metatypePointer?.pointee } 
    
    static var wrapper: TextMarkClassRef? { TextMarkClassRef(metatypePointer) }
    
    
}

// MARK: - TextMarkClass Record


///
/// The `TextMarkClassProtocol` protocol exposes the methods and properties of an underlying `GtkTextMarkClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextMarkClass`.
/// Alternatively, use `TextMarkClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextMarkClassProtocol {
        /// Untyped pointer to the underlying `GtkTextMarkClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTextMarkClass` instance.
    var _ptr: UnsafeMutablePointer<GtkTextMarkClass>! { get }

    /// Required Initialiser for types conforming to `TextMarkClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `TextMarkClassRef` type acts as a lightweight Swift reference to an underlying `GtkTextMarkClass` instance.
/// It exposes methods that can operate on this data type through `TextMarkClassProtocol` conformance.
/// Use `TextMarkClassRef` only as an `unowned` reference to an existing `GtkTextMarkClass` instance.
///
public struct TextMarkClassRef: TextMarkClassProtocol {
        /// Untyped pointer to the underlying `GtkTextMarkClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextMarkClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTextMarkClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTextMarkClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTextMarkClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTextMarkClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextMarkClassProtocol`
    @inlinable init<T: TextMarkClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: TextMarkClass Record: TextMarkClassProtocol extension (methods and fields)
public extension TextMarkClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextMarkClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkTextMarkClass>! { return ptr?.assumingMemoryBound(to: GtkTextMarkClass.self) }


    @inlinable var parentClass: GObjectClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var padding is unavailable because padding is private

}



/// Metatype/GType declaration for TextTag
public extension TextTagClassRef {
    
    /// This getter returns the GLib type identifier registered for `TextTag`
    static var metatypeReference: GType { gtk_text_tag_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkTextTagClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkTextTagClass.self) }
    
    static var metatype: GtkTextTagClass? { metatypePointer?.pointee } 
    
    static var wrapper: TextTagClassRef? { TextTagClassRef(metatypePointer) }
    
    
}

// MARK: - TextTagClass Record


///
/// The `TextTagClassProtocol` protocol exposes the methods and properties of an underlying `GtkTextTagClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextTagClass`.
/// Alternatively, use `TextTagClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextTagClassProtocol {
        /// Untyped pointer to the underlying `GtkTextTagClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTextTagClass` instance.
    var _ptr: UnsafeMutablePointer<GtkTextTagClass>! { get }

    /// Required Initialiser for types conforming to `TextTagClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `TextTagClassRef` type acts as a lightweight Swift reference to an underlying `GtkTextTagClass` instance.
/// It exposes methods that can operate on this data type through `TextTagClassProtocol` conformance.
/// Use `TextTagClassRef` only as an `unowned` reference to an existing `GtkTextTagClass` instance.
///
public struct TextTagClassRef: TextTagClassProtocol {
        /// Untyped pointer to the underlying `GtkTextTagClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextTagClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTextTagClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTextTagClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTextTagClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTextTagClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextTagClassProtocol`
    @inlinable init<T: TextTagClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: TextTagClass Record: TextTagClassProtocol extension (methods and fields)
public extension TextTagClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextTagClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkTextTagClass>! { return ptr?.assumingMemoryBound(to: GtkTextTagClass.self) }


    @inlinable var parentClass: GObjectClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var padding is unavailable because padding is private

}



/// Metatype/GType declaration for TextView
public extension TextViewClassRef {
    
    /// This getter returns the GLib type identifier registered for `TextView`
    static var metatypeReference: GType { gtk_text_view_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkTextViewClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkTextViewClass.self) }
    
    static var metatype: GtkTextViewClass? { metatypePointer?.pointee } 
    
    static var wrapper: TextViewClassRef? { TextViewClassRef(metatypePointer) }
    
    
}

// MARK: - TextViewClass Record


///
/// The `TextViewClassProtocol` protocol exposes the methods and properties of an underlying `GtkTextViewClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextViewClass`.
/// Alternatively, use `TextViewClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextViewClassProtocol {
        /// Untyped pointer to the underlying `GtkTextViewClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTextViewClass` instance.
    var _ptr: UnsafeMutablePointer<GtkTextViewClass>! { get }

    /// Required Initialiser for types conforming to `TextViewClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `TextViewClassRef` type acts as a lightweight Swift reference to an underlying `GtkTextViewClass` instance.
/// It exposes methods that can operate on this data type through `TextViewClassProtocol` conformance.
/// Use `TextViewClassRef` only as an `unowned` reference to an existing `GtkTextViewClass` instance.
///
public struct TextViewClassRef: TextViewClassProtocol {
        /// Untyped pointer to the underlying `GtkTextViewClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextViewClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTextViewClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTextViewClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTextViewClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTextViewClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextViewClassProtocol`
    @inlinable init<T: TextViewClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: TextViewClass Record: TextViewClassProtocol extension (methods and fields)
public extension TextViewClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextViewClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkTextViewClass>! { return ptr?.assumingMemoryBound(to: GtkTextViewClass.self) }


    /// The object class structure needs to be the first
    @inlinable var parentClass: GtkWidgetClass {
        /// The object class structure needs to be the first
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var moveCursor is unavailable because move_cursor is void

    // var setAnchor is unavailable because set_anchor is void

    // var insertAtCursor is unavailable because insert_at_cursor is void

    // var deleteFromCursor is unavailable because delete_from_cursor is void

    // var backspace is unavailable because backspace is void

    // var cutClipboard is unavailable because cut_clipboard is void

    // var copyClipboard is unavailable because copy_clipboard is void

    // var pasteClipboard is unavailable because paste_clipboard is void

    // var toggleOverwrite is unavailable because toggle_overwrite is void

    // var createBuffer is unavailable because create_buffer is void

    // var snapshotLayer is unavailable because snapshot_layer is void

    // var extendSelection is unavailable because extend_selection is void

    // var insertEmoji is unavailable because insert_emoji is void

    // var padding is unavailable because padding is private

}



/// Metatype/GType declaration for ToggleButton
public extension ToggleButtonClassRef {
    
    /// This getter returns the GLib type identifier registered for `ToggleButton`
    static var metatypeReference: GType { gtk_toggle_button_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkToggleButtonClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkToggleButtonClass.self) }
    
    static var metatype: GtkToggleButtonClass? { metatypePointer?.pointee } 
    
    static var wrapper: ToggleButtonClassRef? { ToggleButtonClassRef(metatypePointer) }
    
    
}

// MARK: - ToggleButtonClass Record


///
/// The `ToggleButtonClassProtocol` protocol exposes the methods and properties of an underlying `GtkToggleButtonClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ToggleButtonClass`.
/// Alternatively, use `ToggleButtonClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ToggleButtonClassProtocol {
        /// Untyped pointer to the underlying `GtkToggleButtonClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkToggleButtonClass` instance.
    var _ptr: UnsafeMutablePointer<GtkToggleButtonClass>! { get }

    /// Required Initialiser for types conforming to `ToggleButtonClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `ToggleButtonClassRef` type acts as a lightweight Swift reference to an underlying `GtkToggleButtonClass` instance.
/// It exposes methods that can operate on this data type through `ToggleButtonClassProtocol` conformance.
/// Use `ToggleButtonClassRef` only as an `unowned` reference to an existing `GtkToggleButtonClass` instance.
///
public struct ToggleButtonClassRef: ToggleButtonClassProtocol {
        /// Untyped pointer to the underlying `GtkToggleButtonClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ToggleButtonClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkToggleButtonClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkToggleButtonClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkToggleButtonClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkToggleButtonClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ToggleButtonClassProtocol`
    @inlinable init<T: ToggleButtonClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: ToggleButtonClass Record: ToggleButtonClassProtocol extension (methods and fields)
public extension ToggleButtonClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToggleButtonClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkToggleButtonClass>! { return ptr?.assumingMemoryBound(to: GtkToggleButtonClass.self) }


    @inlinable var parentClass: GtkButtonClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var toggled is unavailable because toggled is void

    // var padding is unavailable because padding is private

}



/// Metatype/GType declaration for TreeDragDest
public extension TreeDragDestIfaceRef {
    
    /// This getter returns the GLib type identifier registered for `TreeDragDest`
    static var metatypeReference: GType { gtk_tree_drag_dest_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkTreeDragDestIface>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkTreeDragDestIface.self) }
    
    static var metatype: GtkTreeDragDestIface? { metatypePointer?.pointee } 
    
    static var wrapper: TreeDragDestIfaceRef? { TreeDragDestIfaceRef(metatypePointer) }
    
    
}

// MARK: - TreeDragDestIface Record


///
/// The `TreeDragDestIfaceProtocol` protocol exposes the methods and properties of an underlying `GtkTreeDragDestIface` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeDragDestIface`.
/// Alternatively, use `TreeDragDestIfaceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeDragDestIfaceProtocol {
        /// Untyped pointer to the underlying `GtkTreeDragDestIface` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeDragDestIface` instance.
    var _ptr: UnsafeMutablePointer<GtkTreeDragDestIface>! { get }

    /// Required Initialiser for types conforming to `TreeDragDestIfaceProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `TreeDragDestIfaceRef` type acts as a lightweight Swift reference to an underlying `GtkTreeDragDestIface` instance.
/// It exposes methods that can operate on this data type through `TreeDragDestIfaceProtocol` conformance.
/// Use `TreeDragDestIfaceRef` only as an `unowned` reference to an existing `GtkTreeDragDestIface` instance.
///
public struct TreeDragDestIfaceRef: TreeDragDestIfaceProtocol {
        /// Untyped pointer to the underlying `GtkTreeDragDestIface` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeDragDestIfaceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeDragDestIface>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeDragDestIface>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeDragDestIface>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeDragDestIface>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeDragDestIfaceProtocol`
    @inlinable init<T: TreeDragDestIfaceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragDestIfaceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragDestIfaceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragDestIfaceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragDestIfaceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragDestIfaceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: TreeDragDestIface Record: TreeDragDestIfaceProtocol extension (methods and fields)
public extension TreeDragDestIfaceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeDragDestIface` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkTreeDragDestIface>! { return ptr?.assumingMemoryBound(to: GtkTreeDragDestIface.self) }


    // var gIface is unavailable because g_iface is private

    // var dragDataReceived is unavailable because drag_data_received is void

    // var rowDropPossible is unavailable because row_drop_possible is void

}



/// Metatype/GType declaration for TreeDragSource
public extension TreeDragSourceIfaceRef {
    
    /// This getter returns the GLib type identifier registered for `TreeDragSource`
    static var metatypeReference: GType { gtk_tree_drag_source_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkTreeDragSourceIface>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkTreeDragSourceIface.self) }
    
    static var metatype: GtkTreeDragSourceIface? { metatypePointer?.pointee } 
    
    static var wrapper: TreeDragSourceIfaceRef? { TreeDragSourceIfaceRef(metatypePointer) }
    
    
}

// MARK: - TreeDragSourceIface Record


///
/// The `TreeDragSourceIfaceProtocol` protocol exposes the methods and properties of an underlying `GtkTreeDragSourceIface` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeDragSourceIface`.
/// Alternatively, use `TreeDragSourceIfaceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeDragSourceIfaceProtocol {
        /// Untyped pointer to the underlying `GtkTreeDragSourceIface` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeDragSourceIface` instance.
    var _ptr: UnsafeMutablePointer<GtkTreeDragSourceIface>! { get }

    /// Required Initialiser for types conforming to `TreeDragSourceIfaceProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `TreeDragSourceIfaceRef` type acts as a lightweight Swift reference to an underlying `GtkTreeDragSourceIface` instance.
/// It exposes methods that can operate on this data type through `TreeDragSourceIfaceProtocol` conformance.
/// Use `TreeDragSourceIfaceRef` only as an `unowned` reference to an existing `GtkTreeDragSourceIface` instance.
///
public struct TreeDragSourceIfaceRef: TreeDragSourceIfaceProtocol {
        /// Untyped pointer to the underlying `GtkTreeDragSourceIface` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeDragSourceIfaceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeDragSourceIface>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeDragSourceIface>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeDragSourceIface>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeDragSourceIface>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeDragSourceIfaceProtocol`
    @inlinable init<T: TreeDragSourceIfaceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragSourceIfaceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragSourceIfaceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragSourceIfaceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragSourceIfaceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragSourceIfaceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: TreeDragSourceIface Record: TreeDragSourceIfaceProtocol extension (methods and fields)
public extension TreeDragSourceIfaceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeDragSourceIface` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkTreeDragSourceIface>! { return ptr?.assumingMemoryBound(to: GtkTreeDragSourceIface.self) }


    // var gIface is unavailable because g_iface is private

    // var rowDraggable is unavailable because row_draggable is void

    // var dragDataGet is unavailable because drag_data_get is void

    // var dragDataDelete is unavailable because drag_data_delete is void

}



/// Metatype/GType declaration for TreeExpander
public extension TreeExpanderClassRef {
    
    /// This getter returns the GLib type identifier registered for `TreeExpander`
    static var metatypeReference: GType { gtk_tree_expander_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkTreeExpanderClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkTreeExpanderClass.self) }
    
    static var metatype: GtkTreeExpanderClass? { metatypePointer?.pointee } 
    
    static var wrapper: TreeExpanderClassRef? { TreeExpanderClassRef(metatypePointer) }
    
    
}

// MARK: - TreeExpanderClass Record


///
/// The `TreeExpanderClassProtocol` protocol exposes the methods and properties of an underlying `GtkTreeExpanderClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeExpanderClass`.
/// Alternatively, use `TreeExpanderClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeExpanderClassProtocol {
        /// Untyped pointer to the underlying `GtkTreeExpanderClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeExpanderClass` instance.
    var _ptr: UnsafeMutablePointer<GtkTreeExpanderClass>! { get }

    /// Required Initialiser for types conforming to `TreeExpanderClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `TreeExpanderClassRef` type acts as a lightweight Swift reference to an underlying `GtkTreeExpanderClass` instance.
/// It exposes methods that can operate on this data type through `TreeExpanderClassProtocol` conformance.
/// Use `TreeExpanderClassRef` only as an `unowned` reference to an existing `GtkTreeExpanderClass` instance.
///
public struct TreeExpanderClassRef: TreeExpanderClassProtocol {
        /// Untyped pointer to the underlying `GtkTreeExpanderClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeExpanderClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeExpanderClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeExpanderClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeExpanderClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeExpanderClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeExpanderClassProtocol`
    @inlinable init<T: TreeExpanderClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeExpanderClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeExpanderClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeExpanderClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeExpanderClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeExpanderClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: TreeExpanderClass Record: TreeExpanderClassProtocol extension (methods and fields)
public extension TreeExpanderClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeExpanderClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkTreeExpanderClass>! { return ptr?.assumingMemoryBound(to: GtkTreeExpanderClass.self) }


    @inlinable var parentClass: GtkWidgetClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

}



// MARK: - TreeIter Record

/// The `GtkTreeIter` is the primary structure
/// for accessing a `GtkTreeModel`. Models are expected to put a unique
/// integer in the `stamp` member, and put
/// model-specific data in the three `user_data`
/// members.
///
/// The `TreeIterProtocol` protocol exposes the methods and properties of an underlying `GtkTreeIter` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeIter`.
/// Alternatively, use `TreeIterRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeIterProtocol {
        /// Untyped pointer to the underlying `GtkTreeIter` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeIter` instance.
    var tree_iter_ptr: UnsafeMutablePointer<GtkTreeIter>! { get }

    /// Required Initialiser for types conforming to `TreeIterProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `GtkTreeIter` is the primary structure
/// for accessing a `GtkTreeModel`. Models are expected to put a unique
/// integer in the `stamp` member, and put
/// model-specific data in the three `user_data`
/// members.
///
/// The `TreeIterRef` type acts as a lightweight Swift reference to an underlying `GtkTreeIter` instance.
/// It exposes methods that can operate on this data type through `TreeIterProtocol` conformance.
/// Use `TreeIterRef` only as an `unowned` reference to an existing `GtkTreeIter` instance.
///
public struct TreeIterRef: TreeIterProtocol {
        /// Untyped pointer to the underlying `GtkTreeIter` instance.
    /// For type-safe access, use the generated, typed pointer `tree_iter_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeIterRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeIter>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeIter>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeIter>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeIter>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeIterProtocol`
    @inlinable init<T: TreeIterProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeIterProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeIterProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeIterProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeIterProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeIterProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `GtkTreeIter` is the primary structure
/// for accessing a `GtkTreeModel`. Models are expected to put a unique
/// integer in the `stamp` member, and put
/// model-specific data in the three `user_data`
/// members.
///
/// The `TreeIter` type acts as an owner of an underlying `GtkTreeIter` instance.
/// It provides the methods that can operate on this data type through `TreeIterProtocol` conformance.
/// Use `TreeIter` as a strong reference or owner of a `GtkTreeIter` instance.
///
open class TreeIterBase: TreeIterProtocol {
        /// Untyped pointer to the underlying `GtkTreeIter` instance.
    /// For type-safe access, use the generated, typed pointer `tree_iter_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeIter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeIter>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeIter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeIter>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeIter` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeIter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeIter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeIter>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeIter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeIter>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GtkTreeIter` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `TreeIter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeIter>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GtkTreeIter, cannot ref(tree_iter_ptr)
    }

    /// Reference intialiser for a related type that implements `TreeIterProtocol`
    /// `GtkTreeIter` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `TreeIterProtocol`
    @inlinable public init<T: TreeIterProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GtkTreeIter, cannot ref(tree_iter_ptr)
    }

    /// Do-nothing destructor for `GtkTreeIter`.
    deinit {
        // no reference counting for GtkTreeIter, cannot unref(tree_iter_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeIterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeIterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GtkTreeIter, cannot ref(tree_iter_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeIterProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeIterProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GtkTreeIter, cannot ref(tree_iter_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeIterProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeIterProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GtkTreeIter, cannot ref(tree_iter_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeIterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeIterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GtkTreeIter, cannot ref(tree_iter_ptr)
    }



}

// MARK: no TreeIter properties

// MARK: no TreeIter signals

// MARK: TreeIter has no signals
// MARK: TreeIter Record: TreeIterProtocol extension (methods and fields)
public extension TreeIterProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeIter` instance.
    @inlinable var tree_iter_ptr: UnsafeMutablePointer<GtkTreeIter>! { return ptr?.assumingMemoryBound(to: GtkTreeIter.self) }

    /// Creates a dynamically allocated tree iterator as a copy of `iter`.
    /// 
    /// This function is not intended for use in applications,
    /// because you can just copy the structs by value
    /// (`GtkTreeIter new_iter = iter;`).
    /// You must free this iter with `gtk_tree_iter_free()`.
    @inlinable func copy() -> TreeIterRef! {
        let result = gtk_tree_iter_copy(tree_iter_ptr)
        guard let rv = TreeIterRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Frees an iterator that has been allocated by `gtk_tree_iter_copy()`.
    /// 
    /// This function is mainly used for language bindings.
    @inlinable func free() {
        
        gtk_tree_iter_free(tree_iter_ptr)
        
    }

    /// Lets a set of row reference created by
    /// `gtk_tree_row_reference_new_proxy()` know that the
    /// model emitted the `rows-reordered` signal.
    @inlinable func treeRowReferenceReordered<GObjectObjectT: GLibObject.ObjectProtocol, TreePathT: TreePathProtocol>(proxy: GObjectObjectT, path: TreePathT, newOrder: UnsafeMutablePointer<CInt>!) {
        
        gtk_tree_row_reference_reordered(proxy.object_ptr, path.tree_path_ptr, tree_iter_ptr, newOrder)
        
    }

    /// a unique stamp to catch invalid iterators
    @inlinable var stamp: gint {
        /// a unique stamp to catch invalid iterators
        get {
            let rv = tree_iter_ptr.pointee.stamp
    return rv
        }
        /// a unique stamp to catch invalid iterators
         set {
            tree_iter_ptr.pointee.stamp = newValue
        }
    }

    /// model-specific data
    @inlinable var userData: gpointer? {
        /// model-specific data
        get {
            let rv = tree_iter_ptr.pointee.user_data
    return rv
        }
        /// model-specific data
         set {
            tree_iter_ptr.pointee.user_data = newValue
        }
    }

    /// model-specific data
    @inlinable var userData2: gpointer? {
        /// model-specific data
        get {
            let rv = tree_iter_ptr.pointee.user_data2
    return rv
        }
        /// model-specific data
         set {
            tree_iter_ptr.pointee.user_data2 = newValue
        }
    }

    /// model-specific data
    @inlinable var userData3: gpointer? {
        /// model-specific data
        get {
            let rv = tree_iter_ptr.pointee.user_data3
    return rv
        }
        /// model-specific data
         set {
            tree_iter_ptr.pointee.user_data3 = newValue
        }
    }

}



/// Metatype/GType declaration for TreeListModel
public extension TreeListModelClassRef {
    
    /// This getter returns the GLib type identifier registered for `TreeListModel`
    static var metatypeReference: GType { gtk_tree_list_model_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkTreeListModelClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkTreeListModelClass.self) }
    
    static var metatype: GtkTreeListModelClass? { metatypePointer?.pointee } 
    
    static var wrapper: TreeListModelClassRef? { TreeListModelClassRef(metatypePointer) }
    
    
}

// MARK: - TreeListModelClass Record


///
/// The `TreeListModelClassProtocol` protocol exposes the methods and properties of an underlying `GtkTreeListModelClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeListModelClass`.
/// Alternatively, use `TreeListModelClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeListModelClassProtocol {
        /// Untyped pointer to the underlying `GtkTreeListModelClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeListModelClass` instance.
    var _ptr: UnsafeMutablePointer<GtkTreeListModelClass>! { get }

    /// Required Initialiser for types conforming to `TreeListModelClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `TreeListModelClassRef` type acts as a lightweight Swift reference to an underlying `GtkTreeListModelClass` instance.
/// It exposes methods that can operate on this data type through `TreeListModelClassProtocol` conformance.
/// Use `TreeListModelClassRef` only as an `unowned` reference to an existing `GtkTreeListModelClass` instance.
///
public struct TreeListModelClassRef: TreeListModelClassProtocol {
        /// Untyped pointer to the underlying `GtkTreeListModelClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeListModelClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeListModelClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeListModelClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeListModelClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeListModelClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeListModelClassProtocol`
    @inlinable init<T: TreeListModelClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListModelClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListModelClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListModelClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListModelClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListModelClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: TreeListModelClass Record: TreeListModelClassProtocol extension (methods and fields)
public extension TreeListModelClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeListModelClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkTreeListModelClass>! { return ptr?.assumingMemoryBound(to: GtkTreeListModelClass.self) }


    @inlinable var parentClass: GObjectClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

}



/// Metatype/GType declaration for TreeListRow
public extension TreeListRowClassRef {
    
    /// This getter returns the GLib type identifier registered for `TreeListRow`
    static var metatypeReference: GType { gtk_tree_list_row_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkTreeListRowClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkTreeListRowClass.self) }
    
    static var metatype: GtkTreeListRowClass? { metatypePointer?.pointee } 
    
    static var wrapper: TreeListRowClassRef? { TreeListRowClassRef(metatypePointer) }
    
    
}

// MARK: - TreeListRowClass Record


///
/// The `TreeListRowClassProtocol` protocol exposes the methods and properties of an underlying `GtkTreeListRowClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeListRowClass`.
/// Alternatively, use `TreeListRowClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeListRowClassProtocol {
        /// Untyped pointer to the underlying `GtkTreeListRowClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeListRowClass` instance.
    var _ptr: UnsafeMutablePointer<GtkTreeListRowClass>! { get }

    /// Required Initialiser for types conforming to `TreeListRowClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `TreeListRowClassRef` type acts as a lightweight Swift reference to an underlying `GtkTreeListRowClass` instance.
/// It exposes methods that can operate on this data type through `TreeListRowClassProtocol` conformance.
/// Use `TreeListRowClassRef` only as an `unowned` reference to an existing `GtkTreeListRowClass` instance.
///
public struct TreeListRowClassRef: TreeListRowClassProtocol {
        /// Untyped pointer to the underlying `GtkTreeListRowClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeListRowClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeListRowClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeListRowClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeListRowClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeListRowClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeListRowClassProtocol`
    @inlinable init<T: TreeListRowClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: TreeListRowClass Record: TreeListRowClassProtocol extension (methods and fields)
public extension TreeListRowClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeListRowClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkTreeListRowClass>! { return ptr?.assumingMemoryBound(to: GtkTreeListRowClass.self) }


    @inlinable var parentClass: GObjectClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

}



/// Metatype/GType declaration for TreeListRowSorter
public extension TreeListRowSorterClassRef {
    
    /// This getter returns the GLib type identifier registered for `TreeListRowSorter`
    static var metatypeReference: GType { gtk_tree_list_row_sorter_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkTreeListRowSorterClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkTreeListRowSorterClass.self) }
    
    static var metatype: GtkTreeListRowSorterClass? { metatypePointer?.pointee } 
    
    static var wrapper: TreeListRowSorterClassRef? { TreeListRowSorterClassRef(metatypePointer) }
    
    
}

// MARK: - TreeListRowSorterClass Record


///
/// The `TreeListRowSorterClassProtocol` protocol exposes the methods and properties of an underlying `GtkTreeListRowSorterClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeListRowSorterClass`.
/// Alternatively, use `TreeListRowSorterClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeListRowSorterClassProtocol {
        /// Untyped pointer to the underlying `GtkTreeListRowSorterClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeListRowSorterClass` instance.
    var _ptr: UnsafeMutablePointer<GtkTreeListRowSorterClass>! { get }

    /// Required Initialiser for types conforming to `TreeListRowSorterClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `TreeListRowSorterClassRef` type acts as a lightweight Swift reference to an underlying `GtkTreeListRowSorterClass` instance.
/// It exposes methods that can operate on this data type through `TreeListRowSorterClassProtocol` conformance.
/// Use `TreeListRowSorterClassRef` only as an `unowned` reference to an existing `GtkTreeListRowSorterClass` instance.
///
public struct TreeListRowSorterClassRef: TreeListRowSorterClassProtocol {
        /// Untyped pointer to the underlying `GtkTreeListRowSorterClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeListRowSorterClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeListRowSorterClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeListRowSorterClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeListRowSorterClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeListRowSorterClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeListRowSorterClassProtocol`
    @inlinable init<T: TreeListRowSorterClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowSorterClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowSorterClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowSorterClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowSorterClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowSorterClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: TreeListRowSorterClass Record: TreeListRowSorterClassProtocol extension (methods and fields)
public extension TreeListRowSorterClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeListRowSorterClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkTreeListRowSorterClass>! { return ptr?.assumingMemoryBound(to: GtkTreeListRowSorterClass.self) }


    @inlinable var parentClass: GtkSorterClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

}



/// Metatype/GType declaration for TreeModelFilter
public extension TreeModelFilterClassRef {
    
    /// This getter returns the GLib type identifier registered for `TreeModelFilter`
    static var metatypeReference: GType { gtk_tree_model_filter_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkTreeModelFilterClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkTreeModelFilterClass.self) }
    
    static var metatype: GtkTreeModelFilterClass? { metatypePointer?.pointee } 
    
    static var wrapper: TreeModelFilterClassRef? { TreeModelFilterClassRef(metatypePointer) }
    
    
}

// MARK: - TreeModelFilterClass Record


///
/// The `TreeModelFilterClassProtocol` protocol exposes the methods and properties of an underlying `GtkTreeModelFilterClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeModelFilterClass`.
/// Alternatively, use `TreeModelFilterClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeModelFilterClassProtocol {
        /// Untyped pointer to the underlying `GtkTreeModelFilterClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeModelFilterClass` instance.
    var _ptr: UnsafeMutablePointer<GtkTreeModelFilterClass>! { get }

    /// Required Initialiser for types conforming to `TreeModelFilterClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `TreeModelFilterClassRef` type acts as a lightweight Swift reference to an underlying `GtkTreeModelFilterClass` instance.
/// It exposes methods that can operate on this data type through `TreeModelFilterClassProtocol` conformance.
/// Use `TreeModelFilterClassRef` only as an `unowned` reference to an existing `GtkTreeModelFilterClass` instance.
///
public struct TreeModelFilterClassRef: TreeModelFilterClassProtocol {
        /// Untyped pointer to the underlying `GtkTreeModelFilterClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeModelFilterClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeModelFilterClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeModelFilterClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeModelFilterClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeModelFilterClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeModelFilterClassProtocol`
    @inlinable init<T: TreeModelFilterClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: TreeModelFilterClass Record: TreeModelFilterClassProtocol extension (methods and fields)
public extension TreeModelFilterClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeModelFilterClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkTreeModelFilterClass>! { return ptr?.assumingMemoryBound(to: GtkTreeModelFilterClass.self) }


    @inlinable var parentClass: GObjectClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var visible is unavailable because visible is void

    // var modify is unavailable because modify is void

    // var padding is unavailable because padding is private

}



/// Metatype/GType declaration for TreeModel
public extension TreeModelIfaceRef {
    
    /// This getter returns the GLib type identifier registered for `TreeModel`
    static var metatypeReference: GType { gtk_tree_model_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkTreeModelIface>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkTreeModelIface.self) }
    
    static var metatype: GtkTreeModelIface? { metatypePointer?.pointee } 
    
    static var wrapper: TreeModelIfaceRef? { TreeModelIfaceRef(metatypePointer) }
    
    
}

// MARK: - TreeModelIface Record


///
/// The `TreeModelIfaceProtocol` protocol exposes the methods and properties of an underlying `GtkTreeModelIface` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeModelIface`.
/// Alternatively, use `TreeModelIfaceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeModelIfaceProtocol {
        /// Untyped pointer to the underlying `GtkTreeModelIface` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeModelIface` instance.
    var _ptr: UnsafeMutablePointer<GtkTreeModelIface>! { get }

    /// Required Initialiser for types conforming to `TreeModelIfaceProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `TreeModelIfaceRef` type acts as a lightweight Swift reference to an underlying `GtkTreeModelIface` instance.
/// It exposes methods that can operate on this data type through `TreeModelIfaceProtocol` conformance.
/// Use `TreeModelIfaceRef` only as an `unowned` reference to an existing `GtkTreeModelIface` instance.
///
public struct TreeModelIfaceRef: TreeModelIfaceProtocol {
        /// Untyped pointer to the underlying `GtkTreeModelIface` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeModelIfaceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeModelIface>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeModelIface>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeModelIface>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeModelIface>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeModelIfaceProtocol`
    @inlinable init<T: TreeModelIfaceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelIfaceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelIfaceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelIfaceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelIfaceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelIfaceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: TreeModelIface Record: TreeModelIfaceProtocol extension (methods and fields)
public extension TreeModelIfaceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeModelIface` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkTreeModelIface>! { return ptr?.assumingMemoryBound(to: GtkTreeModelIface.self) }


    // var gIface is unavailable because g_iface is private

    // var rowChanged is unavailable because row_changed is void

    // var rowInserted is unavailable because row_inserted is void

    // var rowHasChildToggled is unavailable because row_has_child_toggled is void

    // var rowDeleted is unavailable because row_deleted is void

    // var rowsReordered is unavailable because rows_reordered is void

    // var getFlags is unavailable because get_flags is void

    // var getNColumns is unavailable because get_n_columns is void

    // var getColumnType is unavailable because get_column_type is void

    // var getIter is unavailable because get_iter is void

    // var getPath is unavailable because get_path is void

    // var getValue is unavailable because get_value is void

    // var iterNext is unavailable because iter_next is void

    // var iterPrevious is unavailable because iter_previous is void

    // var iterChildren is unavailable because iter_children is void

    // var iterHasChild is unavailable because iter_has_child is void

    // var iterNChildren is unavailable because iter_n_children is void

    // var iterNthChild is unavailable because iter_nth_child is void

    // var iterParent is unavailable because iter_parent is void

    // var refNode is unavailable because ref_node is void

    // var unrefNode is unavailable because unref_node is void

}



/// Metatype/GType declaration for TreeModelSort
public extension TreeModelSortClassRef {
    
    /// This getter returns the GLib type identifier registered for `TreeModelSort`
    static var metatypeReference: GType { gtk_tree_model_sort_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkTreeModelSortClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkTreeModelSortClass.self) }
    
    static var metatype: GtkTreeModelSortClass? { metatypePointer?.pointee } 
    
    static var wrapper: TreeModelSortClassRef? { TreeModelSortClassRef(metatypePointer) }
    
    
}

// MARK: - TreeModelSortClass Record


///
/// The `TreeModelSortClassProtocol` protocol exposes the methods and properties of an underlying `GtkTreeModelSortClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeModelSortClass`.
/// Alternatively, use `TreeModelSortClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeModelSortClassProtocol {
        /// Untyped pointer to the underlying `GtkTreeModelSortClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeModelSortClass` instance.
    var _ptr: UnsafeMutablePointer<GtkTreeModelSortClass>! { get }

    /// Required Initialiser for types conforming to `TreeModelSortClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `TreeModelSortClassRef` type acts as a lightweight Swift reference to an underlying `GtkTreeModelSortClass` instance.
/// It exposes methods that can operate on this data type through `TreeModelSortClassProtocol` conformance.
/// Use `TreeModelSortClassRef` only as an `unowned` reference to an existing `GtkTreeModelSortClass` instance.
///
public struct TreeModelSortClassRef: TreeModelSortClassProtocol {
        /// Untyped pointer to the underlying `GtkTreeModelSortClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeModelSortClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeModelSortClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeModelSortClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeModelSortClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeModelSortClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeModelSortClassProtocol`
    @inlinable init<T: TreeModelSortClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: TreeModelSortClass Record: TreeModelSortClassProtocol extension (methods and fields)
public extension TreeModelSortClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeModelSortClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkTreeModelSortClass>! { return ptr?.assumingMemoryBound(to: GtkTreeModelSortClass.self) }


    @inlinable var parentClass: GObjectClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var padding is unavailable because padding is private

}



// MARK: - TreePath Record

/// An opaque structure representing a path to a row in a model.
///
/// The `TreePathProtocol` protocol exposes the methods and properties of an underlying `GtkTreePath` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreePath`.
/// Alternatively, use `TreePathRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreePathProtocol {
        /// Untyped pointer to the underlying `GtkTreePath` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreePath` instance.
    var tree_path_ptr: UnsafeMutablePointer<GtkTreePath>! { get }

    /// Required Initialiser for types conforming to `TreePathProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// An opaque structure representing a path to a row in a model.
///
/// The `TreePathRef` type acts as a lightweight Swift reference to an underlying `GtkTreePath` instance.
/// It exposes methods that can operate on this data type through `TreePathProtocol` conformance.
/// Use `TreePathRef` only as an `unowned` reference to an existing `GtkTreePath` instance.
///
public struct TreePathRef: TreePathProtocol {
        /// Untyped pointer to the underlying `GtkTreePath` instance.
    /// For type-safe access, use the generated, typed pointer `tree_path_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreePathRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreePath>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreePath>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreePath>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreePath>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreePathProtocol`
    @inlinable init<T: TreePathProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreePathProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreePathProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreePathProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreePathProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreePathProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkTreePath`
    /// This refers to a row.
    @inlinable init() {
            let result = gtk_tree_path_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }


    // *** newFromIndices() is not available because it has a varargs (...) parameter!


    /// Creates a new path with the given `indices` array of `length`.
    @inlinable init(indicesv indices: UnsafeMutablePointer<CInt>!, length: Int) {
            let result = gtk_tree_path_new_from_indicesv(indices, gsize(length))
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkTreePath` initialized to `path`.
    /// 
    /// `path` is expected to be a colon separated list of numbers.
    /// For example, the string “10:4:0” would create a path of depth
    /// 3 pointing to the 11th child of the root node, the 5th
    /// child of that 11th child, and the 1st child of that 5th child.
    /// If an invalid path string is passed in, `nil` is returned.
    @inlinable init(string path: UnsafePointer<CChar>!) {
            let result = gtk_tree_path_new_from_string(path)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkTreePath`.
    /// 
    /// The string representation of this path is “0”.
    @inlinable static func newFirst() -> TreePathRef! {
            let result = gtk_tree_path_new_first()
        guard let rv = TreePathRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }


    // *** newFromIndices() is not available because it has a varargs (...) parameter!


    /// Creates a new path with the given `indices` array of `length`.
    @inlinable static func newFrom(indicesv indices: UnsafeMutablePointer<CInt>!, length: Int) -> TreePathRef! {
            let result = gtk_tree_path_new_from_indicesv(indices, gsize(length))
        guard let rv = TreePathRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Creates a new `GtkTreePath` initialized to `path`.
    /// 
    /// `path` is expected to be a colon separated list of numbers.
    /// For example, the string “10:4:0” would create a path of depth
    /// 3 pointing to the 11th child of the root node, the 5th
    /// child of that 11th child, and the 1st child of that 5th child.
    /// If an invalid path string is passed in, `nil` is returned.
    @inlinable static func newFrom(string path: UnsafePointer<CChar>!) -> TreePathRef! {
            let result = gtk_tree_path_new_from_string(path)
        guard let rv = TreePathRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }
}

/// An opaque structure representing a path to a row in a model.
///
/// The `TreePath` type acts as an owner of an underlying `GtkTreePath` instance.
/// It provides the methods that can operate on this data type through `TreePathProtocol` conformance.
/// Use `TreePath` as a strong reference or owner of a `GtkTreePath` instance.
///
open class TreePath: TreePathProtocol {
        /// Untyped pointer to the underlying `GtkTreePath` instance.
    /// For type-safe access, use the generated, typed pointer `tree_path_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreePath` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreePath>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreePath` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreePath>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreePath` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreePath` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreePath` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreePath>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreePath` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreePath>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GtkTreePath` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `TreePath` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreePath>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GtkTreePath, cannot ref(tree_path_ptr)
    }

    /// Reference intialiser for a related type that implements `TreePathProtocol`
    /// `GtkTreePath` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `TreePathProtocol`
    @inlinable public init<T: TreePathProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GtkTreePath, cannot ref(tree_path_ptr)
    }

    /// Do-nothing destructor for `GtkTreePath`.
    deinit {
        // no reference counting for GtkTreePath, cannot unref(tree_path_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreePathProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreePathProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GtkTreePath, cannot ref(tree_path_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreePathProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreePathProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GtkTreePath, cannot ref(tree_path_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreePathProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreePathProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GtkTreePath, cannot ref(tree_path_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreePathProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreePathProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GtkTreePath, cannot ref(tree_path_ptr)
    }

    /// Creates a new `GtkTreePath`
    /// This refers to a row.
    @inlinable public init() {
            let result = gtk_tree_path_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }


    // *** newFromIndices() is not available because it has a varargs (...) parameter!


    /// Creates a new path with the given `indices` array of `length`.
    @inlinable public init(indicesv indices: UnsafeMutablePointer<CInt>!, length: Int) {
            let result = gtk_tree_path_new_from_indicesv(indices, gsize(length))
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkTreePath` initialized to `path`.
    /// 
    /// `path` is expected to be a colon separated list of numbers.
    /// For example, the string “10:4:0” would create a path of depth
    /// 3 pointing to the 11th child of the root node, the 5th
    /// child of that 11th child, and the 1st child of that 5th child.
    /// If an invalid path string is passed in, `nil` is returned.
    @inlinable public init(string path: UnsafePointer<CChar>!) {
            let result = gtk_tree_path_new_from_string(path)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkTreePath`.
    /// 
    /// The string representation of this path is “0”.
    @inlinable public static func newFirst() -> TreePath! {
            let result = gtk_tree_path_new_first()
        guard let rv = TreePath(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }


    // *** newFromIndices() is not available because it has a varargs (...) parameter!


    /// Creates a new path with the given `indices` array of `length`.
    @inlinable public static func newFrom(indicesv indices: UnsafeMutablePointer<CInt>!, length: Int) -> TreePath! {
            let result = gtk_tree_path_new_from_indicesv(indices, gsize(length))
        guard let rv = TreePath(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Creates a new `GtkTreePath` initialized to `path`.
    /// 
    /// `path` is expected to be a colon separated list of numbers.
    /// For example, the string “10:4:0” would create a path of depth
    /// 3 pointing to the 11th child of the root node, the 5th
    /// child of that 11th child, and the 1st child of that 5th child.
    /// If an invalid path string is passed in, `nil` is returned.
    @inlinable public static func newFrom(string path: UnsafePointer<CChar>!) -> TreePath! {
            let result = gtk_tree_path_new_from_string(path)
        guard let rv = TreePath(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

}

// MARK: no TreePath properties

// MARK: no TreePath signals

// MARK: TreePath has no signals
// MARK: TreePath Record: TreePathProtocol extension (methods and fields)
public extension TreePathProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreePath` instance.
    @inlinable var tree_path_ptr: UnsafeMutablePointer<GtkTreePath>! { return ptr?.assumingMemoryBound(to: GtkTreePath.self) }

    /// Appends a new index to a path.
    /// 
    /// As a result, the depth of the path is increased.
    @inlinable func append(index: Int) {
        
        gtk_tree_path_append_index(tree_path_ptr, gint(index))
        
    }

    /// Compares two paths.
    /// 
    /// If `a` appears before `b` in a tree, then -1 is returned.
    /// If `b` appears before `a`, then 1 is returned.
    /// If the two nodes are equal, then 0 is returned.
    @inlinable func compare<TreePathT: TreePathProtocol>(b: TreePathT) -> Int {
        let result = gtk_tree_path_compare(tree_path_ptr, b.tree_path_ptr)
        let rv = Int(result)
        return rv
    }

    /// Creates a new `GtkTreePath` as a copy of `path`.
    @inlinable func copy() -> TreePathRef! {
        let result = gtk_tree_path_copy(tree_path_ptr)
        guard let rv = TreePathRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Moves `path` to point to the first child of the current path.
    @inlinable func down() {
        
        gtk_tree_path_down(tree_path_ptr)
        
    }

    /// Frees `path`. If `path` is `nil`, it simply returns.
    @inlinable func free() {
        
        gtk_tree_path_free(tree_path_ptr)
        
    }

    /// Returns the current depth of `path`.
    @inlinable func getDepth() -> Int {
        let result = gtk_tree_path_get_depth(tree_path_ptr)
        let rv = Int(result)
        return rv
    }

    /// Returns the current indices of `path`.
    /// 
    /// This is an array of integers, each representing a node in a tree.
    /// This value should not be freed.
    /// 
    /// The length of the array can be obtained with `gtk_tree_path_get_depth()`.
    @inlinable func getIndices() -> UnsafeMutablePointer<gint>? {
        let result = gtk_tree_path_get_indices(tree_path_ptr)
        let rv = result
        return rv
    }

    /// Returns the current indices of `path`.
    /// 
    /// This is an array of integers, each representing a node in a tree.
    /// It also returns the number of elements in the array.
    /// The array should not be freed.
    @inlinable func getIndicesWith(depth: UnsafeMutablePointer<gint>! = nil) -> UnsafeMutablePointer<CInt>! {
        let result = gtk_tree_path_get_indices_with_depth(tree_path_ptr, depth)
        let rv = result
        return rv
    }

    /// Returns `true` if `descendant` is a descendant of `path`.
    @inlinable func isAncestor<TreePathT: TreePathProtocol>(descendant: TreePathT) -> Bool {
        let result = gtk_tree_path_is_ancestor(tree_path_ptr, descendant.tree_path_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns `true` if `path` is a descendant of `ancestor`.
    @inlinable func isDescendant<TreePathT: TreePathProtocol>(ancestor: TreePathT) -> Bool {
        let result = gtk_tree_path_is_descendant(tree_path_ptr, ancestor.tree_path_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves the `path` to point to the next node at the current depth.
    @inlinable func next() {
        
        gtk_tree_path_next(tree_path_ptr)
        
    }

    /// Prepends a new index to a path.
    /// 
    /// As a result, the depth of the path is increased.
    @inlinable func prepend(index: Int) {
        
        gtk_tree_path_prepend_index(tree_path_ptr, gint(index))
        
    }

    /// Moves the `path` to point to the previous node at the
    /// current depth, if it exists.
    @inlinable func prev() -> Bool {
        let result = gtk_tree_path_prev(tree_path_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Generates a string representation of the path.
    /// 
    /// This string is a “:” separated list of numbers.
    /// For example, “4:10:0:3” would be an acceptable
    /// return value for this string. If the path has
    /// depth 0, `nil` is returned.
    @inlinable func toString() -> String! {
        let result = gtk_tree_path_to_string(tree_path_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Moves the `path` to point to its parent node, if it has a parent.
    @inlinable func up() -> Bool {
        let result = gtk_tree_path_up(tree_path_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Creates a content provider for dragging `path` from `tree_model`.
    @inlinable func treeCreateRowDragContent<TreeModelT: TreeModelProtocol>(treeModel: TreeModelT) -> Gdk.ContentProviderRef! {
        let result = gtk_tree_create_row_drag_content(treeModel.tree_model_ptr, tree_path_ptr)
        let rv = Gdk.ContentProviderRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Lets a set of row reference created by
    /// `gtk_tree_row_reference_new_proxy()` know that the
    /// model emitted the `row-deleted` signal.
    @inlinable func treeRowReferenceDeleted<GObjectObjectT: GLibObject.ObjectProtocol>(proxy: GObjectObjectT) {
        
        gtk_tree_row_reference_deleted(proxy.object_ptr, tree_path_ptr)
        
    }

    /// Lets a set of row reference created by
    /// `gtk_tree_row_reference_new_proxy()` know that the
    /// model emitted the `row-inserted` signal.
    @inlinable func treeRowReferenceInserted<GObjectObjectT: GLibObject.ObjectProtocol>(proxy: GObjectObjectT) {
        
        gtk_tree_row_reference_inserted(proxy.object_ptr, tree_path_ptr)
        
    }

    /// Lets a set of row reference created by
    /// `gtk_tree_row_reference_new_proxy()` know that the
    /// model emitted the `rows-reordered` signal.
    @inlinable func treeRowReferenceReordered<GObjectObjectT: GLibObject.ObjectProtocol, TreeIterT: TreeIterProtocol>(proxy: GObjectObjectT, iter: TreeIterT, newOrder: UnsafeMutablePointer<CInt>!) {
        
        gtk_tree_row_reference_reordered(proxy.object_ptr, tree_path_ptr, iter.tree_iter_ptr, newOrder)
        
    }
    /// Returns the current depth of `path`.
    @inlinable var depth: Int {
        /// Returns the current depth of `path`.
        get {
            let result = gtk_tree_path_get_depth(tree_path_ptr)
        let rv = Int(result)
            return rv
        }
    }

    /// Returns the current indices of `path`.
    /// 
    /// This is an array of integers, each representing a node in a tree.
    /// This value should not be freed.
    /// 
    /// The length of the array can be obtained with `gtk_tree_path_get_depth()`.
    @inlinable var indices: UnsafeMutablePointer<gint>? {
        /// Returns the current indices of `path`.
        /// 
        /// This is an array of integers, each representing a node in a tree.
        /// This value should not be freed.
        /// 
        /// The length of the array can be obtained with `gtk_tree_path_get_depth()`.
        get {
            let result = gtk_tree_path_get_indices(tree_path_ptr)
        let rv = result
            return rv
        }
    }


}



// MARK: - TreeRowReference Record

/// A GtkTreeRowReference tracks model changes so that it always refers to the
/// same row (a `GtkTreePath` refers to a position, not a fixed row). Create a
/// new GtkTreeRowReference with `gtk_tree_row_reference_new()`.
///
/// The `TreeRowReferenceProtocol` protocol exposes the methods and properties of an underlying `GtkTreeRowReference` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeRowReference`.
/// Alternatively, use `TreeRowReferenceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeRowReferenceProtocol {
        /// Untyped pointer to the underlying `GtkTreeRowReference` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeRowReference` instance.
    var tree_row_reference_ptr: UnsafeMutablePointer<GtkTreeRowReference>! { get }

    /// Required Initialiser for types conforming to `TreeRowReferenceProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A GtkTreeRowReference tracks model changes so that it always refers to the
/// same row (a `GtkTreePath` refers to a position, not a fixed row). Create a
/// new GtkTreeRowReference with `gtk_tree_row_reference_new()`.
///
/// The `TreeRowReferenceRef` type acts as a lightweight Swift reference to an underlying `GtkTreeRowReference` instance.
/// It exposes methods that can operate on this data type through `TreeRowReferenceProtocol` conformance.
/// Use `TreeRowReferenceRef` only as an `unowned` reference to an existing `GtkTreeRowReference` instance.
///
public struct TreeRowReferenceRef: TreeRowReferenceProtocol {
        /// Untyped pointer to the underlying `GtkTreeRowReference` instance.
    /// For type-safe access, use the generated, typed pointer `tree_row_reference_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeRowReferenceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeRowReference>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeRowReference>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeRowReference>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeRowReference>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeRowReferenceProtocol`
    @inlinable init<T: TreeRowReferenceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeRowReferenceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeRowReferenceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeRowReferenceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeRowReferenceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeRowReferenceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a row reference based on `path`.
    /// 
    /// This reference will keep pointing to the node pointed to
    /// by `path`, so long as it exists. Any changes that occur on `model` are
    /// propagated, and the path is updated appropriately. If
    /// `path` isn’t a valid path in `model`, then `nil` is returned.
    @inlinable init<TreeModelT: TreeModelProtocol, TreePathT: TreePathProtocol>( model: TreeModelT, path: TreePathT) {
            let result = gtk_tree_row_reference_new(model.tree_model_ptr, path.tree_path_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// You do not need to use this function.
    /// 
    /// Creates a row reference based on `path`.
    /// 
    /// This reference will keep pointing to the node pointed to
    /// by `path`, so long as it exists. If `path` isn’t a valid
    /// path in `model`, then `nil` is returned. However, unlike
    /// references created with `gtk_tree_row_reference_new()`, it
    /// does not listen to the model for changes. The creator of
    /// the row reference must do this explicitly using
    /// `gtk_tree_row_reference_inserted()`, `gtk_tree_row_reference_deleted()`,
    /// `gtk_tree_row_reference_reordered()`.
    /// 
    /// These functions must be called exactly once per proxy when the
    /// corresponding signal on the model is emitted. This single call
    /// updates all row references for that proxy. Since built-in GTK
    /// objects like `GtkTreeView` already use this mechanism internally,
    /// using them as the proxy object will produce unpredictable results.
    /// Further more, passing the same object as `model` and `proxy`
    /// doesn’t work for reasons of internal implementation.
    /// 
    /// This type of row reference is primarily meant by structures that
    /// need to carefully monitor exactly when a row reference updates
    /// itself, and is not generally needed by most applications.
    @inlinable init<GObjectObjectT: GLibObject.ObjectProtocol, TreeModelT: TreeModelProtocol, TreePathT: TreePathProtocol>(proxy: GObjectObjectT, model: TreeModelT, path: TreePathT) {
            let result = gtk_tree_row_reference_new_proxy(proxy.object_ptr, model.tree_model_ptr, path.tree_path_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
    /// You do not need to use this function.
    /// 
    /// Creates a row reference based on `path`.
    /// 
    /// This reference will keep pointing to the node pointed to
    /// by `path`, so long as it exists. If `path` isn’t a valid
    /// path in `model`, then `nil` is returned. However, unlike
    /// references created with `gtk_tree_row_reference_new()`, it
    /// does not listen to the model for changes. The creator of
    /// the row reference must do this explicitly using
    /// `gtk_tree_row_reference_inserted()`, `gtk_tree_row_reference_deleted()`,
    /// `gtk_tree_row_reference_reordered()`.
    /// 
    /// These functions must be called exactly once per proxy when the
    /// corresponding signal on the model is emitted. This single call
    /// updates all row references for that proxy. Since built-in GTK
    /// objects like `GtkTreeView` already use this mechanism internally,
    /// using them as the proxy object will produce unpredictable results.
    /// Further more, passing the same object as `model` and `proxy`
    /// doesn’t work for reasons of internal implementation.
    /// 
    /// This type of row reference is primarily meant by structures that
    /// need to carefully monitor exactly when a row reference updates
    /// itself, and is not generally needed by most applications.
    @inlinable static func new<GObjectObjectT: GLibObject.ObjectProtocol, TreeModelT: TreeModelProtocol, TreePathT: TreePathProtocol>(proxy: GObjectObjectT, model: TreeModelT, path: TreePathT) -> TreeRowReferenceRef! {
            let result = gtk_tree_row_reference_new_proxy(proxy.object_ptr, model.tree_model_ptr, path.tree_path_ptr)
        guard let rv = TreeRowReferenceRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }
}

/// A GtkTreeRowReference tracks model changes so that it always refers to the
/// same row (a `GtkTreePath` refers to a position, not a fixed row). Create a
/// new GtkTreeRowReference with `gtk_tree_row_reference_new()`.
///
/// The `TreeRowReference` type acts as an owner of an underlying `GtkTreeRowReference` instance.
/// It provides the methods that can operate on this data type through `TreeRowReferenceProtocol` conformance.
/// Use `TreeRowReference` as a strong reference or owner of a `GtkTreeRowReference` instance.
///
open class TreeRowReference: TreeRowReferenceProtocol {
        /// Untyped pointer to the underlying `GtkTreeRowReference` instance.
    /// For type-safe access, use the generated, typed pointer `tree_row_reference_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeRowReference` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeRowReference>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeRowReference` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeRowReference>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeRowReference` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeRowReference` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeRowReference` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeRowReference>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeRowReference` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeRowReference>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GtkTreeRowReference` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `TreeRowReference` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeRowReference>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GtkTreeRowReference, cannot ref(tree_row_reference_ptr)
    }

    /// Reference intialiser for a related type that implements `TreeRowReferenceProtocol`
    /// `GtkTreeRowReference` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `TreeRowReferenceProtocol`
    @inlinable public init<T: TreeRowReferenceProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GtkTreeRowReference, cannot ref(tree_row_reference_ptr)
    }

    /// Do-nothing destructor for `GtkTreeRowReference`.
    deinit {
        // no reference counting for GtkTreeRowReference, cannot unref(tree_row_reference_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeRowReferenceProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeRowReferenceProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GtkTreeRowReference, cannot ref(tree_row_reference_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeRowReferenceProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeRowReferenceProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GtkTreeRowReference, cannot ref(tree_row_reference_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeRowReferenceProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeRowReferenceProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GtkTreeRowReference, cannot ref(tree_row_reference_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeRowReferenceProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeRowReferenceProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GtkTreeRowReference, cannot ref(tree_row_reference_ptr)
    }

    /// Creates a row reference based on `path`.
    /// 
    /// This reference will keep pointing to the node pointed to
    /// by `path`, so long as it exists. Any changes that occur on `model` are
    /// propagated, and the path is updated appropriately. If
    /// `path` isn’t a valid path in `model`, then `nil` is returned.
    @inlinable public init<TreeModelT: TreeModelProtocol, TreePathT: TreePathProtocol>( model: TreeModelT, path: TreePathT) {
            let result = gtk_tree_row_reference_new(model.tree_model_ptr, path.tree_path_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// You do not need to use this function.
    /// 
    /// Creates a row reference based on `path`.
    /// 
    /// This reference will keep pointing to the node pointed to
    /// by `path`, so long as it exists. If `path` isn’t a valid
    /// path in `model`, then `nil` is returned. However, unlike
    /// references created with `gtk_tree_row_reference_new()`, it
    /// does not listen to the model for changes. The creator of
    /// the row reference must do this explicitly using
    /// `gtk_tree_row_reference_inserted()`, `gtk_tree_row_reference_deleted()`,
    /// `gtk_tree_row_reference_reordered()`.
    /// 
    /// These functions must be called exactly once per proxy when the
    /// corresponding signal on the model is emitted. This single call
    /// updates all row references for that proxy. Since built-in GTK
    /// objects like `GtkTreeView` already use this mechanism internally,
    /// using them as the proxy object will produce unpredictable results.
    /// Further more, passing the same object as `model` and `proxy`
    /// doesn’t work for reasons of internal implementation.
    /// 
    /// This type of row reference is primarily meant by structures that
    /// need to carefully monitor exactly when a row reference updates
    /// itself, and is not generally needed by most applications.
    @inlinable public init<GObjectObjectT: GLibObject.ObjectProtocol, TreeModelT: TreeModelProtocol, TreePathT: TreePathProtocol>(proxy: GObjectObjectT, model: TreeModelT, path: TreePathT) {
            let result = gtk_tree_row_reference_new_proxy(proxy.object_ptr, model.tree_model_ptr, path.tree_path_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// You do not need to use this function.
    /// 
    /// Creates a row reference based on `path`.
    /// 
    /// This reference will keep pointing to the node pointed to
    /// by `path`, so long as it exists. If `path` isn’t a valid
    /// path in `model`, then `nil` is returned. However, unlike
    /// references created with `gtk_tree_row_reference_new()`, it
    /// does not listen to the model for changes. The creator of
    /// the row reference must do this explicitly using
    /// `gtk_tree_row_reference_inserted()`, `gtk_tree_row_reference_deleted()`,
    /// `gtk_tree_row_reference_reordered()`.
    /// 
    /// These functions must be called exactly once per proxy when the
    /// corresponding signal on the model is emitted. This single call
    /// updates all row references for that proxy. Since built-in GTK
    /// objects like `GtkTreeView` already use this mechanism internally,
    /// using them as the proxy object will produce unpredictable results.
    /// Further more, passing the same object as `model` and `proxy`
    /// doesn’t work for reasons of internal implementation.
    /// 
    /// This type of row reference is primarily meant by structures that
    /// need to carefully monitor exactly when a row reference updates
    /// itself, and is not generally needed by most applications.
    @inlinable public static func new<GObjectObjectT: GLibObject.ObjectProtocol, TreeModelT: TreeModelProtocol, TreePathT: TreePathProtocol>(proxy: GObjectObjectT, model: TreeModelT, path: TreePathT) -> TreeRowReference! {
            let result = gtk_tree_row_reference_new_proxy(proxy.object_ptr, model.tree_model_ptr, path.tree_path_ptr)
        guard let rv = TreeRowReference(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

}

// MARK: no TreeRowReference properties

// MARK: no TreeRowReference signals

// MARK: TreeRowReference has no signals
// MARK: TreeRowReference Record: TreeRowReferenceProtocol extension (methods and fields)
public extension TreeRowReferenceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeRowReference` instance.
    @inlinable var tree_row_reference_ptr: UnsafeMutablePointer<GtkTreeRowReference>! { return ptr?.assumingMemoryBound(to: GtkTreeRowReference.self) }

    /// Copies a `GtkTreeRowReference`.
    @inlinable func copy() -> TreeRowReferenceRef! {
        let result = gtk_tree_row_reference_copy(tree_row_reference_ptr)
        guard let rv = TreeRowReferenceRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Free’s `reference`. `reference` may be `nil`
    @inlinable func free() {
        
        gtk_tree_row_reference_free(tree_row_reference_ptr)
        
    }

    /// Returns the model that the row reference is monitoring.
    @inlinable func getModel() -> TreeModelRef! {
        let result = gtk_tree_row_reference_get_model(tree_row_reference_ptr)
        let rv = TreeModelRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns a path that the row reference currently points to,
    /// or `nil` if the path pointed to is no longer valid.
    @inlinable func getPath() -> TreePathRef! {
        let result = gtk_tree_row_reference_get_path(tree_row_reference_ptr)
        let rv = TreePathRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns `true` if the `reference` is non-`nil` and refers to
    /// a current valid path.
    @inlinable func valid() -> Bool {
        let result = gtk_tree_row_reference_valid(tree_row_reference_ptr)
        let rv = ((result) != 0)
        return rv
    }
    /// Returns the model that the row reference is monitoring.
    @inlinable var model: TreeModelRef! {
        /// Returns the model that the row reference is monitoring.
        get {
            let result = gtk_tree_row_reference_get_model(tree_row_reference_ptr)
        let rv = TreeModelRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Returns a path that the row reference currently points to,
    /// or `nil` if the path pointed to is no longer valid.
    @inlinable var path: TreePathRef! {
        /// Returns a path that the row reference currently points to,
        /// or `nil` if the path pointed to is no longer valid.
        get {
            let result = gtk_tree_row_reference_get_path(tree_row_reference_ptr)
        let rv = TreePathRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }


}



/// Metatype/GType declaration for TreeSortable
public extension TreeSortableIfaceRef {
    
    /// This getter returns the GLib type identifier registered for `TreeSortable`
    static var metatypeReference: GType { gtk_tree_sortable_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkTreeSortableIface>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkTreeSortableIface.self) }
    
    static var metatype: GtkTreeSortableIface? { metatypePointer?.pointee } 
    
    static var wrapper: TreeSortableIfaceRef? { TreeSortableIfaceRef(metatypePointer) }
    
    
}

// MARK: - TreeSortableIface Record


///
/// The `TreeSortableIfaceProtocol` protocol exposes the methods and properties of an underlying `GtkTreeSortableIface` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeSortableIface`.
/// Alternatively, use `TreeSortableIfaceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeSortableIfaceProtocol {
        /// Untyped pointer to the underlying `GtkTreeSortableIface` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeSortableIface` instance.
    var _ptr: UnsafeMutablePointer<GtkTreeSortableIface>! { get }

    /// Required Initialiser for types conforming to `TreeSortableIfaceProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `TreeSortableIfaceRef` type acts as a lightweight Swift reference to an underlying `GtkTreeSortableIface` instance.
/// It exposes methods that can operate on this data type through `TreeSortableIfaceProtocol` conformance.
/// Use `TreeSortableIfaceRef` only as an `unowned` reference to an existing `GtkTreeSortableIface` instance.
///
public struct TreeSortableIfaceRef: TreeSortableIfaceProtocol {
        /// Untyped pointer to the underlying `GtkTreeSortableIface` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeSortableIfaceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeSortableIface>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeSortableIface>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeSortableIface>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeSortableIface>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeSortableIfaceProtocol`
    @inlinable init<T: TreeSortableIfaceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSortableIfaceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSortableIfaceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSortableIfaceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSortableIfaceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSortableIfaceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: TreeSortableIface Record: TreeSortableIfaceProtocol extension (methods and fields)
public extension TreeSortableIfaceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeSortableIface` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkTreeSortableIface>! { return ptr?.assumingMemoryBound(to: GtkTreeSortableIface.self) }


    // var gIface is unavailable because g_iface is private

    // var sortColumnChanged is unavailable because sort_column_changed is void

    // var getSortColumnId is unavailable because get_sort_column_id is void

    // var setSortColumnId is unavailable because set_sort_column_id is void

    // var setSortFunc is unavailable because set_sort_func is void

    // var setDefaultSortFunc is unavailable because set_default_sort_func is void

    // var hasDefaultSortFunc is unavailable because has_default_sort_func is void

}



/// Metatype/GType declaration for TreeStore
public extension TreeStoreClassRef {
    
    /// This getter returns the GLib type identifier registered for `TreeStore`
    static var metatypeReference: GType { gtk_tree_store_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkTreeStoreClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkTreeStoreClass.self) }
    
    static var metatype: GtkTreeStoreClass? { metatypePointer?.pointee } 
    
    static var wrapper: TreeStoreClassRef? { TreeStoreClassRef(metatypePointer) }
    
    
}

// MARK: - TreeStoreClass Record


///
/// The `TreeStoreClassProtocol` protocol exposes the methods and properties of an underlying `GtkTreeStoreClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeStoreClass`.
/// Alternatively, use `TreeStoreClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeStoreClassProtocol {
        /// Untyped pointer to the underlying `GtkTreeStoreClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeStoreClass` instance.
    var _ptr: UnsafeMutablePointer<GtkTreeStoreClass>! { get }

    /// Required Initialiser for types conforming to `TreeStoreClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `TreeStoreClassRef` type acts as a lightweight Swift reference to an underlying `GtkTreeStoreClass` instance.
/// It exposes methods that can operate on this data type through `TreeStoreClassProtocol` conformance.
/// Use `TreeStoreClassRef` only as an `unowned` reference to an existing `GtkTreeStoreClass` instance.
///
public struct TreeStoreClassRef: TreeStoreClassProtocol {
        /// Untyped pointer to the underlying `GtkTreeStoreClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeStoreClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeStoreClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeStoreClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeStoreClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeStoreClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeStoreClassProtocol`
    @inlinable init<T: TreeStoreClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: TreeStoreClass Record: TreeStoreClassProtocol extension (methods and fields)
public extension TreeStoreClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeStoreClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkTreeStoreClass>! { return ptr?.assumingMemoryBound(to: GtkTreeStoreClass.self) }


    @inlinable var parentClass: GObjectClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var padding is unavailable because padding is private

}



/// Metatype/GType declaration for TreeView
public extension TreeViewClassRef {
    
    /// This getter returns the GLib type identifier registered for `TreeView`
    static var metatypeReference: GType { gtk_tree_view_get_type() }
    
    private static var metatypePointer: UnsafeMutablePointer<GtkTreeViewClass>? { g_type_class_peek_static(metatypeReference)?.assumingMemoryBound(to: GtkTreeViewClass.self) }
    
    static var metatype: GtkTreeViewClass? { metatypePointer?.pointee } 
    
    static var wrapper: TreeViewClassRef? { TreeViewClassRef(metatypePointer) }
    
    
}

// MARK: - TreeViewClass Record


///
/// The `TreeViewClassProtocol` protocol exposes the methods and properties of an underlying `GtkTreeViewClass` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeViewClass`.
/// Alternatively, use `TreeViewClassRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeViewClassProtocol {
        /// Untyped pointer to the underlying `GtkTreeViewClass` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeViewClass` instance.
    var _ptr: UnsafeMutablePointer<GtkTreeViewClass>! { get }

    /// Required Initialiser for types conforming to `TreeViewClassProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `TreeViewClassRef` type acts as a lightweight Swift reference to an underlying `GtkTreeViewClass` instance.
/// It exposes methods that can operate on this data type through `TreeViewClassProtocol` conformance.
/// Use `TreeViewClassRef` only as an `unowned` reference to an existing `GtkTreeViewClass` instance.
///
public struct TreeViewClassRef: TreeViewClassProtocol {
        /// Untyped pointer to the underlying `GtkTreeViewClass` instance.
    /// For type-safe access, use the generated, typed pointer `_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeViewClassRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeViewClass>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeViewClass>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeViewClass>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeViewClass>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeViewClassProtocol`
    @inlinable init<T: TreeViewClassProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewClassProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewClassProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewClassProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewClassProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewClassProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

// MARK: TreeViewClass Record: TreeViewClassProtocol extension (methods and fields)
public extension TreeViewClassProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeViewClass` instance.
    @inlinable var _ptr: UnsafeMutablePointer<GtkTreeViewClass>! { return ptr?.assumingMemoryBound(to: GtkTreeViewClass.self) }


    @inlinable var parentClass: GtkWidgetClass {
        get {
            let rv = _ptr.pointee.parent_class
    return rv
        }
    }

    // var rowActivated is unavailable because row_activated is void

    // var testExpandRow is unavailable because test_expand_row is void

    // var testCollapseRow is unavailable because test_collapse_row is void

    // var rowExpanded is unavailable because row_expanded is void

    // var rowCollapsed is unavailable because row_collapsed is void

    // var columnsChanged is unavailable because columns_changed is void

    // var cursorChanged is unavailable because cursor_changed is void

    // var moveCursor is unavailable because move_cursor is void

    // var selectAll is unavailable because select_all is void

    // var unselectAll is unavailable because unselect_all is void

    // var selectCursorRow is unavailable because select_cursor_row is void

    // var toggleCursorRow is unavailable because toggle_cursor_row is void

    // var expandCollapseCursorRow is unavailable because expand_collapse_cursor_row is void

    // var selectCursorParent is unavailable because select_cursor_parent is void

    // var startInteractiveSearch is unavailable because start_interactive_search is void

    // var Reserved is unavailable because _reserved is private

}



// MARK: - TreeDragDest Interface

/// Interface for Drag-and-Drop destinations in `GtkTreeView`.
///
/// The `TreeDragDestProtocol` protocol exposes the methods and properties of an underlying `GtkTreeDragDest` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeDragDest`.
/// Alternatively, use `TreeDragDestRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeDragDestProtocol {
        /// Untyped pointer to the underlying `GtkTreeDragDest` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeDragDest` instance.
    var tree_drag_dest_ptr: UnsafeMutablePointer<GtkTreeDragDest>! { get }

    /// Required Initialiser for types conforming to `TreeDragDestProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Interface for Drag-and-Drop destinations in `GtkTreeView`.
///
/// The `TreeDragDestRef` type acts as a lightweight Swift reference to an underlying `GtkTreeDragDest` instance.
/// It exposes methods that can operate on this data type through `TreeDragDestProtocol` conformance.
/// Use `TreeDragDestRef` only as an `unowned` reference to an existing `GtkTreeDragDest` instance.
///
public struct TreeDragDestRef: TreeDragDestProtocol {
        /// Untyped pointer to the underlying `GtkTreeDragDest` instance.
    /// For type-safe access, use the generated, typed pointer `tree_drag_dest_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeDragDestRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeDragDest>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeDragDest>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeDragDest>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeDragDest>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeDragDestProtocol`
    @inlinable init<T: TreeDragDestProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragDestProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragDestProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragDestProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragDestProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragDestProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// Interface for Drag-and-Drop destinations in `GtkTreeView`.
///
/// The `TreeDragDest` type acts as an owner of an underlying `GtkTreeDragDest` instance.
/// It provides the methods that can operate on this data type through `TreeDragDestProtocol` conformance.
/// Use `TreeDragDest` as a strong reference or owner of a `GtkTreeDragDest` instance.
///
open class TreeDragDest: TreeDragDestProtocol {
        /// Untyped pointer to the underlying `GtkTreeDragDest` instance.
    /// For type-safe access, use the generated, typed pointer `tree_drag_dest_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeDragDest` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeDragDest>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeDragDest` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeDragDest>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeDragDest` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeDragDest` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeDragDest` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeDragDest>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeDragDest` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeDragDest>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GtkTreeDragDest` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `TreeDragDest` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeDragDest>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GtkTreeDragDest, cannot ref(tree_drag_dest_ptr)
    }

    /// Reference intialiser for a related type that implements `TreeDragDestProtocol`
    /// `GtkTreeDragDest` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `TreeDragDestProtocol`
    @inlinable public init<T: TreeDragDestProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GtkTreeDragDest, cannot ref(tree_drag_dest_ptr)
    }

    /// Do-nothing destructor for `GtkTreeDragDest`.
    deinit {
        // no reference counting for GtkTreeDragDest, cannot unref(tree_drag_dest_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragDestProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragDestProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GtkTreeDragDest, cannot ref(tree_drag_dest_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragDestProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragDestProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GtkTreeDragDest, cannot ref(tree_drag_dest_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragDestProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragDestProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GtkTreeDragDest, cannot ref(tree_drag_dest_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragDestProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragDestProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GtkTreeDragDest, cannot ref(tree_drag_dest_ptr)
    }



}

// MARK: no TreeDragDest properties

// MARK: no TreeDragDest signals

// MARK: TreeDragDest has no signals
// MARK: TreeDragDest Interface: TreeDragDestProtocol extension (methods and fields)
public extension TreeDragDestProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeDragDest` instance.
    @inlinable var tree_drag_dest_ptr: UnsafeMutablePointer<GtkTreeDragDest>! { return ptr?.assumingMemoryBound(to: GtkTreeDragDest.self) }

    /// Asks the `GtkTreeDragDest` to insert a row before the path `dest`,
    /// deriving the contents of the row from `value`. If `dest` is
    /// outside the tree so that inserting before it is impossible, `false`
    /// will be returned. Also, `false` may be returned if the new row is
    /// not created for some model-specific reason.  Should robustly handle
    /// a `dest` no longer found in the model!
    @inlinable func dragDataReceived<GObjectValueT: GLibObject.ValueProtocol, TreePathT: TreePathProtocol>(dest: TreePathT, value: GObjectValueT) -> Bool {
        let result = gtk_tree_drag_dest_drag_data_received(tree_drag_dest_ptr, dest.tree_path_ptr, value.value_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Determines whether a drop is possible before the given `dest_path`,
    /// at the same depth as `dest_path`. i.e., can we drop the data in
    /// `value` at that location. `dest_path` does not have to
    /// exist; the return value will almost certainly be `false` if the
    /// parent of `dest_path` doesn’t exist, though.
    @inlinable func rowDropPossible<GObjectValueT: GLibObject.ValueProtocol, TreePathT: TreePathProtocol>(destPath: TreePathT, value: GObjectValueT) -> Bool {
        let result = gtk_tree_drag_dest_row_drop_possible(tree_drag_dest_ptr, destPath.tree_path_ptr, value.value_ptr)
        let rv = ((result) != 0)
        return rv
    }


}



// MARK: - TreeDragSource Interface

/// Interface for Drag-and-Drop destinations in `GtkTreeView`.
///
/// The `TreeDragSourceProtocol` protocol exposes the methods and properties of an underlying `GtkTreeDragSource` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeDragSource`.
/// Alternatively, use `TreeDragSourceRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeDragSourceProtocol {
        /// Untyped pointer to the underlying `GtkTreeDragSource` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeDragSource` instance.
    var tree_drag_source_ptr: UnsafeMutablePointer<GtkTreeDragSource>! { get }

    /// Required Initialiser for types conforming to `TreeDragSourceProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Interface for Drag-and-Drop destinations in `GtkTreeView`.
///
/// The `TreeDragSourceRef` type acts as a lightweight Swift reference to an underlying `GtkTreeDragSource` instance.
/// It exposes methods that can operate on this data type through `TreeDragSourceProtocol` conformance.
/// Use `TreeDragSourceRef` only as an `unowned` reference to an existing `GtkTreeDragSource` instance.
///
public struct TreeDragSourceRef: TreeDragSourceProtocol {
        /// Untyped pointer to the underlying `GtkTreeDragSource` instance.
    /// For type-safe access, use the generated, typed pointer `tree_drag_source_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeDragSourceRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeDragSource>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeDragSource>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeDragSource>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeDragSource>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeDragSourceProtocol`
    @inlinable init<T: TreeDragSourceProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragSourceProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragSourceProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragSourceProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragSourceProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragSourceProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// Interface for Drag-and-Drop destinations in `GtkTreeView`.
///
/// The `TreeDragSource` type acts as an owner of an underlying `GtkTreeDragSource` instance.
/// It provides the methods that can operate on this data type through `TreeDragSourceProtocol` conformance.
/// Use `TreeDragSource` as a strong reference or owner of a `GtkTreeDragSource` instance.
///
open class TreeDragSource: TreeDragSourceProtocol {
        /// Untyped pointer to the underlying `GtkTreeDragSource` instance.
    /// For type-safe access, use the generated, typed pointer `tree_drag_source_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeDragSource` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeDragSource>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeDragSource` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeDragSource>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeDragSource` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeDragSource` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeDragSource` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeDragSource>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeDragSource` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeDragSource>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GtkTreeDragSource` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `TreeDragSource` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeDragSource>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GtkTreeDragSource, cannot ref(tree_drag_source_ptr)
    }

    /// Reference intialiser for a related type that implements `TreeDragSourceProtocol`
    /// `GtkTreeDragSource` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `TreeDragSourceProtocol`
    @inlinable public init<T: TreeDragSourceProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GtkTreeDragSource, cannot ref(tree_drag_source_ptr)
    }

    /// Do-nothing destructor for `GtkTreeDragSource`.
    deinit {
        // no reference counting for GtkTreeDragSource, cannot unref(tree_drag_source_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragSourceProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragSourceProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GtkTreeDragSource, cannot ref(tree_drag_source_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragSourceProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragSourceProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GtkTreeDragSource, cannot ref(tree_drag_source_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragSourceProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragSourceProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GtkTreeDragSource, cannot ref(tree_drag_source_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragSourceProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeDragSourceProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GtkTreeDragSource, cannot ref(tree_drag_source_ptr)
    }



}

// MARK: no TreeDragSource properties

// MARK: no TreeDragSource signals

// MARK: TreeDragSource has no signals
// MARK: TreeDragSource Interface: TreeDragSourceProtocol extension (methods and fields)
public extension TreeDragSourceProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeDragSource` instance.
    @inlinable var tree_drag_source_ptr: UnsafeMutablePointer<GtkTreeDragSource>! { return ptr?.assumingMemoryBound(to: GtkTreeDragSource.self) }

    /// Asks the `GtkTreeDragSource` to delete the row at `path`, because
    /// it was moved somewhere else via drag-and-drop. Returns `false`
    /// if the deletion fails because `path` no longer exists, or for
    /// some model-specific reason. Should robustly handle a `path` no
    /// longer found in the model!
    @inlinable func dragDataDelete<TreePathT: TreePathProtocol>(path: TreePathT) -> Bool {
        let result = gtk_tree_drag_source_drag_data_delete(tree_drag_source_ptr, path.tree_path_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Asks the `GtkTreeDragSource` to return a `GdkContentProvider` representing
    /// the row at `path`. Should robustly handle a `path` no
    /// longer found in the model!
    @inlinable func dragDataGet<TreePathT: TreePathProtocol>(path: TreePathT) -> Gdk.ContentProviderRef! {
        let result = gtk_tree_drag_source_drag_data_get(tree_drag_source_ptr, path.tree_path_ptr)
        let rv = Gdk.ContentProviderRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Asks the `GtkTreeDragSource` whether a particular row can be used as
    /// the source of a DND operation. If the source doesn’t implement
    /// this interface, the row is assumed draggable.
    @inlinable func rowDraggable<TreePathT: TreePathProtocol>(path: TreePathT) -> Bool {
        let result = gtk_tree_drag_source_row_draggable(tree_drag_source_ptr, path.tree_path_ptr)
        let rv = ((result) != 0)
        return rv
    }


}



// MARK: - TreeModel Interface

/// The tree interface used by GtkTreeView
/// 
/// The `GtkTreeModel` interface defines a generic tree interface for
/// use by the `GtkTreeView` widget. It is an abstract interface, and
/// is designed to be usable with any appropriate data structure. The
/// programmer just has to implement this interface on their own data
/// type for it to be viewable by a `GtkTreeView` widget.
/// 
/// The model is represented as a hierarchical tree of strongly-typed,
/// columned data. In other words, the model can be seen as a tree where
/// every node has different values depending on which column is being
/// queried. The type of data found in a column is determined by using
/// the GType system (ie. `G_TYPE_INT`, `GTK_TYPE_BUTTON`, `G_TYPE_POINTER`,
/// etc). The types are homogeneous per column across all nodes. It is
/// important to note that this interface only provides a way of examining
/// a model and observing changes. The implementation of each individual
/// model decides how and if changes are made.
/// 
/// In order to make life simpler for programmers who do not need to
/// write their own specialized model, two generic models are provided
/// — the `GtkTreeStore` and the `GtkListStore`. To use these, the
/// developer simply pushes data into these models as necessary. These
/// models provide the data structure as well as all appropriate tree
/// interfaces. As a result, implementing drag and drop, sorting, and
/// storing data is trivial. For the vast majority of trees and lists,
/// these two models are sufficient.
/// 
/// Models are accessed on a node/column level of granularity. One can
/// query for the value of a model at a certain node and a certain
/// column on that node. There are two structures used to reference a
/// particular node in a model. They are the [struct`Gtk.TreePath`] and
/// the [struct`Gtk.TreeIter`] (“iter” is short for iterator). Most of the
/// interface consists of operations on a [struct`Gtk.TreeIter`].
/// 
/// A path is essentially a potential node. It is a location on a model
/// that may or may not actually correspond to a node on a specific
/// model. A [struct`Gtk.TreePath`] can be converted into either an
/// array of unsigned integers or a string. The string form is a list
/// of numbers separated by a colon. Each number refers to the offset
/// at that level. Thus, the path `0` refers to the root
/// node and the path `2:4` refers to the fifth child of
/// the third node.
/// 
/// By contrast, a [struct`Gtk.TreeIter`] is a reference to a specific node on
/// a specific model. It is a generic struct with an integer and three
/// generic pointers. These are filled in by the model in a model-specific
/// way. One can convert a path to an iterator by calling
/// `gtk_tree_model_get_iter()`. These iterators are the primary way
/// of accessing a model and are similar to the iterators used by
/// `GtkTextBuffer`. They are generally statically allocated on the
/// stack and only used for a short time. The model interface defines
/// a set of operations using them for navigating the model.
/// 
/// It is expected that models fill in the iterator with private data.
/// For example, the `GtkListStore` model, which is internally a simple
/// linked list, stores a list node in one of the pointers. The
/// `GtkTreeModel`Sort stores an array and an offset in two of the
/// pointers. Additionally, there is an integer field. This field is
/// generally filled with a unique stamp per model. This stamp is for
/// catching errors resulting from using invalid iterators with a model.
/// 
/// The lifecycle of an iterator can be a little confusing at first.
/// Iterators are expected to always be valid for as long as the model
/// is unchanged (and doesn’t emit a signal). The model is considered
/// to own all outstanding iterators and nothing needs to be done to
/// free them from the user’s point of view. Additionally, some models
/// guarantee that an iterator is valid for as long as the node it refers
/// to is valid (most notably the `GtkTreeStore` and `GtkListStore`).
/// Although generally uninteresting, as one always has to allow for
/// the case where iterators do not persist beyond a signal, some very
/// important performance enhancements were made in the sort model.
/// As a result, the `GTK_TREE_MODEL_ITERS_PERSIST` flag was added to
/// indicate this behavior.
/// 
/// To help show some common operation of a model, some examples are
/// provided. The first example shows three ways of getting the iter at
/// the location `3:2:5`. While the first method shown is
/// easier, the second is much more common, as you often get paths from
/// callbacks.
/// 
/// ## Acquiring a `GtkTreeIter`
/// 
/// ```c
/// // Three ways of getting the iter pointing to the location
/// GtkTreePath *path;
/// GtkTreeIter iter;
/// GtkTreeIter parent_iter;
/// 
/// // get the iterator from a string
/// gtk_tree_model_get_iter_from_string (model,
///                                      &iter,
///                                      "3:2:5");
/// 
/// // get the iterator from a path
/// path = gtk_tree_path_new_from_string ("3:2:5");
/// gtk_tree_model_get_iter (model, &iter, path);
/// gtk_tree_path_free (path);
/// 
/// // walk the tree to find the iterator
/// gtk_tree_model_iter_nth_child (model, &iter,
///                                NULL, 3);
/// parent_iter = iter;
/// gtk_tree_model_iter_nth_child (model, &iter,
///                                &parent_iter, 2);
/// parent_iter = iter;
/// gtk_tree_model_iter_nth_child (model, &iter,
///                                &parent_iter, 5);
/// ```
/// 
/// This second example shows a quick way of iterating through a list
/// and getting a string and an integer from each row. The
/// `populate_model()` function used below is not
/// shown, as it is specific to the `GtkListStore`. For information on
/// how to write such a function, see the `GtkListStore` documentation.
/// 
/// ## Reading data from a `GtkTreeModel`
/// 
/// ```c
/// enum
/// {
///   STRING_COLUMN,
///   INT_COLUMN,
///   N_COLUMNS
/// };
/// 
/// ...
/// 
/// GtkTreeModel *list_store;
/// GtkTreeIter iter;
/// gboolean valid;
/// int row_count = 0;
/// 
/// // make a new list_store
/// list_store = gtk_list_store_new (N_COLUMNS,
///                                  G_TYPE_STRING,
///                                  G_TYPE_INT);
/// 
/// // Fill the list store with data
/// populate_model (list_store);
/// 
/// // Get the first iter in the list, check it is valid and walk
/// // through the list, reading each row.
/// 
/// valid = gtk_tree_model_get_iter_first (list_store,
///                                        &iter);
/// while (valid)
///  {
///    char *str_data;
///    int    int_data;
/// 
///    // Make sure you terminate calls to `gtk_tree_model_get()` with a “-1” value
///    gtk_tree_model_get (list_store, &iter,
///                        STRING_COLUMN, &str_data,
///                        INT_COLUMN, &int_data,
///                        -1);
/// 
///    // Do something with the data
///    g_print ("Row `d:` (`s`,`d`)\n",
///             row_count, str_data, int_data);
///    g_free (str_data);
/// 
///    valid = gtk_tree_model_iter_next (list_store,
///                                      &iter);
///    row_count++;
///  }
/// ```
/// 
/// The `GtkTreeModel` interface contains two methods for reference
/// counting: `gtk_tree_model_ref_node()` and `gtk_tree_model_unref_node()`.
/// These two methods are optional to implement. The reference counting
/// is meant as a way for views to let models know when nodes are being
/// displayed. `GtkTreeView` will take a reference on a node when it is
/// visible, which means the node is either in the toplevel or expanded.
/// Being displayed does not mean that the node is currently directly
/// visible to the user in the viewport. Based on this reference counting
/// scheme a caching model, for example, can decide whether or not to cache
/// a node based on the reference count. A file-system based model would
/// not want to keep the entire file hierarchy in memory, but just the
/// folders that are currently expanded in every current view.
/// 
/// When working with reference counting, the following rules must be taken
/// into account:
/// 
/// - Never take a reference on a node without owning a reference on its parent.
///   This means that all parent nodes of a referenced node must be referenced
///   as well.
/// 
/// - Outstanding references on a deleted node are not released. This is not
///   possible because the node has already been deleted by the time the
///   row-deleted signal is received.
/// 
/// - Models are not obligated to emit a signal on rows of which none of its
///   siblings are referenced. To phrase this differently, signals are only
///   required for levels in which nodes are referenced. For the root level
///   however, signals must be emitted at all times (however the root level
///   is always referenced when any view is attached).
///
/// The `TreeModelProtocol` protocol exposes the methods and properties of an underlying `GtkTreeModel` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeModel`.
/// Alternatively, use `TreeModelRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeModelProtocol {
        /// Untyped pointer to the underlying `GtkTreeModel` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeModel` instance.
    var tree_model_ptr: UnsafeMutablePointer<GtkTreeModel>! { get }

    /// Required Initialiser for types conforming to `TreeModelProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The tree interface used by GtkTreeView
/// 
/// The `GtkTreeModel` interface defines a generic tree interface for
/// use by the `GtkTreeView` widget. It is an abstract interface, and
/// is designed to be usable with any appropriate data structure. The
/// programmer just has to implement this interface on their own data
/// type for it to be viewable by a `GtkTreeView` widget.
/// 
/// The model is represented as a hierarchical tree of strongly-typed,
/// columned data. In other words, the model can be seen as a tree where
/// every node has different values depending on which column is being
/// queried. The type of data found in a column is determined by using
/// the GType system (ie. `G_TYPE_INT`, `GTK_TYPE_BUTTON`, `G_TYPE_POINTER`,
/// etc). The types are homogeneous per column across all nodes. It is
/// important to note that this interface only provides a way of examining
/// a model and observing changes. The implementation of each individual
/// model decides how and if changes are made.
/// 
/// In order to make life simpler for programmers who do not need to
/// write their own specialized model, two generic models are provided
/// — the `GtkTreeStore` and the `GtkListStore`. To use these, the
/// developer simply pushes data into these models as necessary. These
/// models provide the data structure as well as all appropriate tree
/// interfaces. As a result, implementing drag and drop, sorting, and
/// storing data is trivial. For the vast majority of trees and lists,
/// these two models are sufficient.
/// 
/// Models are accessed on a node/column level of granularity. One can
/// query for the value of a model at a certain node and a certain
/// column on that node. There are two structures used to reference a
/// particular node in a model. They are the [struct`Gtk.TreePath`] and
/// the [struct`Gtk.TreeIter`] (“iter” is short for iterator). Most of the
/// interface consists of operations on a [struct`Gtk.TreeIter`].
/// 
/// A path is essentially a potential node. It is a location on a model
/// that may or may not actually correspond to a node on a specific
/// model. A [struct`Gtk.TreePath`] can be converted into either an
/// array of unsigned integers or a string. The string form is a list
/// of numbers separated by a colon. Each number refers to the offset
/// at that level. Thus, the path `0` refers to the root
/// node and the path `2:4` refers to the fifth child of
/// the third node.
/// 
/// By contrast, a [struct`Gtk.TreeIter`] is a reference to a specific node on
/// a specific model. It is a generic struct with an integer and three
/// generic pointers. These are filled in by the model in a model-specific
/// way. One can convert a path to an iterator by calling
/// `gtk_tree_model_get_iter()`. These iterators are the primary way
/// of accessing a model and are similar to the iterators used by
/// `GtkTextBuffer`. They are generally statically allocated on the
/// stack and only used for a short time. The model interface defines
/// a set of operations using them for navigating the model.
/// 
/// It is expected that models fill in the iterator with private data.
/// For example, the `GtkListStore` model, which is internally a simple
/// linked list, stores a list node in one of the pointers. The
/// `GtkTreeModel`Sort stores an array and an offset in two of the
/// pointers. Additionally, there is an integer field. This field is
/// generally filled with a unique stamp per model. This stamp is for
/// catching errors resulting from using invalid iterators with a model.
/// 
/// The lifecycle of an iterator can be a little confusing at first.
/// Iterators are expected to always be valid for as long as the model
/// is unchanged (and doesn’t emit a signal). The model is considered
/// to own all outstanding iterators and nothing needs to be done to
/// free them from the user’s point of view. Additionally, some models
/// guarantee that an iterator is valid for as long as the node it refers
/// to is valid (most notably the `GtkTreeStore` and `GtkListStore`).
/// Although generally uninteresting, as one always has to allow for
/// the case where iterators do not persist beyond a signal, some very
/// important performance enhancements were made in the sort model.
/// As a result, the `GTK_TREE_MODEL_ITERS_PERSIST` flag was added to
/// indicate this behavior.
/// 
/// To help show some common operation of a model, some examples are
/// provided. The first example shows three ways of getting the iter at
/// the location `3:2:5`. While the first method shown is
/// easier, the second is much more common, as you often get paths from
/// callbacks.
/// 
/// ## Acquiring a `GtkTreeIter`
/// 
/// ```c
/// // Three ways of getting the iter pointing to the location
/// GtkTreePath *path;
/// GtkTreeIter iter;
/// GtkTreeIter parent_iter;
/// 
/// // get the iterator from a string
/// gtk_tree_model_get_iter_from_string (model,
///                                      &iter,
///                                      "3:2:5");
/// 
/// // get the iterator from a path
/// path = gtk_tree_path_new_from_string ("3:2:5");
/// gtk_tree_model_get_iter (model, &iter, path);
/// gtk_tree_path_free (path);
/// 
/// // walk the tree to find the iterator
/// gtk_tree_model_iter_nth_child (model, &iter,
///                                NULL, 3);
/// parent_iter = iter;
/// gtk_tree_model_iter_nth_child (model, &iter,
///                                &parent_iter, 2);
/// parent_iter = iter;
/// gtk_tree_model_iter_nth_child (model, &iter,
///                                &parent_iter, 5);
/// ```
/// 
/// This second example shows a quick way of iterating through a list
/// and getting a string and an integer from each row. The
/// `populate_model()` function used below is not
/// shown, as it is specific to the `GtkListStore`. For information on
/// how to write such a function, see the `GtkListStore` documentation.
/// 
/// ## Reading data from a `GtkTreeModel`
/// 
/// ```c
/// enum
/// {
///   STRING_COLUMN,
///   INT_COLUMN,
///   N_COLUMNS
/// };
/// 
/// ...
/// 
/// GtkTreeModel *list_store;
/// GtkTreeIter iter;
/// gboolean valid;
/// int row_count = 0;
/// 
/// // make a new list_store
/// list_store = gtk_list_store_new (N_COLUMNS,
///                                  G_TYPE_STRING,
///                                  G_TYPE_INT);
/// 
/// // Fill the list store with data
/// populate_model (list_store);
/// 
/// // Get the first iter in the list, check it is valid and walk
/// // through the list, reading each row.
/// 
/// valid = gtk_tree_model_get_iter_first (list_store,
///                                        &iter);
/// while (valid)
///  {
///    char *str_data;
///    int    int_data;
/// 
///    // Make sure you terminate calls to `gtk_tree_model_get()` with a “-1” value
///    gtk_tree_model_get (list_store, &iter,
///                        STRING_COLUMN, &str_data,
///                        INT_COLUMN, &int_data,
///                        -1);
/// 
///    // Do something with the data
///    g_print ("Row `d:` (`s`,`d`)\n",
///             row_count, str_data, int_data);
///    g_free (str_data);
/// 
///    valid = gtk_tree_model_iter_next (list_store,
///                                      &iter);
///    row_count++;
///  }
/// ```
/// 
/// The `GtkTreeModel` interface contains two methods for reference
/// counting: `gtk_tree_model_ref_node()` and `gtk_tree_model_unref_node()`.
/// These two methods are optional to implement. The reference counting
/// is meant as a way for views to let models know when nodes are being
/// displayed. `GtkTreeView` will take a reference on a node when it is
/// visible, which means the node is either in the toplevel or expanded.
/// Being displayed does not mean that the node is currently directly
/// visible to the user in the viewport. Based on this reference counting
/// scheme a caching model, for example, can decide whether or not to cache
/// a node based on the reference count. A file-system based model would
/// not want to keep the entire file hierarchy in memory, but just the
/// folders that are currently expanded in every current view.
/// 
/// When working with reference counting, the following rules must be taken
/// into account:
/// 
/// - Never take a reference on a node without owning a reference on its parent.
///   This means that all parent nodes of a referenced node must be referenced
///   as well.
/// 
/// - Outstanding references on a deleted node are not released. This is not
///   possible because the node has already been deleted by the time the
///   row-deleted signal is received.
/// 
/// - Models are not obligated to emit a signal on rows of which none of its
///   siblings are referenced. To phrase this differently, signals are only
///   required for levels in which nodes are referenced. For the root level
///   however, signals must be emitted at all times (however the root level
///   is always referenced when any view is attached).
///
/// The `TreeModelRef` type acts as a lightweight Swift reference to an underlying `GtkTreeModel` instance.
/// It exposes methods that can operate on this data type through `TreeModelProtocol` conformance.
/// Use `TreeModelRef` only as an `unowned` reference to an existing `GtkTreeModel` instance.
///
public struct TreeModelRef: TreeModelProtocol {
        /// Untyped pointer to the underlying `GtkTreeModel` instance.
    /// For type-safe access, use the generated, typed pointer `tree_model_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeModelRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeModel>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeModel>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeModel>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeModel>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeModelProtocol`
    @inlinable init<T: TreeModelProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The tree interface used by GtkTreeView
/// 
/// The `GtkTreeModel` interface defines a generic tree interface for
/// use by the `GtkTreeView` widget. It is an abstract interface, and
/// is designed to be usable with any appropriate data structure. The
/// programmer just has to implement this interface on their own data
/// type for it to be viewable by a `GtkTreeView` widget.
/// 
/// The model is represented as a hierarchical tree of strongly-typed,
/// columned data. In other words, the model can be seen as a tree where
/// every node has different values depending on which column is being
/// queried. The type of data found in a column is determined by using
/// the GType system (ie. `G_TYPE_INT`, `GTK_TYPE_BUTTON`, `G_TYPE_POINTER`,
/// etc). The types are homogeneous per column across all nodes. It is
/// important to note that this interface only provides a way of examining
/// a model and observing changes. The implementation of each individual
/// model decides how and if changes are made.
/// 
/// In order to make life simpler for programmers who do not need to
/// write their own specialized model, two generic models are provided
/// — the `GtkTreeStore` and the `GtkListStore`. To use these, the
/// developer simply pushes data into these models as necessary. These
/// models provide the data structure as well as all appropriate tree
/// interfaces. As a result, implementing drag and drop, sorting, and
/// storing data is trivial. For the vast majority of trees and lists,
/// these two models are sufficient.
/// 
/// Models are accessed on a node/column level of granularity. One can
/// query for the value of a model at a certain node and a certain
/// column on that node. There are two structures used to reference a
/// particular node in a model. They are the [struct`Gtk.TreePath`] and
/// the [struct`Gtk.TreeIter`] (“iter” is short for iterator). Most of the
/// interface consists of operations on a [struct`Gtk.TreeIter`].
/// 
/// A path is essentially a potential node. It is a location on a model
/// that may or may not actually correspond to a node on a specific
/// model. A [struct`Gtk.TreePath`] can be converted into either an
/// array of unsigned integers or a string. The string form is a list
/// of numbers separated by a colon. Each number refers to the offset
/// at that level. Thus, the path `0` refers to the root
/// node and the path `2:4` refers to the fifth child of
/// the third node.
/// 
/// By contrast, a [struct`Gtk.TreeIter`] is a reference to a specific node on
/// a specific model. It is a generic struct with an integer and three
/// generic pointers. These are filled in by the model in a model-specific
/// way. One can convert a path to an iterator by calling
/// `gtk_tree_model_get_iter()`. These iterators are the primary way
/// of accessing a model and are similar to the iterators used by
/// `GtkTextBuffer`. They are generally statically allocated on the
/// stack and only used for a short time. The model interface defines
/// a set of operations using them for navigating the model.
/// 
/// It is expected that models fill in the iterator with private data.
/// For example, the `GtkListStore` model, which is internally a simple
/// linked list, stores a list node in one of the pointers. The
/// `GtkTreeModel`Sort stores an array and an offset in two of the
/// pointers. Additionally, there is an integer field. This field is
/// generally filled with a unique stamp per model. This stamp is for
/// catching errors resulting from using invalid iterators with a model.
/// 
/// The lifecycle of an iterator can be a little confusing at first.
/// Iterators are expected to always be valid for as long as the model
/// is unchanged (and doesn’t emit a signal). The model is considered
/// to own all outstanding iterators and nothing needs to be done to
/// free them from the user’s point of view. Additionally, some models
/// guarantee that an iterator is valid for as long as the node it refers
/// to is valid (most notably the `GtkTreeStore` and `GtkListStore`).
/// Although generally uninteresting, as one always has to allow for
/// the case where iterators do not persist beyond a signal, some very
/// important performance enhancements were made in the sort model.
/// As a result, the `GTK_TREE_MODEL_ITERS_PERSIST` flag was added to
/// indicate this behavior.
/// 
/// To help show some common operation of a model, some examples are
/// provided. The first example shows three ways of getting the iter at
/// the location `3:2:5`. While the first method shown is
/// easier, the second is much more common, as you often get paths from
/// callbacks.
/// 
/// ## Acquiring a `GtkTreeIter`
/// 
/// ```c
/// // Three ways of getting the iter pointing to the location
/// GtkTreePath *path;
/// GtkTreeIter iter;
/// GtkTreeIter parent_iter;
/// 
/// // get the iterator from a string
/// gtk_tree_model_get_iter_from_string (model,
///                                      &iter,
///                                      "3:2:5");
/// 
/// // get the iterator from a path
/// path = gtk_tree_path_new_from_string ("3:2:5");
/// gtk_tree_model_get_iter (model, &iter, path);
/// gtk_tree_path_free (path);
/// 
/// // walk the tree to find the iterator
/// gtk_tree_model_iter_nth_child (model, &iter,
///                                NULL, 3);
/// parent_iter = iter;
/// gtk_tree_model_iter_nth_child (model, &iter,
///                                &parent_iter, 2);
/// parent_iter = iter;
/// gtk_tree_model_iter_nth_child (model, &iter,
///                                &parent_iter, 5);
/// ```
/// 
/// This second example shows a quick way of iterating through a list
/// and getting a string and an integer from each row. The
/// `populate_model()` function used below is not
/// shown, as it is specific to the `GtkListStore`. For information on
/// how to write such a function, see the `GtkListStore` documentation.
/// 
/// ## Reading data from a `GtkTreeModel`
/// 
/// ```c
/// enum
/// {
///   STRING_COLUMN,
///   INT_COLUMN,
///   N_COLUMNS
/// };
/// 
/// ...
/// 
/// GtkTreeModel *list_store;
/// GtkTreeIter iter;
/// gboolean valid;
/// int row_count = 0;
/// 
/// // make a new list_store
/// list_store = gtk_list_store_new (N_COLUMNS,
///                                  G_TYPE_STRING,
///                                  G_TYPE_INT);
/// 
/// // Fill the list store with data
/// populate_model (list_store);
/// 
/// // Get the first iter in the list, check it is valid and walk
/// // through the list, reading each row.
/// 
/// valid = gtk_tree_model_get_iter_first (list_store,
///                                        &iter);
/// while (valid)
///  {
///    char *str_data;
///    int    int_data;
/// 
///    // Make sure you terminate calls to `gtk_tree_model_get()` with a “-1” value
///    gtk_tree_model_get (list_store, &iter,
///                        STRING_COLUMN, &str_data,
///                        INT_COLUMN, &int_data,
///                        -1);
/// 
///    // Do something with the data
///    g_print ("Row `d:` (`s`,`d`)\n",
///             row_count, str_data, int_data);
///    g_free (str_data);
/// 
///    valid = gtk_tree_model_iter_next (list_store,
///                                      &iter);
///    row_count++;
///  }
/// ```
/// 
/// The `GtkTreeModel` interface contains two methods for reference
/// counting: `gtk_tree_model_ref_node()` and `gtk_tree_model_unref_node()`.
/// These two methods are optional to implement. The reference counting
/// is meant as a way for views to let models know when nodes are being
/// displayed. `GtkTreeView` will take a reference on a node when it is
/// visible, which means the node is either in the toplevel or expanded.
/// Being displayed does not mean that the node is currently directly
/// visible to the user in the viewport. Based on this reference counting
/// scheme a caching model, for example, can decide whether or not to cache
/// a node based on the reference count. A file-system based model would
/// not want to keep the entire file hierarchy in memory, but just the
/// folders that are currently expanded in every current view.
/// 
/// When working with reference counting, the following rules must be taken
/// into account:
/// 
/// - Never take a reference on a node without owning a reference on its parent.
///   This means that all parent nodes of a referenced node must be referenced
///   as well.
/// 
/// - Outstanding references on a deleted node are not released. This is not
///   possible because the node has already been deleted by the time the
///   row-deleted signal is received.
/// 
/// - Models are not obligated to emit a signal on rows of which none of its
///   siblings are referenced. To phrase this differently, signals are only
///   required for levels in which nodes are referenced. For the root level
///   however, signals must be emitted at all times (however the root level
///   is always referenced when any view is attached).
///
/// The `TreeModel` type acts as an owner of an underlying `GtkTreeModel` instance.
/// It provides the methods that can operate on this data type through `TreeModelProtocol` conformance.
/// Use `TreeModel` as a strong reference or owner of a `GtkTreeModel` instance.
///
open class TreeModel: TreeModelProtocol {
        /// Untyped pointer to the underlying `GtkTreeModel` instance.
    /// For type-safe access, use the generated, typed pointer `tree_model_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!

    /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeModel>) {
        ptr = UnsafeMutableRawPointer(op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeModel>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModel` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        ptr = p
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeModel>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeModel>?) {
        guard let p = op else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GtkTreeModel` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `TreeModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeModel>) {
        ptr = UnsafeMutableRawPointer(op)
        // no reference counting for GtkTreeModel, cannot ref(tree_model_ptr)
    }

    /// Reference intialiser for a related type that implements `TreeModelProtocol`
    /// `GtkTreeModel` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `TreeModelProtocol`
    @inlinable public init<T: TreeModelProtocol>(_ other: T) {
        ptr = other.ptr
        // no reference counting for GtkTreeModel, cannot ref(tree_model_ptr)
    }

    /// Do-nothing destructor for `GtkTreeModel`.
    deinit {
        // no reference counting for GtkTreeModel, cannot unref(tree_model_ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
        // no reference counting for GtkTreeModel, cannot ref(tree_model_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable public init(raw p: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelProtocol`.**
    @inlinable public init(retainingRaw raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
        // no reference counting for GtkTreeModel, cannot ref(tree_model_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        ptr = p
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable public init(retainingRaw raw: UnsafeMutableRawPointer) {
        ptr = raw
        // no reference counting for GtkTreeModel, cannot ref(tree_model_ptr)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(opaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable public init(retainingOpaquePointer p: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(p)
        // no reference counting for GtkTreeModel, cannot ref(tree_model_ptr)
    }



}

// MARK: no TreeModel properties

public enum TreeModelSignalName: String, SignalNameProtocol {
    /// This signal is emitted when a row in the model has changed.
    case rowChanged = "row-changed"
    /// This signal is emitted when a row has been deleted.
    /// 
    /// Note that no iterator is passed to the signal handler,
    /// since the row is already deleted.
    /// 
    /// This should be called by models after a row has been removed.
    /// The location pointed to by `path` should be the location that
    /// the row previously was at. It may not be a valid location anymore.
    case rowDeleted = "row-deleted"
    /// This signal is emitted when a row has gotten the first child
    /// row or lost its last child row.
    case rowHasChildToggled = "row-has-child-toggled"
    /// This signal is emitted when a new row has been inserted in
    /// the model.
    /// 
    /// Note that the row may still be empty at this point, since
    /// it is a common pattern to first insert an empty row, and
    /// then fill it with the desired values.
    case rowInserted = "row-inserted"
    /// This signal is emitted when the children of a node in the
    /// `GtkTreeModel` have been reordered.
    /// 
    /// Note that this signal is not emitted
    /// when rows are reordered by DND, since this is implemented
    /// by removing and then reinserting the row.
    case rowsReordered = "rows-reordered"

}

// MARK: TreeModel signals
public extension TreeModelProtocol {
    /// Connect a Swift signal handler to the given, typed `TreeModelSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TreeModelSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        GLibObject.ObjectRef(raw: ptr).connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `TreeModelSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TreeModelSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        GLibObject.ObjectRef(raw: ptr).connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// This signal is emitted when the children of a node in the
    /// `GtkTreeModel` have been reordered.
    /// 
    /// Note that this signal is not emitted
    /// when rows are reordered by DND, since this is implemented
    /// by removing and then reinserting the row.
    /// - Note: This represents the underlying `rows-reordered` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter path: a `GtkTreePath` identifying the tree node whose children     have been reordered
    /// - Parameter iter: a valid `GtkTreeIter` pointing to the node whose children     have been reordered, or `nil` if the depth of `path` is 0
    /// - Parameter newOrder: an array of integers mapping the current position     of each child to its old position before the re-ordering,     i.e. `new_order``[newpos] = oldpos`
    /// - Parameter handler: The signal handler to call
    /// - Warning: a `onRowsReordered` wrapper for this signal could not be generated because it contains unimplemented features: { (4)  gpointer argument is not yet supported }
    /// - Note: Instead, you can connect `rowsReorderedSignal` using the `connect(signal:)` methods
    static var rowsReorderedSignal: TreeModelSignalName { .rowsReordered }
    /// This signal is emitted when a row in the model has changed.
    /// - Note: This represents the underlying `row-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter path: a `GtkTreePath` identifying the changed row
    /// - Parameter iter: a valid `GtkTreeIter` pointing to the changed row
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `rowChanged` signal is emitted
    @discardableResult @inlinable func onRowChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeModelRef, _ path: TreePathRef, _ iter: TreeIterRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeModelRef, TreePathRef, TreeIterRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeModelRef(raw: unownedSelf), TreePathRef(raw: arg1), TreeIterRef(raw: arg2)))
            return output
        }
        return connect(
            signal: .rowChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `row-changed` signal for using the `connect(signal:)` methods
    static var rowChangedSignal: TreeModelSignalName { .rowChanged }
    
    /// This signal is emitted when a row has been deleted.
    /// 
    /// Note that no iterator is passed to the signal handler,
    /// since the row is already deleted.
    /// 
    /// This should be called by models after a row has been removed.
    /// The location pointed to by `path` should be the location that
    /// the row previously was at. It may not be a valid location anymore.
    /// - Note: This represents the underlying `row-deleted` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter path: a `GtkTreePath` identifying the row
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `rowDeleted` signal is emitted
    @discardableResult @inlinable func onRowDeleted(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeModelRef, _ path: TreePathRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeModelRef, TreePathRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeModelRef(raw: unownedSelf), TreePathRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .rowDeleted,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `row-deleted` signal for using the `connect(signal:)` methods
    static var rowDeletedSignal: TreeModelSignalName { .rowDeleted }
    
    /// This signal is emitted when a row has gotten the first child
    /// row or lost its last child row.
    /// - Note: This represents the underlying `row-has-child-toggled` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter path: a `GtkTreePath` identifying the row
    /// - Parameter iter: a valid `GtkTreeIter` pointing to the row
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `rowHasChildToggled` signal is emitted
    @discardableResult @inlinable func onRowHasChildToggled(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeModelRef, _ path: TreePathRef, _ iter: TreeIterRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeModelRef, TreePathRef, TreeIterRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeModelRef(raw: unownedSelf), TreePathRef(raw: arg1), TreeIterRef(raw: arg2)))
            return output
        }
        return connect(
            signal: .rowHasChildToggled,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `row-has-child-toggled` signal for using the `connect(signal:)` methods
    static var rowHasChildToggledSignal: TreeModelSignalName { .rowHasChildToggled }
    
    /// This signal is emitted when a new row has been inserted in
    /// the model.
    /// 
    /// Note that the row may still be empty at this point, since
    /// it is a common pattern to first insert an empty row, and
    /// then fill it with the desired values.
    /// - Note: This represents the underlying `row-inserted` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter path: a `GtkTreePath` identifying the new row
    /// - Parameter iter: a valid `GtkTreeIter` pointing to the new row
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `rowInserted` signal is emitted
    @discardableResult @inlinable func onRowInserted(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeModelRef, _ path: TreePathRef, _ iter: TreeIterRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeModelRef, TreePathRef, TreeIterRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeModelRef(raw: unownedSelf), TreePathRef(raw: arg1), TreeIterRef(raw: arg2)))
            return output
        }
        return connect(
            signal: .rowInserted,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `row-inserted` signal for using the `connect(signal:)` methods
    static var rowInsertedSignal: TreeModelSignalName { .rowInserted }
    
    
}

// MARK: TreeModel Interface: TreeModelProtocol extension (methods and fields)
public extension TreeModelProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeModel` instance.
    @inlinable var tree_model_ptr: UnsafeMutablePointer<GtkTreeModel>! { return ptr?.assumingMemoryBound(to: GtkTreeModel.self) }

    /// Creates a new `GtkTreeModel`, with `child_model` as the child_model
    /// and `root` as the virtual root.
    @inlinable func filterNew(root: TreePathRef? = nil) -> TreeModelRef! {
            let result = gtk_tree_model_filter_new(tree_model_ptr, root?.tree_path_ptr)
        guard let rv = TreeModelRef(gconstpointer: gconstpointer(result)) else { return nil }
            return rv
    }
    /// Creates a new `GtkTreeModel`, with `child_model` as the child_model
    /// and `root` as the virtual root.
    @inlinable func filterNew<TreePathT: TreePathProtocol>(root: TreePathT?) -> TreeModelRef! {
        let result = gtk_tree_model_filter_new(tree_model_ptr, root?.tree_path_ptr)
        guard let rv = TreeModelRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Calls `func` on each node in model in a depth-first fashion.
    /// 
    /// If `func` returns `true`, then the tree ceases to be walked,
    /// and `gtk_tree_model_foreach()` returns.
    @inlinable func foreach(`func`: GtkTreeModelForeachFunc?, userData: gpointer? = nil) {
        
        gtk_tree_model_foreach(tree_model_ptr, `func`, userData)
        
    }


    // *** get() is not available because it has a varargs (...) parameter!


    /// Returns the type of the column.
    @inlinable func getColumnType(index: Int) -> GType {
        let result = gtk_tree_model_get_column_type(tree_model_ptr, gint(index))
        let rv = result
        return rv
    }

    /// Returns a set of flags supported by this interface.
    /// 
    /// The flags are a bitwise combination of `GtkTreeModel`Flags.
    /// The flags supported should not change during the lifetime
    /// of the `tree_model`.
    @inlinable func getFlags() -> Gtk.TreeModelFlags {
        let result = gtk_tree_model_get_flags(tree_model_ptr)
        let rv = TreeModelFlags(result)
        return rv
    }

    /// Sets `iter` to a valid iterator pointing to `path`.
    /// 
    /// If `path` does not exist, `iter` is set to an invalid
    /// iterator and `false` is returned.
    @inlinable func get<TreeIterT: TreeIterProtocol, TreePathT: TreePathProtocol>(iter: TreeIterT, path: TreePathT) -> Bool {
        let result = gtk_tree_model_get_iter(tree_model_ptr, iter.tree_iter_ptr, path.tree_path_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Initializes `iter` with the first iterator in the tree
    /// (the one at the path "0").
    /// 
    /// Returns `false` if the tree is empty, `true` otherwise.
    @inlinable func getIterFirst<TreeIterT: TreeIterProtocol>(iter: TreeIterT) -> Bool {
        let result = gtk_tree_model_get_iter_first(tree_model_ptr, iter.tree_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Sets `iter` to a valid iterator pointing to `path_string`, if it
    /// exists.
    /// 
    /// Otherwise, `iter` is left invalid and `false` is returned.
    @inlinable func getIterFromString<TreeIterT: TreeIterProtocol>(iter: TreeIterT, pathString: UnsafePointer<CChar>!) -> Bool {
        let result = gtk_tree_model_get_iter_from_string(tree_model_ptr, iter.tree_iter_ptr, pathString)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns the number of columns supported by `tree_model`.
    @inlinable func getNColumns() -> Int {
        let result = gtk_tree_model_get_n_columns(tree_model_ptr)
        let rv = Int(result)
        return rv
    }

    /// Returns a newly-created `GtkTreePath` referenced by `iter`.
    /// 
    /// This path should be freed with `gtk_tree_path_free()`.
    @inlinable func getPath<TreeIterT: TreeIterProtocol>(iter: TreeIterT) -> TreePathRef! {
        let result = gtk_tree_model_get_path(tree_model_ptr, iter.tree_iter_ptr)
        let rv = TreePathRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Generates a string representation of the iter.
    /// 
    /// This string is a “:” separated list of numbers.
    /// For example, “4:10:0:3” would be an acceptable
    /// return value for this string.
    @inlinable func getStringFrom<TreeIterT: TreeIterProtocol>(iter: TreeIterT) -> String! {
        let result = gtk_tree_model_get_string_from_iter(tree_model_ptr, iter.tree_iter_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Gets the value of one or more cells in the row referenced by `iter`.
    /// 
    /// See [method`Gtk.TreeModel.get`], this version takes a va_list
    /// for language bindings to use.
    @inlinable func getValist<TreeIterT: TreeIterProtocol>(iter: TreeIterT, varArgs: CVaListPointer) {
        
        gtk_tree_model_get_valist(tree_model_ptr, iter.tree_iter_ptr, varArgs)
        
    }

    /// Initializes and sets `value` to that at `column`.
    /// 
    /// When done with `value`, `g_value_unset()` needs to be called
    /// to free any allocated memory.
    @inlinable func getValue<GObjectValueT: GLibObject.ValueProtocol, TreeIterT: TreeIterProtocol>(iter: TreeIterT, column: Int, value: GObjectValueT) {
        
        gtk_tree_model_get_value(tree_model_ptr, iter.tree_iter_ptr, gint(column), value.value_ptr)
        
    }

    /// Sets `iter` to point to the first child of `parent`.
    /// 
    /// If `parent` has no children, `false` is returned and `iter` is
    /// set to be invalid. `parent` will remain a valid node after this
    /// function has been called.
    /// 
    /// If `parent` is `nil` returns the first node, equivalent to
    /// `gtk_tree_model_get_iter_first (tree_model, iter);`
    @inlinable func iterChildren<TreeIterT: TreeIterProtocol>(iter: TreeIterT, parent: TreeIterT?) -> Bool {
        let result = gtk_tree_model_iter_children(tree_model_ptr, iter.tree_iter_ptr, parent?.tree_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns `true` if `iter` has children, `false` otherwise.
    @inlinable func iterHasChild<TreeIterT: TreeIterProtocol>(iter: TreeIterT) -> Bool {
        let result = gtk_tree_model_iter_has_child(tree_model_ptr, iter.tree_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns the number of children that `iter` has.
    /// 
    /// As a special case, if `iter` is `nil`, then the number
    /// of toplevel nodes is returned.
    @inlinable func iterNChildren(iter: TreeIterRef? = nil) -> Int {
            let result = gtk_tree_model_iter_n_children(tree_model_ptr, iter?.tree_iter_ptr)
        let rv = Int(result)
            return rv
    }
    /// Returns the number of children that `iter` has.
    /// 
    /// As a special case, if `iter` is `nil`, then the number
    /// of toplevel nodes is returned.
    @inlinable func iterNChildren<TreeIterT: TreeIterProtocol>(iter: TreeIterT?) -> Int {
        let result = gtk_tree_model_iter_n_children(tree_model_ptr, iter?.tree_iter_ptr)
        let rv = Int(result)
        return rv
    }

    /// Sets `iter` to point to the node following it at the current level.
    /// 
    /// If there is no next `iter`, `false` is returned and `iter` is set
    /// to be invalid.
    @inlinable func iterNext<TreeIterT: TreeIterProtocol>(iter: TreeIterT) -> Bool {
        let result = gtk_tree_model_iter_next(tree_model_ptr, iter.tree_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Sets `iter` to be the child of `parent`, using the given index.
    /// 
    /// The first index is 0. If `n` is too big, or `parent` has no children,
    /// `iter` is set to an invalid iterator and `false` is returned. `parent`
    /// will remain a valid node after this function has been called. As a
    /// special case, if `parent` is `nil`, then the `n-th` root node
    /// is set.
    @inlinable func iterNthChild<TreeIterT: TreeIterProtocol>(iter: TreeIterT, parent: TreeIterT?, n: Int) -> Bool {
        let result = gtk_tree_model_iter_nth_child(tree_model_ptr, iter.tree_iter_ptr, parent?.tree_iter_ptr, gint(n))
        let rv = ((result) != 0)
        return rv
    }

    /// Sets `iter` to be the parent of `child`.
    /// 
    /// If `child` is at the toplevel, and doesn’t have a parent, then
    /// `iter` is set to an invalid iterator and `false` is returned.
    /// `child` will remain a valid node after this function has been
    /// called.
    /// 
    /// `iter` will be initialized before the lookup is performed, so `child`
    /// and `iter` cannot point to the same memory location.
    @inlinable func iterParent<TreeIterT: TreeIterProtocol>(iter: TreeIterT, child: TreeIterT) -> Bool {
        let result = gtk_tree_model_iter_parent(tree_model_ptr, iter.tree_iter_ptr, child.tree_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Sets `iter` to point to the previous node at the current level.
    /// 
    /// If there is no previous `iter`, `false` is returned and `iter` is
    /// set to be invalid.
    @inlinable func iterPrevious<TreeIterT: TreeIterProtocol>(iter: TreeIterT) -> Bool {
        let result = gtk_tree_model_iter_previous(tree_model_ptr, iter.tree_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Lets the tree ref the node.
    /// 
    /// This is an optional method for models to implement.
    /// To be more specific, models may ignore this call as it exists
    /// primarily for performance reasons.
    /// 
    /// This function is primarily meant as a way for views to let
    /// caching models know when nodes are being displayed (and hence,
    /// whether or not to cache that node). Being displayed means a node
    /// is in an expanded branch, regardless of whether the node is currently
    /// visible in the viewport. For example, a file-system based model
    /// would not want to keep the entire file-hierarchy in memory,
    /// just the sections that are currently being displayed by
    /// every current view.
    /// 
    /// A model should be expected to be able to get an iter independent
    /// of its reffed state.
    @inlinable func refNode<TreeIterT: TreeIterProtocol>(iter: TreeIterT) {
        
        gtk_tree_model_ref_node(tree_model_ptr, iter.tree_iter_ptr)
        
    }

    /// Emits the `row-changed` signal on `tree_model`.
    /// 
    /// See [signal`Gtk.TreeModel::row-changed`].
    @inlinable func rowChanged<TreeIterT: TreeIterProtocol, TreePathT: TreePathProtocol>(path: TreePathT, iter: TreeIterT) {
        
        gtk_tree_model_row_changed(tree_model_ptr, path.tree_path_ptr, iter.tree_iter_ptr)
        
    }

    /// Emits the `row-deleted` signal on `tree_model`.
    /// 
    /// See [signal`Gtk.TreeModel::row-deleted`].
    /// 
    /// This should be called by models after a row has been removed.
    /// The location pointed to by `path` should be the location that
    /// the row previously was at. It may not be a valid location anymore.
    /// 
    /// Nodes that are deleted are not unreffed, this means that any
    /// outstanding references on the deleted node should not be released.
    @inlinable func rowDeleted<TreePathT: TreePathProtocol>(path: TreePathT) {
        
        gtk_tree_model_row_deleted(tree_model_ptr, path.tree_path_ptr)
        
    }

    /// Emits the `row-has-child-toggled` signal on `tree_model`.
    /// 
    /// See [signal`Gtk.TreeModel::row-has-child-toggled`].
    /// 
    /// This should be called by models after the child
    /// state of a node changes.
    @inlinable func rowHasChildToggled<TreeIterT: TreeIterProtocol, TreePathT: TreePathProtocol>(path: TreePathT, iter: TreeIterT) {
        
        gtk_tree_model_row_has_child_toggled(tree_model_ptr, path.tree_path_ptr, iter.tree_iter_ptr)
        
    }

    /// Emits the `row-inserted` signal on `tree_model`.
    /// 
    /// See [signal`Gtk.TreeModel::row-inserted`].
    @inlinable func rowInserted<TreeIterT: TreeIterProtocol, TreePathT: TreePathProtocol>(path: TreePathT, iter: TreeIterT) {
        
        gtk_tree_model_row_inserted(tree_model_ptr, path.tree_path_ptr, iter.tree_iter_ptr)
        
    }

    /// Emits the `rows-reordered` signal on `tree_model`.
    /// 
    /// See [signal`Gtk.TreeModel::rows-reordered`].
    /// 
    /// This should be called by models when their rows have been
    /// reordered.
    @inlinable func rowsReordered<TreeIterT: TreeIterProtocol, TreePathT: TreePathProtocol>(path: TreePathT, iter: TreeIterT, newOrder: UnsafeMutablePointer<gint>!) {
        
        gtk_tree_model_rows_reordered(tree_model_ptr, path.tree_path_ptr, iter.tree_iter_ptr, newOrder)
        
    }

    /// Emits the `rows-reordered` signal on `tree_model`.
    /// 
    /// See [signal`Gtk.TreeModel::rows-reordered`].
    /// 
    /// This should be called by models when their rows have been
    /// reordered.
    @inlinable func rowsReorderedWithLength<TreePathT: TreePathProtocol>(path: TreePathT, iter: TreeIterRef? = nil, newOrder: UnsafeMutablePointer<CInt>!, length: Int) {
            
        gtk_tree_model_rows_reordered_with_length(tree_model_ptr, path.tree_path_ptr, iter?.tree_iter_ptr, newOrder, gint(length))
            
    }
    /// Emits the `rows-reordered` signal on `tree_model`.
    /// 
    /// See [signal`Gtk.TreeModel::rows-reordered`].
    /// 
    /// This should be called by models when their rows have been
    /// reordered.
    @inlinable func rowsReorderedWithLength<TreeIterT: TreeIterProtocol, TreePathT: TreePathProtocol>(path: TreePathT, iter: TreeIterT?, newOrder: UnsafeMutablePointer<CInt>!, length: Int) {
        
        gtk_tree_model_rows_reordered_with_length(tree_model_ptr, path.tree_path_ptr, iter?.tree_iter_ptr, newOrder, gint(length))
        
    }

    /// Lets the tree unref the node.
    /// 
    /// This is an optional method for models to implement.
    /// To be more specific, models may ignore this call as it exists
    /// primarily for performance reasons. For more information on what
    /// this means, see `gtk_tree_model_ref_node()`.
    /// 
    /// Please note that nodes that are deleted are not unreffed.
    @inlinable func unrefNode<TreeIterT: TreeIterProtocol>(iter: TreeIterT) {
        
        gtk_tree_model_unref_node(tree_model_ptr, iter.tree_iter_ptr)
        
    }

    /// Creates a content provider for dragging `path` from `tree_model`.
    @inlinable func treeCreateRowDragContent<TreePathT: TreePathProtocol>(path: TreePathT) -> Gdk.ContentProviderRef! {
        let result = gtk_tree_create_row_drag_content(tree_model_ptr, path.tree_path_ptr)
        let rv = Gdk.ContentProviderRef(gconstpointer: gconstpointer(result))
        return rv
    }
    /// Returns a set of flags supported by this interface.
    /// 
    /// The flags are a bitwise combination of `GtkTreeModel`Flags.
    /// The flags supported should not change during the lifetime
    /// of the `tree_model`.
    @inlinable var flags: Gtk.TreeModelFlags {
        /// Returns a set of flags supported by this interface.
        /// 
        /// The flags are a bitwise combination of `GtkTreeModel`Flags.
        /// The flags supported should not change during the lifetime
        /// of the `tree_model`.
        get {
            let result = gtk_tree_model_get_flags(tree_model_ptr)
        let rv = TreeModelFlags(result)
            return rv
        }
    }

    /// Returns the number of columns supported by `tree_model`.
    @inlinable var nColumns: Int {
        /// Returns the number of columns supported by `tree_model`.
        get {
            let result = gtk_tree_model_get_n_columns(tree_model_ptr)
        let rv = Int(result)
            return rv
        }
    }


}



// MARK: - TreeSortable Interface

/// The interface for sortable models used by GtkTreeView
/// 
/// `GtkTreeSortable` is an interface to be implemented by tree models which
/// support sorting. The `GtkTreeView` uses the methods provided by this interface
/// to sort the model.
///
/// The `TreeSortableProtocol` protocol exposes the methods and properties of an underlying `GtkTreeSortable` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeSortable`.
/// Alternatively, use `TreeSortableRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeSortableProtocol: TreeModelProtocol {
        /// Untyped pointer to the underlying `GtkTreeSortable` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeSortable` instance.
    var tree_sortable_ptr: UnsafeMutablePointer<GtkTreeSortable>! { get }

    /// Required Initialiser for types conforming to `TreeSortableProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The interface for sortable models used by GtkTreeView
/// 
/// `GtkTreeSortable` is an interface to be implemented by tree models which
/// support sorting. The `GtkTreeView` uses the methods provided by this interface
/// to sort the model.
///
/// The `TreeSortableRef` type acts as a lightweight Swift reference to an underlying `GtkTreeSortable` instance.
/// It exposes methods that can operate on this data type through `TreeSortableProtocol` conformance.
/// Use `TreeSortableRef` only as an `unowned` reference to an existing `GtkTreeSortable` instance.
///
public struct TreeSortableRef: TreeSortableProtocol {
        /// Untyped pointer to the underlying `GtkTreeSortable` instance.
    /// For type-safe access, use the generated, typed pointer `tree_sortable_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeSortableRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeSortable>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeSortable>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeSortable>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeSortable>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeSortableProtocol`
    @inlinable init<T: TreeSortableProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSortableProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSortableProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSortableProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSortableProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSortableProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The interface for sortable models used by GtkTreeView
/// 
/// `GtkTreeSortable` is an interface to be implemented by tree models which
/// support sorting. The `GtkTreeView` uses the methods provided by this interface
/// to sort the model.
///
/// The `TreeSortable` type acts as an owner of an underlying `GtkTreeSortable` instance.
/// It provides the methods that can operate on this data type through `TreeSortableProtocol` conformance.
/// Use `TreeSortable` as a strong reference or owner of a `GtkTreeSortable` instance.
///
open class TreeSortable: TreeModel, TreeSortableProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeSortable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeSortable>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeSortable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeSortable>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeSortable` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeSortable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeSortable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeSortable>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeSortable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeSortable>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// `GtkTreeSortable` does not allow reference counting, so despite the name no actual retaining will occur.
    /// i.e., ownership is transferred to the `TreeSortable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeSortable>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TreeSortableProtocol`
    /// `GtkTreeSortable` does not allow reference counting.
    /// - Parameter other: an instance of a related type that implements `TreeSortableProtocol`
    @inlinable public init<T: TreeSortableProtocol>(treeSortable other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSortableProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSortableProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSortableProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSortableProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSortableProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSortableProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSortableProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSortableProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

// MARK: no TreeSortable properties

public enum TreeSortableSignalName: String, SignalNameProtocol {
    /// This signal is emitted when a row in the model has changed.
    case rowChanged = "row-changed"
    /// This signal is emitted when a row has been deleted.
    /// 
    /// Note that no iterator is passed to the signal handler,
    /// since the row is already deleted.
    /// 
    /// This should be called by models after a row has been removed.
    /// The location pointed to by `path` should be the location that
    /// the row previously was at. It may not be a valid location anymore.
    case rowDeleted = "row-deleted"
    /// This signal is emitted when a row has gotten the first child
    /// row or lost its last child row.
    case rowHasChildToggled = "row-has-child-toggled"
    /// This signal is emitted when a new row has been inserted in
    /// the model.
    /// 
    /// Note that the row may still be empty at this point, since
    /// it is a common pattern to first insert an empty row, and
    /// then fill it with the desired values.
    case rowInserted = "row-inserted"
    /// This signal is emitted when the children of a node in the
    /// `GtkTreeModel` have been reordered.
    /// 
    /// Note that this signal is not emitted
    /// when rows are reordered by DND, since this is implemented
    /// by removing and then reinserting the row.
    case rowsReordered = "rows-reordered"
    /// The `sort-column-changed` signal is emitted when the sort column
    /// or sort order of `sortable` is changed. The signal is emitted before
    /// the contents of `sortable` are resorted.
    case sortColumnChanged = "sort-column-changed"

}

// MARK: TreeSortable signals
public extension TreeSortableProtocol {
    /// Connect a Swift signal handler to the given, typed `TreeSortableSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TreeSortableSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        GLibObject.ObjectRef(raw: ptr).connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `TreeSortableSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TreeSortableSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        GLibObject.ObjectRef(raw: ptr).connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// The `sort-column-changed` signal is emitted when the sort column
    /// or sort order of `sortable` is changed. The signal is emitted before
    /// the contents of `sortable` are resorted.
    /// - Note: This represents the underlying `sort-column-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `sortColumnChanged` signal is emitted
    @discardableResult @inlinable func onSortColumnChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeSortableRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeSortableRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeSortableRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .sortColumnChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `sort-column-changed` signal for using the `connect(signal:)` methods
    static var sortColumnChangedSignal: TreeSortableSignalName { .sortColumnChanged }
    
    
}

// MARK: TreeSortable Interface: TreeSortableProtocol extension (methods and fields)
public extension TreeSortableProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeSortable` instance.
    @inlinable var tree_sortable_ptr: UnsafeMutablePointer<GtkTreeSortable>! { return ptr?.assumingMemoryBound(to: GtkTreeSortable.self) }

    /// Fills in `sort_column_id` and `order` with the current sort column and the
    /// order. It returns `true` unless the `sort_column_id` is
    /// `GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID` or
    /// `GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID`.
    @inlinable func get(sortColumnId: UnsafeMutablePointer<gint>!, order: UnsafeMutablePointer<GtkSortType>!) -> Bool {
        let result = gtk_tree_sortable_get_sort_column_id(tree_sortable_ptr, sortColumnId, order)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns `true` if the model has a default sort function. This is used
    /// primarily by GtkTreeViewColumns in order to determine if a model can
    /// go back to the default state, or not.
    @inlinable func hasDefaultSortFunc() -> Bool {
        let result = gtk_tree_sortable_has_default_sort_func(tree_sortable_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Sets the default comparison function used when sorting to be `sort_func`.
    /// If the current sort column id of `sortable` is
    /// `GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID`, then the model will sort using
    /// this function.
    /// 
    /// If `sort_func` is `nil`, then there will be no default comparison function.
    /// This means that once the model  has been sorted, it can’t go back to the
    /// default state. In this case, when the current sort column id of `sortable`
    /// is `GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID`, the model will be unsorted.
    @inlinable func setDefault(sortFunc: GtkTreeIterCompareFunc?, userData: gpointer? = nil, destroy: GDestroyNotify? = nil) {
        
        gtk_tree_sortable_set_default_sort_func(tree_sortable_ptr, sortFunc, userData, destroy)
        
    }

    /// Sets the current sort column to be `sort_column_id`. The `sortable` will
    /// resort itself to reflect this change, after emitting a
    /// `GtkTreeSortable`sort-column-changed`` signal. `sort_column_id` may either be
    /// a regular column id, or one of the following special values:
    /// 
    /// - `GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID:` the default sort function
    ///   will be used, if it is set
    /// 
    /// - `GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID:` no sorting will occur
    @inlinable func set(sortColumnId: Int, order: GtkSortType) {
        
        gtk_tree_sortable_set_sort_column_id(tree_sortable_ptr, gint(sortColumnId), order)
        
    }

    /// Sets the comparison function used when sorting to be `sort_func`. If the
    /// current sort column id of `sortable` is the same as `sort_column_id`, then
    /// the model will sort using this function.
    @inlinable func setSortFunc(sortColumnId: Int, sortFunc: GtkTreeIterCompareFunc?, userData: gpointer? = nil, destroy: GDestroyNotify? = nil) {
        
        gtk_tree_sortable_set_sort_func(tree_sortable_ptr, gint(sortColumnId), sortFunc, userData, destroy)
        
    }

    /// Emits a `GtkTreeSortable`sort-column-changed`` signal on `sortable`.
    @inlinable func sortColumnChanged() {
        
        gtk_tree_sortable_sort_column_changed(tree_sortable_ptr)
        
    }


}



// MARK: - Text Class

/// The `GtkText` widget is a single-line text entry widget.
/// 
/// `GtkText` is the common implementation of single-line text editing
/// that is shared between `GtkEntry`, `GtkPasswordEntry`, `GtkSpinButton`
/// and other widgets. In all of these, `GtkText` is used as the delegate
/// for the [iface`Gtk.Editable`] implementation.
/// 
/// A fairly large set of key bindings are supported by default. If the
/// entered text is longer than the allocation of the widget, the widget
/// will scroll so that the cursor position is visible.
/// 
/// When using an entry for passwords and other sensitive information,
/// it can be put into “password mode” using [method`Gtk.Text.set_visibility`].
/// In this mode, entered text is displayed using a “invisible” character.
/// By default, GTK picks the best invisible character that is available
/// in the current font, but it can be changed with
/// [method`Gtk.Text.set_invisible_char`].
/// 
/// If you are looking to add icons or progress display in an entry, look
/// at `GtkEntry`. There other alternatives for more specialized use cases,
/// such as `GtkSearchEntry`.
/// 
/// If you need multi-line editable text, look at `GtkTextView`.
/// 
/// # CSS nodes
/// 
/// ```
/// text[.read-only]
/// ├── placeholder
/// ├── undershoot.left
/// ├── undershoot.right
/// ├── [selection]
/// ├── [block-cursor]
/// ╰── [window.popup]
/// ```
/// 
/// `GtkText` has a main node with the name text. Depending on the properties
/// of the widget, the .read-only style class may appear.
/// 
/// When the entry has a selection, it adds a subnode with the name selection.
/// 
/// When the entry is in overwrite mode, it adds a subnode with the name
/// block-cursor that determines how the block cursor is drawn.
/// 
/// The CSS node for a context menu is added as a subnode below text as well.
/// 
/// The undershoot nodes are used to draw the underflow indication when content
/// is scrolled out of view. These nodes get the .left and .right style classes
/// added depending on where the indication is drawn.
/// 
/// When touch is used and touch selection handles are shown, they are using
/// CSS nodes with name cursor-handle. They get the .top or .bottom style class
/// depending on where they are shown in relation to the selection. If there is
/// just a single handle for the text cursor, it gets the style class
/// .insertion-cursor.
/// 
/// # Accessibility
/// 
/// `GtkText` uses the `GTK_ACCESSIBLE_ROLE_NONE` role, which causes it to be
/// skipped for accessibility. This is because `GtkText` is expected to be used
/// as a delegate for a `GtkEditable` implementation that will be represented
/// to accessibility.
///
/// The `TextProtocol` protocol exposes the methods and properties of an underlying `GtkText` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Text`.
/// Alternatively, use `TextRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextProtocol: WidgetProtocol, EditableProtocol {
        /// Untyped pointer to the underlying `GtkText` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkText` instance.
    var text_ptr: UnsafeMutablePointer<GtkText>! { get }

    /// Required Initialiser for types conforming to `TextProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `GtkText` widget is a single-line text entry widget.
/// 
/// `GtkText` is the common implementation of single-line text editing
/// that is shared between `GtkEntry`, `GtkPasswordEntry`, `GtkSpinButton`
/// and other widgets. In all of these, `GtkText` is used as the delegate
/// for the [iface`Gtk.Editable`] implementation.
/// 
/// A fairly large set of key bindings are supported by default. If the
/// entered text is longer than the allocation of the widget, the widget
/// will scroll so that the cursor position is visible.
/// 
/// When using an entry for passwords and other sensitive information,
/// it can be put into “password mode” using [method`Gtk.Text.set_visibility`].
/// In this mode, entered text is displayed using a “invisible” character.
/// By default, GTK picks the best invisible character that is available
/// in the current font, but it can be changed with
/// [method`Gtk.Text.set_invisible_char`].
/// 
/// If you are looking to add icons or progress display in an entry, look
/// at `GtkEntry`. There other alternatives for more specialized use cases,
/// such as `GtkSearchEntry`.
/// 
/// If you need multi-line editable text, look at `GtkTextView`.
/// 
/// # CSS nodes
/// 
/// ```
/// text[.read-only]
/// ├── placeholder
/// ├── undershoot.left
/// ├── undershoot.right
/// ├── [selection]
/// ├── [block-cursor]
/// ╰── [window.popup]
/// ```
/// 
/// `GtkText` has a main node with the name text. Depending on the properties
/// of the widget, the .read-only style class may appear.
/// 
/// When the entry has a selection, it adds a subnode with the name selection.
/// 
/// When the entry is in overwrite mode, it adds a subnode with the name
/// block-cursor that determines how the block cursor is drawn.
/// 
/// The CSS node for a context menu is added as a subnode below text as well.
/// 
/// The undershoot nodes are used to draw the underflow indication when content
/// is scrolled out of view. These nodes get the .left and .right style classes
/// added depending on where the indication is drawn.
/// 
/// When touch is used and touch selection handles are shown, they are using
/// CSS nodes with name cursor-handle. They get the .top or .bottom style class
/// depending on where they are shown in relation to the selection. If there is
/// just a single handle for the text cursor, it gets the style class
/// .insertion-cursor.
/// 
/// # Accessibility
/// 
/// `GtkText` uses the `GTK_ACCESSIBLE_ROLE_NONE` role, which causes it to be
/// skipped for accessibility. This is because `GtkText` is expected to be used
/// as a delegate for a `GtkEditable` implementation that will be represented
/// to accessibility.
///
/// The `TextRef` type acts as a lightweight Swift reference to an underlying `GtkText` instance.
/// It exposes methods that can operate on this data type through `TextProtocol` conformance.
/// Use `TextRef` only as an `unowned` reference to an existing `GtkText` instance.
///
public struct TextRef: TextProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkText` instance.
    /// For type-safe access, use the generated, typed pointer `text_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkText>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkText>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkText>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkText>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextProtocol`
    @inlinable init<T: TextProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TextProtocol>(_ other: T) -> TextRef { TextRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkText`.
    @inlinable init() {
            let result = gtk_text_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkText` with the specified text buffer.
    @inlinable init<EntryBufferT: EntryBufferProtocol>(buffer: EntryBufferT) {
            let result = gtk_text_new_with_buffer(buffer.entry_buffer_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkText` with the specified text buffer.
    @inlinable static func newWith<EntryBufferT: EntryBufferProtocol>(buffer: EntryBufferT) -> WidgetRef! {
            let result = gtk_text_new_with_buffer(buffer.entry_buffer_ptr)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }
}

/// The `GtkText` widget is a single-line text entry widget.
/// 
/// `GtkText` is the common implementation of single-line text editing
/// that is shared between `GtkEntry`, `GtkPasswordEntry`, `GtkSpinButton`
/// and other widgets. In all of these, `GtkText` is used as the delegate
/// for the [iface`Gtk.Editable`] implementation.
/// 
/// A fairly large set of key bindings are supported by default. If the
/// entered text is longer than the allocation of the widget, the widget
/// will scroll so that the cursor position is visible.
/// 
/// When using an entry for passwords and other sensitive information,
/// it can be put into “password mode” using [method`Gtk.Text.set_visibility`].
/// In this mode, entered text is displayed using a “invisible” character.
/// By default, GTK picks the best invisible character that is available
/// in the current font, but it can be changed with
/// [method`Gtk.Text.set_invisible_char`].
/// 
/// If you are looking to add icons or progress display in an entry, look
/// at `GtkEntry`. There other alternatives for more specialized use cases,
/// such as `GtkSearchEntry`.
/// 
/// If you need multi-line editable text, look at `GtkTextView`.
/// 
/// # CSS nodes
/// 
/// ```
/// text[.read-only]
/// ├── placeholder
/// ├── undershoot.left
/// ├── undershoot.right
/// ├── [selection]
/// ├── [block-cursor]
/// ╰── [window.popup]
/// ```
/// 
/// `GtkText` has a main node with the name text. Depending on the properties
/// of the widget, the .read-only style class may appear.
/// 
/// When the entry has a selection, it adds a subnode with the name selection.
/// 
/// When the entry is in overwrite mode, it adds a subnode with the name
/// block-cursor that determines how the block cursor is drawn.
/// 
/// The CSS node for a context menu is added as a subnode below text as well.
/// 
/// The undershoot nodes are used to draw the underflow indication when content
/// is scrolled out of view. These nodes get the .left and .right style classes
/// added depending on where the indication is drawn.
/// 
/// When touch is used and touch selection handles are shown, they are using
/// CSS nodes with name cursor-handle. They get the .top or .bottom style class
/// depending on where they are shown in relation to the selection. If there is
/// just a single handle for the text cursor, it gets the style class
/// .insertion-cursor.
/// 
/// # Accessibility
/// 
/// `GtkText` uses the `GTK_ACCESSIBLE_ROLE_NONE` role, which causes it to be
/// skipped for accessibility. This is because `GtkText` is expected to be used
/// as a delegate for a `GtkEditable` implementation that will be represented
/// to accessibility.
///
/// The `Text` type acts as a reference-counted owner of an underlying `GtkText` instance.
/// It provides the methods that can operate on this data type through `TextProtocol` conformance.
/// Use `Text` as a strong reference or owner of a `GtkText` instance.
///
open class Text: Widget, TextProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkText>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkText>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkText>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkText>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkText`.
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkText>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TextProtocol`
    /// Will retain `GtkText`.
    /// - Parameter other: an instance of a related type that implements `TextProtocol`
    @inlinable public init<T: TextProtocol>(text other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkText`.
    @inlinable public init() {
            let result = gtk_text_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkText` with the specified text buffer.
    @inlinable public init<EntryBufferT: EntryBufferProtocol>(buffer: EntryBufferT) {
            let result = gtk_text_new_with_buffer(buffer.entry_buffer_ptr)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkText` with the specified text buffer.
    @inlinable public static func newWith<EntryBufferT: EntryBufferProtocol>(buffer: EntryBufferT) -> Widget! {
            let result = gtk_text_new_with_buffer(buffer.entry_buffer_ptr)
        guard let rv = Widget(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

}

public enum TextPropertyName: String, PropertyNameProtocol {
    /// Whether to activate the default widget when Enter is pressed.
    case activatesDefault = "activates-default"
    /// A list of Pango attributes to apply to the text of the `GtkText`.
    /// 
    /// This is mainly useful to change the size or weight of the text.
    /// 
    /// The `PangoAttribute`'s `start_index` and `end_index` must refer to the
    /// `GtkEntryBuffer` text, i.e. without the preedit string.
    case attributes = "attributes"
    /// The `GtkEntryBuffer` object which stores the text.
    case buffer = "buffer"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether to suggest Emoji replacements.
    case enableEmojiCompletion = "enable-emoji-completion"
    /// A menu model whose contents will be appended to
    /// the context menu.
    case extraMenu = "extra-menu"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// Which IM (input method) module should be used for this self.
    /// 
    /// See [class`Gtk.IMMulticontext`].
    /// 
    /// Setting this to a non-`nil` value overrides the system-wide
    /// IM module setting. See the [property`Gtk.Settings:gtk-im-module`]
    /// property.
    case imModule = "im-module"
    /// Additional hints that allow input methods to fine-tune
    /// their behaviour.
    case inputHints = "input-hints"
    /// The purpose of this text field.
    /// 
    /// This property can be used by on-screen keyboards and other input
    /// methods to adjust their behaviour.
    /// 
    /// Note that setting the purpose to `GTK_INPUT_PURPOSE_PASSWORD` or
    /// `GTK_INPUT_PURPOSE_PIN` is independent from setting
    /// [property`Gtk.Text:visibility`].
    case inputPurpose = "input-purpose"
    /// The character to used when masking contents (in “password mode”).
    case invisibleChar = "invisible-char"
    /// Whether the invisible char has been set for the `GtkText`.
    case invisibleCharSet = "invisible-char-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// Maximum number of characters that are allowed.
    /// 
    /// Zero indicates no limit.
    case maxLength = "max-length"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// If text is overwritten when typing in the `GtkText`.
    case overwriteMode = "overwrite-mode"
    /// The parent widget of this widget.
    case parent = "parent"
    /// The text that will be displayed in the `GtkText` when it is empty
    /// and unfocused.
    case placeholderText = "placeholder-text"
    /// Whether the widget should grow and shrink with the content.
    case propagateTextWidth = "propagate-text-width"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Number of pixels scrolled of the screen to the left.
    case scrollOffset = "scroll-offset"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// A list of tabstops to apply to the text of the `GtkText`.
    case tabs = "tabs"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// When `true`, pasted multi-line text is truncated to the first line.
    case truncateMultiline = "truncate-multiline"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// If `false`, the text is masked with the “invisible char”.
    case visibility = "visibility"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension TextProtocol {
    /// Bind a `TextPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TextPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Text property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TextPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Text property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TextPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TextSignalName: String, SignalNameProtocol {
    /// Emitted when the user hits the Enter key.
    /// 
    /// The default bindings for this signal are all forms
    /// of the &lt;kbd&gt;Enter&lt;/kbd&gt; key.
    case activate = "activate"
    /// Emitted when the user asks for it.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Backspace&lt;/kbd&gt; and &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Backspace&lt;/kbd&gt;.
    case backspace = "backspace"
    /// Emitted to copy the selection to the clipboard.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;c&lt;/kbd&gt; and
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;Insert&lt;/kbd&gt;.
    case copyClipboard = "copy-clipboard"
    /// Emitted to cut the selection to the clipboard.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;x&lt;/kbd&gt; and
    /// &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Delete&lt;/kbd&gt;.
    case cutClipboard = "cut-clipboard"
    /// Emitted when the user initiates a text deletion.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// If the `type` is `GTK_DELETE_CHARS`, GTK deletes the selection
    /// if there is one, otherwise it deletes the requested number
    /// of characters.
    /// 
    /// The default bindings for this signal are &lt;kbd&gt;Delete&lt;/kbd&gt;
    /// for deleting a character and &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;Delete&lt;/kbd&gt;
    /// for deleting a word.
    case deleteFromCursor = "delete-from-cursor"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted when the user initiates the insertion of a
    /// fixed string at the cursor.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// This signal has no default bindings.
    case insertAtCursor = "insert-at-cursor"
    /// Emitted to present the Emoji chooser for the widget.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;.&lt;/kbd&gt; and
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;;&lt;/kbd&gt;
    case insertEmoji = "insert-emoji"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the user initiates a cursor movement.
    /// 
    /// If the cursor is not visible in `self`, this signal causes
    /// the viewport to be moved instead.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// Applications should not connect to it, but may emit it with
    /// `g_signal_emit_by_name()` if they need to control the cursor
    /// programmatically.
    /// 
    /// The default bindings for this signal come in two variants,
    /// the variant with the &lt;kbd&gt;Shift&lt;/kbd&gt; modifier extends the
    /// selection, the variant without it does not.
    /// There are too many key combinations to list them all here.
    /// 
    /// - &lt;kbd&gt;←&lt;/kbd&gt;, &lt;kbd&gt;→&lt;/kbd&gt;, &lt;kbd&gt;↑&lt;/kbd&gt;, &lt;kbd&gt;↓&lt;/kbd&gt;
    ///   move by individual characters/lines
    /// - &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;→&lt;/kbd&gt;, etc. move by words/paragraphs
    /// - &lt;kbd&gt;Home&lt;/kbd&gt;, &lt;kbd&gt;End&lt;/kbd&gt; move to the ends of the buffer
    case moveCursor = "move-cursor"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted to paste the contents of the clipboard.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;v&lt;/kbd&gt; and &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Insert&lt;/kbd&gt;.
    case pasteClipboard = "paste-clipboard"
    /// Emitted when the preedit text changes.
    /// 
    /// If an input method is used, the typed text will not immediately
    /// be committed to the buffer. So if you are interested in the text,
    /// connect to this signal.
    case preeditChanged = "preedit-changed"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted to toggle the overwrite mode of the `GtkText`.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal is &lt;kbd&gt;Insert&lt;/kbd&gt;.
    case toggleOverwrite = "toggle-overwrite"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether to activate the default widget when Enter is pressed.
    case notifyActivatesDefault = "notify::activates-default"
    /// A list of Pango attributes to apply to the text of the `GtkText`.
    /// 
    /// This is mainly useful to change the size or weight of the text.
    /// 
    /// The `PangoAttribute`'s `start_index` and `end_index` must refer to the
    /// `GtkEntryBuffer` text, i.e. without the preedit string.
    case notifyAttributes = "notify::attributes"
    /// The `GtkEntryBuffer` object which stores the text.
    case notifyBuffer = "notify::buffer"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether to suggest Emoji replacements.
    case notifyEnableEmojiCompletion = "notify::enable-emoji-completion"
    /// A menu model whose contents will be appended to
    /// the context menu.
    case notifyExtraMenu = "notify::extra-menu"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// Which IM (input method) module should be used for this self.
    /// 
    /// See [class`Gtk.IMMulticontext`].
    /// 
    /// Setting this to a non-`nil` value overrides the system-wide
    /// IM module setting. See the [property`Gtk.Settings:gtk-im-module`]
    /// property.
    case notifyImModule = "notify::im-module"
    /// Additional hints that allow input methods to fine-tune
    /// their behaviour.
    case notifyInputHints = "notify::input-hints"
    /// The purpose of this text field.
    /// 
    /// This property can be used by on-screen keyboards and other input
    /// methods to adjust their behaviour.
    /// 
    /// Note that setting the purpose to `GTK_INPUT_PURPOSE_PASSWORD` or
    /// `GTK_INPUT_PURPOSE_PIN` is independent from setting
    /// [property`Gtk.Text:visibility`].
    case notifyInputPurpose = "notify::input-purpose"
    /// The character to used when masking contents (in “password mode”).
    case notifyInvisibleChar = "notify::invisible-char"
    /// Whether the invisible char has been set for the `GtkText`.
    case notifyInvisibleCharSet = "notify::invisible-char-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// Maximum number of characters that are allowed.
    /// 
    /// Zero indicates no limit.
    case notifyMaxLength = "notify::max-length"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// If text is overwritten when typing in the `GtkText`.
    case notifyOverwriteMode = "notify::overwrite-mode"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// The text that will be displayed in the `GtkText` when it is empty
    /// and unfocused.
    case notifyPlaceholderText = "notify::placeholder-text"
    /// Whether the widget should grow and shrink with the content.
    case notifyPropagateTextWidth = "notify::propagate-text-width"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Number of pixels scrolled of the screen to the left.
    case notifyScrollOffset = "notify::scroll-offset"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// A list of tabstops to apply to the text of the `GtkText`.
    case notifyTabs = "notify::tabs"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// When `true`, pasted multi-line text is truncated to the first line.
    case notifyTruncateMultiline = "notify::truncate-multiline"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// If `false`, the text is masked with the “invisible char”.
    case notifyVisibility = "notify::visibility"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: Text signals
public extension TextProtocol {
    /// Connect a Swift signal handler to the given, typed `TextSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TextSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `TextSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TextSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when the user hits the Enter key.
    /// 
    /// The default bindings for this signal are all forms
    /// of the &lt;kbd&gt;Enter&lt;/kbd&gt; key.
    /// - Note: This represents the underlying `activate` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `activate` signal is emitted
    @discardableResult @inlinable func onActivate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .activate,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `activate` signal for using the `connect(signal:)` methods
    static var activateSignal: TextSignalName { .activate }
    
    /// Emitted when the user asks for it.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Backspace&lt;/kbd&gt; and &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Backspace&lt;/kbd&gt;.
    /// - Note: This represents the underlying `backspace` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `backspace` signal is emitted
    @discardableResult @inlinable func onBackspace(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .backspace,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `backspace` signal for using the `connect(signal:)` methods
    static var backspaceSignal: TextSignalName { .backspace }
    
    /// Emitted to copy the selection to the clipboard.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;c&lt;/kbd&gt; and
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;Insert&lt;/kbd&gt;.
    /// - Note: This represents the underlying `copy-clipboard` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `copyClipboard` signal is emitted
    @discardableResult @inlinable func onCopyClipboard(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .copyClipboard,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `copy-clipboard` signal for using the `connect(signal:)` methods
    static var copyClipboardSignal: TextSignalName { .copyClipboard }
    
    /// Emitted to cut the selection to the clipboard.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;x&lt;/kbd&gt; and
    /// &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Delete&lt;/kbd&gt;.
    /// - Note: This represents the underlying `cut-clipboard` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `cutClipboard` signal is emitted
    @discardableResult @inlinable func onCutClipboard(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .cutClipboard,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `cut-clipboard` signal for using the `connect(signal:)` methods
    static var cutClipboardSignal: TextSignalName { .cutClipboard }
    
    /// Emitted when the user initiates a text deletion.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// If the `type` is `GTK_DELETE_CHARS`, GTK deletes the selection
    /// if there is one, otherwise it deletes the requested number
    /// of characters.
    /// 
    /// The default bindings for this signal are &lt;kbd&gt;Delete&lt;/kbd&gt;
    /// for deleting a character and &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;Delete&lt;/kbd&gt;
    /// for deleting a word.
    /// - Note: This represents the underlying `delete-from-cursor` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter type: the granularity of the deletion, as a `GtkDeleteType`
    /// - Parameter count: the number of `type` units to delete
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `deleteFromCursor` signal is emitted
    @discardableResult @inlinable func onDeleteFromCursor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ type: DeleteType, _ count: Int) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, DeleteType, Int), Void>
        let cCallback: @convention(c) (gpointer, UInt32, gint, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), DeleteType(arg1), Int(arg2)))
            return output
        }
        return connect(
            signal: .deleteFromCursor,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `delete-from-cursor` signal for using the `connect(signal:)` methods
    static var deleteFromCursorSignal: TextSignalName { .deleteFromCursor }
    
    /// Emitted when the user initiates the insertion of a
    /// fixed string at the cursor.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// This signal has no default bindings.
    /// - Note: This represents the underlying `insert-at-cursor` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter string: the string to insert
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `insertAtCursor` signal is emitted
    @discardableResult @inlinable func onInsertAtCursor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ string: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, String), Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!))
            return output
        }
        return connect(
            signal: .insertAtCursor,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `insert-at-cursor` signal for using the `connect(signal:)` methods
    static var insertAtCursorSignal: TextSignalName { .insertAtCursor }
    
    /// Emitted to present the Emoji chooser for the widget.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;.&lt;/kbd&gt; and
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;;&lt;/kbd&gt;
    /// - Note: This represents the underlying `insert-emoji` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `insertEmoji` signal is emitted
    @discardableResult @inlinable func onInsertEmoji(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .insertEmoji,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `insert-emoji` signal for using the `connect(signal:)` methods
    static var insertEmojiSignal: TextSignalName { .insertEmoji }
    
    /// Emitted when the user initiates a cursor movement.
    /// 
    /// If the cursor is not visible in `self`, this signal causes
    /// the viewport to be moved instead.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// Applications should not connect to it, but may emit it with
    /// `g_signal_emit_by_name()` if they need to control the cursor
    /// programmatically.
    /// 
    /// The default bindings for this signal come in two variants,
    /// the variant with the &lt;kbd&gt;Shift&lt;/kbd&gt; modifier extends the
    /// selection, the variant without it does not.
    /// There are too many key combinations to list them all here.
    /// 
    /// - &lt;kbd&gt;←&lt;/kbd&gt;, &lt;kbd&gt;→&lt;/kbd&gt;, &lt;kbd&gt;↑&lt;/kbd&gt;, &lt;kbd&gt;↓&lt;/kbd&gt;
    ///   move by individual characters/lines
    /// - &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;→&lt;/kbd&gt;, etc. move by words/paragraphs
    /// - &lt;kbd&gt;Home&lt;/kbd&gt;, &lt;kbd&gt;End&lt;/kbd&gt; move to the ends of the buffer
    /// - Note: This represents the underlying `move-cursor` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter step: the granularity of the move, as a `GtkMovementStep`
    /// - Parameter count: the number of `step` units to move
    /// - Parameter extend: `true` if the move should extend the selection
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `moveCursor` signal is emitted
    @discardableResult @inlinable func onMoveCursor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ step: MovementStep, _ count: Int, _ extend: Bool) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, MovementStep, Int, Bool), Void>
        let cCallback: @convention(c) (gpointer, UInt32, gint, gboolean, gpointer) -> Void = { unownedSelf, arg1, arg2, arg3, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), MovementStep(arg1), Int(arg2), ((arg3) != 0)))
            return output
        }
        return connect(
            signal: .moveCursor,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `move-cursor` signal for using the `connect(signal:)` methods
    static var moveCursorSignal: TextSignalName { .moveCursor }
    
    /// Emitted to paste the contents of the clipboard.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;v&lt;/kbd&gt; and &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Insert&lt;/kbd&gt;.
    /// - Note: This represents the underlying `paste-clipboard` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `pasteClipboard` signal is emitted
    @discardableResult @inlinable func onPasteClipboard(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .pasteClipboard,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `paste-clipboard` signal for using the `connect(signal:)` methods
    static var pasteClipboardSignal: TextSignalName { .pasteClipboard }
    
    /// Emitted when the preedit text changes.
    /// 
    /// If an input method is used, the typed text will not immediately
    /// be committed to the buffer. So if you are interested in the text,
    /// connect to this signal.
    /// - Note: This represents the underlying `preedit-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter preedit: the current preedit string
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `preeditChanged` signal is emitted
    @discardableResult @inlinable func onPreeditChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ preedit: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, String), Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!))
            return output
        }
        return connect(
            signal: .preeditChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `preedit-changed` signal for using the `connect(signal:)` methods
    static var preeditChangedSignal: TextSignalName { .preeditChanged }
    
    /// Emitted to toggle the overwrite mode of the `GtkText`.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal is &lt;kbd&gt;Insert&lt;/kbd&gt;.
    /// - Note: This represents the underlying `toggle-overwrite` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `toggleOverwrite` signal is emitted
    @discardableResult @inlinable func onToggleOverwrite(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .toggleOverwrite,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `toggle-overwrite` signal for using the `connect(signal:)` methods
    static var toggleOverwriteSignal: TextSignalName { .toggleOverwrite }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::activates-default` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActivatesDefault` signal is emitted
    @discardableResult @inlinable func onNotifyActivatesDefault(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyActivatesDefault,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::activates-default` signal for using the `connect(signal:)` methods
    static var notifyActivatesDefaultSignal: TextSignalName { .notifyActivatesDefault }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::attributes` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAttributes` signal is emitted
    @discardableResult @inlinable func onNotifyAttributes(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyAttributes,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::attributes` signal for using the `connect(signal:)` methods
    static var notifyAttributesSignal: TextSignalName { .notifyAttributes }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::buffer` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyBuffer` signal is emitted
    @discardableResult @inlinable func onNotifyBuffer(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyBuffer,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::buffer` signal for using the `connect(signal:)` methods
    static var notifyBufferSignal: TextSignalName { .notifyBuffer }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::enable-emoji-completion` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEnableEmojiCompletion` signal is emitted
    @discardableResult @inlinable func onNotifyEnableEmojiCompletion(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyEnableEmojiCompletion,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::enable-emoji-completion` signal for using the `connect(signal:)` methods
    static var notifyEnableEmojiCompletionSignal: TextSignalName { .notifyEnableEmojiCompletion }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::extra-menu` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyExtraMenu` signal is emitted
    @discardableResult @inlinable func onNotifyExtraMenu(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyExtraMenu,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::extra-menu` signal for using the `connect(signal:)` methods
    static var notifyExtraMenuSignal: TextSignalName { .notifyExtraMenu }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::im-module` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyImModule` signal is emitted
    @discardableResult @inlinable func onNotifyImModule(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyImModule,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::im-module` signal for using the `connect(signal:)` methods
    static var notifyImModuleSignal: TextSignalName { .notifyImModule }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::input-hints` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyInputHints` signal is emitted
    @discardableResult @inlinable func onNotifyInputHints(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyInputHints,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::input-hints` signal for using the `connect(signal:)` methods
    static var notifyInputHintsSignal: TextSignalName { .notifyInputHints }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::input-purpose` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyInputPurpose` signal is emitted
    @discardableResult @inlinable func onNotifyInputPurpose(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyInputPurpose,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::input-purpose` signal for using the `connect(signal:)` methods
    static var notifyInputPurposeSignal: TextSignalName { .notifyInputPurpose }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::invisible-char` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyInvisibleChar` signal is emitted
    @discardableResult @inlinable func onNotifyInvisibleChar(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyInvisibleChar,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::invisible-char` signal for using the `connect(signal:)` methods
    static var notifyInvisibleCharSignal: TextSignalName { .notifyInvisibleChar }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::invisible-char-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyInvisibleCharSet` signal is emitted
    @discardableResult @inlinable func onNotifyInvisibleCharSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyInvisibleCharSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::invisible-char-set` signal for using the `connect(signal:)` methods
    static var notifyInvisibleCharSetSignal: TextSignalName { .notifyInvisibleCharSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::max-length` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMaxLength` signal is emitted
    @discardableResult @inlinable func onNotifyMaxLength(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyMaxLength,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::max-length` signal for using the `connect(signal:)` methods
    static var notifyMaxLengthSignal: TextSignalName { .notifyMaxLength }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::overwrite-mode` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyOverwriteMode` signal is emitted
    @discardableResult @inlinable func onNotifyOverwriteMode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyOverwriteMode,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::overwrite-mode` signal for using the `connect(signal:)` methods
    static var notifyOverwriteModeSignal: TextSignalName { .notifyOverwriteMode }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::placeholder-text` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPlaceholderText` signal is emitted
    @discardableResult @inlinable func onNotifyPlaceholderText(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyPlaceholderText,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::placeholder-text` signal for using the `connect(signal:)` methods
    static var notifyPlaceholderTextSignal: TextSignalName { .notifyPlaceholderText }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::propagate-text-width` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPropagateTextWidth` signal is emitted
    @discardableResult @inlinable func onNotifyPropagateTextWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyPropagateTextWidth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::propagate-text-width` signal for using the `connect(signal:)` methods
    static var notifyPropagateTextWidthSignal: TextSignalName { .notifyPropagateTextWidth }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::scroll-offset` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyScrollOffset` signal is emitted
    @discardableResult @inlinable func onNotifyScrollOffset(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyScrollOffset,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::scroll-offset` signal for using the `connect(signal:)` methods
    static var notifyScrollOffsetSignal: TextSignalName { .notifyScrollOffset }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::tabs` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTabs` signal is emitted
    @discardableResult @inlinable func onNotifyTabs(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyTabs,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::tabs` signal for using the `connect(signal:)` methods
    static var notifyTabsSignal: TextSignalName { .notifyTabs }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::truncate-multiline` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTruncateMultiline` signal is emitted
    @discardableResult @inlinable func onNotifyTruncateMultiline(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyTruncateMultiline,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::truncate-multiline` signal for using the `connect(signal:)` methods
    static var notifyTruncateMultilineSignal: TextSignalName { .notifyTruncateMultiline }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::visibility` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyVisibility` signal is emitted
    @discardableResult @inlinable func onNotifyVisibility(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyVisibility,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::visibility` signal for using the `connect(signal:)` methods
    static var notifyVisibilitySignal: TextSignalName { .notifyVisibility }
    
}

// MARK: Text Class: TextProtocol extension (methods and fields)
public extension TextProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkText` instance.
    @inlinable var text_ptr: UnsafeMutablePointer<GtkText>! { return ptr?.assumingMemoryBound(to: GtkText.self) }

    /// Determine the positions of the strong and weak cursors if the
    /// insertion point in the layout is at `position`.
    /// 
    /// The position of each cursor is stored as a zero-width rectangle.
    /// The strong cursor location is the location where characters of
    /// the directionality equal to the base direction are inserted.
    /// The weak cursor location is the location where characters of
    /// the directionality opposite to the base direction are inserted.
    /// 
    /// The rectangle positions are in widget coordinates.
    @inlinable func computeCursorExtents(position: Int, strong: Graphene.RectRef? = nil, `weak`: Graphene.RectRef? = nil) {
            
        gtk_text_compute_cursor_extents(text_ptr, gsize(position), strong?.rect_ptr, `weak`?.rect_ptr)
            
    }
    /// Determine the positions of the strong and weak cursors if the
    /// insertion point in the layout is at `position`.
    /// 
    /// The position of each cursor is stored as a zero-width rectangle.
    /// The strong cursor location is the location where characters of
    /// the directionality equal to the base direction are inserted.
    /// The weak cursor location is the location where characters of
    /// the directionality opposite to the base direction are inserted.
    /// 
    /// The rectangle positions are in widget coordinates.
    @inlinable func computeCursorExtents<GrapheneRectT: Graphene.RectProtocol>(position: Int, strong: GrapheneRectT?, `weak`: GrapheneRectT?) {
        
        gtk_text_compute_cursor_extents(text_ptr, gsize(position), strong?.rect_ptr, `weak`?.rect_ptr)
        
    }

    /// Returns whether pressing Enter will activate
    /// the default widget for the window containing `self`.
    /// 
    /// See [method`Gtk.Text.set_activates_default`].
    @inlinable func getActivatesDefault() -> Bool {
        let result = gtk_text_get_activates_default(text_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the attribute list that was set on the `GtkText`.
    /// 
    /// See [method`Gtk.Text.set_attributes`].
    @inlinable func getAttributes() -> Pango.AttrListRef! {
        let result = gtk_text_get_attributes(text_ptr)
        let rv = Pango.AttrListRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Get the `GtkEntryBuffer` object which holds the text for
    /// this widget.
    @inlinable func getBuffer() -> EntryBufferRef! {
        let result = gtk_text_get_buffer(text_ptr)
        let rv = EntryBufferRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns whether Emoji completion is enabled for this
    /// `GtkText` widget.
    @inlinable func getEnableEmojiCompletion() -> Bool {
        let result = gtk_text_get_enable_emoji_completion(text_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the menu model for extra items in the context menu.
    /// 
    /// See [method`Gtk.Text.set_extra_menu`].
    @inlinable func getExtraMenu() -> GIO.MenuModelRef! {
        let result = gtk_text_get_extra_menu(text_ptr)
        let rv = GIO.MenuModelRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the input hints of the `GtkText`.
    @inlinable func getInputHints() -> Gtk.InputHints {
        let result = gtk_text_get_input_hints(text_ptr)
        let rv = InputHints(result)
        return rv
    }

    /// Gets the input purpose of the `GtkText`.
    @inlinable func getInputPurpose() -> GtkInputPurpose {
        let result = gtk_text_get_input_purpose(text_ptr)
        let rv = result
        return rv
    }

    /// Retrieves the character displayed when visibility is set to false.
    /// 
    /// Note that GTK does not compute this value unless it needs it,
    /// so the value returned by this function is not very useful unless
    /// it has been explicitly set with [method`Gtk.Text.set_invisible_char`].
    @inlinable func getInvisibleChar() -> gunichar {
        let result = gtk_text_get_invisible_char(text_ptr)
        let rv = result
        return rv
    }

    /// Retrieves the maximum allowed length of the text in `self`.
    /// 
    /// See [method`Gtk.Text.set_max_length`].
    /// 
    /// This is equivalent to getting `self`'s `GtkEntryBuffer` and
    /// calling [method`Gtk.EntryBuffer.get_max_length`] on it.
    @inlinable func getMaxLength() -> Int {
        let result = gtk_text_get_max_length(text_ptr)
        let rv = Int(result)
        return rv
    }

    /// Gets whether text is overwritten when typing in the `GtkText`.
    /// 
    /// See [method`Gtk.Text.set_overwrite_mode`].
    @inlinable func getOverwriteMode() -> Bool {
        let result = gtk_text_get_overwrite_mode(text_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Retrieves the text that will be displayed when
    /// `self` is empty and unfocused
    /// 
    /// If no placeholder text has been set, `nil` will be returned.
    @inlinable func getPlaceholderText() -> String! {
        let result = gtk_text_get_placeholder_text(text_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Returns whether the `GtkText` will grow and shrink
    /// with the content.
    @inlinable func getPropagateTextWidth() -> Bool {
        let result = gtk_text_get_propagate_text_width(text_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the tabstops that were set on the `GtkText`.
    /// 
    /// See [method`Gtk.Text.set_tabs`].
    @inlinable func getTabs() -> Pango.TabArrayRef! {
        let result = gtk_text_get_tabs(text_ptr)
        let rv = Pango.TabArrayRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Retrieves the current length of the text in `self`.
    /// 
    /// This is equivalent to getting `self`'s `GtkEntryBuffer`
    /// and calling [method`Gtk.EntryBuffer.get_length`] on it.
    @inlinable func getTextLength() -> guint16 {
        let result = gtk_text_get_text_length(text_ptr)
        let rv = result
        return rv
    }

    /// Returns whether the `GtkText` will truncate multi-line text
    /// that is pasted into the widget
    @inlinable func getTruncateMultiline() -> Bool {
        let result = gtk_text_get_truncate_multiline(text_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Retrieves whether the text in `self` is visible.
    @inlinable func getVisibility() -> Bool {
        let result = gtk_text_get_visibility(text_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Causes `self` to have keyboard focus.
    /// 
    /// It behaves like [method`Gtk.Widget.grab_focus`],
    /// except that it doesn't select the contents of `self`.
    /// You only want to call this on some special entries
    /// which the user usually doesn't want to replace all text in,
    /// such as search-as-you-type entries.
    @inlinable func grabFocusWithoutSelecting() -> Bool {
        let result = gtk_text_grab_focus_without_selecting(text_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// If `activates` is `true`, pressing Enter will activate
    /// the default widget for the window containing `self`.
    /// 
    /// This usually means that the dialog containing the `GtkText`
    /// will be closed, since the default widget is usually one of
    /// the dialog buttons.
    @inlinable func setActivatesDefault(activates: Bool) {
        
        gtk_text_set_activates_default(text_ptr, gboolean((activates) ? 1 : 0))
        
    }

    /// Sets attributes that are applied to the text.
    @inlinable func setAttributes(attrs: Pango.AttrListRef? = nil) {
            
        gtk_text_set_attributes(text_ptr, attrs?.attr_list_ptr)
            
    }
    /// Sets attributes that are applied to the text.
    @inlinable func setAttributes<PangoAttrListT: Pango.AttrListProtocol>(attrs: PangoAttrListT?) {
        
        gtk_text_set_attributes(text_ptr, attrs?.attr_list_ptr)
        
    }

    /// Set the `GtkEntryBuffer` object which holds the text for
    /// this widget.
    @inlinable func set<EntryBufferT: EntryBufferProtocol>(buffer: EntryBufferT) {
        
        gtk_text_set_buffer(text_ptr, buffer.entry_buffer_ptr)
        
    }

    /// Sets whether Emoji completion is enabled.
    /// 
    /// If it is, typing ':', followed by a recognized keyword,
    /// will pop up a window with suggested Emojis matching the
    /// keyword.
    @inlinable func set(enableEmojiCompletion: Bool) {
        
        gtk_text_set_enable_emoji_completion(text_ptr, gboolean((enableEmojiCompletion) ? 1 : 0))
        
    }

    /// Sets a menu model to add when constructing
    /// the context menu for `self`.
    @inlinable func setExtraMenu(model: GIO.MenuModelRef? = nil) {
            
        gtk_text_set_extra_menu(text_ptr, model?.menu_model_ptr)
            
    }
    /// Sets a menu model to add when constructing
    /// the context menu for `self`.
    @inlinable func setExtraMenu<GioMenuModelT: GIO.MenuModelProtocol>(model: GioMenuModelT?) {
        
        gtk_text_set_extra_menu(text_ptr, model?.menu_model_ptr)
        
    }

    /// Sets input hints that allow input methods
    /// to fine-tune their behaviour.
    @inlinable func setInput(hints: InputHints) {
        
        gtk_text_set_input_hints(text_ptr, hints.value)
        
    }

    /// Sets the input purpose of the `GtkText`.
    /// 
    /// This can be used by on-screen keyboards and other
    /// input methods to adjust their behaviour.
    @inlinable func setInput(purpose: GtkInputPurpose) {
        
        gtk_text_set_input_purpose(text_ptr, purpose)
        
    }

    /// Sets the character to use when in “password mode”.
    /// 
    /// By default, GTK picks the best invisible char available in the
    /// current font. If you set the invisible char to 0, then the user
    /// will get no feedback at all; there will be no text on the screen
    /// as they type.
    @inlinable func setInvisibleChar(ch: gunichar) {
        
        gtk_text_set_invisible_char(text_ptr, ch)
        
    }

    /// Sets the maximum allowed length of the contents of the widget.
    /// 
    /// If the current contents are longer than the given length, then
    /// they will be truncated to fit.
    /// 
    /// This is equivalent to getting `self`'s `GtkEntryBuffer` and
    /// calling [method`Gtk.EntryBuffer.set_max_length`] on it.
    @inlinable func setMax(length: Int) {
        
        gtk_text_set_max_length(text_ptr, gint(length))
        
    }

    /// Sets whether the text is overwritten when typing
    /// in the `GtkText`.
    @inlinable func setOverwriteMode(overwrite: Bool) {
        
        gtk_text_set_overwrite_mode(text_ptr, gboolean((overwrite) ? 1 : 0))
        
    }

    /// Sets text to be displayed in `self` when it is empty.
    /// 
    /// This can be used to give a visual hint of the expected
    /// contents of the `GtkText`.
    @inlinable func setPlaceholder(text: UnsafePointer<CChar>? = nil) {
        
        gtk_text_set_placeholder_text(text_ptr, text)
        
    }

    /// Sets whether the `GtkText` should grow and shrink with the content.
    @inlinable func set(propagateTextWidth: Bool) {
        
        gtk_text_set_propagate_text_width(text_ptr, gboolean((propagateTextWidth) ? 1 : 0))
        
    }

    /// Sets tabstops that are applied to the text.
    @inlinable func set(tabs: Pango.TabArrayRef? = nil) {
            
        gtk_text_set_tabs(text_ptr, tabs?.tab_array_ptr)
            
    }
    /// Sets tabstops that are applied to the text.
    @inlinable func set<PangoTabArrayT: Pango.TabArrayProtocol>(tabs: PangoTabArrayT?) {
        
        gtk_text_set_tabs(text_ptr, tabs?.tab_array_ptr)
        
    }

    /// Sets whether the `GtkText` should truncate multi-line text
    /// that is pasted into the widget.
    @inlinable func set(truncateMultiline: Bool) {
        
        gtk_text_set_truncate_multiline(text_ptr, gboolean((truncateMultiline) ? 1 : 0))
        
    }

    /// Sets whether the contents of the `GtkText` are visible or not.
    /// 
    /// When visibility is set to `false`, characters are displayed
    /// as the invisible char, and will also appear that way when
    /// the text in the widget is copied to the clipboard.
    /// 
    /// By default, GTK picks the best invisible character available
    /// in the current font, but it can be changed with
    /// [method`Gtk.Text.set_invisible_char`].
    /// 
    /// Note that you probably want to set [property`Gtk.Text:input-purpose`]
    /// to `GTK_INPUT_PURPOSE_PASSWORD` or `GTK_INPUT_PURPOSE_PIN` to
    /// inform input methods about the purpose of this self,
    /// in addition to setting visibility to `false`.
    @inlinable func setVisibility(visible: Bool) {
        
        gtk_text_set_visibility(text_ptr, gboolean((visible) ? 1 : 0))
        
    }

    /// Unsets the invisible char.
    /// 
    /// After calling this, the default invisible
    /// char is used again.
    @inlinable func unsetInvisibleChar() {
        
        gtk_text_unset_invisible_char(text_ptr)
        
    }
    /// Returns whether pressing Enter will activate
    /// the default widget for the window containing `self`.
    /// 
    /// See [method`Gtk.Text.set_activates_default`].
    @inlinable var activatesDefault: Bool {
        /// Returns whether pressing Enter will activate
        /// the default widget for the window containing `self`.
        /// 
        /// See [method`Gtk.Text.set_activates_default`].
        get {
            let result = gtk_text_get_activates_default(text_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// If `activates` is `true`, pressing Enter will activate
        /// the default widget for the window containing `self`.
        /// 
        /// This usually means that the dialog containing the `GtkText`
        /// will be closed, since the default widget is usually one of
        /// the dialog buttons.
        nonmutating set {
            gtk_text_set_activates_default(text_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// A list of Pango attributes to apply to the text of the `GtkText`.
    /// 
    /// This is mainly useful to change the size or weight of the text.
    /// 
    /// The `PangoAttribute`'s `start_index` and `end_index` must refer to the
    /// `GtkEntryBuffer` text, i.e. without the preedit string.
    @inlinable var attributes: Pango.AttrListRef! {
        /// Gets the attribute list that was set on the `GtkText`.
        /// 
        /// See [method`Gtk.Text.set_attributes`].
        get {
            let result = gtk_text_get_attributes(text_ptr)
        let rv = Pango.AttrListRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets attributes that are applied to the text.
        nonmutating set {
            gtk_text_set_attributes(text_ptr, UnsafeMutablePointer<PangoAttrList>(newValue?.attr_list_ptr))
        }
    }

    /// The `GtkEntryBuffer` object which stores the text.
    @inlinable var buffer: EntryBufferRef! {
        /// Get the `GtkEntryBuffer` object which holds the text for
        /// this widget.
        get {
            let result = gtk_text_get_buffer(text_ptr)
        let rv = EntryBufferRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Set the `GtkEntryBuffer` object which holds the text for
        /// this widget.
        nonmutating set {
            gtk_text_set_buffer(text_ptr, UnsafeMutablePointer<GtkEntryBuffer>(newValue?.entry_buffer_ptr))
        }
    }

    /// Returns whether Emoji completion is enabled for this
    /// `GtkText` widget.
    @inlinable var enableEmojiCompletion: Bool {
        /// Returns whether Emoji completion is enabled for this
        /// `GtkText` widget.
        get {
            let result = gtk_text_get_enable_emoji_completion(text_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether Emoji completion is enabled.
        /// 
        /// If it is, typing ':', followed by a recognized keyword,
        /// will pop up a window with suggested Emojis matching the
        /// keyword.
        nonmutating set {
            gtk_text_set_enable_emoji_completion(text_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the menu model for extra items in the context menu.
    /// 
    /// See [method`Gtk.Text.set_extra_menu`].
    @inlinable var extraMenu: GIO.MenuModelRef! {
        /// Gets the menu model for extra items in the context menu.
        /// 
        /// See [method`Gtk.Text.set_extra_menu`].
        get {
            let result = gtk_text_get_extra_menu(text_ptr)
        let rv = GIO.MenuModelRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets a menu model to add when constructing
        /// the context menu for `self`.
        nonmutating set {
            gtk_text_set_extra_menu(text_ptr, UnsafeMutablePointer<GMenuModel>(newValue?.menu_model_ptr))
        }
    }

    /// Gets the input hints of the `GtkText`.
    @inlinable var inputHints: Gtk.InputHints {
        /// Gets the input hints of the `GtkText`.
        get {
            let result = gtk_text_get_input_hints(text_ptr)
        let rv = InputHints(result)
            return rv
        }
        /// Sets input hints that allow input methods
        /// to fine-tune their behaviour.
        nonmutating set {
            gtk_text_set_input_hints(text_ptr, newValue.value)
        }
    }

    /// Gets the input purpose of the `GtkText`.
    @inlinable var inputPurpose: GtkInputPurpose {
        /// Gets the input purpose of the `GtkText`.
        get {
            let result = gtk_text_get_input_purpose(text_ptr)
        let rv = result
            return rv
        }
        /// Sets the input purpose of the `GtkText`.
        /// 
        /// This can be used by on-screen keyboards and other
        /// input methods to adjust their behaviour.
        nonmutating set {
            gtk_text_set_input_purpose(text_ptr, newValue)
        }
    }

    /// Retrieves the character displayed when visibility is set to false.
    /// 
    /// Note that GTK does not compute this value unless it needs it,
    /// so the value returned by this function is not very useful unless
    /// it has been explicitly set with [method`Gtk.Text.set_invisible_char`].
    @inlinable var invisibleChar: gunichar {
        /// Retrieves the character displayed when visibility is set to false.
        /// 
        /// Note that GTK does not compute this value unless it needs it,
        /// so the value returned by this function is not very useful unless
        /// it has been explicitly set with [method`Gtk.Text.set_invisible_char`].
        get {
            let result = gtk_text_get_invisible_char(text_ptr)
        let rv = result
            return rv
        }
        /// Sets the character to use when in “password mode”.
        /// 
        /// By default, GTK picks the best invisible char available in the
        /// current font. If you set the invisible char to 0, then the user
        /// will get no feedback at all; there will be no text on the screen
        /// as they type.
        nonmutating set {
            gtk_text_set_invisible_char(text_ptr, newValue)
        }
    }

    /// Retrieves the maximum allowed length of the text in `self`.
    /// 
    /// See [method`Gtk.Text.set_max_length`].
    /// 
    /// This is equivalent to getting `self`'s `GtkEntryBuffer` and
    /// calling [method`Gtk.EntryBuffer.get_max_length`] on it.
    @inlinable var maxLength: Int {
        /// Retrieves the maximum allowed length of the text in `self`.
        /// 
        /// See [method`Gtk.Text.set_max_length`].
        /// 
        /// This is equivalent to getting `self`'s `GtkEntryBuffer` and
        /// calling [method`Gtk.EntryBuffer.get_max_length`] on it.
        get {
            let result = gtk_text_get_max_length(text_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the maximum allowed length of the contents of the widget.
        /// 
        /// If the current contents are longer than the given length, then
        /// they will be truncated to fit.
        /// 
        /// This is equivalent to getting `self`'s `GtkEntryBuffer` and
        /// calling [method`Gtk.EntryBuffer.set_max_length`] on it.
        nonmutating set {
            gtk_text_set_max_length(text_ptr, gint(newValue))
        }
    }

    /// Gets whether text is overwritten when typing in the `GtkText`.
    /// 
    /// See [method`Gtk.Text.set_overwrite_mode`].
    @inlinable var overwriteMode: Bool {
        /// Gets whether text is overwritten when typing in the `GtkText`.
        /// 
        /// See [method`Gtk.Text.set_overwrite_mode`].
        get {
            let result = gtk_text_get_overwrite_mode(text_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether the text is overwritten when typing
        /// in the `GtkText`.
        nonmutating set {
            gtk_text_set_overwrite_mode(text_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Retrieves the text that will be displayed when
    /// `self` is empty and unfocused
    /// 
    /// If no placeholder text has been set, `nil` will be returned.
    @inlinable var placeholderText: String! {
        /// Retrieves the text that will be displayed when
        /// `self` is empty and unfocused
        /// 
        /// If no placeholder text has been set, `nil` will be returned.
        get {
            let result = gtk_text_get_placeholder_text(text_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
        /// Sets text to be displayed in `self` when it is empty.
        /// 
        /// This can be used to give a visual hint of the expected
        /// contents of the `GtkText`.
        nonmutating set {
            gtk_text_set_placeholder_text(text_ptr, newValue)
        }
    }

    /// Returns whether the `GtkText` will grow and shrink
    /// with the content.
    @inlinable var propagateTextWidth: Bool {
        /// Returns whether the `GtkText` will grow and shrink
        /// with the content.
        get {
            let result = gtk_text_get_propagate_text_width(text_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether the `GtkText` should grow and shrink with the content.
        nonmutating set {
            gtk_text_set_propagate_text_width(text_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// A list of tabstops to apply to the text of the `GtkText`.
    @inlinable var tabs: Pango.TabArrayRef! {
        /// Gets the tabstops that were set on the `GtkText`.
        /// 
        /// See [method`Gtk.Text.set_tabs`].
        get {
            let result = gtk_text_get_tabs(text_ptr)
        let rv = Pango.TabArrayRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets tabstops that are applied to the text.
        nonmutating set {
            gtk_text_set_tabs(text_ptr, UnsafeMutablePointer<PangoTabArray>(newValue?.tab_array_ptr))
        }
    }

    /// Retrieves the current length of the text in `self`.
    /// 
    /// This is equivalent to getting `self`'s `GtkEntryBuffer`
    /// and calling [method`Gtk.EntryBuffer.get_length`] on it.
    @inlinable var textLength: guint16 {
        /// Retrieves the current length of the text in `self`.
        /// 
        /// This is equivalent to getting `self`'s `GtkEntryBuffer`
        /// and calling [method`Gtk.EntryBuffer.get_length`] on it.
        get {
            let result = gtk_text_get_text_length(text_ptr)
        let rv = result
            return rv
        }
    }

    /// Returns whether the `GtkText` will truncate multi-line text
    /// that is pasted into the widget
    @inlinable var truncateMultiline: Bool {
        /// Returns whether the `GtkText` will truncate multi-line text
        /// that is pasted into the widget
        get {
            let result = gtk_text_get_truncate_multiline(text_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether the `GtkText` should truncate multi-line text
        /// that is pasted into the widget.
        nonmutating set {
            gtk_text_set_truncate_multiline(text_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// If `false`, the text is masked with the “invisible char”.
    @inlinable var visibility: Bool {
        /// Retrieves whether the text in `self` is visible.
        get {
            let result = gtk_text_get_visibility(text_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether the contents of the `GtkText` are visible or not.
        /// 
        /// When visibility is set to `false`, characters are displayed
        /// as the invisible char, and will also appear that way when
        /// the text in the widget is copied to the clipboard.
        /// 
        /// By default, GTK picks the best invisible character available
        /// in the current font, but it can be changed with
        /// [method`Gtk.Text.set_invisible_char`].
        /// 
        /// Note that you probably want to set [property`Gtk.Text:input-purpose`]
        /// to `GTK_INPUT_PURPOSE_PASSWORD` or `GTK_INPUT_PURPOSE_PIN` to
        /// inform input methods about the purpose of this self,
        /// in addition to setting visibility to `false`.
        nonmutating set {
            gtk_text_set_visibility(text_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    // var parentInstance is unavailable because parent_instance is private

}



// MARK: - TextBuffer Class

/// Stores text and attributes for display in a `GtkTextView`.
/// 
/// You may wish to begin by reading the
/// [text widget conceptual overview](section-text-widget.html),
/// which gives an overview of all the objects and data types
/// related to the text widget and how they work together.
/// 
/// GtkTextBuffer can support undoing changes to the buffer
/// content, see [method`Gtk.TextBuffer.set_enable_undo`].
///
/// The `TextBufferProtocol` protocol exposes the methods and properties of an underlying `GtkTextBuffer` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextBuffer`.
/// Alternatively, use `TextBufferRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextBufferProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkTextBuffer` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTextBuffer` instance.
    var text_buffer_ptr: UnsafeMutablePointer<GtkTextBuffer>! { get }

    /// Required Initialiser for types conforming to `TextBufferProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Stores text and attributes for display in a `GtkTextView`.
/// 
/// You may wish to begin by reading the
/// [text widget conceptual overview](section-text-widget.html),
/// which gives an overview of all the objects and data types
/// related to the text widget and how they work together.
/// 
/// GtkTextBuffer can support undoing changes to the buffer
/// content, see [method`Gtk.TextBuffer.set_enable_undo`].
///
/// The `TextBufferRef` type acts as a lightweight Swift reference to an underlying `GtkTextBuffer` instance.
/// It exposes methods that can operate on this data type through `TextBufferProtocol` conformance.
/// Use `TextBufferRef` only as an `unowned` reference to an existing `GtkTextBuffer` instance.
///
public struct TextBufferRef: TextBufferProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTextBuffer` instance.
    /// For type-safe access, use the generated, typed pointer `text_buffer_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextBufferRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTextBuffer>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTextBuffer>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTextBuffer>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTextBuffer>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextBufferProtocol`
    @inlinable init<T: TextBufferProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TextBufferProtocol>(_ other: T) -> TextBufferRef { TextBufferRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new text buffer.
    @inlinable init<TextTagTableT: TextTagTableProtocol>( table: TextTagTableT?) {
            let result = gtk_text_buffer_new(table?.text_tag_table_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// Stores text and attributes for display in a `GtkTextView`.
/// 
/// You may wish to begin by reading the
/// [text widget conceptual overview](section-text-widget.html),
/// which gives an overview of all the objects and data types
/// related to the text widget and how they work together.
/// 
/// GtkTextBuffer can support undoing changes to the buffer
/// content, see [method`Gtk.TextBuffer.set_enable_undo`].
///
/// The `TextBuffer` type acts as a reference-counted owner of an underlying `GtkTextBuffer` instance.
/// It provides the methods that can operate on this data type through `TextBufferProtocol` conformance.
/// Use `TextBuffer` as a strong reference or owner of a `GtkTextBuffer` instance.
///
open class TextBuffer: GLibObject.Object, TextBufferProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextBuffer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTextBuffer>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextBuffer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTextBuffer>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextBuffer` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextBuffer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextBuffer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTextBuffer>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextBuffer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTextBuffer>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTextBuffer`.
    /// i.e., ownership is transferred to the `TextBuffer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTextBuffer>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TextBufferProtocol`
    /// Will retain `GtkTextBuffer`.
    /// - Parameter other: an instance of a related type that implements `TextBufferProtocol`
    @inlinable public init<T: TextBufferProtocol>(textBuffer other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new text buffer.
    @inlinable public init<TextTagTableT: TextTagTableProtocol>( table: TextTagTableT?) {
            let result = gtk_text_buffer_new(table?.text_tag_table_ptr)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum TextBufferPropertyName: String, PropertyNameProtocol {
    /// Denotes that the buffer can reapply the last undone action.
    case canRedo = "can-redo"
    /// Denotes that the buffer can undo the last applied action.
    case canUndo = "can-undo"
    /// The position of the insert mark.
    /// 
    /// This is an offset from the beginning of the buffer.
    /// It is useful for getting notified when the cursor moves.
    case cursorPosition = "cursor-position"
    /// Denotes if support for undoing and redoing changes to the buffer is allowed.
    case enableUndo = "enable-undo"
    /// Whether the buffer has some text currently selected.
    case hasSelection = "has-selection"
    /// The GtkTextTagTable for the buffer.
    case tagTable = "tag-table"
    /// The text content of the buffer.
    /// 
    /// Without child widgets and images,
    /// see [method`Gtk.TextBuffer.get_text`] for more information.
    case text = "text"
}

public extension TextBufferProtocol {
    /// Bind a `TextBufferPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TextBufferPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TextBuffer property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TextBufferPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TextBuffer property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TextBufferPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TextBufferSignalName: String, SignalNameProtocol {
    /// Emitted to apply a tag to a range of text in a `GtkTextBuffer`.
    /// 
    /// Applying actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler
    /// it must not invalidate the `start` and `end` iters (or has to
    /// revalidate them).
    /// 
    /// See also:
    /// [method`Gtk.TextBuffer.apply_tag`],
    /// [method`Gtk.TextBuffer.insert_with_tags`],
    /// [method`Gtk.TextBuffer.insert_range`].
    case applyTag = "apply-tag"
    /// Emitted at the beginning of a single user-visible
    /// operation on a `GtkTextBuffer`.
    /// 
    /// See also:
    /// [method`Gtk.TextBuffer.begin_user_action`],
    /// [method`Gtk.TextBuffer.insert_interactive`],
    /// [method`Gtk.TextBuffer.insert_range_interactive`],
    /// [method`Gtk.TextBuffer.delete_interactive`],
    /// [method`Gtk.TextBuffer.backspace`],
    /// [method`Gtk.TextBuffer.delete_selection`].
    case beginUserAction = "begin-user-action"
    /// Emitted when the content of a `GtkTextBuffer` has changed.
    case changed = "changed"
    /// Emitted to delete a range from a `GtkTextBuffer`.
    /// 
    /// Note that if your handler runs before the default handler
    /// it must not invalidate the `start` and `end` iters (or has
    /// to revalidate them). The default signal handler revalidates
    /// the `start` and `end` iters to both point to the location
    /// where text was deleted. Handlers which run after the default
    /// handler (see `g_signal_connect_after()`) do not have access to
    /// the deleted text.
    /// 
    /// See also: [method`Gtk.TextBuffer.delete`].
    case deleteRange = "delete-range"
    /// Emitted at the end of a single user-visible
    /// operation on the `GtkTextBuffer`.
    /// 
    /// See also:
    /// [method`Gtk.TextBuffer.end_user_action`],
    /// [method`Gtk.TextBuffer.insert_interactive`],
    /// [method`Gtk.TextBuffer.insert_range_interactive`],
    /// [method`Gtk.TextBuffer.delete_interactive`],
    /// [method`Gtk.TextBuffer.backspace`],
    /// [method`Gtk.TextBuffer.delete_selection`],
    /// [method`Gtk.TextBuffer.backspace`].
    case endUserAction = "end-user-action"
    /// Emitted to insert a `GtkTextChildAnchor` in a `GtkTextBuffer`.
    /// 
    /// Insertion actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler
    /// it must not invalidate the `location` iter (or has to
    /// revalidate it). The default signal handler revalidates
    /// it to be placed after the inserted `anchor`.
    /// 
    /// See also: [method`Gtk.TextBuffer.insert_child_anchor`].
    case insertChildAnchor = "insert-child-anchor"
    /// Emitted to insert a `GdkPaintable` in a `GtkTextBuffer`.
    /// 
    /// Insertion actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler
    /// it must not invalidate the `location` iter (or has to
    /// revalidate it). The default signal handler revalidates
    /// it to be placed after the inserted `paintable`.
    /// 
    /// See also: [method`Gtk.TextBuffer.insert_paintable`].
    case insertPaintable = "insert-paintable"
    /// Emitted to insert text in a `GtkTextBuffer`.
    /// 
    /// Insertion actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler
    /// it must not invalidate the `location` iter (or has to
    /// revalidate it). The default signal handler revalidates
    /// it to point to the end of the inserted text.
    /// 
    /// See also: [method`Gtk.TextBuffer.insert`],
    /// [method`Gtk.TextBuffer.insert_range`].
    case insertText = "insert-text"
    /// Emitted as notification after a `GtkTextMark` is deleted.
    /// 
    /// See also: [method`Gtk.TextBuffer.delete_mark`].
    case markDeleted = "mark-deleted"
    /// Emitted as notification after a `GtkTextMark` is set.
    /// 
    /// See also:
    /// [method`Gtk.TextBuffer.create_mark`],
    /// [method`Gtk.TextBuffer.move_mark`].
    case markSet = "mark-set"
    /// Emitted when the modified bit of a `GtkTextBuffer` flips.
    /// 
    /// See also: [method`Gtk.TextBuffer.set_modified`].
    case modifiedChanged = "modified-changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted after paste operation has been completed.
    /// 
    /// This is useful to properly scroll the view to the end
    /// of the pasted text. See [method`Gtk.TextBuffer.paste_clipboard`]
    /// for more details.
    case pasteDone = "paste-done"
    /// Emitted when a request has been made to redo the
    /// previously undone operation.
    case redo = "redo"
    /// Emitted to remove all occurrences of `tag` from a range
    /// of text in a `GtkTextBuffer`.
    /// 
    /// Removal actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler
    /// it must not invalidate the `start` and `end` iters (or has
    /// to revalidate them).
    /// 
    /// See also: [method`Gtk.TextBuffer.remove_tag`].
    case removeTag = "remove-tag"
    /// Emitted when a request has been made to undo the
    /// previous operation or set of operations that have
    /// been grouped together.
    case undo = "undo"
    /// Denotes that the buffer can reapply the last undone action.
    case notifyCanRedo = "notify::can-redo"
    /// Denotes that the buffer can undo the last applied action.
    case notifyCanUndo = "notify::can-undo"
    /// The position of the insert mark.
    /// 
    /// This is an offset from the beginning of the buffer.
    /// It is useful for getting notified when the cursor moves.
    case notifyCursorPosition = "notify::cursor-position"
    /// Denotes if support for undoing and redoing changes to the buffer is allowed.
    case notifyEnableUndo = "notify::enable-undo"
    /// Whether the buffer has some text currently selected.
    case notifyHasSelection = "notify::has-selection"
    /// The GtkTextTagTable for the buffer.
    case notifyTagTable = "notify::tag-table"
    /// The text content of the buffer.
    /// 
    /// Without child widgets and images,
    /// see [method`Gtk.TextBuffer.get_text`] for more information.
    case notifyText = "notify::text"
}

// MARK: TextBuffer signals
public extension TextBufferProtocol {
    /// Connect a Swift signal handler to the given, typed `TextBufferSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TextBufferSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `TextBufferSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TextBufferSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted to apply a tag to a range of text in a `GtkTextBuffer`.
    /// 
    /// Applying actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler
    /// it must not invalidate the `start` and `end` iters (or has to
    /// revalidate them).
    /// 
    /// See also:
    /// [method`Gtk.TextBuffer.apply_tag`],
    /// [method`Gtk.TextBuffer.insert_with_tags`],
    /// [method`Gtk.TextBuffer.insert_range`].
    /// - Note: This represents the underlying `apply-tag` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter tag: the applied tag
    /// - Parameter start: the start of the range the tag is applied to
    /// - Parameter end: the end of the range the tag is applied to
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `applyTag` signal is emitted
    @discardableResult @inlinable func onApplyTag(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ tag: TextTagRef, _ start: TextIterRef, _ end: TextIterRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef, TextTagRef, TextIterRef, TextIterRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, arg3, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf), TextTagRef(raw: arg1), TextIterRef(raw: arg2), TextIterRef(raw: arg3)))
            return output
        }
        return connect(
            signal: .applyTag,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `apply-tag` signal for using the `connect(signal:)` methods
    static var applyTagSignal: TextBufferSignalName { .applyTag }
    
    /// Emitted at the beginning of a single user-visible
    /// operation on a `GtkTextBuffer`.
    /// 
    /// See also:
    /// [method`Gtk.TextBuffer.begin_user_action`],
    /// [method`Gtk.TextBuffer.insert_interactive`],
    /// [method`Gtk.TextBuffer.insert_range_interactive`],
    /// [method`Gtk.TextBuffer.delete_interactive`],
    /// [method`Gtk.TextBuffer.backspace`],
    /// [method`Gtk.TextBuffer.delete_selection`].
    /// - Note: This represents the underlying `begin-user-action` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `beginUserAction` signal is emitted
    @discardableResult @inlinable func onBeginUserAction(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .beginUserAction,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `begin-user-action` signal for using the `connect(signal:)` methods
    static var beginUserActionSignal: TextBufferSignalName { .beginUserAction }
    
    /// Emitted when the content of a `GtkTextBuffer` has changed.
    /// - Note: This represents the underlying `changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `changed` signal is emitted
    @discardableResult @inlinable func onChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .changed,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `changed` signal for using the `connect(signal:)` methods
    static var changedSignal: TextBufferSignalName { .changed }
    
    /// Emitted to delete a range from a `GtkTextBuffer`.
    /// 
    /// Note that if your handler runs before the default handler
    /// it must not invalidate the `start` and `end` iters (or has
    /// to revalidate them). The default signal handler revalidates
    /// the `start` and `end` iters to both point to the location
    /// where text was deleted. Handlers which run after the default
    /// handler (see `g_signal_connect_after()`) do not have access to
    /// the deleted text.
    /// 
    /// See also: [method`Gtk.TextBuffer.delete`].
    /// - Note: This represents the underlying `delete-range` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter start: the start of the range to be deleted
    /// - Parameter end: the end of the range to be deleted
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `deleteRange` signal is emitted
    @discardableResult @inlinable func onDeleteRange(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ start: TextIterRef, _ end: TextIterRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef, TextIterRef, TextIterRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf), TextIterRef(raw: arg1), TextIterRef(raw: arg2)))
            return output
        }
        return connect(
            signal: .deleteRange,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `delete-range` signal for using the `connect(signal:)` methods
    static var deleteRangeSignal: TextBufferSignalName { .deleteRange }
    
    /// Emitted at the end of a single user-visible
    /// operation on the `GtkTextBuffer`.
    /// 
    /// See also:
    /// [method`Gtk.TextBuffer.end_user_action`],
    /// [method`Gtk.TextBuffer.insert_interactive`],
    /// [method`Gtk.TextBuffer.insert_range_interactive`],
    /// [method`Gtk.TextBuffer.delete_interactive`],
    /// [method`Gtk.TextBuffer.backspace`],
    /// [method`Gtk.TextBuffer.delete_selection`],
    /// [method`Gtk.TextBuffer.backspace`].
    /// - Note: This represents the underlying `end-user-action` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `endUserAction` signal is emitted
    @discardableResult @inlinable func onEndUserAction(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .endUserAction,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `end-user-action` signal for using the `connect(signal:)` methods
    static var endUserActionSignal: TextBufferSignalName { .endUserAction }
    
    /// Emitted to insert a `GtkTextChildAnchor` in a `GtkTextBuffer`.
    /// 
    /// Insertion actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler
    /// it must not invalidate the `location` iter (or has to
    /// revalidate it). The default signal handler revalidates
    /// it to be placed after the inserted `anchor`.
    /// 
    /// See also: [method`Gtk.TextBuffer.insert_child_anchor`].
    /// - Note: This represents the underlying `insert-child-anchor` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter location: position to insert `anchor` in `textbuffer`
    /// - Parameter anchor: the `GtkTextChildAnchor` to be inserted
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `insertChildAnchor` signal is emitted
    @discardableResult @inlinable func onInsertChildAnchor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ location: TextIterRef, _ anchor: TextChildAnchorRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef, TextIterRef, TextChildAnchorRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf), TextIterRef(raw: arg1), TextChildAnchorRef(raw: arg2)))
            return output
        }
        return connect(
            signal: .insertChildAnchor,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `insert-child-anchor` signal for using the `connect(signal:)` methods
    static var insertChildAnchorSignal: TextBufferSignalName { .insertChildAnchor }
    
    /// Emitted to insert a `GdkPaintable` in a `GtkTextBuffer`.
    /// 
    /// Insertion actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler
    /// it must not invalidate the `location` iter (or has to
    /// revalidate it). The default signal handler revalidates
    /// it to be placed after the inserted `paintable`.
    /// 
    /// See also: [method`Gtk.TextBuffer.insert_paintable`].
    /// - Note: This represents the underlying `insert-paintable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter location: position to insert `paintable` in `textbuffer`
    /// - Parameter paintable: the `GdkPaintable` to be inserted
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `insertPaintable` signal is emitted
    @discardableResult @inlinable func onInsertPaintable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ location: TextIterRef, _ paintable: Gdk.PaintableRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef, TextIterRef, Gdk.PaintableRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf), TextIterRef(raw: arg1), Gdk.PaintableRef(raw: arg2)))
            return output
        }
        return connect(
            signal: .insertPaintable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `insert-paintable` signal for using the `connect(signal:)` methods
    static var insertPaintableSignal: TextBufferSignalName { .insertPaintable }
    
    /// Emitted to insert text in a `GtkTextBuffer`.
    /// 
    /// Insertion actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler
    /// it must not invalidate the `location` iter (or has to
    /// revalidate it). The default signal handler revalidates
    /// it to point to the end of the inserted text.
    /// 
    /// See also: [method`Gtk.TextBuffer.insert`],
    /// [method`Gtk.TextBuffer.insert_range`].
    /// - Note: This represents the underlying `insert-text` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter location: position to insert `text` in `textbuffer`
    /// - Parameter text: the UTF-8 text to be inserted
    /// - Parameter len: length of the inserted text in bytes
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `insertText` signal is emitted
    @discardableResult @inlinable func onInsertText(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ location: TextIterRef, _ text: String, _ len: Int) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef, TextIterRef, String, Int), Void>
        let cCallback: @convention(c) (gpointer, gpointer, UnsafeMutablePointer<gchar>?, gint, gpointer) -> Void = { unownedSelf, arg1, arg2, arg3, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf), TextIterRef(raw: arg1), arg2.map({ String(cString: $0) })!, Int(arg3)))
            return output
        }
        return connect(
            signal: .insertText,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `insert-text` signal for using the `connect(signal:)` methods
    static var insertTextSignal: TextBufferSignalName { .insertText }
    
    /// Emitted as notification after a `GtkTextMark` is deleted.
    /// 
    /// See also: [method`Gtk.TextBuffer.delete_mark`].
    /// - Note: This represents the underlying `mark-deleted` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter mark: The mark that was deleted
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `markDeleted` signal is emitted
    @discardableResult @inlinable func onMarkDeleted(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ mark: TextMarkRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef, TextMarkRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf), TextMarkRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .markDeleted,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `mark-deleted` signal for using the `connect(signal:)` methods
    static var markDeletedSignal: TextBufferSignalName { .markDeleted }
    
    /// Emitted as notification after a `GtkTextMark` is set.
    /// 
    /// See also:
    /// [method`Gtk.TextBuffer.create_mark`],
    /// [method`Gtk.TextBuffer.move_mark`].
    /// - Note: This represents the underlying `mark-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter location: The location of `mark` in `textbuffer`
    /// - Parameter mark: The mark that is set
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `markSet` signal is emitted
    @discardableResult @inlinable func onMarkSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ location: TextIterRef, _ mark: TextMarkRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef, TextIterRef, TextMarkRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf), TextIterRef(raw: arg1), TextMarkRef(raw: arg2)))
            return output
        }
        return connect(
            signal: .markSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `mark-set` signal for using the `connect(signal:)` methods
    static var markSetSignal: TextBufferSignalName { .markSet }
    
    /// Emitted when the modified bit of a `GtkTextBuffer` flips.
    /// 
    /// See also: [method`Gtk.TextBuffer.set_modified`].
    /// - Note: This represents the underlying `modified-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `modifiedChanged` signal is emitted
    @discardableResult @inlinable func onModifiedChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .modifiedChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `modified-changed` signal for using the `connect(signal:)` methods
    static var modifiedChangedSignal: TextBufferSignalName { .modifiedChanged }
    
    /// Emitted after paste operation has been completed.
    /// 
    /// This is useful to properly scroll the view to the end
    /// of the pasted text. See [method`Gtk.TextBuffer.paste_clipboard`]
    /// for more details.
    /// - Note: This represents the underlying `paste-done` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter clipboard: the `GdkClipboard` pasted from
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `pasteDone` signal is emitted
    @discardableResult @inlinable func onPasteDone(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ clipboard: Gdk.ClipboardRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef, Gdk.ClipboardRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf), Gdk.ClipboardRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .pasteDone,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `paste-done` signal for using the `connect(signal:)` methods
    static var pasteDoneSignal: TextBufferSignalName { .pasteDone }
    
    /// Emitted when a request has been made to redo the
    /// previously undone operation.
    /// - Note: This represents the underlying `redo` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `redo` signal is emitted
    @discardableResult @inlinable func onRedo(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .redo,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `redo` signal for using the `connect(signal:)` methods
    static var redoSignal: TextBufferSignalName { .redo }
    
    /// Emitted to remove all occurrences of `tag` from a range
    /// of text in a `GtkTextBuffer`.
    /// 
    /// Removal actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler
    /// it must not invalidate the `start` and `end` iters (or has
    /// to revalidate them).
    /// 
    /// See also: [method`Gtk.TextBuffer.remove_tag`].
    /// - Note: This represents the underlying `remove-tag` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter tag: the tag to be removed
    /// - Parameter start: the start of the range the tag is removed from
    /// - Parameter end: the end of the range the tag is removed from
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `removeTag` signal is emitted
    @discardableResult @inlinable func onRemoveTag(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ tag: TextTagRef, _ start: TextIterRef, _ end: TextIterRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef, TextTagRef, TextIterRef, TextIterRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, arg3, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf), TextTagRef(raw: arg1), TextIterRef(raw: arg2), TextIterRef(raw: arg3)))
            return output
        }
        return connect(
            signal: .removeTag,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `remove-tag` signal for using the `connect(signal:)` methods
    static var removeTagSignal: TextBufferSignalName { .removeTag }
    
    /// Emitted when a request has been made to undo the
    /// previous operation or set of operations that have
    /// been grouped together.
    /// - Note: This represents the underlying `undo` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `undo` signal is emitted
    @discardableResult @inlinable func onUndo(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .undo,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `undo` signal for using the `connect(signal:)` methods
    static var undoSignal: TextBufferSignalName { .undo }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::can-redo` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyCanRedo` signal is emitted
    @discardableResult @inlinable func onNotifyCanRedo(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyCanRedo,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::can-redo` signal for using the `connect(signal:)` methods
    static var notifyCanRedoSignal: TextBufferSignalName { .notifyCanRedo }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::can-undo` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyCanUndo` signal is emitted
    @discardableResult @inlinable func onNotifyCanUndo(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyCanUndo,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::can-undo` signal for using the `connect(signal:)` methods
    static var notifyCanUndoSignal: TextBufferSignalName { .notifyCanUndo }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::cursor-position` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyCursorPosition` signal is emitted
    @discardableResult @inlinable func onNotifyCursorPosition(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyCursorPosition,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::cursor-position` signal for using the `connect(signal:)` methods
    static var notifyCursorPositionSignal: TextBufferSignalName { .notifyCursorPosition }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::enable-undo` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEnableUndo` signal is emitted
    @discardableResult @inlinable func onNotifyEnableUndo(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyEnableUndo,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::enable-undo` signal for using the `connect(signal:)` methods
    static var notifyEnableUndoSignal: TextBufferSignalName { .notifyEnableUndo }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::has-selection` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHasSelection` signal is emitted
    @discardableResult @inlinable func onNotifyHasSelection(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyHasSelection,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::has-selection` signal for using the `connect(signal:)` methods
    static var notifyHasSelectionSignal: TextBufferSignalName { .notifyHasSelection }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::tag-table` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTagTable` signal is emitted
    @discardableResult @inlinable func onNotifyTagTable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyTagTable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::tag-table` signal for using the `connect(signal:)` methods
    static var notifyTagTableSignal: TextBufferSignalName { .notifyTagTable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::text` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyText` signal is emitted
    @discardableResult @inlinable func onNotifyText(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextBufferRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextBufferRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyText,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::text` signal for using the `connect(signal:)` methods
    static var notifyTextSignal: TextBufferSignalName { .notifyText }
    
}

// MARK: TextBuffer Class: TextBufferProtocol extension (methods and fields)
public extension TextBufferProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextBuffer` instance.
    @inlinable var text_buffer_ptr: UnsafeMutablePointer<GtkTextBuffer>! { return ptr?.assumingMemoryBound(to: GtkTextBuffer.self) }

    /// Adds the mark at position `where`.
    /// 
    /// The mark must not be added to another buffer, and if its name
    /// is not `nil` then there must not be another mark in the buffer
    /// with the same name.
    /// 
    /// Emits the [signal`Gtk.TextBuffer::mark-set`] signal as notification
    /// of the mark's initial placement.
    @inlinable func add<TextIterT: TextIterProtocol, TextMarkT: TextMarkProtocol>(mark: TextMarkT, `where`: TextIterT) {
        
        gtk_text_buffer_add_mark(text_buffer_ptr, mark.text_mark_ptr, `where`.text_iter_ptr)
        
    }

    /// Adds `clipboard` to the list of clipboards in which the selection
    /// contents of `buffer` are available.
    /// 
    /// In most cases, `clipboard` will be the `GdkClipboard` returned by
    /// [method`Gtk.Widget.get_primary_clipboard`] for a view of `buffer`.
    @inlinable func addSelection<GdkClipboardT: Gdk.ClipboardProtocol>(clipboard: GdkClipboardT) {
        
        gtk_text_buffer_add_selection_clipboard(text_buffer_ptr, clipboard.clipboard_ptr)
        
    }

    /// Emits the “apply-tag” signal on `buffer`.
    /// 
    /// The default handler for the signal applies
    /// `tag` to the given range. `start` and `end` do
    /// not have to be in order.
    @inlinable func apply<TextIterT: TextIterProtocol, TextTagT: TextTagProtocol>(tag: TextTagT, start: TextIterT, end: TextIterT) {
        
        gtk_text_buffer_apply_tag(text_buffer_ptr, tag.text_tag_ptr, start.text_iter_ptr, end.text_iter_ptr)
        
    }

    /// Emits the “apply-tag” signal on `buffer`.
    /// 
    /// Calls [method`Gtk.TextTagTable.lookup`] on the buffer’s
    /// tag table to get a `GtkTextTag`, then calls
    /// [method`Gtk.TextBuffer.apply_tag`].
    @inlinable func applyTagBy<TextIterT: TextIterProtocol>(name: UnsafePointer<CChar>!, start: TextIterT, end: TextIterT) {
        
        gtk_text_buffer_apply_tag_by_name(text_buffer_ptr, name, start.text_iter_ptr, end.text_iter_ptr)
        
    }

    /// Performs the appropriate action as if the user hit the delete
    /// key with the cursor at the position specified by `iter`.
    /// 
    /// In the normal case a single character will be deleted, but when
    /// combining accents are involved, more than one character can
    /// be deleted, and when precomposed character and accent combinations
    /// are involved, less than one character will be deleted.
    /// 
    /// Because the buffer is modified, all outstanding iterators become
    /// invalid after calling this function; however, the `iter` will be
    /// re-initialized to point to the location where text was deleted.
    @inlinable func backspace<TextIterT: TextIterProtocol>(iter: TextIterT, interactive: Bool, defaultEditable: Bool) -> Bool {
        let result = gtk_text_buffer_backspace(text_buffer_ptr, iter.text_iter_ptr, gboolean((interactive) ? 1 : 0), gboolean((defaultEditable) ? 1 : 0))
        let rv = ((result) != 0)
        return rv
    }

    /// Denotes the beginning of an action that may not be undone.
    /// 
    /// This will cause any previous operations in the undo/redo queue
    /// to be cleared.
    /// 
    /// This should be paired with a call to
    /// [method`Gtk.TextBuffer.end_irreversible_action`] after the irreversible
    /// action has completed.
    /// 
    /// You may nest calls to `gtk_text_buffer_begin_irreversible_action()`
    /// and `gtk_text_buffer_end_irreversible_action()` pairs.
    @inlinable func beginIrreversibleAction() {
        
        gtk_text_buffer_begin_irreversible_action(text_buffer_ptr)
        
    }

    /// Called to indicate that the buffer operations between here and a
    /// call to `gtk_text_buffer_end_user_action()` are part of a single
    /// user-visible operation.
    /// 
    /// The operations between `gtk_text_buffer_begin_user_action()` and
    /// `gtk_text_buffer_end_user_action()` can then be grouped when creating
    /// an undo stack. `GtkTextBuffer` maintains a count of calls to
    /// `gtk_text_buffer_begin_user_action()` that have not been closed with
    /// a call to `gtk_text_buffer_end_user_action()`, and emits the
    /// “begin-user-action” and “end-user-action” signals only for the
    /// outermost pair of calls. This allows you to build user actions
    /// from other user actions.
    /// 
    /// The “interactive” buffer mutation functions, such as
    /// [method`Gtk.TextBuffer.insert_interactive`], automatically call
    /// begin/end user action around the buffer operations they perform,
    /// so there's no need to add extra calls if you user action consists
    /// solely of a single call to one of those functions.
    @inlinable func beginUserAction() {
        
        gtk_text_buffer_begin_user_action(text_buffer_ptr)
        
    }

    /// Copies the currently-selected text to a clipboard.
    @inlinable func copy<GdkClipboardT: Gdk.ClipboardProtocol>(clipboard: GdkClipboardT) {
        
        gtk_text_buffer_copy_clipboard(text_buffer_ptr, clipboard.clipboard_ptr)
        
    }

    /// Creates and inserts a child anchor.
    /// 
    /// This is a convenience function which simply creates a child anchor
    /// with [ctor`Gtk.TextChildAnchor.new`] and inserts it into the buffer
    /// with [method`Gtk.TextBuffer.insert_child_anchor`].
    /// 
    /// The new anchor is owned by the buffer; no reference count is
    /// returned to the caller of this function.
    @inlinable func createChildAnchor<TextIterT: TextIterProtocol>(iter: TextIterT) -> TextChildAnchorRef! {
        let result = gtk_text_buffer_create_child_anchor(text_buffer_ptr, iter.text_iter_ptr)
        let rv = TextChildAnchorRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Creates a mark at position `where`.
    /// 
    /// If `mark_name` is `nil`, the mark is anonymous; otherwise, the mark
    /// can be retrieved by name using [method`Gtk.TextBuffer.get_mark`].
    /// If a mark has left gravity, and text is inserted at the mark’s
    /// current location, the mark will be moved to the left of the
    /// newly-inserted text. If the mark has right gravity
    /// (`left_gravity` = `false`), the mark will end up on the right of
    /// newly-inserted text. The standard left-to-right cursor is a mark
    /// with right gravity (when you type, the cursor stays on the right
    /// side of the text you’re typing).
    /// 
    /// The caller of this function does not own a
    /// reference to the returned `GtkTextMark`, so you can ignore the
    /// return value if you like. Marks are owned by the buffer and go
    /// away when the buffer does.
    /// 
    /// Emits the [signal`Gtk.TextBuffer::mark-set`] signal as notification
    /// of the mark's initial placement.
    @inlinable func createMark<TextIterT: TextIterProtocol>(markName: UnsafePointer<CChar>? = nil, `where`: TextIterT, leftGravity: Bool) -> TextMarkRef! {
        let result = gtk_text_buffer_create_mark(text_buffer_ptr, markName, `where`.text_iter_ptr, gboolean((leftGravity) ? 1 : 0))
        let rv = TextMarkRef(gconstpointer: gconstpointer(result))
        return rv
    }


    // *** createTag() is not available because it has a varargs (...) parameter!


    /// Copies the currently-selected text to a clipboard,
    /// then deletes said text if it’s editable.
    @inlinable func cut<GdkClipboardT: Gdk.ClipboardProtocol>(clipboard: GdkClipboardT, defaultEditable: Bool) {
        
        gtk_text_buffer_cut_clipboard(text_buffer_ptr, clipboard.clipboard_ptr, gboolean((defaultEditable) ? 1 : 0))
        
    }

    /// Deletes text between `start` and `end`.
    /// 
    /// The order of `start` and `end` is not actually relevant;
    /// `gtk_text_buffer_delete()` will reorder them.
    /// 
    /// This function actually emits the “delete-range” signal, and
    /// the default handler of that signal deletes the text. Because the
    /// buffer is modified, all outstanding iterators become invalid after
    /// calling this function; however, the `start` and `end` will be
    /// re-initialized to point to the location where text was deleted.
    @inlinable func delete<TextIterT: TextIterProtocol>(start: TextIterT, end: TextIterT) {
        
        gtk_text_buffer_delete(text_buffer_ptr, start.text_iter_ptr, end.text_iter_ptr)
        
    }

    /// Deletes all editable text in the given range.
    /// 
    /// Calls [method`Gtk.TextBuffer.delete`] for each editable
    /// sub-range of [`start`,`end`). `start` and `end` are revalidated
    /// to point to the location of the last deleted range, or left
    /// untouched if no text was deleted.
    @inlinable func deleteInteractive<TextIterT: TextIterProtocol>(startIter: TextIterT, endIter: TextIterT, defaultEditable: Bool) -> Bool {
        let result = gtk_text_buffer_delete_interactive(text_buffer_ptr, startIter.text_iter_ptr, endIter.text_iter_ptr, gboolean((defaultEditable) ? 1 : 0))
        let rv = ((result) != 0)
        return rv
    }

    /// Deletes `mark`, so that it’s no longer located anywhere in the
    /// buffer.
    /// 
    /// Removes the reference the buffer holds to the mark, so if
    /// you haven’t called `g_object_ref()` on the mark, it will be freed.
    /// Even if the mark isn’t freed, most operations on `mark` become
    /// invalid, until it gets added to a buffer again with
    /// [method`Gtk.TextBuffer.add_mark`]. Use [method`Gtk.TextMark.get_deleted`]
    /// to find out if a mark has been removed from its buffer.
    /// 
    /// The [signal`Gtk.TextBuffer::mark-deleted`] signal will be emitted as
    /// notification after the mark is deleted.
    @inlinable func delete<TextMarkT: TextMarkProtocol>(mark: TextMarkT) {
        
        gtk_text_buffer_delete_mark(text_buffer_ptr, mark.text_mark_ptr)
        
    }

    /// Deletes the mark named `name`; the mark must exist.
    /// 
    /// See [method`Gtk.TextBuffer.delete_mark`] for details.
    @inlinable func deleteMarkBy(name: UnsafePointer<CChar>!) {
        
        gtk_text_buffer_delete_mark_by_name(text_buffer_ptr, name)
        
    }

    /// Deletes the range between the “insert” and “selection_bound” marks,
    /// that is, the currently-selected text.
    /// 
    /// If `interactive` is `true`, the editability of the selection will be
    /// considered (users can’t delete uneditable text).
    @inlinable func deleteSelection(interactive: Bool, defaultEditable: Bool) -> Bool {
        let result = gtk_text_buffer_delete_selection(text_buffer_ptr, gboolean((interactive) ? 1 : 0), gboolean((defaultEditable) ? 1 : 0))
        let rv = ((result) != 0)
        return rv
    }

    /// Denotes the end of an action that may not be undone.
    /// 
    /// This will cause any previous operations in the undo/redo
    /// queue to be cleared.
    /// 
    /// This should be called after completing modifications to the
    /// text buffer after [method`Gtk.TextBuffer.begin_irreversible_action`]
    /// was called.
    /// 
    /// You may nest calls to `gtk_text_buffer_begin_irreversible_action()`
    /// and `gtk_text_buffer_end_irreversible_action()` pairs.
    @inlinable func endIrreversibleAction() {
        
        gtk_text_buffer_end_irreversible_action(text_buffer_ptr)
        
    }

    /// Ends a user-visible operation.
    /// 
    /// Should be paired with a call to
    /// [method`Gtk.TextBuffer.begin_user_action`].
    /// See that function for a full explanation.
    @inlinable func endUserAction() {
        
        gtk_text_buffer_end_user_action(text_buffer_ptr)
        
    }

    /// Retrieves the first and last iterators in the buffer, i.e. the
    /// entire buffer lies within the range [`start`,`end`).
    @inlinable func getBounds<TextIterT: TextIterProtocol>(start: TextIterT, end: TextIterT) {
        
        gtk_text_buffer_get_bounds(text_buffer_ptr, start.text_iter_ptr, end.text_iter_ptr)
        
    }

    /// Gets whether there is a redoable action in the history.
    @inlinable func getCanRedo() -> Bool {
        let result = gtk_text_buffer_get_can_redo(text_buffer_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets whether there is an undoable action in the history.
    @inlinable func getCanUndo() -> Bool {
        let result = gtk_text_buffer_get_can_undo(text_buffer_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the number of characters in the buffer.
    /// 
    /// Note that characters and bytes are not the same, you can’t e.g.
    /// expect the contents of the buffer in string form to be this
    /// many bytes long.
    /// 
    /// The character count is cached, so this function is very fast.
    @inlinable func getCharCount() -> Int {
        let result = gtk_text_buffer_get_char_count(text_buffer_ptr)
        let rv = Int(result)
        return rv
    }

    /// Gets whether the buffer is saving modifications to the buffer
    /// to allow for undo and redo actions.
    /// 
    /// See [method`Gtk.TextBuffer.begin_irreversible_action`] and
    /// [method`Gtk.TextBuffer.end_irreversible_action`] to create
    /// changes to the buffer that cannot be undone.
    @inlinable func getEnableUndo() -> Bool {
        let result = gtk_text_buffer_get_enable_undo(text_buffer_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Initializes `iter` with the “end iterator,” one past the last valid
    /// character in the text buffer.
    /// 
    /// If dereferenced with [method`Gtk.TextIter.get_char`], the end
    /// iterator has a character value of 0.
    /// The entire buffer lies in the range from the first position in
    /// the buffer (call [method`Gtk.TextBuffer.get_start_iter`] to get
    /// character position 0) to the end iterator.
    @inlinable func getEnd<TextIterT: TextIterProtocol>(iter: TextIterT) {
        
        gtk_text_buffer_get_end_iter(text_buffer_ptr, iter.text_iter_ptr)
        
    }

    /// Indicates whether the buffer has some text currently selected.
    @inlinable func getHasSelection() -> Bool {
        let result = gtk_text_buffer_get_has_selection(text_buffer_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns the mark that represents the cursor (insertion point).
    /// 
    /// Equivalent to calling [method`Gtk.TextBuffer.get_mark`]
    /// to get the mark named “insert”, but very slightly more
    /// efficient, and involves less typing.
    @inlinable func getInsert() -> TextMarkRef! {
        let result = gtk_text_buffer_get_insert(text_buffer_ptr)
        let rv = TextMarkRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Obtains the location of `anchor` within `buffer`.
    @inlinable func getIterAtChildAnchor<TextChildAnchorT: TextChildAnchorProtocol, TextIterT: TextIterProtocol>(iter: TextIterT, anchor: TextChildAnchorT) {
        
        gtk_text_buffer_get_iter_at_child_anchor(text_buffer_ptr, iter.text_iter_ptr, anchor.text_child_anchor_ptr)
        
    }

    /// Initializes `iter` to the start of the given line.
    /// 
    /// If `line_number` is greater than or equal to the number of lines
    /// in the `buffer`, the end iterator is returned.
    @inlinable func getIterAtLine<TextIterT: TextIterProtocol>(iter: TextIterT, lineNumber: Int) -> Bool {
        let result = gtk_text_buffer_get_iter_at_line(text_buffer_ptr, iter.text_iter_ptr, gint(lineNumber))
        let rv = ((result) != 0)
        return rv
    }

    /// Obtains an iterator pointing to `byte_index` within the given line.
    /// 
    /// `byte_index` must be the start of a UTF-8 character. Note bytes, not
    /// characters; UTF-8 may encode one character as multiple bytes.
    /// 
    /// If `line_number` is greater than or equal to the number of lines in the `buffer`,
    /// the end iterator is returned. And if `byte_index` is off the
    /// end of the line, the iterator at the end of the line is returned.
    @inlinable func getIterAtLineIndex<TextIterT: TextIterProtocol>(iter: TextIterT, lineNumber: Int, byteIndex: Int) -> Bool {
        let result = gtk_text_buffer_get_iter_at_line_index(text_buffer_ptr, iter.text_iter_ptr, gint(lineNumber), gint(byteIndex))
        let rv = ((result) != 0)
        return rv
    }

    /// Obtains an iterator pointing to `char_offset` within the given line.
    /// 
    /// Note characters, not bytes; UTF-8 may encode one character as multiple
    /// bytes.
    /// 
    /// If `line_number` is greater than or equal to the number of lines in the `buffer`,
    /// the end iterator is returned. And if `char_offset` is off the
    /// end of the line, the iterator at the end of the line is returned.
    @inlinable func getIterAtLineOffset<TextIterT: TextIterProtocol>(iter: TextIterT, lineNumber: Int, charOffset: Int) -> Bool {
        let result = gtk_text_buffer_get_iter_at_line_offset(text_buffer_ptr, iter.text_iter_ptr, gint(lineNumber), gint(charOffset))
        let rv = ((result) != 0)
        return rv
    }

    /// Initializes `iter` with the current position of `mark`.
    @inlinable func getIterAtMark<TextIterT: TextIterProtocol, TextMarkT: TextMarkProtocol>(iter: TextIterT, mark: TextMarkT) {
        
        gtk_text_buffer_get_iter_at_mark(text_buffer_ptr, iter.text_iter_ptr, mark.text_mark_ptr)
        
    }

    /// Initializes `iter` to a position `char_offset` chars from the start
    /// of the entire buffer.
    /// 
    /// If `char_offset` is -1 or greater than the number
    /// of characters in the buffer, `iter` is initialized to the end iterator,
    /// the iterator one past the last valid character in the buffer.
    @inlinable func getIterAtOffset<TextIterT: TextIterProtocol>(iter: TextIterT, charOffset: Int) {
        
        gtk_text_buffer_get_iter_at_offset(text_buffer_ptr, iter.text_iter_ptr, gint(charOffset))
        
    }

    /// Obtains the number of lines in the buffer.
    /// 
    /// This value is cached, so the function is very fast.
    @inlinable func getLineCount() -> Int {
        let result = gtk_text_buffer_get_line_count(text_buffer_ptr)
        let rv = Int(result)
        return rv
    }

    /// Returns the mark named `name` in buffer `buffer`, or `nil` if no such
    /// mark exists in the buffer.
    @inlinable func getMark(name: UnsafePointer<CChar>!) -> TextMarkRef! {
        let result = gtk_text_buffer_get_mark(text_buffer_ptr, name)
        let rv = TextMarkRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the maximum number of undo levels to perform.
    /// 
    /// If 0, unlimited undo actions may be performed. Note that this may
    /// have a memory usage impact as it requires storing an additional
    /// copy of the inserted or removed text within the text buffer.
    @inlinable func getMaxUndoLevels() -> Int {
        let result = gtk_text_buffer_get_max_undo_levels(text_buffer_ptr)
        let rv = Int(result)
        return rv
    }

    /// Indicates whether the buffer has been modified since the last call
    /// to [method`Gtk.TextBuffer.set_modified`] set the modification flag to
    /// `false`.
    /// 
    /// Used for example to enable a “save” function in a text editor.
    @inlinable func getModified() -> Bool {
        let result = gtk_text_buffer_get_modified(text_buffer_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns the mark that represents the selection bound.
    /// 
    /// Equivalent to calling [method`Gtk.TextBuffer.get_mark`]
    /// to get the mark named “selection_bound”, but very slightly
    /// more efficient, and involves less typing.
    /// 
    /// The currently-selected text in `buffer` is the region between the
    /// “selection_bound” and “insert” marks. If “selection_bound” and
    /// “insert” are in the same place, then there is no current selection.
    /// [method`Gtk.TextBuffer.get_selection_bounds`] is another convenient
    /// function for handling the selection, if you just want to know whether
    /// there’s a selection and what its bounds are.
    @inlinable func getSelectionBound() -> TextMarkRef! {
        let result = gtk_text_buffer_get_selection_bound(text_buffer_ptr)
        let rv = TextMarkRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns `true` if some text is selected; places the bounds
    /// of the selection in `start` and `end`.
    /// 
    /// If the selection has length 0, then `start` and `end` are filled
    /// in with the same value. `start` and `end` will be in ascending order.
    /// If `start` and `end` are `nil`, then they are not filled in, but the
    /// return value still indicates whether text is selected.
    @inlinable func getSelectionBounds<TextIterT: TextIterProtocol>(start: TextIterT, end: TextIterT) -> Bool {
        let result = gtk_text_buffer_get_selection_bounds(text_buffer_ptr, start.text_iter_ptr, end.text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Get a content provider for this buffer.
    /// 
    /// It can be used to make the content of `buffer` available
    /// in a `GdkClipboard`, see [method`Gdk.Clipboard.set_content`].
    @inlinable func getSelectionContent() -> Gdk.ContentProviderRef! {
        let result = gtk_text_buffer_get_selection_content(text_buffer_ptr)
        let rv = Gdk.ContentProviderRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns the text in the range [`start`,`end`).
    /// 
    /// Excludes undisplayed text (text marked with tags that set the
    /// invisibility attribute) if `include_hidden_chars` is `false`.
    /// The returned string includes a 0xFFFC character whenever the
    /// buffer contains embedded images, so byte and character indexes
    /// into the returned string do correspond to byte and character
    /// indexes into the buffer. Contrast with [method`Gtk.TextBuffer.get_text`].
    /// Note that 0xFFFC can occur in normal text as well, so it is not a
    /// reliable indicator that a paintable or widget is in the buffer.
    @inlinable func getSlice<TextIterT: TextIterProtocol>(start: TextIterT, end: TextIterT, includeHiddenChars: Bool) -> String! {
        let result = gtk_text_buffer_get_slice(text_buffer_ptr, start.text_iter_ptr, end.text_iter_ptr, gboolean((includeHiddenChars) ? 1 : 0))
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Initialized `iter` with the first position in the text buffer.
    /// 
    /// This is the same as using [method`Gtk.TextBuffer.get_iter_at_offset`]
    /// to get the iter at character offset 0.
    @inlinable func getStart<TextIterT: TextIterProtocol>(iter: TextIterT) {
        
        gtk_text_buffer_get_start_iter(text_buffer_ptr, iter.text_iter_ptr)
        
    }

    /// Get the `GtkTextTagTable` associated with this buffer.
    @inlinable func getTagTable() -> TextTagTableRef! {
        let result = gtk_text_buffer_get_tag_table(text_buffer_ptr)
        let rv = TextTagTableRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns the text in the range [`start`,`end`).
    /// 
    /// Excludes undisplayed text (text marked with tags that set the
    /// invisibility attribute) if `include_hidden_chars` is `false`.
    /// Does not include characters representing embedded images, so
    /// byte and character indexes into the returned string do not
    /// correspond to byte and character indexes into the buffer.
    /// Contrast with [method`Gtk.TextBuffer.get_slice`].
    @inlinable func getText<TextIterT: TextIterProtocol>(start: TextIterT, end: TextIterT, includeHiddenChars: Bool) -> String! {
        let result = gtk_text_buffer_get_text(text_buffer_ptr, start.text_iter_ptr, end.text_iter_ptr, gboolean((includeHiddenChars) ? 1 : 0))
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Inserts `len` bytes of `text` at position `iter`.
    /// 
    /// If `len` is -1, `text` must be nul-terminated and will be inserted in its
    /// entirety. Emits the “insert-text” signal; insertion actually occurs
    /// in the default handler for the signal. `iter` is invalidated when
    /// insertion occurs (because the buffer contents change), but the
    /// default signal handler revalidates it to point to the end of the
    /// inserted text.
    @inlinable func getInsert<TextIterT: TextIterProtocol>(iter: TextIterT, text: UnsafePointer<CChar>!, len: Int) {
        
        gtk_text_buffer_insert(text_buffer_ptr, iter.text_iter_ptr, text, gint(len))
        
    }

    /// Inserts `text` in `buffer`.
    /// 
    /// Simply calls [method`Gtk.TextBuffer.insert`],
    /// using the current cursor position as the insertion point.
    @inlinable func insertAtCursor(text: UnsafePointer<CChar>!, len: Int) {
        
        gtk_text_buffer_insert_at_cursor(text_buffer_ptr, text, gint(len))
        
    }

    /// Inserts a child widget anchor into the text buffer at `iter`.
    /// 
    /// The anchor will be counted as one character in character counts, and
    /// when obtaining the buffer contents as a string, will be represented
    /// by the Unicode “object replacement character” 0xFFFC. Note that the
    /// “slice” variants for obtaining portions of the buffer as a string
    /// include this character for child anchors, but the “text” variants do
    /// not. E.g. see [method`Gtk.TextBuffer.get_slice`] and
    /// [method`Gtk.TextBuffer.get_text`].
    /// 
    /// Consider [method`Gtk.TextBuffer.create_child_anchor`] as a more
    /// convenient alternative to this function. The buffer will add a
    /// reference to the anchor, so you can unref it after insertion.
    @inlinable func insertChildAnchor<TextChildAnchorT: TextChildAnchorProtocol, TextIterT: TextIterProtocol>(iter: TextIterT, anchor: TextChildAnchorT) {
        
        gtk_text_buffer_insert_child_anchor(text_buffer_ptr, iter.text_iter_ptr, anchor.text_child_anchor_ptr)
        
    }

    /// Inserts `text` in `buffer`.
    /// 
    /// Like [method`Gtk.TextBuffer.insert`], but the insertion will not occur
    /// if `iter` is at a non-editable location in the buffer. Usually you
    /// want to prevent insertions at ineditable locations if the insertion
    /// results from a user action (is interactive).
    /// 
    /// `default_editable` indicates the editability of text that doesn't
    /// have a tag affecting editability applied to it. Typically the
    /// result of [method`Gtk.TextView.get_editable`] is appropriate here.
    @inlinable func insertInteractive<TextIterT: TextIterProtocol>(iter: TextIterT, text: UnsafePointer<CChar>!, len: Int, defaultEditable: Bool) -> Bool {
        let result = gtk_text_buffer_insert_interactive(text_buffer_ptr, iter.text_iter_ptr, text, gint(len), gboolean((defaultEditable) ? 1 : 0))
        let rv = ((result) != 0)
        return rv
    }

    /// Inserts `text` in `buffer`.
    /// 
    /// Calls [method`Gtk.TextBuffer.insert_interactive`]
    /// at the cursor position.
    /// 
    /// `default_editable` indicates the editability of text that doesn't
    /// have a tag affecting editability applied to it. Typically the
    /// result of [method`Gtk.TextView.get_editable`] is appropriate here.
    @inlinable func insertInteractiveAtCursor(text: UnsafePointer<CChar>!, len: Int, defaultEditable: Bool) -> Bool {
        let result = gtk_text_buffer_insert_interactive_at_cursor(text_buffer_ptr, text, gint(len), gboolean((defaultEditable) ? 1 : 0))
        let rv = ((result) != 0)
        return rv
    }

    /// Inserts the text in `markup` at position `iter`.
    /// 
    /// `markup` will be inserted in its entirety and must be nul-terminated
    /// and valid UTF-8. Emits the [signal`Gtk.TextBuffer::insert-text`] signal,
    /// possibly multiple times; insertion actually occurs in the default handler
    /// for the signal. `iter` will point to the end of the inserted text on return.
    @inlinable func insertMarkup<TextIterT: TextIterProtocol>(iter: TextIterT, markup: UnsafePointer<CChar>!, len: Int) {
        
        gtk_text_buffer_insert_markup(text_buffer_ptr, iter.text_iter_ptr, markup, gint(len))
        
    }

    /// Inserts an image into the text buffer at `iter`.
    /// 
    /// The image will be counted as one character in character counts,
    /// and when obtaining the buffer contents as a string, will be
    /// represented by the Unicode “object replacement character” 0xFFFC.
    /// Note that the “slice” variants for obtaining portions of the buffer
    /// as a string include this character for paintable, but the “text”
    /// variants do not. e.g. see [method`Gtk.TextBuffer.get_slice`] and
    /// [method`Gtk.TextBuffer.get_text`].
    @inlinable func insertPaintable<GdkPaintableT: Gdk.PaintableProtocol, TextIterT: TextIterProtocol>(iter: TextIterT, paintable: GdkPaintableT) {
        
        gtk_text_buffer_insert_paintable(text_buffer_ptr, iter.text_iter_ptr, paintable.paintable_ptr)
        
    }

    /// Copies text, tags, and paintables between `start` and `end`
    /// and inserts the copy at `iter`.
    /// 
    /// The order of `start` and `end` doesn’t matter.
    /// 
    /// Used instead of simply getting/inserting text because it preserves
    /// images and tags. If `start` and `end` are in a different buffer from
    /// `buffer`, the two buffers must share the same tag table.
    /// 
    /// Implemented via emissions of the `insert-text` and `apply-tag` signals,
    /// so expect those.
    @inlinable func insertRange<TextIterT: TextIterProtocol>(iter: TextIterT, start: TextIterT, end: TextIterT) {
        
        gtk_text_buffer_insert_range(text_buffer_ptr, iter.text_iter_ptr, start.text_iter_ptr, end.text_iter_ptr)
        
    }

    /// Copies text, tags, and paintables between `start` and `end`
    /// and inserts the copy at `iter`.
    /// 
    /// Same as [method`Gtk.TextBuffer.insert_range`], but does nothing
    /// if the insertion point isn’t editable. The `default_editable`
    /// parameter indicates whether the text is editable at `iter` if
    /// no tags enclosing `iter` affect editability. Typically the result
    /// of [method`Gtk.TextView.get_editable`] is appropriate here.
    @inlinable func insertRangeInteractive<TextIterT: TextIterProtocol>(iter: TextIterT, start: TextIterT, end: TextIterT, defaultEditable: Bool) -> Bool {
        let result = gtk_text_buffer_insert_range_interactive(text_buffer_ptr, iter.text_iter_ptr, start.text_iter_ptr, end.text_iter_ptr, gboolean((defaultEditable) ? 1 : 0))
        let rv = ((result) != 0)
        return rv
    }


    // *** insertWithTags() is not available because it has a varargs (...) parameter!



    // *** insertWithTagsByName() is not available because it has a varargs (...) parameter!


    /// Moves `mark` to the new location `where`.
    /// 
    /// Emits the [signal`Gtk.TextBuffer::mark-set`] signal
    /// as notification of the move.
    @inlinable func move<TextIterT: TextIterProtocol, TextMarkT: TextMarkProtocol>(mark: TextMarkT, `where`: TextIterT) {
        
        gtk_text_buffer_move_mark(text_buffer_ptr, mark.text_mark_ptr, `where`.text_iter_ptr)
        
    }

    /// Moves the mark named `name` (which must exist) to location `where`.
    /// 
    /// See [method`Gtk.TextBuffer.move_mark`] for details.
    @inlinable func moveMarkBy<TextIterT: TextIterProtocol>(name: UnsafePointer<CChar>!, `where`: TextIterT) {
        
        gtk_text_buffer_move_mark_by_name(text_buffer_ptr, name, `where`.text_iter_ptr)
        
    }

    /// Pastes the contents of a clipboard.
    /// 
    /// If `override_location` is `nil`, the pasted text will be inserted
    /// at the cursor position, or the buffer selection will be replaced
    /// if the selection is non-empty.
    /// 
    /// Note: pasting is asynchronous, that is, we’ll ask for the paste data
    /// and return, and at some point later after the main loop runs, the paste
    /// data will be inserted.
    @inlinable func paste<GdkClipboardT: Gdk.ClipboardProtocol>(clipboard: GdkClipboardT, overrideLocation: TextIterRef? = nil, defaultEditable: Bool) {
            
        gtk_text_buffer_paste_clipboard(text_buffer_ptr, clipboard.clipboard_ptr, overrideLocation?.text_iter_ptr, gboolean((defaultEditable) ? 1 : 0))
            
    }
    /// Pastes the contents of a clipboard.
    /// 
    /// If `override_location` is `nil`, the pasted text will be inserted
    /// at the cursor position, or the buffer selection will be replaced
    /// if the selection is non-empty.
    /// 
    /// Note: pasting is asynchronous, that is, we’ll ask for the paste data
    /// and return, and at some point later after the main loop runs, the paste
    /// data will be inserted.
    @inlinable func paste<GdkClipboardT: Gdk.ClipboardProtocol, TextIterT: TextIterProtocol>(clipboard: GdkClipboardT, overrideLocation: TextIterT?, defaultEditable: Bool) {
        
        gtk_text_buffer_paste_clipboard(text_buffer_ptr, clipboard.clipboard_ptr, overrideLocation?.text_iter_ptr, gboolean((defaultEditable) ? 1 : 0))
        
    }

    /// This function moves the “insert” and “selection_bound” marks
    /// simultaneously.
    /// 
    /// If you move them to the same place in two steps with
    /// [method`Gtk.TextBuffer.move_mark`], you will temporarily select a
    /// region in between their old and new locations, which can be pretty
    /// inefficient since the temporarily-selected region will force stuff
    /// to be recalculated. This function moves them as a unit, which can
    /// be optimized.
    @inlinable func placeCursor<TextIterT: TextIterProtocol>(`where`: TextIterT) {
        
        gtk_text_buffer_place_cursor(text_buffer_ptr, `where`.text_iter_ptr)
        
    }

    /// Redoes the next redoable action on the buffer, if there is one.
    @inlinable func redo() {
        
        gtk_text_buffer_redo(text_buffer_ptr)
        
    }

    /// Removes all tags in the range between `start` and `end`.
    /// 
    /// Be careful with this function; it could remove tags added in code
    /// unrelated to the code you’re currently writing. That is, using this
    /// function is probably a bad idea if you have two or more unrelated
    /// code sections that add tags.
    @inlinable func removeAllTags<TextIterT: TextIterProtocol>(start: TextIterT, end: TextIterT) {
        
        gtk_text_buffer_remove_all_tags(text_buffer_ptr, start.text_iter_ptr, end.text_iter_ptr)
        
    }

    /// Removes a `GdkClipboard` added with
    /// `gtk_text_buffer_add_selection_clipboard()`.
    @inlinable func removeSelection<GdkClipboardT: Gdk.ClipboardProtocol>(clipboard: GdkClipboardT) {
        
        gtk_text_buffer_remove_selection_clipboard(text_buffer_ptr, clipboard.clipboard_ptr)
        
    }

    /// Emits the “remove-tag” signal.
    /// 
    /// The default handler for the signal removes all occurrences
    /// of `tag` from the given range. `start` and `end` don’t have
    /// to be in order.
    @inlinable func remove<TextIterT: TextIterProtocol, TextTagT: TextTagProtocol>(tag: TextTagT, start: TextIterT, end: TextIterT) {
        
        gtk_text_buffer_remove_tag(text_buffer_ptr, tag.text_tag_ptr, start.text_iter_ptr, end.text_iter_ptr)
        
    }

    /// Emits the “remove-tag” signal.
    /// 
    /// Calls [method`Gtk.TextTagTable.lookup`] on the buffer’s
    /// tag table to get a `GtkTextTag`, then calls
    /// [method`Gtk.TextBuffer.remove_tag`].
    @inlinable func removeTagBy<TextIterT: TextIterProtocol>(name: UnsafePointer<CChar>!, start: TextIterT, end: TextIterT) {
        
        gtk_text_buffer_remove_tag_by_name(text_buffer_ptr, name, start.text_iter_ptr, end.text_iter_ptr)
        
    }

    /// This function moves the “insert” and “selection_bound” marks
    /// simultaneously.
    /// 
    /// If you move them in two steps with
    /// [method`Gtk.TextBuffer.move_mark`], you will temporarily select a
    /// region in between their old and new locations, which can be pretty
    /// inefficient since the temporarily-selected region will force stuff
    /// to be recalculated. This function moves them as a unit, which can
    /// be optimized.
    @inlinable func selectRange<TextIterT: TextIterProtocol>(ins: TextIterT, bound: TextIterT) {
        
        gtk_text_buffer_select_range(text_buffer_ptr, ins.text_iter_ptr, bound.text_iter_ptr)
        
    }

    /// Sets whether or not to enable undoable actions in the text buffer.
    /// 
    /// Undoable actions in this context are changes to the text content of
    /// the buffer. Changes to tags and marks are not tracked.
    /// 
    /// If enabled, the user will be able to undo the last number of actions
    /// up to [method`Gtk.TextBuffer.get_max_undo_levels`].
    /// 
    /// See [method`Gtk.TextBuffer.begin_irreversible_action`] and
    /// [method`Gtk.TextBuffer.end_irreversible_action`] to create
    /// changes to the buffer that cannot be undone.
    @inlinable func set(enableUndo: Bool) {
        
        gtk_text_buffer_set_enable_undo(text_buffer_ptr, gboolean((enableUndo) ? 1 : 0))
        
    }

    /// Sets the maximum number of undo levels to perform.
    /// 
    /// If 0, unlimited undo actions may be performed. Note that this may
    /// have a memory usage impact as it requires storing an additional
    /// copy of the inserted or removed text within the text buffer.
    @inlinable func set(maxUndoLevels: Int) {
        
        gtk_text_buffer_set_max_undo_levels(text_buffer_ptr, guint(maxUndoLevels))
        
    }

    /// Used to keep track of whether the buffer has been
    /// modified since the last time it was saved.
    /// 
    /// Whenever the buffer is saved to disk, call
    /// `gtk_text_buffer_set_modified (`buffer`, FALSE)`.
    /// When the buffer is modified, it will automatically
    /// toggled on the modified bit again. When the modified
    /// bit flips, the buffer emits the
    /// [signal`Gtk.TextBuffer::modified-changed`] signal.
    @inlinable func setModified(setting: Bool) {
        
        gtk_text_buffer_set_modified(text_buffer_ptr, gboolean((setting) ? 1 : 0))
        
    }

    /// Deletes current contents of `buffer`, and inserts `text` instead. This is
    /// automatically marked as an irreversible action in the undo stack. If you
    /// wish to mark this action as part of a larger undo operation, call
    /// [method`TextBuffer.delete`] and [method`TextBuffer.insert`] directly instead.
    /// 
    /// If `len` is -1, `text` must be nul-terminated.
    /// `text` must be valid UTF-8.
    @inlinable func set(text: UnsafePointer<CChar>!, len: Int) {
        
        gtk_text_buffer_set_text(text_buffer_ptr, text, gint(len))
        
    }

    /// Undoes the last undoable action on the buffer, if there is one.
    @inlinable func undo() {
        
        gtk_text_buffer_undo(text_buffer_ptr)
        
    }
    /// Gets whether there is a redoable action in the history.
    @inlinable var canRedo: Bool {
        /// Gets whether there is a redoable action in the history.
        get {
            let result = gtk_text_buffer_get_can_redo(text_buffer_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// Gets whether there is an undoable action in the history.
    @inlinable var canUndo: Bool {
        /// Gets whether there is an undoable action in the history.
        get {
            let result = gtk_text_buffer_get_can_undo(text_buffer_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// Gets the number of characters in the buffer.
    /// 
    /// Note that characters and bytes are not the same, you can’t e.g.
    /// expect the contents of the buffer in string form to be this
    /// many bytes long.
    /// 
    /// The character count is cached, so this function is very fast.
    @inlinable var charCount: Int {
        /// Gets the number of characters in the buffer.
        /// 
        /// Note that characters and bytes are not the same, you can’t e.g.
        /// expect the contents of the buffer in string form to be this
        /// many bytes long.
        /// 
        /// The character count is cached, so this function is very fast.
        get {
            let result = gtk_text_buffer_get_char_count(text_buffer_ptr)
        let rv = Int(result)
            return rv
        }
    }

    /// Gets whether the buffer is saving modifications to the buffer
    /// to allow for undo and redo actions.
    /// 
    /// See [method`Gtk.TextBuffer.begin_irreversible_action`] and
    /// [method`Gtk.TextBuffer.end_irreversible_action`] to create
    /// changes to the buffer that cannot be undone.
    @inlinable var enableUndo: Bool {
        /// Gets whether the buffer is saving modifications to the buffer
        /// to allow for undo and redo actions.
        /// 
        /// See [method`Gtk.TextBuffer.begin_irreversible_action`] and
        /// [method`Gtk.TextBuffer.end_irreversible_action`] to create
        /// changes to the buffer that cannot be undone.
        get {
            let result = gtk_text_buffer_get_enable_undo(text_buffer_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether or not to enable undoable actions in the text buffer.
        /// 
        /// Undoable actions in this context are changes to the text content of
        /// the buffer. Changes to tags and marks are not tracked.
        /// 
        /// If enabled, the user will be able to undo the last number of actions
        /// up to [method`Gtk.TextBuffer.get_max_undo_levels`].
        /// 
        /// See [method`Gtk.TextBuffer.begin_irreversible_action`] and
        /// [method`Gtk.TextBuffer.end_irreversible_action`] to create
        /// changes to the buffer that cannot be undone.
        nonmutating set {
            gtk_text_buffer_set_enable_undo(text_buffer_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Indicates whether the buffer has some text currently selected.
    @inlinable var hasSelection: Bool {
        /// Indicates whether the buffer has some text currently selected.
        get {
            let result = gtk_text_buffer_get_has_selection(text_buffer_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// Returns the mark that represents the cursor (insertion point).
    /// 
    /// Equivalent to calling [method`Gtk.TextBuffer.get_mark`]
    /// to get the mark named “insert”, but very slightly more
    /// efficient, and involves less typing.
    @inlinable var insert: TextMarkRef! {
        /// Returns the mark that represents the cursor (insertion point).
        /// 
        /// Equivalent to calling [method`Gtk.TextBuffer.get_mark`]
        /// to get the mark named “insert”, but very slightly more
        /// efficient, and involves less typing.
        get {
            let result = gtk_text_buffer_get_insert(text_buffer_ptr)
        let rv = TextMarkRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Obtains the number of lines in the buffer.
    /// 
    /// This value is cached, so the function is very fast.
    @inlinable var lineCount: Int {
        /// Obtains the number of lines in the buffer.
        /// 
        /// This value is cached, so the function is very fast.
        get {
            let result = gtk_text_buffer_get_line_count(text_buffer_ptr)
        let rv = Int(result)
            return rv
        }
    }

    /// Gets the maximum number of undo levels to perform.
    /// 
    /// If 0, unlimited undo actions may be performed. Note that this may
    /// have a memory usage impact as it requires storing an additional
    /// copy of the inserted or removed text within the text buffer.
    @inlinable var maxUndoLevels: Int {
        /// Gets the maximum number of undo levels to perform.
        /// 
        /// If 0, unlimited undo actions may be performed. Note that this may
        /// have a memory usage impact as it requires storing an additional
        /// copy of the inserted or removed text within the text buffer.
        get {
            let result = gtk_text_buffer_get_max_undo_levels(text_buffer_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the maximum number of undo levels to perform.
        /// 
        /// If 0, unlimited undo actions may be performed. Note that this may
        /// have a memory usage impact as it requires storing an additional
        /// copy of the inserted or removed text within the text buffer.
        nonmutating set {
            gtk_text_buffer_set_max_undo_levels(text_buffer_ptr, guint(newValue))
        }
    }

    /// Indicates whether the buffer has been modified since the last call
    /// to [method`Gtk.TextBuffer.set_modified`] set the modification flag to
    /// `false`.
    /// 
    /// Used for example to enable a “save” function in a text editor.
    @inlinable var modified: Bool {
        /// Indicates whether the buffer has been modified since the last call
        /// to [method`Gtk.TextBuffer.set_modified`] set the modification flag to
        /// `false`.
        /// 
        /// Used for example to enable a “save” function in a text editor.
        get {
            let result = gtk_text_buffer_get_modified(text_buffer_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Used to keep track of whether the buffer has been
        /// modified since the last time it was saved.
        /// 
        /// Whenever the buffer is saved to disk, call
        /// `gtk_text_buffer_set_modified (`buffer`, FALSE)`.
        /// When the buffer is modified, it will automatically
        /// toggled on the modified bit again. When the modified
        /// bit flips, the buffer emits the
        /// [signal`Gtk.TextBuffer::modified-changed`] signal.
        nonmutating set {
            gtk_text_buffer_set_modified(text_buffer_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns the mark that represents the selection bound.
    /// 
    /// Equivalent to calling [method`Gtk.TextBuffer.get_mark`]
    /// to get the mark named “selection_bound”, but very slightly
    /// more efficient, and involves less typing.
    /// 
    /// The currently-selected text in `buffer` is the region between the
    /// “selection_bound” and “insert” marks. If “selection_bound” and
    /// “insert” are in the same place, then there is no current selection.
    /// [method`Gtk.TextBuffer.get_selection_bounds`] is another convenient
    /// function for handling the selection, if you just want to know whether
    /// there’s a selection and what its bounds are.
    @inlinable var selectionBound: TextMarkRef! {
        /// Returns the mark that represents the selection bound.
        /// 
        /// Equivalent to calling [method`Gtk.TextBuffer.get_mark`]
        /// to get the mark named “selection_bound”, but very slightly
        /// more efficient, and involves less typing.
        /// 
        /// The currently-selected text in `buffer` is the region between the
        /// “selection_bound” and “insert” marks. If “selection_bound” and
        /// “insert” are in the same place, then there is no current selection.
        /// [method`Gtk.TextBuffer.get_selection_bounds`] is another convenient
        /// function for handling the selection, if you just want to know whether
        /// there’s a selection and what its bounds are.
        get {
            let result = gtk_text_buffer_get_selection_bound(text_buffer_ptr)
        let rv = TextMarkRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Get a content provider for this buffer.
    /// 
    /// It can be used to make the content of `buffer` available
    /// in a `GdkClipboard`, see [method`Gdk.Clipboard.set_content`].
    @inlinable var selectionContent: Gdk.ContentProviderRef! {
        /// Get a content provider for this buffer.
        /// 
        /// It can be used to make the content of `buffer` available
        /// in a `GdkClipboard`, see [method`Gdk.Clipboard.set_content`].
        get {
            let result = gtk_text_buffer_get_selection_content(text_buffer_ptr)
        let rv = Gdk.ContentProviderRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Get the `GtkTextTagTable` associated with this buffer.
    @inlinable var tagTable: TextTagTableRef! {
        /// Get the `GtkTextTagTable` associated with this buffer.
        get {
            let result = gtk_text_buffer_get_tag_table(text_buffer_ptr)
        let rv = TextTagTableRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    @inlinable var parentInstance: GObject {
        get {
            let rv = text_buffer_ptr.pointee.parent_instance
    return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - TextChildAnchor Class

/// A `GtkTextChildAnchor` is a spot in a `GtkTextBuffer` where child widgets can
/// be “anchored”.
/// 
/// The anchor can have multiple widgets anchored, to allow for multiple views.
///
/// The `TextChildAnchorProtocol` protocol exposes the methods and properties of an underlying `GtkTextChildAnchor` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextChildAnchor`.
/// Alternatively, use `TextChildAnchorRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextChildAnchorProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkTextChildAnchor` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTextChildAnchor` instance.
    var text_child_anchor_ptr: UnsafeMutablePointer<GtkTextChildAnchor>! { get }

    /// Required Initialiser for types conforming to `TextChildAnchorProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkTextChildAnchor` is a spot in a `GtkTextBuffer` where child widgets can
/// be “anchored”.
/// 
/// The anchor can have multiple widgets anchored, to allow for multiple views.
///
/// The `TextChildAnchorRef` type acts as a lightweight Swift reference to an underlying `GtkTextChildAnchor` instance.
/// It exposes methods that can operate on this data type through `TextChildAnchorProtocol` conformance.
/// Use `TextChildAnchorRef` only as an `unowned` reference to an existing `GtkTextChildAnchor` instance.
///
public struct TextChildAnchorRef: TextChildAnchorProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTextChildAnchor` instance.
    /// For type-safe access, use the generated, typed pointer `text_child_anchor_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextChildAnchorRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTextChildAnchor>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTextChildAnchor>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTextChildAnchor>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTextChildAnchor>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextChildAnchorProtocol`
    @inlinable init<T: TextChildAnchorProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TextChildAnchorProtocol>(_ other: T) -> TextChildAnchorRef { TextChildAnchorRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkTextChildAnchor`.
    /// 
    /// Usually you would then insert it into a `GtkTextBuffer` with
    /// [method`Gtk.TextBuffer.insert_child_anchor`]. To perform the
    /// creation and insertion in one step, use the convenience
    /// function [method`Gtk.TextBuffer.create_child_anchor`].
    @inlinable init() {
            let result = gtk_text_child_anchor_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkTextChildAnchor` with the given replacement character.
    /// 
    /// Usually you would then insert it into a `GtkTextBuffer` with
    /// [method`Gtk.TextBuffer.insert_child_anchor`].
    @inlinable init(replacement character: UnsafePointer<CChar>!) {
            let result = gtk_text_child_anchor_new_with_replacement(character)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkTextChildAnchor` with the given replacement character.
    /// 
    /// Usually you would then insert it into a `GtkTextBuffer` with
    /// [method`Gtk.TextBuffer.insert_child_anchor`].
    @inlinable static func newWith(replacement character: UnsafePointer<CChar>!) -> TextChildAnchorRef! {
            let result = gtk_text_child_anchor_new_with_replacement(character)
        guard let rv = TextChildAnchorRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }
}

/// A `GtkTextChildAnchor` is a spot in a `GtkTextBuffer` where child widgets can
/// be “anchored”.
/// 
/// The anchor can have multiple widgets anchored, to allow for multiple views.
///
/// The `TextChildAnchor` type acts as a reference-counted owner of an underlying `GtkTextChildAnchor` instance.
/// It provides the methods that can operate on this data type through `TextChildAnchorProtocol` conformance.
/// Use `TextChildAnchor` as a strong reference or owner of a `GtkTextChildAnchor` instance.
///
open class TextChildAnchor: GLibObject.Object, TextChildAnchorProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextChildAnchor` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTextChildAnchor>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextChildAnchor` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTextChildAnchor>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextChildAnchor` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextChildAnchor` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextChildAnchor` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTextChildAnchor>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextChildAnchor` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTextChildAnchor>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTextChildAnchor`.
    /// i.e., ownership is transferred to the `TextChildAnchor` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTextChildAnchor>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TextChildAnchorProtocol`
    /// Will retain `GtkTextChildAnchor`.
    /// - Parameter other: an instance of a related type that implements `TextChildAnchorProtocol`
    @inlinable public init<T: TextChildAnchorProtocol>(textChildAnchor other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkTextChildAnchor`.
    /// 
    /// Usually you would then insert it into a `GtkTextBuffer` with
    /// [method`Gtk.TextBuffer.insert_child_anchor`]. To perform the
    /// creation and insertion in one step, use the convenience
    /// function [method`Gtk.TextBuffer.create_child_anchor`].
    @inlinable public init() {
            let result = gtk_text_child_anchor_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkTextChildAnchor` with the given replacement character.
    /// 
    /// Usually you would then insert it into a `GtkTextBuffer` with
    /// [method`Gtk.TextBuffer.insert_child_anchor`].
    @inlinable public init(replacement character: UnsafePointer<CChar>!) {
            let result = gtk_text_child_anchor_new_with_replacement(character)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkTextChildAnchor` with the given replacement character.
    /// 
    /// Usually you would then insert it into a `GtkTextBuffer` with
    /// [method`Gtk.TextBuffer.insert_child_anchor`].
    @inlinable public static func newWith(replacement character: UnsafePointer<CChar>!) -> TextChildAnchor! {
            let result = gtk_text_child_anchor_new_with_replacement(character)
        guard let rv = TextChildAnchor(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

}

// MARK: no TextChildAnchor properties

public enum TextChildAnchorSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: TextChildAnchor has no signals
// MARK: TextChildAnchor Class: TextChildAnchorProtocol extension (methods and fields)
public extension TextChildAnchorProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextChildAnchor` instance.
    @inlinable var text_child_anchor_ptr: UnsafeMutablePointer<GtkTextChildAnchor>! { return ptr?.assumingMemoryBound(to: GtkTextChildAnchor.self) }

    /// Determines whether a child anchor has been deleted from
    /// the buffer.
    /// 
    /// Keep in mind that the child anchor will be unreferenced
    /// when removed from the buffer, so you need to hold your own
    /// reference (with `g_object_ref()`) if you plan to use this
    /// function — otherwise all deleted child anchors will also
    /// be finalized.
    @inlinable func getDeleted() -> Bool {
        let result = gtk_text_child_anchor_get_deleted(text_child_anchor_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets a list of all widgets anchored at this child anchor.
    /// 
    /// The order in which the widgets are returned is not defined.
    @inlinable func getWidgets(outLen: UnsafeMutablePointer<guint>!) -> UnsafeMutablePointer<UnsafeMutablePointer<GtkWidget>?>! {
        let result = gtk_text_child_anchor_get_widgets(text_child_anchor_ptr, outLen)
        let rv = result
        return rv
    }
    /// Determines whether a child anchor has been deleted from
    /// the buffer.
    /// 
    /// Keep in mind that the child anchor will be unreferenced
    /// when removed from the buffer, so you need to hold your own
    /// reference (with `g_object_ref()`) if you plan to use this
    /// function — otherwise all deleted child anchors will also
    /// be finalized.
    @inlinable var deleted: Bool {
        /// Determines whether a child anchor has been deleted from
        /// the buffer.
        /// 
        /// Keep in mind that the child anchor will be unreferenced
        /// when removed from the buffer, so you need to hold your own
        /// reference (with `g_object_ref()`) if you plan to use this
        /// function — otherwise all deleted child anchors will also
        /// be finalized.
        get {
            let result = gtk_text_child_anchor_get_deleted(text_child_anchor_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    @inlinable var parentInstance: GObject {
        get {
            let rv = text_child_anchor_ptr.pointee.parent_instance
    return rv
        }
    }

    // var segment is unavailable because segment is private

}



// MARK: - TextMark Class

/// A `GtkTextMark` is a position in a `GtkTextbuffer` that is preserved
/// across modifications.
/// 
/// You may wish to begin by reading the
/// [text widget conceptual overview](section-text-widget.html),
/// which gives an overview of all the objects and data types
/// related to the text widget and how they work together.
/// 
/// A `GtkTextMark` is like a bookmark in a text buffer; it preserves
/// a position in the text. You can convert the mark to an iterator using
/// [method`Gtk.TextBuffer.get_iter_at_mark`]. Unlike iterators, marks remain
/// valid across buffer mutations, because their behavior is defined when
/// text is inserted or deleted. When text containing a mark is deleted,
/// the mark remains in the position originally occupied by the deleted
/// text. When text is inserted at a mark, a mark with “left gravity” will
/// be moved to the beginning of the newly-inserted text, and a mark with
/// “right gravity” will be moved to the end.
/// 
/// Note that “left” and “right” here refer to logical direction (left
/// is the toward the start of the buffer); in some languages such as
/// Hebrew the logically-leftmost text is not actually on the left when
/// displayed.
/// 
/// Marks are reference counted, but the reference count only controls
/// the validity of the memory; marks can be deleted from the buffer at
/// any time with [method`Gtk.TextBuffer.delete_mark`]. Once deleted from
/// the buffer, a mark is essentially useless.
/// 
/// Marks optionally have names; these can be convenient to avoid passing
/// the `GtkTextMark` object around.
/// 
/// Marks are typically created using the [method`Gtk.TextBuffer.create_mark`]
/// function.
///
/// The `TextMarkProtocol` protocol exposes the methods and properties of an underlying `GtkTextMark` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextMark`.
/// Alternatively, use `TextMarkRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextMarkProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkTextMark` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTextMark` instance.
    var text_mark_ptr: UnsafeMutablePointer<GtkTextMark>! { get }

    /// Required Initialiser for types conforming to `TextMarkProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkTextMark` is a position in a `GtkTextbuffer` that is preserved
/// across modifications.
/// 
/// You may wish to begin by reading the
/// [text widget conceptual overview](section-text-widget.html),
/// which gives an overview of all the objects and data types
/// related to the text widget and how they work together.
/// 
/// A `GtkTextMark` is like a bookmark in a text buffer; it preserves
/// a position in the text. You can convert the mark to an iterator using
/// [method`Gtk.TextBuffer.get_iter_at_mark`]. Unlike iterators, marks remain
/// valid across buffer mutations, because their behavior is defined when
/// text is inserted or deleted. When text containing a mark is deleted,
/// the mark remains in the position originally occupied by the deleted
/// text. When text is inserted at a mark, a mark with “left gravity” will
/// be moved to the beginning of the newly-inserted text, and a mark with
/// “right gravity” will be moved to the end.
/// 
/// Note that “left” and “right” here refer to logical direction (left
/// is the toward the start of the buffer); in some languages such as
/// Hebrew the logically-leftmost text is not actually on the left when
/// displayed.
/// 
/// Marks are reference counted, but the reference count only controls
/// the validity of the memory; marks can be deleted from the buffer at
/// any time with [method`Gtk.TextBuffer.delete_mark`]. Once deleted from
/// the buffer, a mark is essentially useless.
/// 
/// Marks optionally have names; these can be convenient to avoid passing
/// the `GtkTextMark` object around.
/// 
/// Marks are typically created using the [method`Gtk.TextBuffer.create_mark`]
/// function.
///
/// The `TextMarkRef` type acts as a lightweight Swift reference to an underlying `GtkTextMark` instance.
/// It exposes methods that can operate on this data type through `TextMarkProtocol` conformance.
/// Use `TextMarkRef` only as an `unowned` reference to an existing `GtkTextMark` instance.
///
public struct TextMarkRef: TextMarkProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTextMark` instance.
    /// For type-safe access, use the generated, typed pointer `text_mark_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextMarkRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTextMark>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTextMark>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTextMark>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTextMark>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextMarkProtocol`
    @inlinable init<T: TextMarkProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TextMarkProtocol>(_ other: T) -> TextMarkRef { TextMarkRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a text mark.
    /// 
    /// Add it to a buffer using [method`Gtk.TextBuffer.add_mark`].
    /// If `name` is `nil`, the mark is anonymous; otherwise, the mark can be
    /// retrieved by name using [method`Gtk.TextBuffer.get_mark`]. If a mark
    /// has left gravity, and text is inserted at the mark’s current location,
    /// the mark will be moved to the left of the newly-inserted text. If the
    /// mark has right gravity (`left_gravity` = `false`), the mark will end up
    /// on the right of newly-inserted text. The standard left-to-right cursor
    /// is a mark with right gravity (when you type, the cursor stays on the
    /// right side of the text you’re typing).
    @inlinable init( name: UnsafePointer<CChar>? = nil, leftGravity: Bool) {
            let result = gtk_text_mark_new(name, gboolean((leftGravity) ? 1 : 0))
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// A `GtkTextMark` is a position in a `GtkTextbuffer` that is preserved
/// across modifications.
/// 
/// You may wish to begin by reading the
/// [text widget conceptual overview](section-text-widget.html),
/// which gives an overview of all the objects and data types
/// related to the text widget and how they work together.
/// 
/// A `GtkTextMark` is like a bookmark in a text buffer; it preserves
/// a position in the text. You can convert the mark to an iterator using
/// [method`Gtk.TextBuffer.get_iter_at_mark`]. Unlike iterators, marks remain
/// valid across buffer mutations, because their behavior is defined when
/// text is inserted or deleted. When text containing a mark is deleted,
/// the mark remains in the position originally occupied by the deleted
/// text. When text is inserted at a mark, a mark with “left gravity” will
/// be moved to the beginning of the newly-inserted text, and a mark with
/// “right gravity” will be moved to the end.
/// 
/// Note that “left” and “right” here refer to logical direction (left
/// is the toward the start of the buffer); in some languages such as
/// Hebrew the logically-leftmost text is not actually on the left when
/// displayed.
/// 
/// Marks are reference counted, but the reference count only controls
/// the validity of the memory; marks can be deleted from the buffer at
/// any time with [method`Gtk.TextBuffer.delete_mark`]. Once deleted from
/// the buffer, a mark is essentially useless.
/// 
/// Marks optionally have names; these can be convenient to avoid passing
/// the `GtkTextMark` object around.
/// 
/// Marks are typically created using the [method`Gtk.TextBuffer.create_mark`]
/// function.
///
/// The `TextMark` type acts as a reference-counted owner of an underlying `GtkTextMark` instance.
/// It provides the methods that can operate on this data type through `TextMarkProtocol` conformance.
/// Use `TextMark` as a strong reference or owner of a `GtkTextMark` instance.
///
open class TextMark: GLibObject.Object, TextMarkProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextMark` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTextMark>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextMark` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTextMark>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextMark` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextMark` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextMark` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTextMark>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextMark` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTextMark>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTextMark`.
    /// i.e., ownership is transferred to the `TextMark` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTextMark>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TextMarkProtocol`
    /// Will retain `GtkTextMark`.
    /// - Parameter other: an instance of a related type that implements `TextMarkProtocol`
    @inlinable public init<T: TextMarkProtocol>(textMark other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a text mark.
    /// 
    /// Add it to a buffer using [method`Gtk.TextBuffer.add_mark`].
    /// If `name` is `nil`, the mark is anonymous; otherwise, the mark can be
    /// retrieved by name using [method`Gtk.TextBuffer.get_mark`]. If a mark
    /// has left gravity, and text is inserted at the mark’s current location,
    /// the mark will be moved to the left of the newly-inserted text. If the
    /// mark has right gravity (`left_gravity` = `false`), the mark will end up
    /// on the right of newly-inserted text. The standard left-to-right cursor
    /// is a mark with right gravity (when you type, the cursor stays on the
    /// right side of the text you’re typing).
    @inlinable public init( name: UnsafePointer<CChar>? = nil, leftGravity: Bool) {
            let result = gtk_text_mark_new(name, gboolean((leftGravity) ? 1 : 0))
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum TextMarkPropertyName: String, PropertyNameProtocol {
    /// Whether the mark has left gravity.
    /// 
    /// When text is inserted at the mark’s current location, if the mark
    /// has left gravity it will be moved to the left of the newly-inserted
    /// text, otherwise to the right.
    case leftGravity = "left-gravity"
    /// The name of the mark or `nil` if the mark is anonymous.
    case name = "name"
}

public extension TextMarkProtocol {
    /// Bind a `TextMarkPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TextMarkPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TextMark property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TextMarkPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TextMark property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TextMarkPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TextMarkSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Whether the mark has left gravity.
    /// 
    /// When text is inserted at the mark’s current location, if the mark
    /// has left gravity it will be moved to the left of the newly-inserted
    /// text, otherwise to the right.
    case notifyLeftGravity = "notify::left-gravity"
    /// The name of the mark or `nil` if the mark is anonymous.
    case notifyName = "notify::name"
}

// MARK: TextMark has no signals
// MARK: TextMark Class: TextMarkProtocol extension (methods and fields)
public extension TextMarkProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextMark` instance.
    @inlinable var text_mark_ptr: UnsafeMutablePointer<GtkTextMark>! { return ptr?.assumingMemoryBound(to: GtkTextMark.self) }

    /// Gets the buffer this mark is located inside.
    /// 
    /// Returns `nil` if the mark is deleted.
    @inlinable func getBuffer() -> TextBufferRef! {
        let result = gtk_text_mark_get_buffer(text_mark_ptr)
        let rv = TextBufferRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns `true` if the mark has been removed from its buffer.
    /// 
    /// See [method`Gtk.TextBuffer.add_mark`] for a way to add it
    /// to a buffer again.
    @inlinable func getDeleted() -> Bool {
        let result = gtk_text_mark_get_deleted(text_mark_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Determines whether the mark has left gravity.
    @inlinable func getLeftGravity() -> Bool {
        let result = gtk_text_mark_get_left_gravity(text_mark_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns the mark name.
    /// 
    /// Returns `nil` for anonymous marks.
    @inlinable func getName() -> String! {
        let result = gtk_text_mark_get_name(text_mark_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Returns `true` if the mark is visible.
    /// 
    /// A cursor is displayed for visible marks.
    @inlinable func getVisible() -> Bool {
        let result = gtk_text_mark_get_visible(text_mark_ptr)
        let rv = ((result) != 0)
        return rv
    }

    @inlinable func setVisible(setting: Bool) {
        
        gtk_text_mark_set_visible(text_mark_ptr, gboolean((setting) ? 1 : 0))
        
    }
    /// Gets the buffer this mark is located inside.
    /// 
    /// Returns `nil` if the mark is deleted.
    @inlinable var buffer: TextBufferRef! {
        /// Gets the buffer this mark is located inside.
        /// 
        /// Returns `nil` if the mark is deleted.
        get {
            let result = gtk_text_mark_get_buffer(text_mark_ptr)
        let rv = TextBufferRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Returns `true` if the mark has been removed from its buffer.
    /// 
    /// See [method`Gtk.TextBuffer.add_mark`] for a way to add it
    /// to a buffer again.
    @inlinable var deleted: Bool {
        /// Returns `true` if the mark has been removed from its buffer.
        /// 
        /// See [method`Gtk.TextBuffer.add_mark`] for a way to add it
        /// to a buffer again.
        get {
            let result = gtk_text_mark_get_deleted(text_mark_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// Determines whether the mark has left gravity.
    @inlinable var leftGravity: Bool {
        /// Determines whether the mark has left gravity.
        get {
            let result = gtk_text_mark_get_left_gravity(text_mark_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// The name of the mark or `nil` if the mark is anonymous.
    @inlinable var name: String! {
        /// Returns the mark name.
        /// 
        /// Returns `nil` for anonymous marks.
        get {
            let result = gtk_text_mark_get_name(text_mark_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
    }

    /// Returns `true` if the mark is visible.
    /// 
    /// A cursor is displayed for visible marks.
    @inlinable var visible: Bool {
        /// Returns `true` if the mark is visible.
        /// 
        /// A cursor is displayed for visible marks.
        get {
            let result = gtk_text_mark_get_visible(text_mark_ptr)
        let rv = ((result) != 0)
            return rv
        }
        nonmutating set {
            gtk_text_mark_set_visible(text_mark_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var parentInstance: GObject {
        get {
            let rv = text_mark_ptr.pointee.parent_instance
    return rv
        }
    }

    // var segment is unavailable because segment is private

}



// MARK: - TextTag Class

/// A tag that can be applied to text contained in a `GtkTextBuffer`.
/// 
/// You may wish to begin by reading the
/// [text widget conceptual overview](section-text-widget.html),
/// which gives an overview of all the objects and data types
/// related to the text widget and how they work together.
/// 
/// Tags should be in the [class`Gtk.TextTagTable`] for a given
/// `GtkTextBuffer` before using them with that buffer.
/// 
/// [method`Gtk.TextBuffer.create_tag`] is the best way to create tags.
/// See “gtk4-demo” for numerous examples.
/// 
/// For each property of `GtkTextTag`, there is a “set” property, e.g.
/// “font-set” corresponds to “font”. These “set” properties reflect
/// whether a property has been set or not.
/// 
/// They are maintained by GTK and you should not set them independently.
///
/// The `TextTagProtocol` protocol exposes the methods and properties of an underlying `GtkTextTag` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextTag`.
/// Alternatively, use `TextTagRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextTagProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkTextTag` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTextTag` instance.
    var text_tag_ptr: UnsafeMutablePointer<GtkTextTag>! { get }

    /// Required Initialiser for types conforming to `TextTagProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A tag that can be applied to text contained in a `GtkTextBuffer`.
/// 
/// You may wish to begin by reading the
/// [text widget conceptual overview](section-text-widget.html),
/// which gives an overview of all the objects and data types
/// related to the text widget and how they work together.
/// 
/// Tags should be in the [class`Gtk.TextTagTable`] for a given
/// `GtkTextBuffer` before using them with that buffer.
/// 
/// [method`Gtk.TextBuffer.create_tag`] is the best way to create tags.
/// See “gtk4-demo” for numerous examples.
/// 
/// For each property of `GtkTextTag`, there is a “set” property, e.g.
/// “font-set” corresponds to “font”. These “set” properties reflect
/// whether a property has been set or not.
/// 
/// They are maintained by GTK and you should not set them independently.
///
/// The `TextTagRef` type acts as a lightweight Swift reference to an underlying `GtkTextTag` instance.
/// It exposes methods that can operate on this data type through `TextTagProtocol` conformance.
/// Use `TextTagRef` only as an `unowned` reference to an existing `GtkTextTag` instance.
///
public struct TextTagRef: TextTagProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTextTag` instance.
    /// For type-safe access, use the generated, typed pointer `text_tag_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextTagRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTextTag>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTextTag>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTextTag>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTextTag>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextTagProtocol`
    @inlinable init<T: TextTagProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TextTagProtocol>(_ other: T) -> TextTagRef { TextTagRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a `GtkTextTag`.
    @inlinable init( name: UnsafePointer<CChar>? = nil) {
            let result = gtk_text_tag_new(name)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// A tag that can be applied to text contained in a `GtkTextBuffer`.
/// 
/// You may wish to begin by reading the
/// [text widget conceptual overview](section-text-widget.html),
/// which gives an overview of all the objects and data types
/// related to the text widget and how they work together.
/// 
/// Tags should be in the [class`Gtk.TextTagTable`] for a given
/// `GtkTextBuffer` before using them with that buffer.
/// 
/// [method`Gtk.TextBuffer.create_tag`] is the best way to create tags.
/// See “gtk4-demo” for numerous examples.
/// 
/// For each property of `GtkTextTag`, there is a “set” property, e.g.
/// “font-set” corresponds to “font”. These “set” properties reflect
/// whether a property has been set or not.
/// 
/// They are maintained by GTK and you should not set them independently.
///
/// The `TextTag` type acts as a reference-counted owner of an underlying `GtkTextTag` instance.
/// It provides the methods that can operate on this data type through `TextTagProtocol` conformance.
/// Use `TextTag` as a strong reference or owner of a `GtkTextTag` instance.
///
open class TextTag: GLibObject.Object, TextTagProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTag` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTextTag>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTag` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTextTag>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTag` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTag` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTag` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTextTag>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTag` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTextTag>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTextTag`.
    /// i.e., ownership is transferred to the `TextTag` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTextTag>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TextTagProtocol`
    /// Will retain `GtkTextTag`.
    /// - Parameter other: an instance of a related type that implements `TextTagProtocol`
    @inlinable public init<T: TextTagProtocol>(textTag other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a `GtkTextTag`.
    @inlinable public init( name: UnsafePointer<CChar>? = nil) {
            let result = gtk_text_tag_new(name)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum TextTagPropertyName: String, PropertyNameProtocol {
    /// Whether the margins accumulate or override each other.
    /// 
    /// When set to `true` the margins of this tag are added to the margins
    /// of any other non-accumulative margins present. When set to `false`
    /// the margins override one another (the default).
    case accumulativeMargin = "accumulative-margin"
    /// Whether breaks are allowed.
    case allowBreaks = "allow-breaks"
    case allowBreaksSet = "allow-breaks-set"
    /// Background color as a string.
    case background = "background"
    /// Whether the background color fills the entire line height
    /// or only the height of the tagged characters.
    case backgroundFullHeight = "background-full-height"
    case backgroundFullHeightSet = "background-full-height-set"
    /// Background color as a `GdkRGBA`.
    case backgroundRgba = "background-rgba"
    case backgroundSet = "background-set"
    /// Text direction, e.g. right-to-left or left-to-right.
    case direction = "direction"
    /// Whether the text can be modified by the user.
    case editable = "editable"
    case editableSet = "editable-set"
    /// Whether font fallback is enabled.
    /// 
    /// When set to `true`, other fonts will be substituted
    /// where the current font is missing glyphs.
    case fallback = "fallback"
    case fallbackSet = "fallback-set"
    /// Name of the font family, e.g. Sans, Helvetica, Times, Monospace.
    case family = "family"
    case familySet = "family-set"
    /// Font description as string, e.g. \"Sans Italic 12\".
    /// 
    /// Note that the initial value of this property depends on
    /// the internals of `PangoFontDescription`.
    case font = "font"
    /// Font description as a `PangoFontDescription`.
    case fontDesc = "font-desc"
    /// OpenType font features, as a string.
    case fontFeatures = "font-features"
    case fontFeaturesSet = "font-features-set"
    /// Foreground color as a string.
    case foreground = "foreground"
    /// Foreground color as a `GdkRGBA`.
    case foregroundRgba = "foreground-rgba"
    case foregroundSet = "foreground-set"
    /// Amount to indent the paragraph, in pixels.
    case indent = "indent"
    case indentSet = "indent-set"
    /// Whether to insert hyphens at breaks.
    case insertHyphens = "insert-hyphens"
    case insertHyphensSet = "insert-hyphens-set"
    /// Whether this text is hidden.
    /// 
    /// Note that there may still be problems with the support for invisible
    /// text, in particular when navigating programmatically inside a buffer
    /// containing invisible segments.
    case invisible = "invisible"
    case invisibleSet = "invisible-set"
    /// Left, right, or center justification.
    case justification = "justification"
    case justificationSet = "justification-set"
    /// The language this text is in, as an ISO code.
    /// 
    /// Pango can use this as a hint when rendering the text.
    /// If not set, an appropriate default will be used.
    /// 
    /// Note that the initial value of this property depends
    /// on the current locale, see also [func`Gtk.get_default_language`].
    case language = "language"
    case languageSet = "language-set"
    /// Width of the left margin in pixels.
    case leftMargin = "left-margin"
    case leftMarginSet = "left-margin-set"
    /// Extra spacing between graphemes, in Pango units.
    case letterSpacing = "letter-spacing"
    case letterSpacingSet = "letter-spacing-set"
    /// Factor to scale line height by.
    case lineHeight = "line-height"
    case lineHeightSet = "line-height-set"
    /// The name used to refer to the tag.
    /// 
    /// `nil` for anonymous tags.
    case name = "name"
    /// Style of overline for this text.
    case overline = "overline"
    /// This property modifies the color of overlines.
    /// 
    /// If not set, overlines will use the foreground color.
    case overlineRgba = "overline-rgba"
    case overlineRgbaSet = "overline-rgba-set"
    case overlineSet = "overline-set"
    /// The paragraph background color as a string.
    case paragraphBackground = "paragraph-background"
    /// The paragraph background color as a `GdkRGBA`.
    case paragraphBackgroundRgba = "paragraph-background-rgba"
    case paragraphBackgroundSet = "paragraph-background-set"
    /// Pixels of blank space above paragraphs.
    case pixelsAboveLines = "pixels-above-lines"
    case pixelsAboveLinesSet = "pixels-above-lines-set"
    /// Pixels of blank space below paragraphs.
    case pixelsBelowLines = "pixels-below-lines"
    case pixelsBelowLinesSet = "pixels-below-lines-set"
    /// Pixels of blank space between wrapped lines in a paragraph.
    case pixelsInsideWrap = "pixels-inside-wrap"
    case pixelsInsideWrapSet = "pixels-inside-wrap-set"
    /// Width of the right margin, in pixels.
    case rightMargin = "right-margin"
    case rightMarginSet = "right-margin-set"
    /// Offset of text above the baseline, in Pango units.
    /// 
    /// Negative values go below the baseline.
    case rise = "rise"
    case riseSet = "rise-set"
    /// Font size as a scale factor relative to the default font size.
    /// 
    /// This properly adapts to theme changes, etc. so is recommended.
    /// Pango predefines some scales such as `PANGO_SCALE_X_LARGE`.
    case scale = "scale"
    case scaleSet = "scale-set"
    /// Whether this tag represents a single sentence.
    /// 
    /// This affects cursor movement.
    case sentence = "sentence"
    case sentenceSet = "sentence-set"
    /// How to render invisible characters.
    case showSpaces = "show-spaces"
    case showSpacesSet = "show-spaces-set"
    /// Font size in Pango units.
    case size = "size"
    /// Font size in points.
    case sizePoints = "size-points"
    case sizeSet = "size-set"
    /// Font stretch as a `PangoStretch`, e.g. `PANGO_STRETCH_CONDENSED`.
    case stretch = "stretch"
    case stretchSet = "stretch-set"
    /// Whether to strike through the text.
    case strikethrough = "strikethrough"
    /// This property modifies the color of strikeouts.
    /// 
    /// If not set, strikeouts will use the foreground color.
    case strikethroughRgba = "strikethrough-rgba"
    /// If the `strikethrough-rgba` property has been set.
    case strikethroughRgbaSet = "strikethrough-rgba-set"
    case strikethroughSet = "strikethrough-set"
    /// Font style as a `PangoStyle`, e.g. `PANGO_STYLE_ITALIC`.
    case style = "style"
    case styleSet = "style-set"
    /// Custom tabs for this text.
    case tabs = "tabs"
    case tabsSet = "tabs-set"
    /// How to transform the text for display.
    case textTransform = "text-transform"
    case textTransformSet = "text-transform-set"
    /// Style of underline for this text.
    case underline = "underline"
    /// This property modifies the color of underlines.
    /// 
    /// If not set, underlines will use the foreground color.
    /// 
    /// If [property`Gtk.TextTag:underline`] is set to `PANGO_UNDERLINE_ERROR`,
    /// an alternate color may be applied instead of the foreground. Setting
    /// this property will always override those defaults.
    case underlineRgba = "underline-rgba"
    /// If the `underline-rgba` property has been set.
    case underlineRgbaSet = "underline-rgba-set"
    case underlineSet = "underline-set"
    /// Font variant as a `PangoVariant`, e.g. `PANGO_VARIANT_SMALL_CAPS`.
    case variant = "variant"
    case variantSet = "variant-set"
    /// Font weight as an integer.
    case weight = "weight"
    case weightSet = "weight-set"
    /// Whether this tag represents a single word.
    /// 
    /// This affects line breaks and cursor movement.
    case word = "word"
    case wordSet = "word-set"
    /// Whether to wrap lines never, at word boundaries, or
    /// at character boundaries.
    case wrapMode = "wrap-mode"
    case wrapModeSet = "wrap-mode-set"
}

public extension TextTagProtocol {
    /// Bind a `TextTagPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TextTagPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TextTag property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TextTagPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TextTag property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TextTagPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TextTagSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Whether the margins accumulate or override each other.
    /// 
    /// When set to `true` the margins of this tag are added to the margins
    /// of any other non-accumulative margins present. When set to `false`
    /// the margins override one another (the default).
    case notifyAccumulativeMargin = "notify::accumulative-margin"
    /// Whether breaks are allowed.
    case notifyAllowBreaks = "notify::allow-breaks"
    case notifyAllowBreaksSet = "notify::allow-breaks-set"
    /// Background color as a string.
    case notifyBackground = "notify::background"
    /// Whether the background color fills the entire line height
    /// or only the height of the tagged characters.
    case notifyBackgroundFullHeight = "notify::background-full-height"
    case notifyBackgroundFullHeightSet = "notify::background-full-height-set"
    /// Background color as a `GdkRGBA`.
    case notifyBackgroundRgba = "notify::background-rgba"
    case notifyBackgroundSet = "notify::background-set"
    /// Text direction, e.g. right-to-left or left-to-right.
    case notifyDirection = "notify::direction"
    /// Whether the text can be modified by the user.
    case notifyEditable = "notify::editable"
    case notifyEditableSet = "notify::editable-set"
    /// Whether font fallback is enabled.
    /// 
    /// When set to `true`, other fonts will be substituted
    /// where the current font is missing glyphs.
    case notifyFallback = "notify::fallback"
    case notifyFallbackSet = "notify::fallback-set"
    /// Name of the font family, e.g. Sans, Helvetica, Times, Monospace.
    case notifyFamily = "notify::family"
    case notifyFamilySet = "notify::family-set"
    /// Font description as string, e.g. \"Sans Italic 12\".
    /// 
    /// Note that the initial value of this property depends on
    /// the internals of `PangoFontDescription`.
    case notifyFont = "notify::font"
    /// Font description as a `PangoFontDescription`.
    case notifyFontDesc = "notify::font-desc"
    /// OpenType font features, as a string.
    case notifyFontFeatures = "notify::font-features"
    case notifyFontFeaturesSet = "notify::font-features-set"
    /// Foreground color as a string.
    case notifyForeground = "notify::foreground"
    /// Foreground color as a `GdkRGBA`.
    case notifyForegroundRgba = "notify::foreground-rgba"
    case notifyForegroundSet = "notify::foreground-set"
    /// Amount to indent the paragraph, in pixels.
    case notifyIndent = "notify::indent"
    case notifyIndentSet = "notify::indent-set"
    /// Whether to insert hyphens at breaks.
    case notifyInsertHyphens = "notify::insert-hyphens"
    case notifyInsertHyphensSet = "notify::insert-hyphens-set"
    /// Whether this text is hidden.
    /// 
    /// Note that there may still be problems with the support for invisible
    /// text, in particular when navigating programmatically inside a buffer
    /// containing invisible segments.
    case notifyInvisible = "notify::invisible"
    case notifyInvisibleSet = "notify::invisible-set"
    /// Left, right, or center justification.
    case notifyJustification = "notify::justification"
    case notifyJustificationSet = "notify::justification-set"
    /// The language this text is in, as an ISO code.
    /// 
    /// Pango can use this as a hint when rendering the text.
    /// If not set, an appropriate default will be used.
    /// 
    /// Note that the initial value of this property depends
    /// on the current locale, see also [func`Gtk.get_default_language`].
    case notifyLanguage = "notify::language"
    case notifyLanguageSet = "notify::language-set"
    /// Width of the left margin in pixels.
    case notifyLeftMargin = "notify::left-margin"
    case notifyLeftMarginSet = "notify::left-margin-set"
    /// Extra spacing between graphemes, in Pango units.
    case notifyLetterSpacing = "notify::letter-spacing"
    case notifyLetterSpacingSet = "notify::letter-spacing-set"
    /// Factor to scale line height by.
    case notifyLineHeight = "notify::line-height"
    case notifyLineHeightSet = "notify::line-height-set"
    /// The name used to refer to the tag.
    /// 
    /// `nil` for anonymous tags.
    case notifyName = "notify::name"
    /// Style of overline for this text.
    case notifyOverline = "notify::overline"
    /// This property modifies the color of overlines.
    /// 
    /// If not set, overlines will use the foreground color.
    case notifyOverlineRgba = "notify::overline-rgba"
    case notifyOverlineRgbaSet = "notify::overline-rgba-set"
    case notifyOverlineSet = "notify::overline-set"
    /// The paragraph background color as a string.
    case notifyParagraphBackground = "notify::paragraph-background"
    /// The paragraph background color as a `GdkRGBA`.
    case notifyParagraphBackgroundRgba = "notify::paragraph-background-rgba"
    case notifyParagraphBackgroundSet = "notify::paragraph-background-set"
    /// Pixels of blank space above paragraphs.
    case notifyPixelsAboveLines = "notify::pixels-above-lines"
    case notifyPixelsAboveLinesSet = "notify::pixels-above-lines-set"
    /// Pixels of blank space below paragraphs.
    case notifyPixelsBelowLines = "notify::pixels-below-lines"
    case notifyPixelsBelowLinesSet = "notify::pixels-below-lines-set"
    /// Pixels of blank space between wrapped lines in a paragraph.
    case notifyPixelsInsideWrap = "notify::pixels-inside-wrap"
    case notifyPixelsInsideWrapSet = "notify::pixels-inside-wrap-set"
    /// Width of the right margin, in pixels.
    case notifyRightMargin = "notify::right-margin"
    case notifyRightMarginSet = "notify::right-margin-set"
    /// Offset of text above the baseline, in Pango units.
    /// 
    /// Negative values go below the baseline.
    case notifyRise = "notify::rise"
    case notifyRiseSet = "notify::rise-set"
    /// Font size as a scale factor relative to the default font size.
    /// 
    /// This properly adapts to theme changes, etc. so is recommended.
    /// Pango predefines some scales such as `PANGO_SCALE_X_LARGE`.
    case notifyScale = "notify::scale"
    case notifyScaleSet = "notify::scale-set"
    /// Whether this tag represents a single sentence.
    /// 
    /// This affects cursor movement.
    case notifySentence = "notify::sentence"
    case notifySentenceSet = "notify::sentence-set"
    /// How to render invisible characters.
    case notifyShowSpaces = "notify::show-spaces"
    case notifyShowSpacesSet = "notify::show-spaces-set"
    /// Font size in Pango units.
    case notifySize = "notify::size"
    /// Font size in points.
    case notifySizePoints = "notify::size-points"
    case notifySizeSet = "notify::size-set"
    /// Font stretch as a `PangoStretch`, e.g. `PANGO_STRETCH_CONDENSED`.
    case notifyStretch = "notify::stretch"
    case notifyStretchSet = "notify::stretch-set"
    /// Whether to strike through the text.
    case notifyStrikethrough = "notify::strikethrough"
    /// This property modifies the color of strikeouts.
    /// 
    /// If not set, strikeouts will use the foreground color.
    case notifyStrikethroughRgba = "notify::strikethrough-rgba"
    /// If the `strikethrough-rgba` property has been set.
    case notifyStrikethroughRgbaSet = "notify::strikethrough-rgba-set"
    case notifyStrikethroughSet = "notify::strikethrough-set"
    /// Font style as a `PangoStyle`, e.g. `PANGO_STYLE_ITALIC`.
    case notifyStyle = "notify::style"
    case notifyStyleSet = "notify::style-set"
    /// Custom tabs for this text.
    case notifyTabs = "notify::tabs"
    case notifyTabsSet = "notify::tabs-set"
    /// How to transform the text for display.
    case notifyTextTransform = "notify::text-transform"
    case notifyTextTransformSet = "notify::text-transform-set"
    /// Style of underline for this text.
    case notifyUnderline = "notify::underline"
    /// This property modifies the color of underlines.
    /// 
    /// If not set, underlines will use the foreground color.
    /// 
    /// If [property`Gtk.TextTag:underline`] is set to `PANGO_UNDERLINE_ERROR`,
    /// an alternate color may be applied instead of the foreground. Setting
    /// this property will always override those defaults.
    case notifyUnderlineRgba = "notify::underline-rgba"
    /// If the `underline-rgba` property has been set.
    case notifyUnderlineRgbaSet = "notify::underline-rgba-set"
    case notifyUnderlineSet = "notify::underline-set"
    /// Font variant as a `PangoVariant`, e.g. `PANGO_VARIANT_SMALL_CAPS`.
    case notifyVariant = "notify::variant"
    case notifyVariantSet = "notify::variant-set"
    /// Font weight as an integer.
    case notifyWeight = "notify::weight"
    case notifyWeightSet = "notify::weight-set"
    /// Whether this tag represents a single word.
    /// 
    /// This affects line breaks and cursor movement.
    case notifyWord = "notify::word"
    case notifyWordSet = "notify::word-set"
    /// Whether to wrap lines never, at word boundaries, or
    /// at character boundaries.
    case notifyWrapMode = "notify::wrap-mode"
    case notifyWrapModeSet = "notify::wrap-mode-set"
}

// MARK: TextTag has no signals
// MARK: TextTag Class: TextTagProtocol extension (methods and fields)
public extension TextTagProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextTag` instance.
    @inlinable var text_tag_ptr: UnsafeMutablePointer<GtkTextTag>! { return ptr?.assumingMemoryBound(to: GtkTextTag.self) }

    /// Emits the [signal`Gtk.TextTagTable::tag-changed`] signal on the
    /// `GtkTextTagTable` where the tag is included.
    /// 
    /// The signal is already emitted when setting a `GtkTextTag` property.
    /// This function is useful for a `GtkTextTag` subclass.
    @inlinable func changed(sizeChanged: Bool) {
        
        gtk_text_tag_changed(text_tag_ptr, gboolean((sizeChanged) ? 1 : 0))
        
    }

    /// Get the tag priority.
    @inlinable func getPriority() -> Int {
        let result = gtk_text_tag_get_priority(text_tag_ptr)
        let rv = Int(result)
        return rv
    }

    /// Sets the priority of a `GtkTextTag`.
    /// 
    /// Valid priorities start at 0 and go to one less than
    /// [method`Gtk.TextTagTable.get_size`]. Each tag in a table
    /// has a unique priority; setting the priority of one tag shifts
    /// the priorities of all the other tags in the table to maintain
    /// a unique priority for each tag.
    /// 
    /// Higher priority tags “win” if two tags both set the same text
    /// attribute. When adding a tag to a tag table, it will be assigned
    /// the highest priority in the table by default; so normally the
    /// precedence of a set of tags is the order in which they were added
    /// to the table, or created with [method`Gtk.TextBuffer.create_tag`],
    /// which adds the tag to the buffer’s table automatically.
    @inlinable func set(priority: Int) {
        
        gtk_text_tag_set_priority(text_tag_ptr, gint(priority))
        
    }
    /// Get the tag priority.
    @inlinable var priority: Int {
        /// Get the tag priority.
        get {
            let result = gtk_text_tag_get_priority(text_tag_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the priority of a `GtkTextTag`.
        /// 
        /// Valid priorities start at 0 and go to one less than
        /// [method`Gtk.TextTagTable.get_size`]. Each tag in a table
        /// has a unique priority; setting the priority of one tag shifts
        /// the priorities of all the other tags in the table to maintain
        /// a unique priority for each tag.
        /// 
        /// Higher priority tags “win” if two tags both set the same text
        /// attribute. When adding a tag to a tag table, it will be assigned
        /// the highest priority in the table by default; so normally the
        /// precedence of a set of tags is the order in which they were added
        /// to the table, or created with [method`Gtk.TextBuffer.create_tag`],
        /// which adds the tag to the buffer’s table automatically.
        nonmutating set {
            gtk_text_tag_set_priority(text_tag_ptr, gint(newValue))
        }
    }

    @inlinable var parentInstance: GObject {
        get {
            let rv = text_tag_ptr.pointee.parent_instance
    return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - TextTagTable Class

/// The collection of tags in a `GtkTextBuffer`
/// 
/// You may wish to begin by reading the
/// [text widget conceptual overview](section-text-widget.html),
/// which gives an overview of all the objects and data types
/// related to the text widget and how they work together.
/// 
/// # GtkTextTagTables as GtkBuildable
/// 
/// The `GtkTextTagTable` implementation of the `GtkBuildable` interface
/// supports adding tags by specifying “tag” as the “type” attribute
/// of a &lt;child&gt; element.
/// 
/// An example of a UI definition fragment specifying tags:
/// ```xml
/// &lt;object class="GtkTextTagTable"&gt;
///  &lt;child type="tag"&gt;
///    &lt;object class="GtkTextTag"/&gt;
///  &lt;/child&gt;
/// &lt;/object&gt;
/// ```
///
/// The `TextTagTableProtocol` protocol exposes the methods and properties of an underlying `GtkTextTagTable` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextTagTable`.
/// Alternatively, use `TextTagTableRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextTagTableProtocol: GLibObject.ObjectProtocol, BuildableProtocol {
        /// Untyped pointer to the underlying `GtkTextTagTable` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTextTagTable` instance.
    var text_tag_table_ptr: UnsafeMutablePointer<GtkTextTagTable>! { get }

    /// Required Initialiser for types conforming to `TextTagTableProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The collection of tags in a `GtkTextBuffer`
/// 
/// You may wish to begin by reading the
/// [text widget conceptual overview](section-text-widget.html),
/// which gives an overview of all the objects and data types
/// related to the text widget and how they work together.
/// 
/// # GtkTextTagTables as GtkBuildable
/// 
/// The `GtkTextTagTable` implementation of the `GtkBuildable` interface
/// supports adding tags by specifying “tag” as the “type” attribute
/// of a &lt;child&gt; element.
/// 
/// An example of a UI definition fragment specifying tags:
/// ```xml
/// &lt;object class="GtkTextTagTable"&gt;
///  &lt;child type="tag"&gt;
///    &lt;object class="GtkTextTag"/&gt;
///  &lt;/child&gt;
/// &lt;/object&gt;
/// ```
///
/// The `TextTagTableRef` type acts as a lightweight Swift reference to an underlying `GtkTextTagTable` instance.
/// It exposes methods that can operate on this data type through `TextTagTableProtocol` conformance.
/// Use `TextTagTableRef` only as an `unowned` reference to an existing `GtkTextTagTable` instance.
///
public struct TextTagTableRef: TextTagTableProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTextTagTable` instance.
    /// For type-safe access, use the generated, typed pointer `text_tag_table_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextTagTableRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTextTagTable>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTextTagTable>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTextTagTable>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTextTagTable>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextTagTableProtocol`
    @inlinable init<T: TextTagTableProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TextTagTableProtocol>(_ other: T) -> TextTagTableRef { TextTagTableRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkTextTagTable`.
    /// 
    /// The table contains no tags by default.
    @inlinable init() {
            let result = gtk_text_tag_table_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The collection of tags in a `GtkTextBuffer`
/// 
/// You may wish to begin by reading the
/// [text widget conceptual overview](section-text-widget.html),
/// which gives an overview of all the objects and data types
/// related to the text widget and how they work together.
/// 
/// # GtkTextTagTables as GtkBuildable
/// 
/// The `GtkTextTagTable` implementation of the `GtkBuildable` interface
/// supports adding tags by specifying “tag” as the “type” attribute
/// of a &lt;child&gt; element.
/// 
/// An example of a UI definition fragment specifying tags:
/// ```xml
/// &lt;object class="GtkTextTagTable"&gt;
///  &lt;child type="tag"&gt;
///    &lt;object class="GtkTextTag"/&gt;
///  &lt;/child&gt;
/// &lt;/object&gt;
/// ```
///
/// The `TextTagTable` type acts as a reference-counted owner of an underlying `GtkTextTagTable` instance.
/// It provides the methods that can operate on this data type through `TextTagTableProtocol` conformance.
/// Use `TextTagTable` as a strong reference or owner of a `GtkTextTagTable` instance.
///
open class TextTagTable: GLibObject.Object, TextTagTableProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTagTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTextTagTable>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTagTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTextTagTable>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTagTable` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTagTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTagTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTextTagTable>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTagTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTextTagTable>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTextTagTable`.
    /// i.e., ownership is transferred to the `TextTagTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTextTagTable>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TextTagTableProtocol`
    /// Will retain `GtkTextTagTable`.
    /// - Parameter other: an instance of a related type that implements `TextTagTableProtocol`
    @inlinable public init<T: TextTagTableProtocol>(textTagTable other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkTextTagTable`.
    /// 
    /// The table contains no tags by default.
    @inlinable public init() {
            let result = gtk_text_tag_table_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no TextTagTable properties

public enum TextTagTableSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted every time a new tag is added in the `GtkTextTagTable`.
    case tagAdded = "tag-added"
    /// Emitted every time a tag in the `GtkTextTagTable` changes.
    case tagChanged = "tag-changed"
    /// Emitted every time a tag is removed from the `GtkTextTagTable`.
    /// 
    /// The `tag` is still valid by the time the signal is emitted, but
    /// it is not associated with a tag table any more.
    case tagRemoved = "tag-removed"

}

// MARK: TextTagTable signals
public extension TextTagTableProtocol {
    /// Connect a Swift signal handler to the given, typed `TextTagTableSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TextTagTableSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `TextTagTableSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TextTagTableSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted every time a new tag is added in the `GtkTextTagTable`.
    /// - Note: This represents the underlying `tag-added` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter tag: the added tag.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `tagAdded` signal is emitted
    @discardableResult @inlinable func onTagAdded(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagTableRef, _ tag: TextTagRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextTagTableRef, TextTagRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextTagTableRef(raw: unownedSelf), TextTagRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .tagAdded,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `tag-added` signal for using the `connect(signal:)` methods
    static var tagAddedSignal: TextTagTableSignalName { .tagAdded }
    
    /// Emitted every time a tag in the `GtkTextTagTable` changes.
    /// - Note: This represents the underlying `tag-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter tag: the changed tag.
    /// - Parameter sizeChanged: whether the change affects the `GtkTextView` layout.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `tagChanged` signal is emitted
    @discardableResult @inlinable func onTagChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagTableRef, _ tag: TextTagRef, _ sizeChanged: Bool) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextTagTableRef, TextTagRef, Bool), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gboolean, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextTagTableRef(raw: unownedSelf), TextTagRef(raw: arg1), ((arg2) != 0)))
            return output
        }
        return connect(
            signal: .tagChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `tag-changed` signal for using the `connect(signal:)` methods
    static var tagChangedSignal: TextTagTableSignalName { .tagChanged }
    
    /// Emitted every time a tag is removed from the `GtkTextTagTable`.
    /// 
    /// The `tag` is still valid by the time the signal is emitted, but
    /// it is not associated with a tag table any more.
    /// - Note: This represents the underlying `tag-removed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter tag: the removed tag.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `tagRemoved` signal is emitted
    @discardableResult @inlinable func onTagRemoved(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagTableRef, _ tag: TextTagRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextTagTableRef, TextTagRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextTagTableRef(raw: unownedSelf), TextTagRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .tagRemoved,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `tag-removed` signal for using the `connect(signal:)` methods
    static var tagRemovedSignal: TextTagTableSignalName { .tagRemoved }
    
    
}

// MARK: TextTagTable Class: TextTagTableProtocol extension (methods and fields)
public extension TextTagTableProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextTagTable` instance.
    @inlinable var text_tag_table_ptr: UnsafeMutablePointer<GtkTextTagTable>! { return ptr?.assumingMemoryBound(to: GtkTextTagTable.self) }

    /// Add a tag to the table.
    /// 
    /// The tag is assigned the highest priority in the table.
    /// 
    /// `tag` must not be in a tag table already, and may not have
    /// the same name as an already-added tag.
    @inlinable func add<TextTagT: TextTagProtocol>(tag: TextTagT) -> Bool {
        let result = gtk_text_tag_table_add(text_tag_table_ptr, tag.text_tag_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Calls `func` on each tag in `table`, with user data `data`.
    /// 
    /// Note that the table may not be modified while iterating
    /// over it (you can’t add/remove tags).
    @inlinable func foreach(`func`: @escaping GtkTextTagTableForeach, data: gpointer? = nil) {
        
        gtk_text_tag_table_foreach(text_tag_table_ptr, `func`, data)
        
    }

    /// Returns the size of the table (number of tags)
    @inlinable func getSize() -> Int {
        let result = gtk_text_tag_table_get_size(text_tag_table_ptr)
        let rv = Int(result)
        return rv
    }

    /// Look up a named tag.
    @inlinable func lookup(name: UnsafePointer<CChar>!) -> TextTagRef! {
        let result = gtk_text_tag_table_lookup(text_tag_table_ptr, name)
        let rv = TextTagRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Remove a tag from the table.
    /// 
    /// If a `GtkTextBuffer` has `table` as its tag table, the tag is
    /// removed from the buffer. The table’s reference to the tag is
    /// removed, so the tag will end up destroyed if you don’t have
    /// a reference to it.
    @inlinable func remove<TextTagT: TextTagProtocol>(tag: TextTagT) {
        
        gtk_text_tag_table_remove(text_tag_table_ptr, tag.text_tag_ptr)
        
    }
    /// Returns the size of the table (number of tags)
    @inlinable var size: Int {
        /// Returns the size of the table (number of tags)
        get {
            let result = gtk_text_tag_table_get_size(text_tag_table_ptr)
        let rv = Int(result)
            return rv
        }
    }


}



// MARK: - TextView Class

/// A widget that displays the contents of a [class`Gtk.TextBuffer`].
/// 
/// ![An example GtkTextview](multiline-text.png)
/// 
/// You may wish to begin by reading the [conceptual overview](section-text-widget.html),
/// which gives an overview of all the objects and data types related to the
/// text widget and how they work together.
/// 
/// ## CSS nodes
/// 
/// ```
/// textview.view
/// ├── border.top
/// ├── border.left
/// ├── text
/// │   ╰── [selection]
/// ├── border.right
/// ├── border.bottom
/// ╰── [window.popup]
/// ```
/// 
/// `GtkTextView` has a main css node with name textview and style class .view,
/// and subnodes for each of the border windows, and the main text area,
/// with names border and text, respectively. The border nodes each get
/// one of the style classes .left, .right, .top or .bottom.
/// 
/// A node representing the selection will appear below the text node.
/// 
/// If a context menu is opened, the window node will appear as a subnode
/// of the main node.
/// 
/// ## Accessibility
/// 
/// `GtkTextView` uses the `GTK_ACCESSIBLE_ROLE_TEXT_BOX` role.
///
/// The `TextViewProtocol` protocol exposes the methods and properties of an underlying `GtkTextView` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextView`.
/// Alternatively, use `TextViewRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextViewProtocol: WidgetProtocol, ScrollableProtocol {
        /// Untyped pointer to the underlying `GtkTextView` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTextView` instance.
    var text_view_ptr: UnsafeMutablePointer<GtkTextView>! { get }

    /// Required Initialiser for types conforming to `TextViewProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A widget that displays the contents of a [class`Gtk.TextBuffer`].
/// 
/// ![An example GtkTextview](multiline-text.png)
/// 
/// You may wish to begin by reading the [conceptual overview](section-text-widget.html),
/// which gives an overview of all the objects and data types related to the
/// text widget and how they work together.
/// 
/// ## CSS nodes
/// 
/// ```
/// textview.view
/// ├── border.top
/// ├── border.left
/// ├── text
/// │   ╰── [selection]
/// ├── border.right
/// ├── border.bottom
/// ╰── [window.popup]
/// ```
/// 
/// `GtkTextView` has a main css node with name textview and style class .view,
/// and subnodes for each of the border windows, and the main text area,
/// with names border and text, respectively. The border nodes each get
/// one of the style classes .left, .right, .top or .bottom.
/// 
/// A node representing the selection will appear below the text node.
/// 
/// If a context menu is opened, the window node will appear as a subnode
/// of the main node.
/// 
/// ## Accessibility
/// 
/// `GtkTextView` uses the `GTK_ACCESSIBLE_ROLE_TEXT_BOX` role.
///
/// The `TextViewRef` type acts as a lightweight Swift reference to an underlying `GtkTextView` instance.
/// It exposes methods that can operate on this data type through `TextViewProtocol` conformance.
/// Use `TextViewRef` only as an `unowned` reference to an existing `GtkTextView` instance.
///
public struct TextViewRef: TextViewProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTextView` instance.
    /// For type-safe access, use the generated, typed pointer `text_view_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextViewRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTextView>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTextView>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTextView>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTextView>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextViewProtocol`
    @inlinable init<T: TextViewProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TextViewProtocol>(_ other: T) -> TextViewRef { TextViewRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkTextView`.
    /// 
    /// If you don’t call [method`Gtk.TextView.set_buffer`] before using the
    /// text view, an empty default buffer will be created for you. Get the
    /// buffer with [method`Gtk.TextView.get_buffer`]. If you want to specify
    /// your own buffer, consider [ctor`Gtk.TextView.new_with_buffer`].
    @inlinable init() {
            let result = gtk_text_view_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkTextView` widget displaying the buffer `buffer`.
    /// 
    /// One buffer can be shared among many widgets. `buffer` may be `nil`
    /// to create a default buffer, in which case this function is equivalent
    /// to [ctor`Gtk.TextView.new`]. The text view adds its own reference count
    /// to the buffer; it does not take over an existing reference.
    @inlinable init<TextBufferT: TextBufferProtocol>(buffer: TextBufferT) {
            let result = gtk_text_view_new_with_buffer(buffer.text_buffer_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkTextView` widget displaying the buffer `buffer`.
    /// 
    /// One buffer can be shared among many widgets. `buffer` may be `nil`
    /// to create a default buffer, in which case this function is equivalent
    /// to [ctor`Gtk.TextView.new`]. The text view adds its own reference count
    /// to the buffer; it does not take over an existing reference.
    @inlinable static func newWith<TextBufferT: TextBufferProtocol>(buffer: TextBufferT) -> WidgetRef! {
            let result = gtk_text_view_new_with_buffer(buffer.text_buffer_ptr)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }
}

/// A widget that displays the contents of a [class`Gtk.TextBuffer`].
/// 
/// ![An example GtkTextview](multiline-text.png)
/// 
/// You may wish to begin by reading the [conceptual overview](section-text-widget.html),
/// which gives an overview of all the objects and data types related to the
/// text widget and how they work together.
/// 
/// ## CSS nodes
/// 
/// ```
/// textview.view
/// ├── border.top
/// ├── border.left
/// ├── text
/// │   ╰── [selection]
/// ├── border.right
/// ├── border.bottom
/// ╰── [window.popup]
/// ```
/// 
/// `GtkTextView` has a main css node with name textview and style class .view,
/// and subnodes for each of the border windows, and the main text area,
/// with names border and text, respectively. The border nodes each get
/// one of the style classes .left, .right, .top or .bottom.
/// 
/// A node representing the selection will appear below the text node.
/// 
/// If a context menu is opened, the window node will appear as a subnode
/// of the main node.
/// 
/// ## Accessibility
/// 
/// `GtkTextView` uses the `GTK_ACCESSIBLE_ROLE_TEXT_BOX` role.
///
/// The `TextView` type acts as a reference-counted owner of an underlying `GtkTextView` instance.
/// It provides the methods that can operate on this data type through `TextViewProtocol` conformance.
/// Use `TextView` as a strong reference or owner of a `GtkTextView` instance.
///
open class TextView: Widget, TextViewProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTextView>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTextView>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextView` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTextView>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTextView>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTextView`.
    /// i.e., ownership is transferred to the `TextView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTextView>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TextViewProtocol`
    /// Will retain `GtkTextView`.
    /// - Parameter other: an instance of a related type that implements `TextViewProtocol`
    @inlinable public init<T: TextViewProtocol>(textView other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkTextView`.
    /// 
    /// If you don’t call [method`Gtk.TextView.set_buffer`] before using the
    /// text view, an empty default buffer will be created for you. Get the
    /// buffer with [method`Gtk.TextView.get_buffer`]. If you want to specify
    /// your own buffer, consider [ctor`Gtk.TextView.new_with_buffer`].
    @inlinable public init() {
            let result = gtk_text_view_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkTextView` widget displaying the buffer `buffer`.
    /// 
    /// One buffer can be shared among many widgets. `buffer` may be `nil`
    /// to create a default buffer, in which case this function is equivalent
    /// to [ctor`Gtk.TextView.new`]. The text view adds its own reference count
    /// to the buffer; it does not take over an existing reference.
    @inlinable public init<TextBufferT: TextBufferProtocol>(buffer: TextBufferT) {
            let result = gtk_text_view_new_with_buffer(buffer.text_buffer_ptr)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkTextView` widget displaying the buffer `buffer`.
    /// 
    /// One buffer can be shared among many widgets. `buffer` may be `nil`
    /// to create a default buffer, in which case this function is equivalent
    /// to [ctor`Gtk.TextView.new`]. The text view adds its own reference count
    /// to the buffer; it does not take over an existing reference.
    @inlinable public static func newWith<TextBufferT: TextBufferProtocol>(buffer: TextBufferT) -> Widget! {
            let result = gtk_text_view_new_with_buffer(buffer.text_buffer_ptr)
        guard let rv = Widget(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

}

public enum TextViewPropertyName: String, PropertyNameProtocol {
    /// Whether Tab will result in a tab character being entered.
    case acceptsTab = "accepts-tab"
    /// The bottom margin for text in the text view.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    /// 
    /// Don't confuse this property with [property`Gtk.Widget:margin-bottom`].
    case bottomMargin = "bottom-margin"
    /// The buffer which is displayed.
    case buffer = "buffer"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// If the insertion cursor is shown.
    case cursorVisible = "cursor-visible"
    case editable = "editable"
    /// A menu model whose contents will be appended to the context menu.
    case extraMenu = "extra-menu"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// Which IM (input method) module should be used for this text_view.
    /// 
    /// See [class`Gtk.IMMulticontext`].
    /// 
    /// Setting this to a non-`nil` value overrides the system-wide IM module
    /// setting. See the GtkSettings [property`Gtk.Settings:gtk-im-module`] property.
    case imModule = "im-module"
    /// Amount to indent the paragraph, in pixels.
    case indent = "indent"
    /// Additional hints (beyond [property`Gtk.TextView:input-purpose`])
    /// that allow input methods to fine-tune their behaviour.
    case inputHints = "input-hints"
    /// The purpose of this text field.
    /// 
    /// This property can be used by on-screen keyboards and other input
    /// methods to adjust their behaviour.
    case inputPurpose = "input-purpose"
    case justification = "justification"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// The default left margin for text in the text view.
    /// 
    /// Tags in the buffer may override the default.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    case leftMargin = "left-margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// Whether text should be displayed in a monospace font.
    /// 
    /// If `true`, set the .monospace style class on the
    /// text view to indicate that a monospace font is desired.
    case monospace = "monospace"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// Whether entered text overwrites existing contents.
    case overwrite = "overwrite"
    /// The parent widget of this widget.
    case parent = "parent"
    case pixelsAboveLines = "pixels-above-lines"
    case pixelsBelowLines = "pixels-below-lines"
    case pixelsInsideWrap = "pixels-inside-wrap"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The default right margin for text in the text view.
    /// 
    /// Tags in the buffer may override the default.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    case rightMargin = "right-margin"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    case tabs = "tabs"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// The top margin for text in the text view.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    /// 
    /// Don't confuse this property with [property`Gtk.Widget:margin-top`].
    case topMargin = "top-margin"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
    case wrapMode = "wrap-mode"
}

public extension TextViewProtocol {
    /// Bind a `TextViewPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TextViewPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TextView property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TextViewPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TextView property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TextViewPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TextViewSignalName: String, SignalNameProtocol {
    /// Gets emitted when the user asks for it.
    /// 
    /// The `backspace` signal is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Backspace&lt;/kbd&gt; and &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Backspace&lt;/kbd&gt;.
    case backspace = "backspace"
    /// Gets emitted to copy the selection to the clipboard.
    /// 
    /// The `copy-clipboard` signal is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;c&lt;/kbd&gt; and
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;Insert&lt;/kbd&gt;.
    case copyClipboard = "copy-clipboard"
    /// Gets emitted to cut the selection to the clipboard.
    /// 
    /// The `cut-clipboard` signal is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;x&lt;/kbd&gt; and
    /// &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Delete&lt;/kbd&gt;.
    case cutClipboard = "cut-clipboard"
    /// Gets emitted when the user initiates a text deletion.
    /// 
    /// The `delete-from-cursor` signal is a [keybinding signal](class.SignalAction.html).
    /// 
    /// If the `type` is `GTK_DELETE_CHARS`, GTK deletes the selection
    /// if there is one, otherwise it deletes the requested number
    /// of characters.
    /// 
    /// The default bindings for this signal are &lt;kbd&gt;Delete&lt;/kbd&gt; for
    /// deleting a character, &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;Delete&lt;/kbd&gt; for
    /// deleting a word and &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;Backspace&lt;/kbd&gt; for
    /// deleting a word backwards.
    case deleteFromCursor = "delete-from-cursor"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when the selection needs to be extended at `location`.
    case extendSelection = "extend-selection"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Gets emitted when the user initiates the insertion of a
    /// fixed string at the cursor.
    /// 
    /// The `insert-at-cursor` signal is a [keybinding signal](class.SignalAction.html).
    /// 
    /// This signal has no default bindings.
    case insertAtCursor = "insert-at-cursor"
    /// Gets emitted to present the Emoji chooser for the `text_view`.
    /// 
    /// The `insert-emoji` signal is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;.&lt;/kbd&gt; and
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;;&lt;/kbd&gt;
    case insertEmoji = "insert-emoji"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Gets emitted when the user initiates a cursor movement.
    /// 
    /// The `move-cursor` signal is a [keybinding signal](class.SignalAction.html).
    /// If the cursor is not visible in `text_view`, this signal causes
    /// the viewport to be moved instead.
    /// 
    /// Applications should not connect to it, but may emit it with
    /// `g_signal_emit_by_name()` if they need to control the cursor
    /// programmatically.
    /// 
    /// 
    /// The default bindings for this signal come in two variants,
    /// the variant with the &lt;kbd&gt;Shift&lt;/kbd&gt; modifier extends the
    /// selection, the variant without it does not.
    /// There are too many key combinations to list them all here.
    /// 
    /// - &lt;kbd&gt;←&lt;/kbd&gt;, &lt;kbd&gt;→&lt;/kbd&gt;, &lt;kbd&gt;↑&lt;/kbd&gt;, &lt;kbd&gt;↓&lt;/kbd&gt;
    ///   move by individual characters/lines
    /// - &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;→&lt;/kbd&gt;, etc. move by words/paragraphs
    /// - &lt;kbd&gt;Home&lt;/kbd&gt;, &lt;kbd&gt;End&lt;/kbd&gt; move to the ends of the buffer
    /// - &lt;kbd&gt;PgUp&lt;/kbd&gt;, &lt;kbd&gt;PgDn&lt;/kbd&gt; move vertically by pages
    /// - &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;PgUp&lt;/kbd&gt;, &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;PgDn&lt;/kbd&gt;
    ///   move horizontally by pages
    case moveCursor = "move-cursor"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// Gets emitted to move the viewport.
    /// 
    /// The `move-viewport` signal is a [keybinding signal](class.SignalAction.html),
    /// which can be bound to key combinations to allow the user to move the viewport,
    /// i.e. change what part of the text view is visible in a containing scrolled
    /// window.
    /// 
    /// There are no default bindings for this signal.
    case moveViewport = "move-viewport"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Gets emitted to paste the contents of the clipboard
    /// into the text view.
    /// 
    /// The `paste-clipboard` signal is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;v&lt;/kbd&gt; and
    /// &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Insert&lt;/kbd&gt;.
    case pasteClipboard = "paste-clipboard"
    /// Emitted when preedit text of the active IM changes.
    /// 
    /// If an input method is used, the typed text will not immediately
    /// be committed to the buffer. So if you are interested in the text,
    /// connect to this signal.
    /// 
    /// This signal is only emitted if the text at the given position
    /// is actually editable.
    case preeditChanged = "preedit-changed"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Gets emitted to select or unselect the complete contents of the text view.
    /// 
    /// The `select-all` signal is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;a&lt;/kbd&gt; and
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;/&lt;/kbd&gt; for selecting and
    /// &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;a&lt;/kbd&gt; and
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;\&lt;/kbd&gt; for unselecting.
    case selectAll = "select-all"
    /// Gets emitted when the user initiates settings the "anchor" mark.
    /// 
    /// The `set-anchor` signal is a [keybinding signal](class.SignalAction.html)
    /// which gets emitted when the user initiates setting the "anchor"
    /// mark. The "anchor" mark gets placed at the same position as the
    /// "insert" mark.
    /// 
    /// This signal has no default bindings.
    case setAnchor = "set-anchor"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Gets emitted to toggle the `cursor-visible` property.
    /// 
    /// The `toggle-cursor-visible` signal is a
    /// [keybinding signal](class.SignalAction.html).
    /// 
    /// The default binding for this signal is &lt;kbd&gt;F7&lt;/kbd&gt;.
    case toggleCursorVisible = "toggle-cursor-visible"
    /// Gets emitted to toggle the overwrite mode of the text view.
    /// 
    /// The `toggle-overwrite` signal is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default binding for this signal is &lt;kbd&gt;Insert&lt;/kbd&gt;.
    case toggleOverwrite = "toggle-overwrite"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether Tab will result in a tab character being entered.
    case notifyAcceptsTab = "notify::accepts-tab"
    /// The bottom margin for text in the text view.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    /// 
    /// Don't confuse this property with [property`Gtk.Widget:margin-bottom`].
    case notifyBottomMargin = "notify::bottom-margin"
    /// The buffer which is displayed.
    case notifyBuffer = "notify::buffer"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// If the insertion cursor is shown.
    case notifyCursorVisible = "notify::cursor-visible"
    case notifyEditable = "notify::editable"
    /// A menu model whose contents will be appended to the context menu.
    case notifyExtraMenu = "notify::extra-menu"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// Which IM (input method) module should be used for this text_view.
    /// 
    /// See [class`Gtk.IMMulticontext`].
    /// 
    /// Setting this to a non-`nil` value overrides the system-wide IM module
    /// setting. See the GtkSettings [property`Gtk.Settings:gtk-im-module`] property.
    case notifyImModule = "notify::im-module"
    /// Amount to indent the paragraph, in pixels.
    case notifyIndent = "notify::indent"
    /// Additional hints (beyond [property`Gtk.TextView:input-purpose`])
    /// that allow input methods to fine-tune their behaviour.
    case notifyInputHints = "notify::input-hints"
    /// The purpose of this text field.
    /// 
    /// This property can be used by on-screen keyboards and other input
    /// methods to adjust their behaviour.
    case notifyInputPurpose = "notify::input-purpose"
    case notifyJustification = "notify::justification"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// The default left margin for text in the text view.
    /// 
    /// Tags in the buffer may override the default.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    case notifyLeftMargin = "notify::left-margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// Whether text should be displayed in a monospace font.
    /// 
    /// If `true`, set the .monospace style class on the
    /// text view to indicate that a monospace font is desired.
    case notifyMonospace = "notify::monospace"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// Whether entered text overwrites existing contents.
    case notifyOverwrite = "notify::overwrite"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    case notifyPixelsAboveLines = "notify::pixels-above-lines"
    case notifyPixelsBelowLines = "notify::pixels-below-lines"
    case notifyPixelsInsideWrap = "notify::pixels-inside-wrap"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The default right margin for text in the text view.
    /// 
    /// Tags in the buffer may override the default.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    case notifyRightMargin = "notify::right-margin"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    case notifyTabs = "notify::tabs"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// The top margin for text in the text view.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    /// 
    /// Don't confuse this property with [property`Gtk.Widget:margin-top`].
    case notifyTopMargin = "notify::top-margin"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
    case notifyWrapMode = "notify::wrap-mode"
}

// MARK: TextView signals
public extension TextViewProtocol {
    /// Connect a Swift signal handler to the given, typed `TextViewSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TextViewSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `TextViewSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TextViewSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Gets emitted when the user asks for it.
    /// 
    /// The `backspace` signal is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Backspace&lt;/kbd&gt; and &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Backspace&lt;/kbd&gt;.
    /// - Note: This represents the underlying `backspace` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `backspace` signal is emitted
    @discardableResult @inlinable func onBackspace(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .backspace,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `backspace` signal for using the `connect(signal:)` methods
    static var backspaceSignal: TextViewSignalName { .backspace }
    
    /// Gets emitted to copy the selection to the clipboard.
    /// 
    /// The `copy-clipboard` signal is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;c&lt;/kbd&gt; and
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;Insert&lt;/kbd&gt;.
    /// - Note: This represents the underlying `copy-clipboard` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `copyClipboard` signal is emitted
    @discardableResult @inlinable func onCopyClipboard(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .copyClipboard,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `copy-clipboard` signal for using the `connect(signal:)` methods
    static var copyClipboardSignal: TextViewSignalName { .copyClipboard }
    
    /// Gets emitted to cut the selection to the clipboard.
    /// 
    /// The `cut-clipboard` signal is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;x&lt;/kbd&gt; and
    /// &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Delete&lt;/kbd&gt;.
    /// - Note: This represents the underlying `cut-clipboard` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `cutClipboard` signal is emitted
    @discardableResult @inlinable func onCutClipboard(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .cutClipboard,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `cut-clipboard` signal for using the `connect(signal:)` methods
    static var cutClipboardSignal: TextViewSignalName { .cutClipboard }
    
    /// Gets emitted when the user initiates a text deletion.
    /// 
    /// The `delete-from-cursor` signal is a [keybinding signal](class.SignalAction.html).
    /// 
    /// If the `type` is `GTK_DELETE_CHARS`, GTK deletes the selection
    /// if there is one, otherwise it deletes the requested number
    /// of characters.
    /// 
    /// The default bindings for this signal are &lt;kbd&gt;Delete&lt;/kbd&gt; for
    /// deleting a character, &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;Delete&lt;/kbd&gt; for
    /// deleting a word and &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;Backspace&lt;/kbd&gt; for
    /// deleting a word backwards.
    /// - Note: This represents the underlying `delete-from-cursor` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter type: the granularity of the deletion, as a `GtkDeleteType`
    /// - Parameter count: the number of `type` units to delete
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `deleteFromCursor` signal is emitted
    @discardableResult @inlinable func onDeleteFromCursor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ type: DeleteType, _ count: Int) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, DeleteType, Int), Void>
        let cCallback: @convention(c) (gpointer, UInt32, gint, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), DeleteType(arg1), Int(arg2)))
            return output
        }
        return connect(
            signal: .deleteFromCursor,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `delete-from-cursor` signal for using the `connect(signal:)` methods
    static var deleteFromCursorSignal: TextViewSignalName { .deleteFromCursor }
    
    /// Emitted when the selection needs to be extended at `location`.
    /// - Note: This represents the underlying `extend-selection` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter granularity: the granularity type
    /// - Parameter location: the location where to extend the selection
    /// - Parameter start: where the selection should start
    /// - Parameter end: where the selection should end
    /// - Parameter handler: `GDK_EVENT_STOP` to stop other handlers from being invoked for the   event. `GDK_EVENT_PROPAGATE` to propagate the event further.
    /// Run the given callback whenever the `extendSelection` signal is emitted
    @discardableResult @inlinable func onExtendSelection(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ granularity: TextExtendSelection, _ location: TextIterRef, _ start: TextIterRef, _ end: TextIterRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, TextExtendSelection, TextIterRef, TextIterRef, TextIterRef), Bool>
        let cCallback: @convention(c) (gpointer, UInt32, gpointer, gpointer, gpointer, gpointer) -> gboolean = { unownedSelf, arg1, arg2, arg3, arg4, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call((TextViewRef(raw: unownedSelf), TextExtendSelection(arg1), TextIterRef(raw: arg2), TextIterRef(raw: arg3), TextIterRef(raw: arg4)))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .extendSelection,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `extend-selection` signal for using the `connect(signal:)` methods
    static var extendSelectionSignal: TextViewSignalName { .extendSelection }
    
    /// Gets emitted when the user initiates the insertion of a
    /// fixed string at the cursor.
    /// 
    /// The `insert-at-cursor` signal is a [keybinding signal](class.SignalAction.html).
    /// 
    /// This signal has no default bindings.
    /// - Note: This represents the underlying `insert-at-cursor` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter string: the string to insert
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `insertAtCursor` signal is emitted
    @discardableResult @inlinable func onInsertAtCursor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ string: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, String), Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!))
            return output
        }
        return connect(
            signal: .insertAtCursor,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `insert-at-cursor` signal for using the `connect(signal:)` methods
    static var insertAtCursorSignal: TextViewSignalName { .insertAtCursor }
    
    /// Gets emitted to present the Emoji chooser for the `text_view`.
    /// 
    /// The `insert-emoji` signal is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;.&lt;/kbd&gt; and
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;;&lt;/kbd&gt;
    /// - Note: This represents the underlying `insert-emoji` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `insertEmoji` signal is emitted
    @discardableResult @inlinable func onInsertEmoji(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .insertEmoji,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `insert-emoji` signal for using the `connect(signal:)` methods
    static var insertEmojiSignal: TextViewSignalName { .insertEmoji }
    
    /// Gets emitted when the user initiates a cursor movement.
    /// 
    /// The `move-cursor` signal is a [keybinding signal](class.SignalAction.html).
    /// If the cursor is not visible in `text_view`, this signal causes
    /// the viewport to be moved instead.
    /// 
    /// Applications should not connect to it, but may emit it with
    /// `g_signal_emit_by_name()` if they need to control the cursor
    /// programmatically.
    /// 
    /// 
    /// The default bindings for this signal come in two variants,
    /// the variant with the &lt;kbd&gt;Shift&lt;/kbd&gt; modifier extends the
    /// selection, the variant without it does not.
    /// There are too many key combinations to list them all here.
    /// 
    /// - &lt;kbd&gt;←&lt;/kbd&gt;, &lt;kbd&gt;→&lt;/kbd&gt;, &lt;kbd&gt;↑&lt;/kbd&gt;, &lt;kbd&gt;↓&lt;/kbd&gt;
    ///   move by individual characters/lines
    /// - &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;→&lt;/kbd&gt;, etc. move by words/paragraphs
    /// - &lt;kbd&gt;Home&lt;/kbd&gt;, &lt;kbd&gt;End&lt;/kbd&gt; move to the ends of the buffer
    /// - &lt;kbd&gt;PgUp&lt;/kbd&gt;, &lt;kbd&gt;PgDn&lt;/kbd&gt; move vertically by pages
    /// - &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;PgUp&lt;/kbd&gt;, &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;PgDn&lt;/kbd&gt;
    ///   move horizontally by pages
    /// - Note: This represents the underlying `move-cursor` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter step: the granularity of the move, as a `GtkMovementStep`
    /// - Parameter count: the number of `step` units to move
    /// - Parameter extendSelection: `true` if the move should extend the selection
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `moveCursor` signal is emitted
    @discardableResult @inlinable func onMoveCursor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ step: MovementStep, _ count: Int, _ extendSelection: Bool) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, MovementStep, Int, Bool), Void>
        let cCallback: @convention(c) (gpointer, UInt32, gint, gboolean, gpointer) -> Void = { unownedSelf, arg1, arg2, arg3, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), MovementStep(arg1), Int(arg2), ((arg3) != 0)))
            return output
        }
        return connect(
            signal: .moveCursor,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `move-cursor` signal for using the `connect(signal:)` methods
    static var moveCursorSignal: TextViewSignalName { .moveCursor }
    
    /// Gets emitted to move the viewport.
    /// 
    /// The `move-viewport` signal is a [keybinding signal](class.SignalAction.html),
    /// which can be bound to key combinations to allow the user to move the viewport,
    /// i.e. change what part of the text view is visible in a containing scrolled
    /// window.
    /// 
    /// There are no default bindings for this signal.
    /// - Note: This represents the underlying `move-viewport` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter step: the granularity of the movement, as a `GtkScrollStep`
    /// - Parameter count: the number of `step` units to move
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `moveViewport` signal is emitted
    @discardableResult @inlinable func onMoveViewport(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ step: ScrollStep, _ count: Int) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, ScrollStep, Int), Void>
        let cCallback: @convention(c) (gpointer, UInt32, gint, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), ScrollStep(arg1), Int(arg2)))
            return output
        }
        return connect(
            signal: .moveViewport,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `move-viewport` signal for using the `connect(signal:)` methods
    static var moveViewportSignal: TextViewSignalName { .moveViewport }
    
    /// Gets emitted to paste the contents of the clipboard
    /// into the text view.
    /// 
    /// The `paste-clipboard` signal is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;v&lt;/kbd&gt; and
    /// &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Insert&lt;/kbd&gt;.
    /// - Note: This represents the underlying `paste-clipboard` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `pasteClipboard` signal is emitted
    @discardableResult @inlinable func onPasteClipboard(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .pasteClipboard,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `paste-clipboard` signal for using the `connect(signal:)` methods
    static var pasteClipboardSignal: TextViewSignalName { .pasteClipboard }
    
    /// Emitted when preedit text of the active IM changes.
    /// 
    /// If an input method is used, the typed text will not immediately
    /// be committed to the buffer. So if you are interested in the text,
    /// connect to this signal.
    /// 
    /// This signal is only emitted if the text at the given position
    /// is actually editable.
    /// - Note: This represents the underlying `preedit-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter preedit: the current preedit string
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `preeditChanged` signal is emitted
    @discardableResult @inlinable func onPreeditChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ preedit: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, String), Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!))
            return output
        }
        return connect(
            signal: .preeditChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `preedit-changed` signal for using the `connect(signal:)` methods
    static var preeditChangedSignal: TextViewSignalName { .preeditChanged }
    
    /// Gets emitted to select or unselect the complete contents of the text view.
    /// 
    /// The `select-all` signal is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;a&lt;/kbd&gt; and
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;/&lt;/kbd&gt; for selecting and
    /// &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;a&lt;/kbd&gt; and
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;\&lt;/kbd&gt; for unselecting.
    /// - Note: This represents the underlying `select-all` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter select: `true` to select, `false` to unselect
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `selectAll` signal is emitted
    @discardableResult @inlinable func onSelectAll(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ select: Bool) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, Bool), Void>
        let cCallback: @convention(c) (gpointer, gboolean, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), ((arg1) != 0)))
            return output
        }
        return connect(
            signal: .selectAll,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `select-all` signal for using the `connect(signal:)` methods
    static var selectAllSignal: TextViewSignalName { .selectAll }
    
    /// Gets emitted when the user initiates settings the "anchor" mark.
    /// 
    /// The `set-anchor` signal is a [keybinding signal](class.SignalAction.html)
    /// which gets emitted when the user initiates setting the "anchor"
    /// mark. The "anchor" mark gets placed at the same position as the
    /// "insert" mark.
    /// 
    /// This signal has no default bindings.
    /// - Note: This represents the underlying `set-anchor` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `setAnchor` signal is emitted
    @discardableResult @inlinable func onSetAnchor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .setAnchor,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `set-anchor` signal for using the `connect(signal:)` methods
    static var setAnchorSignal: TextViewSignalName { .setAnchor }
    
    /// Gets emitted to toggle the `cursor-visible` property.
    /// 
    /// The `toggle-cursor-visible` signal is a
    /// [keybinding signal](class.SignalAction.html).
    /// 
    /// The default binding for this signal is &lt;kbd&gt;F7&lt;/kbd&gt;.
    /// - Note: This represents the underlying `toggle-cursor-visible` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `toggleCursorVisible` signal is emitted
    @discardableResult @inlinable func onToggleCursorVisible(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .toggleCursorVisible,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `toggle-cursor-visible` signal for using the `connect(signal:)` methods
    static var toggleCursorVisibleSignal: TextViewSignalName { .toggleCursorVisible }
    
    /// Gets emitted to toggle the overwrite mode of the text view.
    /// 
    /// The `toggle-overwrite` signal is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default binding for this signal is &lt;kbd&gt;Insert&lt;/kbd&gt;.
    /// - Note: This represents the underlying `toggle-overwrite` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `toggleOverwrite` signal is emitted
    @discardableResult @inlinable func onToggleOverwrite(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .toggleOverwrite,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `toggle-overwrite` signal for using the `connect(signal:)` methods
    static var toggleOverwriteSignal: TextViewSignalName { .toggleOverwrite }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::accepts-tab` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAcceptsTab` signal is emitted
    @discardableResult @inlinable func onNotifyAcceptsTab(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyAcceptsTab,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::accepts-tab` signal for using the `connect(signal:)` methods
    static var notifyAcceptsTabSignal: TextViewSignalName { .notifyAcceptsTab }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::bottom-margin` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyBottomMargin` signal is emitted
    @discardableResult @inlinable func onNotifyBottomMargin(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyBottomMargin,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::bottom-margin` signal for using the `connect(signal:)` methods
    static var notifyBottomMarginSignal: TextViewSignalName { .notifyBottomMargin }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::buffer` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyBuffer` signal is emitted
    @discardableResult @inlinable func onNotifyBuffer(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyBuffer,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::buffer` signal for using the `connect(signal:)` methods
    static var notifyBufferSignal: TextViewSignalName { .notifyBuffer }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::cursor-visible` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyCursorVisible` signal is emitted
    @discardableResult @inlinable func onNotifyCursorVisible(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyCursorVisible,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::cursor-visible` signal for using the `connect(signal:)` methods
    static var notifyCursorVisibleSignal: TextViewSignalName { .notifyCursorVisible }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::editable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEditable` signal is emitted
    @discardableResult @inlinable func onNotifyEditable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyEditable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::editable` signal for using the `connect(signal:)` methods
    static var notifyEditableSignal: TextViewSignalName { .notifyEditable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::extra-menu` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyExtraMenu` signal is emitted
    @discardableResult @inlinable func onNotifyExtraMenu(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyExtraMenu,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::extra-menu` signal for using the `connect(signal:)` methods
    static var notifyExtraMenuSignal: TextViewSignalName { .notifyExtraMenu }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::im-module` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyImModule` signal is emitted
    @discardableResult @inlinable func onNotifyImModule(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyImModule,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::im-module` signal for using the `connect(signal:)` methods
    static var notifyImModuleSignal: TextViewSignalName { .notifyImModule }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::indent` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyIndent` signal is emitted
    @discardableResult @inlinable func onNotifyIndent(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyIndent,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::indent` signal for using the `connect(signal:)` methods
    static var notifyIndentSignal: TextViewSignalName { .notifyIndent }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::input-hints` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyInputHints` signal is emitted
    @discardableResult @inlinable func onNotifyInputHints(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyInputHints,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::input-hints` signal for using the `connect(signal:)` methods
    static var notifyInputHintsSignal: TextViewSignalName { .notifyInputHints }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::input-purpose` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyInputPurpose` signal is emitted
    @discardableResult @inlinable func onNotifyInputPurpose(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyInputPurpose,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::input-purpose` signal for using the `connect(signal:)` methods
    static var notifyInputPurposeSignal: TextViewSignalName { .notifyInputPurpose }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::justification` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyJustification` signal is emitted
    @discardableResult @inlinable func onNotifyJustification(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyJustification,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::justification` signal for using the `connect(signal:)` methods
    static var notifyJustificationSignal: TextViewSignalName { .notifyJustification }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::left-margin` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyLeftMargin` signal is emitted
    @discardableResult @inlinable func onNotifyLeftMargin(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyLeftMargin,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::left-margin` signal for using the `connect(signal:)` methods
    static var notifyLeftMarginSignal: TextViewSignalName { .notifyLeftMargin }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::monospace` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMonospace` signal is emitted
    @discardableResult @inlinable func onNotifyMonospace(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyMonospace,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::monospace` signal for using the `connect(signal:)` methods
    static var notifyMonospaceSignal: TextViewSignalName { .notifyMonospace }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::overwrite` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyOverwrite` signal is emitted
    @discardableResult @inlinable func onNotifyOverwrite(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyOverwrite,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::overwrite` signal for using the `connect(signal:)` methods
    static var notifyOverwriteSignal: TextViewSignalName { .notifyOverwrite }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::pixels-above-lines` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPixelsAboveLines` signal is emitted
    @discardableResult @inlinable func onNotifyPixelsAboveLines(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyPixelsAboveLines,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::pixels-above-lines` signal for using the `connect(signal:)` methods
    static var notifyPixelsAboveLinesSignal: TextViewSignalName { .notifyPixelsAboveLines }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::pixels-below-lines` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPixelsBelowLines` signal is emitted
    @discardableResult @inlinable func onNotifyPixelsBelowLines(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyPixelsBelowLines,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::pixels-below-lines` signal for using the `connect(signal:)` methods
    static var notifyPixelsBelowLinesSignal: TextViewSignalName { .notifyPixelsBelowLines }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::pixels-inside-wrap` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPixelsInsideWrap` signal is emitted
    @discardableResult @inlinable func onNotifyPixelsInsideWrap(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyPixelsInsideWrap,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::pixels-inside-wrap` signal for using the `connect(signal:)` methods
    static var notifyPixelsInsideWrapSignal: TextViewSignalName { .notifyPixelsInsideWrap }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::right-margin` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyRightMargin` signal is emitted
    @discardableResult @inlinable func onNotifyRightMargin(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyRightMargin,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::right-margin` signal for using the `connect(signal:)` methods
    static var notifyRightMarginSignal: TextViewSignalName { .notifyRightMargin }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::tabs` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTabs` signal is emitted
    @discardableResult @inlinable func onNotifyTabs(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyTabs,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::tabs` signal for using the `connect(signal:)` methods
    static var notifyTabsSignal: TextViewSignalName { .notifyTabs }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::top-margin` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTopMargin` signal is emitted
    @discardableResult @inlinable func onNotifyTopMargin(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyTopMargin,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::top-margin` signal for using the `connect(signal:)` methods
    static var notifyTopMarginSignal: TextViewSignalName { .notifyTopMargin }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::wrap-mode` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWrapMode` signal is emitted
    @discardableResult @inlinable func onNotifyWrapMode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TextViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TextViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyWrapMode,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::wrap-mode` signal for using the `connect(signal:)` methods
    static var notifyWrapModeSignal: TextViewSignalName { .notifyWrapMode }
    
}

// MARK: TextView Class: TextViewProtocol extension (methods and fields)
public extension TextViewProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextView` instance.
    @inlinable var text_view_ptr: UnsafeMutablePointer<GtkTextView>! { return ptr?.assumingMemoryBound(to: GtkTextView.self) }

    /// Adds a child widget in the text buffer, at the given `anchor`.
    @inlinable func addChildAtAnchor<TextChildAnchorT: TextChildAnchorProtocol, WidgetT: WidgetProtocol>(child: WidgetT, anchor: TextChildAnchorT) {
        
        gtk_text_view_add_child_at_anchor(text_view_ptr, child.widget_ptr, anchor.text_child_anchor_ptr)
        
    }

    /// Adds `child` at a fixed coordinate in the `GtkTextView`'s text window.
    /// 
    /// The `xpos` and `ypos` must be in buffer coordinates (see
    /// [method`Gtk.TextView.get_iter_location`] to convert to
    /// buffer coordinates).
    /// 
    /// `child` will scroll with the text view.
    /// 
    /// If instead you want a widget that will not move with the
    /// `GtkTextView` contents see `GtkOverlay`.
    @inlinable func addOverlay<WidgetT: WidgetProtocol>(child: WidgetT, xpos: Int, ypos: Int) {
        
        gtk_text_view_add_overlay(text_view_ptr, child.widget_ptr, gint(xpos), gint(ypos))
        
    }

    /// Moves the given `iter` backward by one display (wrapped) line.
    /// 
    /// A display line is different from a paragraph. Paragraphs are
    /// separated by newlines or other paragraph separator characters.
    /// Display lines are created by line-wrapping a paragraph. If
    /// wrapping is turned off, display lines and paragraphs will be the
    /// same. Display lines are divided differently for each view, since
    /// they depend on the view’s width; paragraphs are the same in all
    /// views, since they depend on the contents of the `GtkTextBuffer`.
    @inlinable func backwardDisplayLine<TextIterT: TextIterProtocol>(iter: TextIterT) -> Bool {
        let result = gtk_text_view_backward_display_line(text_view_ptr, iter.text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves the given `iter` backward to the next display line start.
    /// 
    /// A display line is different from a paragraph. Paragraphs are
    /// separated by newlines or other paragraph separator characters.
    /// Display lines are created by line-wrapping a paragraph. If
    /// wrapping is turned off, display lines and paragraphs will be the
    /// same. Display lines are divided differently for each view, since
    /// they depend on the view’s width; paragraphs are the same in all
    /// views, since they depend on the contents of the `GtkTextBuffer`.
    @inlinable func backwardDisplayLineStart<TextIterT: TextIterProtocol>(iter: TextIterT) -> Bool {
        let result = gtk_text_view_backward_display_line_start(text_view_ptr, iter.text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Converts buffer coordinates to window coordinates.
    @inlinable func bufferToWindowCoords(win: GtkTextWindowType, bufferX: Int, bufferY: Int, windowX: UnsafeMutablePointer<gint>! = nil, windowY: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_text_view_buffer_to_window_coords(text_view_ptr, win, gint(bufferX), gint(bufferY), windowX, windowY)
        
    }

    /// Moves the given `iter` forward by one display (wrapped) line.
    /// 
    /// A display line is different from a paragraph. Paragraphs are
    /// separated by newlines or other paragraph separator characters.
    /// Display lines are created by line-wrapping a paragraph. If
    /// wrapping is turned off, display lines and paragraphs will be the
    /// same. Display lines are divided differently for each view, since
    /// they depend on the view’s width; paragraphs are the same in all
    /// views, since they depend on the contents of the `GtkTextBuffer`.
    @inlinable func forwardDisplayLine<TextIterT: TextIterProtocol>(iter: TextIterT) -> Bool {
        let result = gtk_text_view_forward_display_line(text_view_ptr, iter.text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves the given `iter` forward to the next display line end.
    /// 
    /// A display line is different from a paragraph. Paragraphs are
    /// separated by newlines or other paragraph separator characters.
    /// Display lines are created by line-wrapping a paragraph. If
    /// wrapping is turned off, display lines and paragraphs will be the
    /// same. Display lines are divided differently for each view, since
    /// they depend on the view’s width; paragraphs are the same in all
    /// views, since they depend on the contents of the `GtkTextBuffer`.
    @inlinable func forwardDisplayLineEnd<TextIterT: TextIterProtocol>(iter: TextIterT) -> Bool {
        let result = gtk_text_view_forward_display_line_end(text_view_ptr, iter.text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns whether pressing the &lt;kbd&gt;Tab&lt;/kbd&gt; key inserts a tab characters.
    /// 
    /// See [method`Gtk.TextView.set_accepts_tab`].
    @inlinable func getAcceptsTab() -> Bool {
        let result = gtk_text_view_get_accepts_tab(text_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the bottom margin for text in the `text_view`.
    @inlinable func getBottomMargin() -> Int {
        let result = gtk_text_view_get_bottom_margin(text_view_ptr)
        let rv = Int(result)
        return rv
    }

    /// Returns the `GtkTextBuffer` being displayed by this text view.
    /// 
    /// The reference count on the buffer is not incremented; the caller
    /// of this function won’t own a new reference.
    @inlinable func getBuffer() -> TextBufferRef! {
        let result = gtk_text_view_get_buffer(text_view_ptr)
        let rv = TextBufferRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Determine the positions of the strong and weak cursors if the
    /// insertion point is at `iter`.
    /// 
    /// The position of each cursor is stored as a zero-width rectangle.
    /// The strong cursor location is the location where characters of
    /// the directionality equal to the base direction of the paragraph
    /// are inserted. The weak cursor location is the location where
    /// characters of the directionality opposite to the base direction
    /// of the paragraph are inserted.
    /// 
    /// If `iter` is `nil`, the actual cursor position is used.
    /// 
    /// Note that if `iter` happens to be the actual cursor position, and
    /// there is currently an IM preedit sequence being entered, the
    /// returned locations will be adjusted to account for the preedit
    /// cursor’s offset within the preedit sequence.
    /// 
    /// The rectangle position is in buffer coordinates; use
    /// [method`Gtk.TextView.buffer_to_window_coords`] to convert these
    /// coordinates to coordinates for one of the windows in the text view.
    @inlinable func getCursorLocations(iter: TextIterRef? = nil, strong: Gdk.RectangleRef? = nil, `weak`: Gdk.RectangleRef? = nil) {
            
        gtk_text_view_get_cursor_locations(text_view_ptr, iter?.text_iter_ptr, strong?.rectangle_ptr, `weak`?.rectangle_ptr)
            
    }
    /// Determine the positions of the strong and weak cursors if the
    /// insertion point is at `iter`.
    /// 
    /// The position of each cursor is stored as a zero-width rectangle.
    /// The strong cursor location is the location where characters of
    /// the directionality equal to the base direction of the paragraph
    /// are inserted. The weak cursor location is the location where
    /// characters of the directionality opposite to the base direction
    /// of the paragraph are inserted.
    /// 
    /// If `iter` is `nil`, the actual cursor position is used.
    /// 
    /// Note that if `iter` happens to be the actual cursor position, and
    /// there is currently an IM preedit sequence being entered, the
    /// returned locations will be adjusted to account for the preedit
    /// cursor’s offset within the preedit sequence.
    /// 
    /// The rectangle position is in buffer coordinates; use
    /// [method`Gtk.TextView.buffer_to_window_coords`] to convert these
    /// coordinates to coordinates for one of the windows in the text view.
    @inlinable func getCursorLocations<GdkRectangleT: Gdk.RectangleProtocol, TextIterT: TextIterProtocol>(iter: TextIterT?, strong: GdkRectangleT?, `weak`: GdkRectangleT?) {
        
        gtk_text_view_get_cursor_locations(text_view_ptr, iter?.text_iter_ptr, strong?.rectangle_ptr, `weak`?.rectangle_ptr)
        
    }

    /// Find out whether the cursor should be displayed.
    @inlinable func getCursorVisible() -> Bool {
        let result = gtk_text_view_get_cursor_visible(text_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns the default editability of the `GtkTextView`.
    /// 
    /// Tags in the buffer may override this setting for some ranges of text.
    @inlinable func getEditable() -> Bool {
        let result = gtk_text_view_get_editable(text_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the menu model that gets added to the context menu
    /// or `nil` if none has been set.
    @inlinable func getExtraMenu() -> GIO.MenuModelRef! {
        let result = gtk_text_view_get_extra_menu(text_view_ptr)
        let rv = GIO.MenuModelRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets a `GtkWidget` that has previously been set as gutter.
    /// 
    /// See [method`Gtk.TextView.set_gutter`].
    /// 
    /// `win` must be one of `GTK_TEXT_WINDOW_LEFT`, `GTK_TEXT_WINDOW_RIGHT`,
    /// `GTK_TEXT_WINDOW_TOP`, or `GTK_TEXT_WINDOW_BOTTOM`.
    @inlinable func getGutter(win: GtkTextWindowType) -> WidgetRef! {
        let result = gtk_text_view_get_gutter(text_view_ptr, win)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Gets the default indentation of paragraphs in `text_view`.
    /// 
    /// Tags in the view’s buffer may override the default.
    /// The indentation may be negative.
    @inlinable func getIndent() -> Int {
        let result = gtk_text_view_get_indent(text_view_ptr)
        let rv = Int(result)
        return rv
    }

    /// Gets the `input-hints` of the `GtkTextView`.
    @inlinable func getInputHints() -> Gtk.InputHints {
        let result = gtk_text_view_get_input_hints(text_view_ptr)
        let rv = InputHints(result)
        return rv
    }

    /// Gets the `input-purpose` of the `GtkTextView`.
    @inlinable func getInputPurpose() -> GtkInputPurpose {
        let result = gtk_text_view_get_input_purpose(text_view_ptr)
        let rv = result
        return rv
    }

    /// Retrieves the iterator at buffer coordinates `x` and `y`.
    /// 
    /// Buffer coordinates are coordinates for the entire buffer, not just
    /// the currently-displayed portion. If you have coordinates from an
    /// event, you have to convert those to buffer coordinates with
    /// [method`Gtk.TextView.window_to_buffer_coords`].
    @inlinable func getIterAtLocation<TextIterT: TextIterProtocol>(iter: TextIterT, x: Int, y: Int) -> Bool {
        let result = gtk_text_view_get_iter_at_location(text_view_ptr, iter.text_iter_ptr, gint(x), gint(y))
        let rv = ((result) != 0)
        return rv
    }

    /// Retrieves the iterator pointing to the character at buffer
    /// coordinates `x` and `y`.
    /// 
    /// Buffer coordinates are coordinates for the entire buffer, not just
    /// the currently-displayed portion. If you have coordinates from an event,
    /// you have to convert those to buffer coordinates with
    /// [method`Gtk.TextView.window_to_buffer_coords`].
    /// 
    /// Note that this is different from [method`Gtk.TextView.get_iter_at_location`],
    /// which returns cursor locations, i.e. positions between characters.
    @inlinable func getIterAtPosition<TextIterT: TextIterProtocol>(iter: TextIterT, trailing: UnsafeMutablePointer<gint>! = nil, x: Int, y: Int) -> Bool {
        let result = gtk_text_view_get_iter_at_position(text_view_ptr, iter.text_iter_ptr, trailing, gint(x), gint(y))
        let rv = ((result) != 0)
        return rv
    }

    /// Gets a rectangle which roughly contains the character at `iter`.
    /// 
    /// The rectangle position is in buffer coordinates; use
    /// [method`Gtk.TextView.buffer_to_window_coords`] to convert these
    /// coordinates to coordinates for one of the windows in the text view.
    @inlinable func getIterLocation<GdkRectangleT: Gdk.RectangleProtocol, TextIterT: TextIterProtocol>(iter: TextIterT, location: GdkRectangleT) {
        
        gtk_text_view_get_iter_location(text_view_ptr, iter.text_iter_ptr, location.rectangle_ptr)
        
    }

    /// Gets the default justification of paragraphs in `text_view`.
    /// 
    /// Tags in the buffer may override the default.
    @inlinable func getJustification() -> GtkJustification {
        let result = gtk_text_view_get_justification(text_view_ptr)
        let rv = result
        return rv
    }

    /// Gets the default left margin size of paragraphs in the `text_view`.
    /// 
    /// Tags in the buffer may override the default.
    @inlinable func getLeftMargin() -> Int {
        let result = gtk_text_view_get_left_margin(text_view_ptr)
        let rv = Int(result)
        return rv
    }

    /// Gets the `GtkTextIter` at the start of the line containing
    /// the coordinate `y`.
    /// 
    /// `y` is in buffer coordinates, convert from window coordinates with
    /// [method`Gtk.TextView.window_to_buffer_coords`]. If non-`nil`,
    /// `line_top` will be filled with the coordinate of the top edge
    /// of the line.
    @inlinable func getLineAtY<TextIterT: TextIterProtocol>(targetIter: TextIterT, y: Int, lineTop: UnsafeMutablePointer<gint>!) {
        
        gtk_text_view_get_line_at_y(text_view_ptr, targetIter.text_iter_ptr, gint(y), lineTop)
        
    }

    /// Gets the y coordinate of the top of the line containing `iter`,
    /// and the height of the line.
    /// 
    /// The coordinate is a buffer coordinate; convert to window
    /// coordinates with [method`Gtk.TextView.buffer_to_window_coords`].
    @inlinable func getLineYrange<TextIterT: TextIterProtocol>(iter: TextIterT, y: UnsafeMutablePointer<gint>!, height: UnsafeMutablePointer<gint>!) {
        
        gtk_text_view_get_line_yrange(text_view_ptr, iter.text_iter_ptr, y, height)
        
    }

    /// Gets the `PangoContext` that is used for rendering LTR directed
    /// text layouts.
    /// 
    /// The context may be replaced when CSS changes occur.
    @inlinable func getLtrContext() -> Pango.ContextRef! {
        let result = gtk_text_view_get_ltr_context(text_view_ptr)
        let rv = Pango.ContextRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets whether the `GtkTextView` uses monospace styling.
    @inlinable func getMonospace() -> Bool {
        let result = gtk_text_view_get_monospace(text_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns whether the `GtkTextView` is in overwrite mode or not.
    @inlinable func getOverwrite() -> Bool {
        let result = gtk_text_view_get_overwrite(text_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the default number of pixels to put above paragraphs.
    /// 
    /// Adding this function with [method`Gtk.TextView.get_pixels_below_lines`]
    /// is equal to the line space between each paragraph.
    @inlinable func getPixelsAboveLines() -> Int {
        let result = gtk_text_view_get_pixels_above_lines(text_view_ptr)
        let rv = Int(result)
        return rv
    }

    /// Gets the default number of pixels to put below paragraphs.
    /// 
    /// The line space is the sum of the value returned by this function and
    /// the value returned by [method`Gtk.TextView.get_pixels_above_lines`].
    @inlinable func getPixelsBelowLines() -> Int {
        let result = gtk_text_view_get_pixels_below_lines(text_view_ptr)
        let rv = Int(result)
        return rv
    }

    /// Gets the default number of pixels to put between wrapped lines
    /// inside a paragraph.
    @inlinable func getPixelsInsideWrap() -> Int {
        let result = gtk_text_view_get_pixels_inside_wrap(text_view_ptr)
        let rv = Int(result)
        return rv
    }

    /// Gets the default right margin for text in `text_view`.
    /// 
    /// Tags in the buffer may override the default.
    @inlinable func getRightMargin() -> Int {
        let result = gtk_text_view_get_right_margin(text_view_ptr)
        let rv = Int(result)
        return rv
    }

    /// Gets the `PangoContext` that is used for rendering RTL directed
    /// text layouts.
    /// 
    /// The context may be replaced when CSS changes occur.
    @inlinable func getRtlContext() -> Pango.ContextRef! {
        let result = gtk_text_view_get_rtl_context(text_view_ptr)
        let rv = Pango.ContextRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the default tabs for `text_view`.
    /// 
    /// Tags in the buffer may override the defaults. The returned array
    /// will be `nil` if “standard” (8-space) tabs are used. Free the
    /// return value with [method`Pango.TabArray.free`].
    @inlinable func getTabs() -> Pango.TabArrayRef! {
        let result = gtk_text_view_get_tabs(text_view_ptr)
        let rv = Pango.TabArrayRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the top margin for text in the `text_view`.
    @inlinable func getTopMargin() -> Int {
        let result = gtk_text_view_get_top_margin(text_view_ptr)
        let rv = Int(result)
        return rv
    }

    /// Fills `visible_rect` with the currently-visible
    /// region of the buffer, in buffer coordinates.
    /// 
    /// Convert to window coordinates with
    /// [method`Gtk.TextView.buffer_to_window_coords`].
    @inlinable func get<GdkRectangleT: Gdk.RectangleProtocol>(visibleRect: GdkRectangleT) {
        
        gtk_text_view_get_visible_rect(text_view_ptr, visibleRect.rectangle_ptr)
        
    }

    /// Gets the line wrapping for the view.
    @inlinable func getWrapMode() -> GtkWrapMode {
        let result = gtk_text_view_get_wrap_mode(text_view_ptr)
        let rv = result
        return rv
    }

    /// Allow the `GtkTextView` input method to internally handle key press
    /// and release events.
    /// 
    /// If this function returns `true`, then no further processing should be
    /// done for this key event. See [method`Gtk.IMContext.filter_keypress`].
    /// 
    /// Note that you are expected to call this function from your handler
    /// when overriding key event handling. This is needed in the case when
    /// you need to insert your own key handling between the input method
    /// and the default key event handling of the `GtkTextView`.
    /// 
    /// ```c
    /// static gboolean
    /// gtk_foo_bar_key_press_event (GtkWidget *widget,
    ///                              GdkEvent  *event)
    /// {
    ///   guint keyval;
    /// 
    ///   gdk_event_get_keyval ((GdkEvent*)event, &keyval);
    /// 
    ///   if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
    ///     {
    ///       if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
    ///         return TRUE;
    ///     }
    /// 
    ///   // Do some stuff
    /// 
    ///   return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)-&gt;key_press_event (widget, event);
    /// }
    /// ```
    @inlinable func imContextFilterKeypress<GdkEventT: Gdk.EventProtocol>(event: GdkEventT) -> Bool {
        let result = gtk_text_view_im_context_filter_keypress(text_view_ptr, event.event_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves a mark within the buffer so that it's
    /// located within the currently-visible text area.
    @inlinable func moveMarkOnscreen<TextMarkT: TextMarkProtocol>(mark: TextMarkT) -> Bool {
        let result = gtk_text_view_move_mark_onscreen(text_view_ptr, mark.text_mark_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Updates the position of a child.
    /// 
    /// See [method`Gtk.TextView.add_overlay`].
    @inlinable func moveOverlay<WidgetT: WidgetProtocol>(child: WidgetT, xpos: Int, ypos: Int) {
        
        gtk_text_view_move_overlay(text_view_ptr, child.widget_ptr, gint(xpos), gint(ypos))
        
    }

    /// Move the iterator a given number of characters visually, treating
    /// it as the strong cursor position.
    /// 
    /// If `count` is positive, then the new strong cursor position will
    /// be `count` positions to the right of the old cursor position.
    /// If `count` is negative then the new strong cursor position will
    /// be `count` positions to the left of the old cursor position.
    /// 
    /// In the presence of bi-directional text, the correspondence
    /// between logical and visual order will depend on the direction
    /// of the current run, and there may be jumps when the cursor
    /// is moved off of the end of a run.
    @inlinable func moveVisually<TextIterT: TextIterProtocol>(iter: TextIterT, count: Int) -> Bool {
        let result = gtk_text_view_move_visually(text_view_ptr, iter.text_iter_ptr, gint(count))
        let rv = ((result) != 0)
        return rv
    }

    /// Moves the cursor to the currently visible region of the
    /// buffer.
    @inlinable func placeCursorOnscreen() -> Bool {
        let result = gtk_text_view_place_cursor_onscreen(text_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Removes a child widget from `text_view`.
    @inlinable func remove<WidgetT: WidgetProtocol>(child: WidgetT) {
        
        gtk_text_view_remove(text_view_ptr, child.widget_ptr)
        
    }

    /// Ensures that the cursor is shown.
    /// 
    /// This also resets the time that it will stay blinking (or
    /// visible, in case blinking is disabled).
    /// 
    /// This function should be called in response to user input
    /// (e.g. from derived classes that override the textview's
    /// event handlers).
    @inlinable func resetCursorBlink() {
        
        gtk_text_view_reset_cursor_blink(text_view_ptr)
        
    }

    /// Reset the input method context of the text view if needed.
    /// 
    /// This can be necessary in the case where modifying the buffer
    /// would confuse on-going input method behavior.
    @inlinable func resetImContext() {
        
        gtk_text_view_reset_im_context(text_view_ptr)
        
    }

    /// Scrolls `text_view` the minimum distance such that `mark` is contained
    /// within the visible area of the widget.
    @inlinable func scrollMarkOnscreen<TextMarkT: TextMarkProtocol>(mark: TextMarkT) {
        
        gtk_text_view_scroll_mark_onscreen(text_view_ptr, mark.text_mark_ptr)
        
    }

    /// Scrolls `text_view` so that `iter` is on the screen in the position
    /// indicated by `xalign` and `yalign`.
    /// 
    /// An alignment of 0.0 indicates left or top, 1.0 indicates right or
    /// bottom, 0.5 means center. If `use_align` is `false`, the text scrolls
    /// the minimal distance to get the mark onscreen, possibly not scrolling
    /// at all. The effective screen for purposes of this function is reduced
    /// by a margin of size `within_margin`.
    /// 
    /// Note that this function uses the currently-computed height of the
    /// lines in the text buffer. Line heights are computed in an idle
    /// handler; so this function may not have the desired effect if it’s
    /// called before the height computations. To avoid oddness, consider
    /// using [method`Gtk.TextView.scroll_to_mark`] which saves a point to be
    /// scrolled to after line validation.
    @inlinable func scrollTo<TextIterT: TextIterProtocol>(iter: TextIterT, within margin: CDouble, useAlign: Bool, xalign: CDouble, yalign: CDouble) -> Bool {
        let result = gtk_text_view_scroll_to_iter(text_view_ptr, iter.text_iter_ptr, margin, gboolean((useAlign) ? 1 : 0), xalign, yalign)
        let rv = ((result) != 0)
        return rv
    }

    /// Scrolls `text_view` so that `mark` is on the screen in the position
    /// indicated by `xalign` and `yalign`.
    /// 
    /// An alignment of 0.0 indicates left or top, 1.0 indicates right or
    /// bottom, 0.5 means center. If `use_align` is `false`, the text scrolls
    /// the minimal distance to get the mark onscreen, possibly not scrolling
    /// at all. The effective screen for purposes of this function is reduced
    /// by a margin of size `within_margin`.
    @inlinable func scrollTo<TextMarkT: TextMarkProtocol>(mark: TextMarkT, within margin: CDouble, useAlign: Bool, xalign: CDouble, yalign: CDouble) {
        
        gtk_text_view_scroll_to_mark(text_view_ptr, mark.text_mark_ptr, margin, gboolean((useAlign) ? 1 : 0), xalign, yalign)
        
    }

    /// Sets the behavior of the text widget when the &lt;kbd&gt;Tab&lt;/kbd&gt; key is pressed.
    /// 
    /// If `accepts_tab` is `true`, a tab character is inserted. If `accepts_tab`
    /// is `false` the keyboard focus is moved to the next widget in the focus
    /// chain.
    @inlinable func set(acceptsTab: Bool) {
        
        gtk_text_view_set_accepts_tab(text_view_ptr, gboolean((acceptsTab) ? 1 : 0))
        
    }

    /// Sets the bottom margin for text in `text_view`.
    /// 
    /// Note that this function is confusingly named.
    /// In CSS terms, the value set here is padding.
    @inlinable func set(bottomMargin: Int) {
        
        gtk_text_view_set_bottom_margin(text_view_ptr, gint(bottomMargin))
        
    }

    /// Sets `buffer` as the buffer being displayed by `text_view`.
    /// 
    /// The previous buffer displayed by the text view is unreferenced, and
    /// a reference is added to `buffer`. If you owned a reference to `buffer`
    /// before passing it to this function, you must remove that reference
    /// yourself; `GtkTextView` will not “adopt” it.
    @inlinable func set(buffer: TextBufferRef? = nil) {
            
        gtk_text_view_set_buffer(text_view_ptr, buffer?.text_buffer_ptr)
            
    }
    /// Sets `buffer` as the buffer being displayed by `text_view`.
    /// 
    /// The previous buffer displayed by the text view is unreferenced, and
    /// a reference is added to `buffer`. If you owned a reference to `buffer`
    /// before passing it to this function, you must remove that reference
    /// yourself; `GtkTextView` will not “adopt” it.
    @inlinable func set<TextBufferT: TextBufferProtocol>(buffer: TextBufferT?) {
        
        gtk_text_view_set_buffer(text_view_ptr, buffer?.text_buffer_ptr)
        
    }

    /// Toggles whether the insertion point should be displayed.
    /// 
    /// A buffer with no editable text probably shouldn’t have a visible
    /// cursor, so you may want to turn the cursor off.
    /// 
    /// Note that this property may be overridden by the
    /// [property`GtkSettings:gtk-keynav-use-caret`] setting.
    @inlinable func setCursorVisible(setting: Bool) {
        
        gtk_text_view_set_cursor_visible(text_view_ptr, gboolean((setting) ? 1 : 0))
        
    }

    /// Sets the default editability of the `GtkTextView`.
    /// 
    /// You can override this default setting with tags in the buffer,
    /// using the “editable” attribute of tags.
    @inlinable func setEditable(setting: Bool) {
        
        gtk_text_view_set_editable(text_view_ptr, gboolean((setting) ? 1 : 0))
        
    }

    /// Sets a menu model to add when constructing the context
    /// menu for `text_view`.
    /// 
    /// You can pass `nil` to remove a previously set extra menu.
    @inlinable func setExtraMenu(model: GIO.MenuModelRef? = nil) {
            
        gtk_text_view_set_extra_menu(text_view_ptr, model?.menu_model_ptr)
            
    }
    /// Sets a menu model to add when constructing the context
    /// menu for `text_view`.
    /// 
    /// You can pass `nil` to remove a previously set extra menu.
    @inlinable func setExtraMenu<GioMenuModelT: GIO.MenuModelProtocol>(model: GioMenuModelT?) {
        
        gtk_text_view_set_extra_menu(text_view_ptr, model?.menu_model_ptr)
        
    }

    /// Places `widget` into the gutter specified by `win`.
    /// 
    /// `win` must be one of `GTK_TEXT_WINDOW_LEFT`, `GTK_TEXT_WINDOW_RIGHT`,
    /// `GTK_TEXT_WINDOW_TOP`, or `GTK_TEXT_WINDOW_BOTTOM`.
    @inlinable func setGutter(win: GtkTextWindowType, widget: WidgetRef? = nil) {
            
        gtk_text_view_set_gutter(text_view_ptr, win, widget?.widget_ptr)
            
    }
    /// Places `widget` into the gutter specified by `win`.
    /// 
    /// `win` must be one of `GTK_TEXT_WINDOW_LEFT`, `GTK_TEXT_WINDOW_RIGHT`,
    /// `GTK_TEXT_WINDOW_TOP`, or `GTK_TEXT_WINDOW_BOTTOM`.
    @inlinable func setGutter<WidgetT: WidgetProtocol>(win: GtkTextWindowType, widget: WidgetT?) {
        
        gtk_text_view_set_gutter(text_view_ptr, win, widget?.widget_ptr)
        
    }

    /// Sets the default indentation for paragraphs in `text_view`.
    /// 
    /// Tags in the buffer may override the default.
    @inlinable func set(indent: Int) {
        
        gtk_text_view_set_indent(text_view_ptr, gint(indent))
        
    }

    /// Sets the `input-hints` of the `GtkTextView`.
    /// 
    /// The `input-hints` allow input methods to fine-tune
    /// their behaviour.
    @inlinable func setInput(hints: InputHints) {
        
        gtk_text_view_set_input_hints(text_view_ptr, hints.value)
        
    }

    /// Sets the `input-purpose` of the `GtkTextView`.
    /// 
    /// The `input-purpose` can be used by on-screen keyboards
    /// and other input methods to adjust their behaviour.
    @inlinable func setInput(purpose: GtkInputPurpose) {
        
        gtk_text_view_set_input_purpose(text_view_ptr, purpose)
        
    }

    /// Sets the default justification of text in `text_view`.
    /// 
    /// Tags in the view’s buffer may override the default.
    @inlinable func set(justification: GtkJustification) {
        
        gtk_text_view_set_justification(text_view_ptr, justification)
        
    }

    /// Sets the default left margin for text in `text_view`.
    /// 
    /// Tags in the buffer may override the default.
    /// 
    /// Note that this function is confusingly named.
    /// In CSS terms, the value set here is padding.
    @inlinable func set(leftMargin: Int) {
        
        gtk_text_view_set_left_margin(text_view_ptr, gint(leftMargin))
        
    }

    /// Sets whether the `GtkTextView` should display text in
    /// monospace styling.
    @inlinable func set(monospace: Bool) {
        
        gtk_text_view_set_monospace(text_view_ptr, gboolean((monospace) ? 1 : 0))
        
    }

    /// Changes the `GtkTextView` overwrite mode.
    @inlinable func set(overwrite: Bool) {
        
        gtk_text_view_set_overwrite(text_view_ptr, gboolean((overwrite) ? 1 : 0))
        
    }

    /// Sets the default number of blank pixels above paragraphs in `text_view`.
    /// 
    /// Tags in the buffer for `text_view` may override the defaults.
    @inlinable func set(pixelsAboveLines: Int) {
        
        gtk_text_view_set_pixels_above_lines(text_view_ptr, gint(pixelsAboveLines))
        
    }

    /// Sets the default number of pixels of blank space
    /// to put below paragraphs in `text_view`.
    /// 
    /// May be overridden by tags applied to `text_view`’s buffer.
    @inlinable func set(pixelsBelowLines: Int) {
        
        gtk_text_view_set_pixels_below_lines(text_view_ptr, gint(pixelsBelowLines))
        
    }

    /// Sets the default number of pixels of blank space to leave between
    /// display/wrapped lines within a paragraph.
    /// 
    /// May be overridden by tags in `text_view`’s buffer.
    @inlinable func set(pixelsInsideWrap: Int) {
        
        gtk_text_view_set_pixels_inside_wrap(text_view_ptr, gint(pixelsInsideWrap))
        
    }

    /// Sets the default right margin for text in the text view.
    /// 
    /// Tags in the buffer may override the default.
    /// 
    /// Note that this function is confusingly named.
    /// In CSS terms, the value set here is padding.
    @inlinable func set(rightMargin: Int) {
        
        gtk_text_view_set_right_margin(text_view_ptr, gint(rightMargin))
        
    }

    /// Sets the default tab stops for paragraphs in `text_view`.
    /// 
    /// Tags in the buffer may override the default.
    @inlinable func set<PangoTabArrayT: Pango.TabArrayProtocol>(tabs: PangoTabArrayT) {
        
        gtk_text_view_set_tabs(text_view_ptr, tabs.tab_array_ptr)
        
    }

    /// Sets the top margin for text in `text_view`.
    /// 
    /// Note that this function is confusingly named.
    /// In CSS terms, the value set here is padding.
    @inlinable func set(topMargin: Int) {
        
        gtk_text_view_set_top_margin(text_view_ptr, gint(topMargin))
        
    }

    /// Sets the line wrapping for the view.
    @inlinable func set(wrapMode: GtkWrapMode) {
        
        gtk_text_view_set_wrap_mode(text_view_ptr, wrapMode)
        
    }

    /// Determines whether `iter` is at the start of a display line.
    /// 
    /// See [method`Gtk.TextView.forward_display_line`] for an
    /// explanation of display lines vs. paragraphs.
    @inlinable func startsDisplayLine<TextIterT: TextIterProtocol>(iter: TextIterT) -> Bool {
        let result = gtk_text_view_starts_display_line(text_view_ptr, iter.text_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Converts coordinates on the window identified by `win` to buffer
    /// coordinates.
    @inlinable func windowToBufferCoords(win: GtkTextWindowType, windowX: Int, windowY: Int, bufferX: UnsafeMutablePointer<gint>! = nil, bufferY: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_text_view_window_to_buffer_coords(text_view_ptr, win, gint(windowX), gint(windowY), bufferX, bufferY)
        
    }
    /// Returns whether pressing the &lt;kbd&gt;Tab&lt;/kbd&gt; key inserts a tab characters.
    /// 
    /// See [method`Gtk.TextView.set_accepts_tab`].
    @inlinable var acceptsTab: Bool {
        /// Returns whether pressing the &lt;kbd&gt;Tab&lt;/kbd&gt; key inserts a tab characters.
        /// 
        /// See [method`Gtk.TextView.set_accepts_tab`].
        get {
            let result = gtk_text_view_get_accepts_tab(text_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets the behavior of the text widget when the &lt;kbd&gt;Tab&lt;/kbd&gt; key is pressed.
        /// 
        /// If `accepts_tab` is `true`, a tab character is inserted. If `accepts_tab`
        /// is `false` the keyboard focus is moved to the next widget in the focus
        /// chain.
        nonmutating set {
            gtk_text_view_set_accepts_tab(text_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the bottom margin for text in the `text_view`.
    @inlinable var bottomMargin: Int {
        /// Gets the bottom margin for text in the `text_view`.
        get {
            let result = gtk_text_view_get_bottom_margin(text_view_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the bottom margin for text in `text_view`.
        /// 
        /// Note that this function is confusingly named.
        /// In CSS terms, the value set here is padding.
        nonmutating set {
            gtk_text_view_set_bottom_margin(text_view_ptr, gint(newValue))
        }
    }

    /// The buffer which is displayed.
    @inlinable var buffer: TextBufferRef! {
        /// Returns the `GtkTextBuffer` being displayed by this text view.
        /// 
        /// The reference count on the buffer is not incremented; the caller
        /// of this function won’t own a new reference.
        get {
            let result = gtk_text_view_get_buffer(text_view_ptr)
        let rv = TextBufferRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets `buffer` as the buffer being displayed by `text_view`.
        /// 
        /// The previous buffer displayed by the text view is unreferenced, and
        /// a reference is added to `buffer`. If you owned a reference to `buffer`
        /// before passing it to this function, you must remove that reference
        /// yourself; `GtkTextView` will not “adopt” it.
        nonmutating set {
            gtk_text_view_set_buffer(text_view_ptr, UnsafeMutablePointer<GtkTextBuffer>(newValue?.text_buffer_ptr))
        }
    }

    /// Find out whether the cursor should be displayed.
    @inlinable var cursorVisible: Bool {
        /// Find out whether the cursor should be displayed.
        get {
            let result = gtk_text_view_get_cursor_visible(text_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Toggles whether the insertion point should be displayed.
        /// 
        /// A buffer with no editable text probably shouldn’t have a visible
        /// cursor, so you may want to turn the cursor off.
        /// 
        /// Note that this property may be overridden by the
        /// [property`GtkSettings:gtk-keynav-use-caret`] setting.
        nonmutating set {
            gtk_text_view_set_cursor_visible(text_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var editable: Bool {
        /// Returns the default editability of the `GtkTextView`.
        /// 
        /// Tags in the buffer may override this setting for some ranges of text.
        get {
            let result = gtk_text_view_get_editable(text_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets the default editability of the `GtkTextView`.
        /// 
        /// You can override this default setting with tags in the buffer,
        /// using the “editable” attribute of tags.
        nonmutating set {
            gtk_text_view_set_editable(text_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the menu model that gets added to the context menu
    /// or `nil` if none has been set.
    @inlinable var extraMenu: GIO.MenuModelRef! {
        /// Gets the menu model that gets added to the context menu
        /// or `nil` if none has been set.
        get {
            let result = gtk_text_view_get_extra_menu(text_view_ptr)
        let rv = GIO.MenuModelRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets a menu model to add when constructing the context
        /// menu for `text_view`.
        /// 
        /// You can pass `nil` to remove a previously set extra menu.
        nonmutating set {
            gtk_text_view_set_extra_menu(text_view_ptr, UnsafeMutablePointer<GMenuModel>(newValue?.menu_model_ptr))
        }
    }

    /// Amount to indent the paragraph, in pixels.
    @inlinable var indent: Int {
        /// Gets the default indentation of paragraphs in `text_view`.
        /// 
        /// Tags in the view’s buffer may override the default.
        /// The indentation may be negative.
        get {
            let result = gtk_text_view_get_indent(text_view_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the default indentation for paragraphs in `text_view`.
        /// 
        /// Tags in the buffer may override the default.
        nonmutating set {
            gtk_text_view_set_indent(text_view_ptr, gint(newValue))
        }
    }

    /// Gets the `input-hints` of the `GtkTextView`.
    @inlinable var inputHints: Gtk.InputHints {
        /// Gets the `input-hints` of the `GtkTextView`.
        get {
            let result = gtk_text_view_get_input_hints(text_view_ptr)
        let rv = InputHints(result)
            return rv
        }
        /// Sets the `input-hints` of the `GtkTextView`.
        /// 
        /// The `input-hints` allow input methods to fine-tune
        /// their behaviour.
        nonmutating set {
            gtk_text_view_set_input_hints(text_view_ptr, newValue.value)
        }
    }

    /// Gets the `input-purpose` of the `GtkTextView`.
    @inlinable var inputPurpose: GtkInputPurpose {
        /// Gets the `input-purpose` of the `GtkTextView`.
        get {
            let result = gtk_text_view_get_input_purpose(text_view_ptr)
        let rv = result
            return rv
        }
        /// Sets the `input-purpose` of the `GtkTextView`.
        /// 
        /// The `input-purpose` can be used by on-screen keyboards
        /// and other input methods to adjust their behaviour.
        nonmutating set {
            gtk_text_view_set_input_purpose(text_view_ptr, newValue)
        }
    }

    @inlinable var justification: GtkJustification {
        /// Gets the default justification of paragraphs in `text_view`.
        /// 
        /// Tags in the buffer may override the default.
        get {
            let result = gtk_text_view_get_justification(text_view_ptr)
        let rv = result
            return rv
        }
        /// Sets the default justification of text in `text_view`.
        /// 
        /// Tags in the view’s buffer may override the default.
        nonmutating set {
            gtk_text_view_set_justification(text_view_ptr, newValue)
        }
    }

    /// Gets the default left margin size of paragraphs in the `text_view`.
    /// 
    /// Tags in the buffer may override the default.
    @inlinable var leftMargin: Int {
        /// Gets the default left margin size of paragraphs in the `text_view`.
        /// 
        /// Tags in the buffer may override the default.
        get {
            let result = gtk_text_view_get_left_margin(text_view_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the default left margin for text in `text_view`.
        /// 
        /// Tags in the buffer may override the default.
        /// 
        /// Note that this function is confusingly named.
        /// In CSS terms, the value set here is padding.
        nonmutating set {
            gtk_text_view_set_left_margin(text_view_ptr, gint(newValue))
        }
    }

    /// Gets the `PangoContext` that is used for rendering LTR directed
    /// text layouts.
    /// 
    /// The context may be replaced when CSS changes occur.
    @inlinable var ltrContext: Pango.ContextRef! {
        /// Gets the `PangoContext` that is used for rendering LTR directed
        /// text layouts.
        /// 
        /// The context may be replaced when CSS changes occur.
        get {
            let result = gtk_text_view_get_ltr_context(text_view_ptr)
        let rv = Pango.ContextRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Whether text should be displayed in a monospace font.
    /// 
    /// If `true`, set the .monospace style class on the
    /// text view to indicate that a monospace font is desired.
    @inlinable var monospace: Bool {
        /// Gets whether the `GtkTextView` uses monospace styling.
        get {
            let result = gtk_text_view_get_monospace(text_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether the `GtkTextView` should display text in
        /// monospace styling.
        nonmutating set {
            gtk_text_view_set_monospace(text_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Whether entered text overwrites existing contents.
    @inlinable var overwrite: Bool {
        /// Returns whether the `GtkTextView` is in overwrite mode or not.
        get {
            let result = gtk_text_view_get_overwrite(text_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Changes the `GtkTextView` overwrite mode.
        nonmutating set {
            gtk_text_view_set_overwrite(text_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the default number of pixels to put above paragraphs.
    /// 
    /// Adding this function with [method`Gtk.TextView.get_pixels_below_lines`]
    /// is equal to the line space between each paragraph.
    @inlinable var pixelsAboveLines: Int {
        /// Gets the default number of pixels to put above paragraphs.
        /// 
        /// Adding this function with [method`Gtk.TextView.get_pixels_below_lines`]
        /// is equal to the line space between each paragraph.
        get {
            let result = gtk_text_view_get_pixels_above_lines(text_view_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the default number of blank pixels above paragraphs in `text_view`.
        /// 
        /// Tags in the buffer for `text_view` may override the defaults.
        nonmutating set {
            gtk_text_view_set_pixels_above_lines(text_view_ptr, gint(newValue))
        }
    }

    /// Gets the default number of pixels to put below paragraphs.
    /// 
    /// The line space is the sum of the value returned by this function and
    /// the value returned by [method`Gtk.TextView.get_pixels_above_lines`].
    @inlinable var pixelsBelowLines: Int {
        /// Gets the default number of pixels to put below paragraphs.
        /// 
        /// The line space is the sum of the value returned by this function and
        /// the value returned by [method`Gtk.TextView.get_pixels_above_lines`].
        get {
            let result = gtk_text_view_get_pixels_below_lines(text_view_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the default number of pixels of blank space
        /// to put below paragraphs in `text_view`.
        /// 
        /// May be overridden by tags applied to `text_view`’s buffer.
        nonmutating set {
            gtk_text_view_set_pixels_below_lines(text_view_ptr, gint(newValue))
        }
    }

    /// Gets the default number of pixels to put between wrapped lines
    /// inside a paragraph.
    @inlinable var pixelsInsideWrap: Int {
        /// Gets the default number of pixels to put between wrapped lines
        /// inside a paragraph.
        get {
            let result = gtk_text_view_get_pixels_inside_wrap(text_view_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the default number of pixels of blank space to leave between
        /// display/wrapped lines within a paragraph.
        /// 
        /// May be overridden by tags in `text_view`’s buffer.
        nonmutating set {
            gtk_text_view_set_pixels_inside_wrap(text_view_ptr, gint(newValue))
        }
    }

    /// Gets the default right margin for text in `text_view`.
    /// 
    /// Tags in the buffer may override the default.
    @inlinable var rightMargin: Int {
        /// Gets the default right margin for text in `text_view`.
        /// 
        /// Tags in the buffer may override the default.
        get {
            let result = gtk_text_view_get_right_margin(text_view_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the default right margin for text in the text view.
        /// 
        /// Tags in the buffer may override the default.
        /// 
        /// Note that this function is confusingly named.
        /// In CSS terms, the value set here is padding.
        nonmutating set {
            gtk_text_view_set_right_margin(text_view_ptr, gint(newValue))
        }
    }

    /// Gets the `PangoContext` that is used for rendering RTL directed
    /// text layouts.
    /// 
    /// The context may be replaced when CSS changes occur.
    @inlinable var rtlContext: Pango.ContextRef! {
        /// Gets the `PangoContext` that is used for rendering RTL directed
        /// text layouts.
        /// 
        /// The context may be replaced when CSS changes occur.
        get {
            let result = gtk_text_view_get_rtl_context(text_view_ptr)
        let rv = Pango.ContextRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    @inlinable var tabs: Pango.TabArrayRef! {
        /// Gets the default tabs for `text_view`.
        /// 
        /// Tags in the buffer may override the defaults. The returned array
        /// will be `nil` if “standard” (8-space) tabs are used. Free the
        /// return value with [method`Pango.TabArray.free`].
        get {
            let result = gtk_text_view_get_tabs(text_view_ptr)
        let rv = Pango.TabArrayRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets the default tab stops for paragraphs in `text_view`.
        /// 
        /// Tags in the buffer may override the default.
        nonmutating set {
            gtk_text_view_set_tabs(text_view_ptr, UnsafeMutablePointer<PangoTabArray>(newValue?.tab_array_ptr))
        }
    }

    /// Gets the top margin for text in the `text_view`.
    @inlinable var topMargin: Int {
        /// Gets the top margin for text in the `text_view`.
        get {
            let result = gtk_text_view_get_top_margin(text_view_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the top margin for text in `text_view`.
        /// 
        /// Note that this function is confusingly named.
        /// In CSS terms, the value set here is padding.
        nonmutating set {
            gtk_text_view_set_top_margin(text_view_ptr, gint(newValue))
        }
    }

    /// Gets the line wrapping for the view.
    @inlinable var wrapMode: GtkWrapMode {
        /// Gets the line wrapping for the view.
        get {
            let result = gtk_text_view_get_wrap_mode(text_view_ptr)
        let rv = result
            return rv
        }
        /// Sets the line wrapping for the view.
        nonmutating set {
            gtk_text_view_set_wrap_mode(text_view_ptr, newValue)
        }
    }

    @inlinable var parentInstance: GtkWidget {
        get {
            let rv = text_view_ptr.pointee.parent_instance
    return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - ToggleButton Class

/// A `GtkToggleButton` is a button which remains “pressed-in” when
/// clicked.
/// 
/// Clicking again will cause the toggle button to return to its normal state.
/// 
/// A toggle button is created by calling either [ctor`Gtk.ToggleButton.new`] or
/// [ctor`Gtk.ToggleButton.new_with_label`]. If using the former, it is advisable
/// to pack a widget, (such as a `GtkLabel` and/or a `GtkImage`), into the toggle
/// button’s container. (See [class`Gtk.Button`] for more information).
/// 
/// The state of a `GtkToggleButton` can be set specifically using
/// [method`Gtk.ToggleButton.set_active`], and retrieved using
/// [method`Gtk.ToggleButton.get_active`].
/// 
/// To simply switch the state of a toggle button, use
/// [method`Gtk.ToggleButton.toggled`].
/// 
/// ## Grouping
/// 
/// Toggle buttons can be grouped together, to form mutually exclusive
/// groups - only one of the buttons can be toggled at a time, and toggling
/// another one will switch the currently toggled one off.
/// 
/// To add a `GtkToggleButton` to a group, use [method`Gtk.ToggleButton.set_group`].
/// 
/// ## CSS nodes
/// 
/// `GtkToggleButton` has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the `.toggle` style class.
/// 
/// ## Creating two `GtkToggleButton` widgets.
/// 
/// ```c
/// static void
/// output_state (GtkToggleButton *source,
///               gpointer         user_data)
/// {
///   g_print ("Toggle button "`s`" is active: `s`",
///            gtk_button_get_label (GTK_BUTTON (source)),
///            gtk_toggle_button_get_active (source) ? "Yes" : "No");
/// }
/// 
/// static void
/// make_toggles (void)
/// {
///   GtkWidget *window, *toggle1, *toggle2;
///   GtkWidget *box;
///   const char *text;
/// 
///   window = gtk_window_new ();
///   box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
/// 
///   text = "Hi, I’m toggle button one";
///   toggle1 = gtk_toggle_button_new_with_label (text);
/// 
///   g_signal_connect (toggle1, "toggled",
///                     G_CALLBACK (output_state),
///                     NULL);
///   gtk_box_append (GTK_BOX (box), toggle1);
/// 
///   text = "Hi, I’m toggle button two";
///   toggle2 = gtk_toggle_button_new_with_label (text);
///   g_signal_connect (toggle2, "toggled",
///                     G_CALLBACK (output_state),
///                     NULL);
///   gtk_box_append (GTK_BOX (box), toggle2);
/// 
///   gtk_window_set_child (GTK_WINDOW (window), box);
///   gtk_widget_show (window);
/// }
/// ```
///
/// The `ToggleButtonProtocol` protocol exposes the methods and properties of an underlying `GtkToggleButton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ToggleButton`.
/// Alternatively, use `ToggleButtonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ToggleButtonProtocol: ButtonProtocol {
        /// Untyped pointer to the underlying `GtkToggleButton` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkToggleButton` instance.
    var toggle_button_ptr: UnsafeMutablePointer<GtkToggleButton>! { get }

    /// Required Initialiser for types conforming to `ToggleButtonProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkToggleButton` is a button which remains “pressed-in” when
/// clicked.
/// 
/// Clicking again will cause the toggle button to return to its normal state.
/// 
/// A toggle button is created by calling either [ctor`Gtk.ToggleButton.new`] or
/// [ctor`Gtk.ToggleButton.new_with_label`]. If using the former, it is advisable
/// to pack a widget, (such as a `GtkLabel` and/or a `GtkImage`), into the toggle
/// button’s container. (See [class`Gtk.Button`] for more information).
/// 
/// The state of a `GtkToggleButton` can be set specifically using
/// [method`Gtk.ToggleButton.set_active`], and retrieved using
/// [method`Gtk.ToggleButton.get_active`].
/// 
/// To simply switch the state of a toggle button, use
/// [method`Gtk.ToggleButton.toggled`].
/// 
/// ## Grouping
/// 
/// Toggle buttons can be grouped together, to form mutually exclusive
/// groups - only one of the buttons can be toggled at a time, and toggling
/// another one will switch the currently toggled one off.
/// 
/// To add a `GtkToggleButton` to a group, use [method`Gtk.ToggleButton.set_group`].
/// 
/// ## CSS nodes
/// 
/// `GtkToggleButton` has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the `.toggle` style class.
/// 
/// ## Creating two `GtkToggleButton` widgets.
/// 
/// ```c
/// static void
/// output_state (GtkToggleButton *source,
///               gpointer         user_data)
/// {
///   g_print ("Toggle button "`s`" is active: `s`",
///            gtk_button_get_label (GTK_BUTTON (source)),
///            gtk_toggle_button_get_active (source) ? "Yes" : "No");
/// }
/// 
/// static void
/// make_toggles (void)
/// {
///   GtkWidget *window, *toggle1, *toggle2;
///   GtkWidget *box;
///   const char *text;
/// 
///   window = gtk_window_new ();
///   box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
/// 
///   text = "Hi, I’m toggle button one";
///   toggle1 = gtk_toggle_button_new_with_label (text);
/// 
///   g_signal_connect (toggle1, "toggled",
///                     G_CALLBACK (output_state),
///                     NULL);
///   gtk_box_append (GTK_BOX (box), toggle1);
/// 
///   text = "Hi, I’m toggle button two";
///   toggle2 = gtk_toggle_button_new_with_label (text);
///   g_signal_connect (toggle2, "toggled",
///                     G_CALLBACK (output_state),
///                     NULL);
///   gtk_box_append (GTK_BOX (box), toggle2);
/// 
///   gtk_window_set_child (GTK_WINDOW (window), box);
///   gtk_widget_show (window);
/// }
/// ```
///
/// The `ToggleButtonRef` type acts as a lightweight Swift reference to an underlying `GtkToggleButton` instance.
/// It exposes methods that can operate on this data type through `ToggleButtonProtocol` conformance.
/// Use `ToggleButtonRef` only as an `unowned` reference to an existing `GtkToggleButton` instance.
///
public struct ToggleButtonRef: ToggleButtonProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkToggleButton` instance.
    /// For type-safe access, use the generated, typed pointer `toggle_button_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ToggleButtonRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkToggleButton>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkToggleButton>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkToggleButton>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkToggleButton>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ToggleButtonProtocol`
    @inlinable init<T: ToggleButtonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ToggleButtonProtocol>(_ other: T) -> ToggleButtonRef { ToggleButtonRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new toggle button.
    /// 
    /// A widget should be packed into the button, as in [ctor`Gtk.Button.new`].
    @inlinable init() {
            let result = gtk_toggle_button_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new toggle button with a text label.
    @inlinable init(label: UnsafePointer<CChar>!) {
            let result = gtk_toggle_button_new_with_label(label)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkToggleButton` containing a label.
    /// 
    /// The label will be created using [ctor`Gtk.Label.new_with_mnemonic`],
    /// so underscores in `label` indicate the mnemonic for the button.
    @inlinable init(mnemonic label: UnsafePointer<CChar>!) {
            let result = gtk_toggle_button_new_with_mnemonic(label)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new toggle button with a text label.
    @inlinable static func toggleButtonNewWith(label: UnsafePointer<CChar>!) -> WidgetRef! {
            let result = gtk_toggle_button_new_with_label(label)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Creates a new `GtkToggleButton` containing a label.
    /// 
    /// The label will be created using [ctor`Gtk.Label.new_with_mnemonic`],
    /// so underscores in `label` indicate the mnemonic for the button.
    @inlinable static func toggleButtonNewWith(mnemonic label: UnsafePointer<CChar>!) -> WidgetRef! {
            let result = gtk_toggle_button_new_with_mnemonic(label)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }
}

/// A `GtkToggleButton` is a button which remains “pressed-in” when
/// clicked.
/// 
/// Clicking again will cause the toggle button to return to its normal state.
/// 
/// A toggle button is created by calling either [ctor`Gtk.ToggleButton.new`] or
/// [ctor`Gtk.ToggleButton.new_with_label`]. If using the former, it is advisable
/// to pack a widget, (such as a `GtkLabel` and/or a `GtkImage`), into the toggle
/// button’s container. (See [class`Gtk.Button`] for more information).
/// 
/// The state of a `GtkToggleButton` can be set specifically using
/// [method`Gtk.ToggleButton.set_active`], and retrieved using
/// [method`Gtk.ToggleButton.get_active`].
/// 
/// To simply switch the state of a toggle button, use
/// [method`Gtk.ToggleButton.toggled`].
/// 
/// ## Grouping
/// 
/// Toggle buttons can be grouped together, to form mutually exclusive
/// groups - only one of the buttons can be toggled at a time, and toggling
/// another one will switch the currently toggled one off.
/// 
/// To add a `GtkToggleButton` to a group, use [method`Gtk.ToggleButton.set_group`].
/// 
/// ## CSS nodes
/// 
/// `GtkToggleButton` has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the `.toggle` style class.
/// 
/// ## Creating two `GtkToggleButton` widgets.
/// 
/// ```c
/// static void
/// output_state (GtkToggleButton *source,
///               gpointer         user_data)
/// {
///   g_print ("Toggle button "`s`" is active: `s`",
///            gtk_button_get_label (GTK_BUTTON (source)),
///            gtk_toggle_button_get_active (source) ? "Yes" : "No");
/// }
/// 
/// static void
/// make_toggles (void)
/// {
///   GtkWidget *window, *toggle1, *toggle2;
///   GtkWidget *box;
///   const char *text;
/// 
///   window = gtk_window_new ();
///   box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
/// 
///   text = "Hi, I’m toggle button one";
///   toggle1 = gtk_toggle_button_new_with_label (text);
/// 
///   g_signal_connect (toggle1, "toggled",
///                     G_CALLBACK (output_state),
///                     NULL);
///   gtk_box_append (GTK_BOX (box), toggle1);
/// 
///   text = "Hi, I’m toggle button two";
///   toggle2 = gtk_toggle_button_new_with_label (text);
///   g_signal_connect (toggle2, "toggled",
///                     G_CALLBACK (output_state),
///                     NULL);
///   gtk_box_append (GTK_BOX (box), toggle2);
/// 
///   gtk_window_set_child (GTK_WINDOW (window), box);
///   gtk_widget_show (window);
/// }
/// ```
///
/// The `ToggleButton` type acts as a reference-counted owner of an underlying `GtkToggleButton` instance.
/// It provides the methods that can operate on this data type through `ToggleButtonProtocol` conformance.
/// Use `ToggleButton` as a strong reference or owner of a `GtkToggleButton` instance.
///
open class ToggleButton: Button, ToggleButtonProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkToggleButton>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkToggleButton>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleButton` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkToggleButton>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkToggleButton>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkToggleButton`.
    /// i.e., ownership is transferred to the `ToggleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkToggleButton>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ToggleButtonProtocol`
    /// Will retain `GtkToggleButton`.
    /// - Parameter other: an instance of a related type that implements `ToggleButtonProtocol`
    @inlinable public init<T: ToggleButtonProtocol>(toggleButton other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new toggle button.
    /// 
    /// A widget should be packed into the button, as in [ctor`Gtk.Button.new`].
    @inlinable override public init() {
            let result = gtk_toggle_button_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new toggle button with a text label.
    @inlinable override public init(label: UnsafePointer<CChar>!) {
            let result = gtk_toggle_button_new_with_label(label)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkToggleButton` containing a label.
    /// 
    /// The label will be created using [ctor`Gtk.Label.new_with_mnemonic`],
    /// so underscores in `label` indicate the mnemonic for the button.
    @inlinable override public init(mnemonic label: UnsafePointer<CChar>!) {
            let result = gtk_toggle_button_new_with_mnemonic(label)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new toggle button with a text label.
    @inlinable public static func toggleButtonNewWith(label: UnsafePointer<CChar>!) -> Widget! {
            let result = gtk_toggle_button_new_with_label(label)
        guard let rv = Widget(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

    /// Creates a new `GtkToggleButton` containing a label.
    /// 
    /// The label will be created using [ctor`Gtk.Label.new_with_mnemonic`],
    /// so underscores in `label` indicate the mnemonic for the button.
    @inlinable public static func toggleButtonNewWith(mnemonic label: UnsafePointer<CChar>!) -> Widget! {
            let result = gtk_toggle_button_new_with_mnemonic(label)
        guard let rv = Widget(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

}

public enum ToggleButtonPropertyName: String, PropertyNameProtocol {
    /// If the toggle button should be pressed in.
    case active = "active"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// The child widget.
    case child = "child"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// The toggle button whose group this widget belongs to.
    case group = "group"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Whether the button has a frame.
    case hasFrame = "has-frame"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The name of the icon used to automatically populate the button.
    case iconName = "icon-name"
    /// Text of the label inside the button, if the button contains a label widget.
    case label = "label"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// If set, an underline in the text indicates that the following character is
    /// to be used as mnemonic.
    case useUnderline = "use-underline"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension ToggleButtonProtocol {
    /// Bind a `ToggleButtonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToggleButtonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ToggleButton property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ToggleButtonPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ToggleButton property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ToggleButtonPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ToggleButtonSignalName: String, SignalNameProtocol {
    /// Emitted to animate press then release.
    /// 
    /// This is an action signal. Applications should never connect
    /// to this signal, but use the [signal`Gtk.Button::clicked`] signal.
    case activate = "activate"
    /// Emitted when the button has been activated (pressed and released).
    case clicked = "clicked"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted whenever the `GtkToggleButton`'s state is changed.
    case toggled = "toggled"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// If the toggle button should be pressed in.
    case notifyActive = "notify::active"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// The child widget.
    case notifyChild = "notify::child"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// The toggle button whose group this widget belongs to.
    case notifyGroup = "notify::group"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Whether the button has a frame.
    case notifyHasFrame = "notify::has-frame"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The name of the icon used to automatically populate the button.
    case notifyIconName = "notify::icon-name"
    /// Text of the label inside the button, if the button contains a label widget.
    case notifyLabel = "notify::label"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// If set, an underline in the text indicates that the following character is
    /// to be used as mnemonic.
    case notifyUseUnderline = "notify::use-underline"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: ToggleButton signals
public extension ToggleButtonProtocol {
    /// Connect a Swift signal handler to the given, typed `ToggleButtonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ToggleButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `ToggleButtonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ToggleButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted whenever the `GtkToggleButton`'s state is changed.
    /// - Note: This represents the underlying `toggled` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `toggled` signal is emitted
    @discardableResult @inlinable func onToggled(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToggleButtonRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ToggleButtonRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ToggleButtonRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .toggled,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `toggled` signal for using the `connect(signal:)` methods
    static var toggledSignal: ToggleButtonSignalName { .toggled }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::active` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActive` signal is emitted
    @discardableResult @inlinable func onNotifyActive(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToggleButtonRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ToggleButtonRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ToggleButtonRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyActive,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::active` signal for using the `connect(signal:)` methods
    static var notifyActiveSignal: ToggleButtonSignalName { .notifyActive }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::group` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyGroup` signal is emitted
    @discardableResult @inlinable func onNotifyGroup(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToggleButtonRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(ToggleButtonRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((ToggleButtonRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyGroup,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::group` signal for using the `connect(signal:)` methods
    static var notifyGroupSignal: ToggleButtonSignalName { .notifyGroup }
    
}

// MARK: ToggleButton Class: ToggleButtonProtocol extension (methods and fields)
public extension ToggleButtonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToggleButton` instance.
    @inlinable var toggle_button_ptr: UnsafeMutablePointer<GtkToggleButton>! { return ptr?.assumingMemoryBound(to: GtkToggleButton.self) }

    /// Queries a `GtkToggleButton` and returns its current state.
    /// 
    /// Returns `true` if the toggle button is pressed in and `false`
    /// if it is raised.
    @inlinable func getActive() -> Bool {
        let result = gtk_toggle_button_get_active(toggle_button_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Sets the status of the toggle button.
    /// 
    /// Set to `true` if you want the `GtkToggleButton` to be “pressed in”,
    /// and `false` to raise it.
    /// 
    /// If the status of the button changes, this action causes the
    /// [signal`GtkToggleButton::toggled`] signal to be emitted.
    @inlinable func setActive(isActive: Bool) {
        
        gtk_toggle_button_set_active(toggle_button_ptr, gboolean((isActive) ? 1 : 0))
        
    }

    /// Adds `self` to the group of `group`.
    /// 
    /// In a group of multiple toggle buttons, only one button can be active
    /// at a time.
    /// 
    /// Setting up groups in a cycle leads to undefined behavior.
    /// 
    /// Note that the same effect can be achieved via the [iface`Gtk.Actionable`]
    /// API, by using the same action with parameter type and state type 's'
    /// for all buttons in the group, and giving each button its own target
    /// value.
    @inlinable func set(group: ToggleButtonRef? = nil) {
            
        gtk_toggle_button_set_group(toggle_button_ptr, group?.toggle_button_ptr)
            
    }
    /// Adds `self` to the group of `group`.
    /// 
    /// In a group of multiple toggle buttons, only one button can be active
    /// at a time.
    /// 
    /// Setting up groups in a cycle leads to undefined behavior.
    /// 
    /// Note that the same effect can be achieved via the [iface`Gtk.Actionable`]
    /// API, by using the same action with parameter type and state type 's'
    /// for all buttons in the group, and giving each button its own target
    /// value.
    @inlinable func set<ToggleButtonT: ToggleButtonProtocol>(group: ToggleButtonT?) {
        
        gtk_toggle_button_set_group(toggle_button_ptr, group?.toggle_button_ptr)
        
    }

    /// Emits the `toggled` signal on the `GtkToggleButton`.
    /// 
    /// There is no good reason for an application ever to call this function.
    @inlinable func toggled() {
        
        gtk_toggle_button_toggled(toggle_button_ptr)
        
    }
    /// If the toggle button should be pressed in.
    @inlinable var active: Bool {
        /// Queries a `GtkToggleButton` and returns its current state.
        /// 
        /// Returns `true` if the toggle button is pressed in and `false`
        /// if it is raised.
        get {
            let result = gtk_toggle_button_get_active(toggle_button_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets the status of the toggle button.
        /// 
        /// Set to `true` if you want the `GtkToggleButton` to be “pressed in”,
        /// and `false` to raise it.
        /// 
        /// If the status of the button changes, this action causes the
        /// [signal`GtkToggleButton::toggled`] signal to be emitted.
        nonmutating set {
            gtk_toggle_button_set_active(toggle_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    // var button is unavailable because button is private

}



// MARK: - Tooltip Class

/// `GtkTooltip` is an object representing a widget tooltip.
/// 
/// Basic tooltips can be realized simply by using
/// [method`Gtk.Widget.set_tooltip_text`] or
/// [method`Gtk.Widget.set_tooltip_markup`] without
/// any explicit tooltip object.
/// 
/// When you need a tooltip with a little more fancy contents,
/// like adding an image, or you want the tooltip to have different
/// contents per `GtkTreeView` row or cell, you will have to do a
/// little more work:
/// 
/// - Set the [property`Gtk.Widget:has-tooltip`] property to `true`.
///   This will make GTK monitor the widget for motion and related events
///   which are needed to determine when and where to show a tooltip.
/// 
/// - Connect to the [signal`Gtk.Widget::query-tooltip`] signal.
///   This signal will be emitted when a tooltip is supposed to be shown.
///   One of the arguments passed to the signal handler is a `GtkTooltip`
///   object. This is the object that we are about to display as a tooltip,
///   and can be manipulated in your callback using functions like
///   [method`Gtk.Tooltip.set_icon`]. There are functions for setting
///   the tooltip’s markup, setting an image from a named icon, or even
///   putting in a custom widget.
/// 
/// - Return `true` from your `query-tooltip` handler. This causes the tooltip
///   to be show. If you return `false`, it will not be shown.
///
/// The `TooltipProtocol` protocol exposes the methods and properties of an underlying `GtkTooltip` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Tooltip`.
/// Alternatively, use `TooltipRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TooltipProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkTooltip` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTooltip` instance.
    var tooltip_ptr: UnsafeMutablePointer<GtkTooltip>! { get }

    /// Required Initialiser for types conforming to `TooltipProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkTooltip` is an object representing a widget tooltip.
/// 
/// Basic tooltips can be realized simply by using
/// [method`Gtk.Widget.set_tooltip_text`] or
/// [method`Gtk.Widget.set_tooltip_markup`] without
/// any explicit tooltip object.
/// 
/// When you need a tooltip with a little more fancy contents,
/// like adding an image, or you want the tooltip to have different
/// contents per `GtkTreeView` row or cell, you will have to do a
/// little more work:
/// 
/// - Set the [property`Gtk.Widget:has-tooltip`] property to `true`.
///   This will make GTK monitor the widget for motion and related events
///   which are needed to determine when and where to show a tooltip.
/// 
/// - Connect to the [signal`Gtk.Widget::query-tooltip`] signal.
///   This signal will be emitted when a tooltip is supposed to be shown.
///   One of the arguments passed to the signal handler is a `GtkTooltip`
///   object. This is the object that we are about to display as a tooltip,
///   and can be manipulated in your callback using functions like
///   [method`Gtk.Tooltip.set_icon`]. There are functions for setting
///   the tooltip’s markup, setting an image from a named icon, or even
///   putting in a custom widget.
/// 
/// - Return `true` from your `query-tooltip` handler. This causes the tooltip
///   to be show. If you return `false`, it will not be shown.
///
/// The `TooltipRef` type acts as a lightweight Swift reference to an underlying `GtkTooltip` instance.
/// It exposes methods that can operate on this data type through `TooltipProtocol` conformance.
/// Use `TooltipRef` only as an `unowned` reference to an existing `GtkTooltip` instance.
///
public struct TooltipRef: TooltipProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTooltip` instance.
    /// For type-safe access, use the generated, typed pointer `tooltip_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TooltipRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTooltip>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTooltip>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTooltip>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTooltip>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TooltipProtocol`
    @inlinable init<T: TooltipProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TooltipProtocol>(_ other: T) -> TooltipRef { TooltipRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// `GtkTooltip` is an object representing a widget tooltip.
/// 
/// Basic tooltips can be realized simply by using
/// [method`Gtk.Widget.set_tooltip_text`] or
/// [method`Gtk.Widget.set_tooltip_markup`] without
/// any explicit tooltip object.
/// 
/// When you need a tooltip with a little more fancy contents,
/// like adding an image, or you want the tooltip to have different
/// contents per `GtkTreeView` row or cell, you will have to do a
/// little more work:
/// 
/// - Set the [property`Gtk.Widget:has-tooltip`] property to `true`.
///   This will make GTK monitor the widget for motion and related events
///   which are needed to determine when and where to show a tooltip.
/// 
/// - Connect to the [signal`Gtk.Widget::query-tooltip`] signal.
///   This signal will be emitted when a tooltip is supposed to be shown.
///   One of the arguments passed to the signal handler is a `GtkTooltip`
///   object. This is the object that we are about to display as a tooltip,
///   and can be manipulated in your callback using functions like
///   [method`Gtk.Tooltip.set_icon`]. There are functions for setting
///   the tooltip’s markup, setting an image from a named icon, or even
///   putting in a custom widget.
/// 
/// - Return `true` from your `query-tooltip` handler. This causes the tooltip
///   to be show. If you return `false`, it will not be shown.
///
/// The `Tooltip` type acts as a reference-counted owner of an underlying `GtkTooltip` instance.
/// It provides the methods that can operate on this data type through `TooltipProtocol` conformance.
/// Use `Tooltip` as a strong reference or owner of a `GtkTooltip` instance.
///
open class Tooltip: GLibObject.Object, TooltipProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Tooltip` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTooltip>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Tooltip` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTooltip>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Tooltip` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Tooltip` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Tooltip` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTooltip>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Tooltip` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTooltip>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTooltip`.
    /// i.e., ownership is transferred to the `Tooltip` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTooltip>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TooltipProtocol`
    /// Will retain `GtkTooltip`.
    /// - Parameter other: an instance of a related type that implements `TooltipProtocol`
    @inlinable public init<T: TooltipProtocol>(tooltip other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

// MARK: no Tooltip properties

public enum TooltipSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: Tooltip has no signals
// MARK: Tooltip Class: TooltipProtocol extension (methods and fields)
public extension TooltipProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTooltip` instance.
    @inlinable var tooltip_ptr: UnsafeMutablePointer<GtkTooltip>! { return ptr?.assumingMemoryBound(to: GtkTooltip.self) }

    /// Replaces the widget packed into the tooltip with
    /// `custom_widget`. `custom_widget` does not get destroyed when the tooltip goes
    /// away.
    /// By default a box with a `GtkImage` and `GtkLabel` is embedded in
    /// the tooltip, which can be configured using `gtk_tooltip_set_markup()`
    /// and `gtk_tooltip_set_icon()`.
    @inlinable func setCustom(customWidget: WidgetRef? = nil) {
            
        gtk_tooltip_set_custom(tooltip_ptr, customWidget?.widget_ptr)
            
    }
    /// Replaces the widget packed into the tooltip with
    /// `custom_widget`. `custom_widget` does not get destroyed when the tooltip goes
    /// away.
    /// By default a box with a `GtkImage` and `GtkLabel` is embedded in
    /// the tooltip, which can be configured using `gtk_tooltip_set_markup()`
    /// and `gtk_tooltip_set_icon()`.
    @inlinable func setCustom<WidgetT: WidgetProtocol>(customWidget: WidgetT?) {
        
        gtk_tooltip_set_custom(tooltip_ptr, customWidget?.widget_ptr)
        
    }

    /// Sets the icon of the tooltip (which is in front of the text) to be
    /// `paintable`.  If `paintable` is `nil`, the image will be hidden.
    @inlinable func setIcon(paintable: Gdk.PaintableRef? = nil) {
            
        gtk_tooltip_set_icon(tooltip_ptr, paintable?.paintable_ptr)
            
    }
    /// Sets the icon of the tooltip (which is in front of the text) to be
    /// `paintable`.  If `paintable` is `nil`, the image will be hidden.
    @inlinable func setIcon<GdkPaintableT: Gdk.PaintableProtocol>(paintable: GdkPaintableT?) {
        
        gtk_tooltip_set_icon(tooltip_ptr, paintable?.paintable_ptr)
        
    }

    /// Sets the icon of the tooltip (which is in front of the text)
    /// to be the icon indicated by `gicon` with the size indicated
    /// by `size`. If `gicon` is `nil`, the image will be hidden.
    @inlinable func setIconFrom(gicon: GIO.IconRef? = nil) {
            
        gtk_tooltip_set_icon_from_gicon(tooltip_ptr, gicon?.icon_ptr)
            
    }
    /// Sets the icon of the tooltip (which is in front of the text)
    /// to be the icon indicated by `gicon` with the size indicated
    /// by `size`. If `gicon` is `nil`, the image will be hidden.
    @inlinable func setIconFrom<GioIconT: GIO.IconProtocol>(gicon: GioIconT?) {
        
        gtk_tooltip_set_icon_from_gicon(tooltip_ptr, gicon?.icon_ptr)
        
    }

    /// Sets the icon of the tooltip (which is in front of the text) to be
    /// the icon indicated by `icon_name` with the size indicated
    /// by `size`.  If `icon_name` is `nil`, the image will be hidden.
    @inlinable func setIconFrom(iconName: UnsafePointer<CChar>? = nil) {
        
        gtk_tooltip_set_icon_from_icon_name(tooltip_ptr, iconName)
        
    }

    /// Sets the text of the tooltip to be `markup`.
    /// 
    /// The string must be marked up with Pango markup.
    /// If `markup` is `nil`, the label will be hidden.
    @inlinable func set(markup: UnsafePointer<CChar>? = nil) {
        
        gtk_tooltip_set_markup(tooltip_ptr, markup)
        
    }

    /// Sets the text of the tooltip to be `text`.
    /// 
    /// If `text` is `nil`, the label will be hidden.
    /// See also [method`Gtk.Tooltip.set_markup`].
    @inlinable func set(text: UnsafePointer<CChar>? = nil) {
        
        gtk_tooltip_set_text(tooltip_ptr, text)
        
    }

    /// Sets the area of the widget, where the contents of this tooltip apply,
    /// to be `rect` (in widget coordinates).  This is especially useful for
    /// properly setting tooltips on `GtkTreeView` rows and cells, `GtkIconViews`,
    /// etc.
    /// 
    /// For setting tooltips on `GtkTreeView`, please refer to the convenience
    /// functions for this: `gtk_tree_view_set_tooltip_row()` and
    /// `gtk_tree_view_set_tooltip_cell()`.
    @inlinable func setTipArea<GdkRectangleT: Gdk.RectangleProtocol>(rect: GdkRectangleT) {
        
        gtk_tooltip_set_tip_area(tooltip_ptr, rect.rectangle_ptr)
        
    }


}



// MARK: - TreeExpander Class

/// `GtkTreeExpander` is a widget that provides an expander for a list.
/// 
/// It is typically placed as a bottommost child into a `GtkListView`
/// to allow users to expand and collapse children in a list with a
/// [class`Gtk.TreeListModel`]. `GtkTreeExpander` provides the common UI
/// elements, gestures and keybindings for this purpose.
/// 
/// On top of this, the "listitem.expand", "listitem.collapse" and
/// "listitem.toggle-expand" actions are provided to allow adding custom
/// UI for managing expanded state.
/// 
/// The `GtkTreeListModel` must be set to not be passthrough. Then it
/// will provide [class`Gtk.TreeListRow`] items which can be set via
/// [method`Gtk.TreeExpander.set_list_row`] on the expander.
/// The expander will then watch that row item automatically.
/// [method`Gtk.TreeExpander.set_child`] sets the widget that displays
/// the actual row contents.
/// 
/// # CSS nodes
/// 
/// ```
/// treeexpander
/// ├── [indent]*
/// ├── [expander]
/// ╰── &lt;child&gt;
/// ```
/// 
/// `GtkTreeExpander` has zero or one CSS nodes with the name "expander" that
/// should display the expander icon. The node will be `:checked` when it
/// is expanded. If the node is not expandable, an "indent" node will be
/// displayed instead.
/// 
/// For every level of depth, another "indent" node is prepended.
/// 
/// # Accessibility
/// 
/// `GtkTreeExpander` uses the `GTK_ACCESSIBLE_ROLE_GROUP` role. The expander icon
/// is represented as a `GTK_ACCESSIBLE_ROLE_BUTTON`, labelled by the expander's
/// child, and toggling it will change the `GTK_ACCESSIBLE_STATE_EXPANDED` state.
///
/// The `TreeExpanderProtocol` protocol exposes the methods and properties of an underlying `GtkTreeExpander` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeExpander`.
/// Alternatively, use `TreeExpanderRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeExpanderProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkTreeExpander` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeExpander` instance.
    var tree_expander_ptr: UnsafeMutablePointer<GtkTreeExpander>! { get }

    /// Required Initialiser for types conforming to `TreeExpanderProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkTreeExpander` is a widget that provides an expander for a list.
/// 
/// It is typically placed as a bottommost child into a `GtkListView`
/// to allow users to expand and collapse children in a list with a
/// [class`Gtk.TreeListModel`]. `GtkTreeExpander` provides the common UI
/// elements, gestures and keybindings for this purpose.
/// 
/// On top of this, the "listitem.expand", "listitem.collapse" and
/// "listitem.toggle-expand" actions are provided to allow adding custom
/// UI for managing expanded state.
/// 
/// The `GtkTreeListModel` must be set to not be passthrough. Then it
/// will provide [class`Gtk.TreeListRow`] items which can be set via
/// [method`Gtk.TreeExpander.set_list_row`] on the expander.
/// The expander will then watch that row item automatically.
/// [method`Gtk.TreeExpander.set_child`] sets the widget that displays
/// the actual row contents.
/// 
/// # CSS nodes
/// 
/// ```
/// treeexpander
/// ├── [indent]*
/// ├── [expander]
/// ╰── &lt;child&gt;
/// ```
/// 
/// `GtkTreeExpander` has zero or one CSS nodes with the name "expander" that
/// should display the expander icon. The node will be `:checked` when it
/// is expanded. If the node is not expandable, an "indent" node will be
/// displayed instead.
/// 
/// For every level of depth, another "indent" node is prepended.
/// 
/// # Accessibility
/// 
/// `GtkTreeExpander` uses the `GTK_ACCESSIBLE_ROLE_GROUP` role. The expander icon
/// is represented as a `GTK_ACCESSIBLE_ROLE_BUTTON`, labelled by the expander's
/// child, and toggling it will change the `GTK_ACCESSIBLE_STATE_EXPANDED` state.
///
/// The `TreeExpanderRef` type acts as a lightweight Swift reference to an underlying `GtkTreeExpander` instance.
/// It exposes methods that can operate on this data type through `TreeExpanderProtocol` conformance.
/// Use `TreeExpanderRef` only as an `unowned` reference to an existing `GtkTreeExpander` instance.
///
public struct TreeExpanderRef: TreeExpanderProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTreeExpander` instance.
    /// For type-safe access, use the generated, typed pointer `tree_expander_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeExpanderRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeExpander>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeExpander>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeExpander>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeExpander>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeExpanderProtocol`
    @inlinable init<T: TreeExpanderProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TreeExpanderProtocol>(_ other: T) -> TreeExpanderRef { TreeExpanderRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeExpanderProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeExpanderProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeExpanderProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeExpanderProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeExpanderProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkTreeExpander`
    @inlinable init() {
            let result = gtk_tree_expander_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkTreeExpander` is a widget that provides an expander for a list.
/// 
/// It is typically placed as a bottommost child into a `GtkListView`
/// to allow users to expand and collapse children in a list with a
/// [class`Gtk.TreeListModel`]. `GtkTreeExpander` provides the common UI
/// elements, gestures and keybindings for this purpose.
/// 
/// On top of this, the "listitem.expand", "listitem.collapse" and
/// "listitem.toggle-expand" actions are provided to allow adding custom
/// UI for managing expanded state.
/// 
/// The `GtkTreeListModel` must be set to not be passthrough. Then it
/// will provide [class`Gtk.TreeListRow`] items which can be set via
/// [method`Gtk.TreeExpander.set_list_row`] on the expander.
/// The expander will then watch that row item automatically.
/// [method`Gtk.TreeExpander.set_child`] sets the widget that displays
/// the actual row contents.
/// 
/// # CSS nodes
/// 
/// ```
/// treeexpander
/// ├── [indent]*
/// ├── [expander]
/// ╰── &lt;child&gt;
/// ```
/// 
/// `GtkTreeExpander` has zero or one CSS nodes with the name "expander" that
/// should display the expander icon. The node will be `:checked` when it
/// is expanded. If the node is not expandable, an "indent" node will be
/// displayed instead.
/// 
/// For every level of depth, another "indent" node is prepended.
/// 
/// # Accessibility
/// 
/// `GtkTreeExpander` uses the `GTK_ACCESSIBLE_ROLE_GROUP` role. The expander icon
/// is represented as a `GTK_ACCESSIBLE_ROLE_BUTTON`, labelled by the expander's
/// child, and toggling it will change the `GTK_ACCESSIBLE_STATE_EXPANDED` state.
///
/// The `TreeExpander` type acts as a reference-counted owner of an underlying `GtkTreeExpander` instance.
/// It provides the methods that can operate on this data type through `TreeExpanderProtocol` conformance.
/// Use `TreeExpander` as a strong reference or owner of a `GtkTreeExpander` instance.
///
open class TreeExpander: Widget, TreeExpanderProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeExpander` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeExpander>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeExpander` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeExpander>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeExpander` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeExpander` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeExpander` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeExpander>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeExpander` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeExpander>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTreeExpander`.
    /// i.e., ownership is transferred to the `TreeExpander` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeExpander>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TreeExpanderProtocol`
    /// Will retain `GtkTreeExpander`.
    /// - Parameter other: an instance of a related type that implements `TreeExpanderProtocol`
    @inlinable public init<T: TreeExpanderProtocol>(treeExpander other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeExpanderProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeExpanderProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeExpanderProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeExpanderProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeExpanderProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeExpanderProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeExpanderProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeExpanderProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkTreeExpander`
    @inlinable public init() {
            let result = gtk_tree_expander_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum TreeExpanderPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// The child widget with the actual contents.
    case child = "child"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// TreeExpander indents the child by the width of an expander-icon if it is not expandable.
    case indentForIcon = "indent-for-icon"
    /// The item held by this expander's row.
    case item = "item"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// The list row to track for expander state.
    case listRow = "list-row"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension TreeExpanderProtocol {
    /// Bind a `TreeExpanderPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeExpanderPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TreeExpander property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TreeExpanderPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TreeExpander property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TreeExpanderPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TreeExpanderSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// The child widget with the actual contents.
    case notifyChild = "notify::child"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// TreeExpander indents the child by the width of an expander-icon if it is not expandable.
    case notifyIndentForIcon = "notify::indent-for-icon"
    /// The item held by this expander's row.
    case notifyItem = "notify::item"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// The list row to track for expander state.
    case notifyListRow = "notify::list-row"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: TreeExpander has no signals
// MARK: TreeExpander Class: TreeExpanderProtocol extension (methods and fields)
public extension TreeExpanderProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeExpander` instance.
    @inlinable var tree_expander_ptr: UnsafeMutablePointer<GtkTreeExpander>! { return ptr?.assumingMemoryBound(to: GtkTreeExpander.self) }

    /// Gets the child widget displayed by `self`.
    @inlinable func getChild() -> WidgetRef! {
        let result = gtk_tree_expander_get_child(tree_expander_ptr)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// TreeExpander indents the child by the width of an expander-icon if it is not expandable.
    @inlinable func getIndentForIcon() -> Bool {
        let result = gtk_tree_expander_get_indent_for_icon(tree_expander_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Forwards the item set on the `GtkTreeListRow` that `self` is managing.
    /// 
    /// This call is essentially equivalent to calling:
    /// 
    /// ```c
    /// gtk_tree_list_row_get_item (gtk_tree_expander_get_list_row (`self`));
    /// ```
    @inlinable func getItem() -> GLibObject.ObjectRef! {
        let result = gtk_tree_expander_get_item(tree_expander_ptr)
        guard let rv = GLibObject.ObjectRef(gpointer: result) else { return nil }
        return rv
    }

    /// Gets the list row managed by `self`.
    @inlinable func getListRow() -> TreeListRowRef! {
        let result = gtk_tree_expander_get_list_row(tree_expander_ptr)
        let rv = TreeListRowRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Sets the content widget to display.
    @inlinable func set(child: WidgetRef? = nil) {
            
        gtk_tree_expander_set_child(tree_expander_ptr, child?.widget_ptr)
            
    }
    /// Sets the content widget to display.
    @inlinable func set<WidgetT: WidgetProtocol>(child: WidgetT?) {
        
        gtk_tree_expander_set_child(tree_expander_ptr, child?.widget_ptr)
        
    }

    /// Sets if the TreeExpander should indent the child by the width of an expander-icon when it is not expandable.
    @inlinable func set(indentForIcon: Bool) {
        
        gtk_tree_expander_set_indent_for_icon(tree_expander_ptr, gboolean((indentForIcon) ? 1 : 0))
        
    }

    /// Sets the tree list row that this expander should manage.
    @inlinable func set(listRow: TreeListRowRef? = nil) {
            
        gtk_tree_expander_set_list_row(tree_expander_ptr, listRow?.tree_list_row_ptr)
            
    }
    /// Sets the tree list row that this expander should manage.
    @inlinable func set<TreeListRowT: TreeListRowProtocol>(listRow: TreeListRowT?) {
        
        gtk_tree_expander_set_list_row(tree_expander_ptr, listRow?.tree_list_row_ptr)
        
    }
    /// The child widget with the actual contents.
    @inlinable var child: WidgetRef! {
        /// Gets the child widget displayed by `self`.
        get {
            let result = gtk_tree_expander_get_child(tree_expander_ptr)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
            return rv
        }
        /// Sets the content widget to display.
        nonmutating set {
            gtk_tree_expander_set_child(tree_expander_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// TreeExpander indents the child by the width of an expander-icon if it is not expandable.
    @inlinable var indentForIcon: Bool {
        /// TreeExpander indents the child by the width of an expander-icon if it is not expandable.
        get {
            let result = gtk_tree_expander_get_indent_for_icon(tree_expander_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets if the TreeExpander should indent the child by the width of an expander-icon when it is not expandable.
        nonmutating set {
            gtk_tree_expander_set_indent_for_icon(tree_expander_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// The item held by this expander's row.
    @inlinable var item: GLibObject.ObjectRef! {
        /// Forwards the item set on the `GtkTreeListRow` that `self` is managing.
        /// 
        /// This call is essentially equivalent to calling:
        /// 
        /// ```c
        /// gtk_tree_list_row_get_item (gtk_tree_expander_get_list_row (`self`));
        /// ```
        get {
            let result = gtk_tree_expander_get_item(tree_expander_ptr)
        guard let rv = GLibObject.ObjectRef(gpointer: result) else { return nil }
            return rv
        }
    }

    /// Gets the list row managed by `self`.
    @inlinable var listRow: TreeListRowRef! {
        /// Gets the list row managed by `self`.
        get {
            let result = gtk_tree_expander_get_list_row(tree_expander_ptr)
        let rv = TreeListRowRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets the tree list row that this expander should manage.
        nonmutating set {
            gtk_tree_expander_set_list_row(tree_expander_ptr, UnsafeMutablePointer<GtkTreeListRow>(newValue?.tree_list_row_ptr))
        }
    }


}



// MARK: - TreeListModel Class

/// `GtkTreeListModel` is a list model that can create child models on demand.
///
/// The `TreeListModelProtocol` protocol exposes the methods and properties of an underlying `GtkTreeListModel` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeListModel`.
/// Alternatively, use `TreeListModelRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeListModelProtocol: GLibObject.ObjectProtocol, GIO.ListModelProtocol {
        /// Untyped pointer to the underlying `GtkTreeListModel` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeListModel` instance.
    var tree_list_model_ptr: UnsafeMutablePointer<GtkTreeListModel>! { get }

    /// Required Initialiser for types conforming to `TreeListModelProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkTreeListModel` is a list model that can create child models on demand.
///
/// The `TreeListModelRef` type acts as a lightweight Swift reference to an underlying `GtkTreeListModel` instance.
/// It exposes methods that can operate on this data type through `TreeListModelProtocol` conformance.
/// Use `TreeListModelRef` only as an `unowned` reference to an existing `GtkTreeListModel` instance.
///
public struct TreeListModelRef: TreeListModelProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTreeListModel` instance.
    /// For type-safe access, use the generated, typed pointer `tree_list_model_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeListModelRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeListModel>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeListModel>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeListModel>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeListModel>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeListModelProtocol`
    @inlinable init<T: TreeListModelProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TreeListModelProtocol>(_ other: T) -> TreeListModelRef { TreeListModelRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListModelProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListModelProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListModelProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListModelProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListModelProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new empty `GtkTreeListModel` displaying `root`
    /// with all rows collapsed.
    @inlinable init<GioListModelT: GIO.ListModelProtocol>( root: GioListModelT, passthrough: Bool, autoexpand: Bool, createFunc: GtkTreeListModelCreateModelFunc?, userData: gpointer? = nil, userDestroy: GDestroyNotify?) {
            let result = gtk_tree_list_model_new(root.list_model_ptr, gboolean((passthrough) ? 1 : 0), gboolean((autoexpand) ? 1 : 0), createFunc, userData, userDestroy)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkTreeListModel` is a list model that can create child models on demand.
///
/// The `TreeListModel` type acts as a reference-counted owner of an underlying `GtkTreeListModel` instance.
/// It provides the methods that can operate on this data type through `TreeListModelProtocol` conformance.
/// Use `TreeListModel` as a strong reference or owner of a `GtkTreeListModel` instance.
///
open class TreeListModel: GLibObject.Object, TreeListModelProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeListModel>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeListModel>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeListModel` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeListModel>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeListModel>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTreeListModel`.
    /// i.e., ownership is transferred to the `TreeListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeListModel>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TreeListModelProtocol`
    /// Will retain `GtkTreeListModel`.
    /// - Parameter other: an instance of a related type that implements `TreeListModelProtocol`
    @inlinable public init<T: TreeListModelProtocol>(treeListModel other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListModelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListModelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListModelProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListModelProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListModelProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListModelProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListModelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListModelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new empty `GtkTreeListModel` displaying `root`
    /// with all rows collapsed.
    @inlinable public init<GioListModelT: GIO.ListModelProtocol>( root: GioListModelT, passthrough: Bool, autoexpand: Bool, createFunc: GtkTreeListModelCreateModelFunc?, userData: gpointer? = nil, userDestroy: GDestroyNotify?) {
            let result = gtk_tree_list_model_new(root.list_model_ptr, gboolean((passthrough) ? 1 : 0), gboolean((autoexpand) ? 1 : 0), createFunc, userData, userDestroy)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum TreeListModelPropertyName: String, PropertyNameProtocol {
    /// If all rows should be expanded by default.
    case autoexpand = "autoexpand"
    /// The type of items. See [method`Gio.ListModel.get_item_type`].
    case itemType = "item-type"
    /// The root model displayed.
    case model = "model"
    /// The number of items. See [method`Gio.ListModel.get_n_items`].
    case nItems = "n-items"
    /// Gets whether the model is in passthrough mode.
    /// 
    /// If `false`, the `GListModel` functions for this object return custom
    /// [class`Gtk.TreeListRow`] objects. If `true`, the values of the child
    /// models are pass through unmodified.
    case passthrough = "passthrough"
}

public extension TreeListModelProtocol {
    /// Bind a `TreeListModelPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeListModelPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TreeListModel property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TreeListModelPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TreeListModel property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TreeListModelPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TreeListModelSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// If all rows should be expanded by default.
    case notifyAutoexpand = "notify::autoexpand"
    /// The type of items. See [method`Gio.ListModel.get_item_type`].
    case notifyItemType = "notify::item-type"
    /// The root model displayed.
    case notifyModel = "notify::model"
    /// The number of items. See [method`Gio.ListModel.get_n_items`].
    case notifyNItems = "notify::n-items"
    /// Gets whether the model is in passthrough mode.
    /// 
    /// If `false`, the `GListModel` functions for this object return custom
    /// [class`Gtk.TreeListRow`] objects. If `true`, the values of the child
    /// models are pass through unmodified.
    case notifyPassthrough = "notify::passthrough"
}

// MARK: TreeListModel has no signals
// MARK: TreeListModel Class: TreeListModelProtocol extension (methods and fields)
public extension TreeListModelProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeListModel` instance.
    @inlinable var tree_list_model_ptr: UnsafeMutablePointer<GtkTreeListModel>! { return ptr?.assumingMemoryBound(to: GtkTreeListModel.self) }

    /// Gets whether the model is set to automatically expand new rows
    /// that get added.
    /// 
    /// This can be either rows added by changes to the underlying
    /// models or via [method`Gtk.TreeListRow.set_expanded`].
    @inlinable func getAutoexpand() -> Bool {
        let result = gtk_tree_list_model_get_autoexpand(tree_list_model_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the row item corresponding to the child at index `position` for
    /// `self`'s root model.
    /// 
    /// If `position` is greater than the number of children in the root model,
    /// `nil` is returned.
    /// 
    /// Do not confuse this function with [method`Gtk.TreeListModel.get_row`].
    @inlinable func getChildRow(position: Int) -> TreeListRowRef! {
        let result = gtk_tree_list_model_get_child_row(tree_list_model_ptr, guint(position))
        let rv = TreeListRowRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the root model that `self` was created with.
    @inlinable func getModel() -> GIO.ListModelRef! {
        let result = gtk_tree_list_model_get_model(tree_list_model_ptr)
        let rv = GIO.ListModelRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets whether the model is passing through original row items.
    /// 
    /// If this function returns `false`, the `GListModel` functions for `self`
    /// return custom `GtkTreeListRow` objects. You need to call
    /// [method`Gtk.TreeListRow.get_item`] on these objects to get the original
    /// item.
    /// 
    /// If `true`, the values of the child models are passed through in their
    /// original state. You then need to call [method`Gtk.TreeListModel.get_row`]
    /// to get the custom `GtkTreeListRow`s.
    @inlinable func getPassthrough() -> Bool {
        let result = gtk_tree_list_model_get_passthrough(tree_list_model_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the row object for the given row.
    /// 
    /// If `position` is greater than the number of items in `self`,
    /// `nil` is returned.
    /// 
    /// The row object can be used to expand and collapse rows as
    /// well as to inspect its position in the tree. See its
    /// documentation for details.
    /// 
    /// This row object is persistent and will refer to the current
    /// item as long as the row is present in `self`, independent of
    /// other rows being added or removed.
    /// 
    /// If `self` is set to not be passthrough, this function is
    /// equivalent to calling `g_list_model_get_item()`.
    /// 
    /// Do not confuse this function with [method`Gtk.TreeListModel.get_child_row`].
    @inlinable func getRow(position: Int) -> TreeListRowRef! {
        let result = gtk_tree_list_model_get_row(tree_list_model_ptr, guint(position))
        let rv = TreeListRowRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Sets whether the model should autoexpand.
    /// 
    /// If set to `true`, the model will recursively expand all rows that
    /// get added to the model. This can be either rows added by changes
    /// to the underlying models or via [method`Gtk.TreeListRow.set_expanded`].
    @inlinable func set(autoexpand: Bool) {
        
        gtk_tree_list_model_set_autoexpand(tree_list_model_ptr, gboolean((autoexpand) ? 1 : 0))
        
    }
    /// If all rows should be expanded by default.
    @inlinable var autoexpand: Bool {
        /// Gets whether the model is set to automatically expand new rows
        /// that get added.
        /// 
        /// This can be either rows added by changes to the underlying
        /// models or via [method`Gtk.TreeListRow.set_expanded`].
        get {
            let result = gtk_tree_list_model_get_autoexpand(tree_list_model_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether the model should autoexpand.
        /// 
        /// If set to `true`, the model will recursively expand all rows that
        /// get added to the model. This can be either rows added by changes
        /// to the underlying models or via [method`Gtk.TreeListRow.set_expanded`].
        nonmutating set {
            gtk_tree_list_model_set_autoexpand(tree_list_model_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// The root model displayed.
    @inlinable var model: GIO.ListModelRef! {
        /// Gets the root model that `self` was created with.
        get {
            let result = gtk_tree_list_model_get_model(tree_list_model_ptr)
        let rv = GIO.ListModelRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Gets whether the model is in passthrough mode.
    /// 
    /// If `false`, the `GListModel` functions for this object return custom
    /// [class`Gtk.TreeListRow`] objects. If `true`, the values of the child
    /// models are pass through unmodified.
    @inlinable var passthrough: Bool {
        /// Gets whether the model is passing through original row items.
        /// 
        /// If this function returns `false`, the `GListModel` functions for `self`
        /// return custom `GtkTreeListRow` objects. You need to call
        /// [method`Gtk.TreeListRow.get_item`] on these objects to get the original
        /// item.
        /// 
        /// If `true`, the values of the child models are passed through in their
        /// original state. You then need to call [method`Gtk.TreeListModel.get_row`]
        /// to get the custom `GtkTreeListRow`s.
        get {
            let result = gtk_tree_list_model_get_passthrough(tree_list_model_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }


}



// MARK: - TreeListRow Class

/// `GtkTreeListRow` is used by `GtkTreeListModel` to represent items.
/// 
/// It allows navigating the model as a tree and modify the state of rows.
/// 
/// `GtkTreeListRow` instances are created by a `GtkTreeListModel` only
/// when the [property`Gtk.TreeListModel:passthrough`] property is not set.
/// 
/// There are various support objects that can make use of `GtkTreeListRow`
/// objects, such as the [class`Gtk.TreeExpander`] widget that allows displaying
/// an icon to expand or collapse a row or [class`Gtk.TreeListRowSorter`] that
/// makes it possible to sort trees properly.
///
/// The `TreeListRowProtocol` protocol exposes the methods and properties of an underlying `GtkTreeListRow` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeListRow`.
/// Alternatively, use `TreeListRowRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeListRowProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkTreeListRow` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeListRow` instance.
    var tree_list_row_ptr: UnsafeMutablePointer<GtkTreeListRow>! { get }

    /// Required Initialiser for types conforming to `TreeListRowProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkTreeListRow` is used by `GtkTreeListModel` to represent items.
/// 
/// It allows navigating the model as a tree and modify the state of rows.
/// 
/// `GtkTreeListRow` instances are created by a `GtkTreeListModel` only
/// when the [property`Gtk.TreeListModel:passthrough`] property is not set.
/// 
/// There are various support objects that can make use of `GtkTreeListRow`
/// objects, such as the [class`Gtk.TreeExpander`] widget that allows displaying
/// an icon to expand or collapse a row or [class`Gtk.TreeListRowSorter`] that
/// makes it possible to sort trees properly.
///
/// The `TreeListRowRef` type acts as a lightweight Swift reference to an underlying `GtkTreeListRow` instance.
/// It exposes methods that can operate on this data type through `TreeListRowProtocol` conformance.
/// Use `TreeListRowRef` only as an `unowned` reference to an existing `GtkTreeListRow` instance.
///
public struct TreeListRowRef: TreeListRowProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTreeListRow` instance.
    /// For type-safe access, use the generated, typed pointer `tree_list_row_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeListRowRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeListRow>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeListRow>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeListRow>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeListRow>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeListRowProtocol`
    @inlinable init<T: TreeListRowProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TreeListRowProtocol>(_ other: T) -> TreeListRowRef { TreeListRowRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// `GtkTreeListRow` is used by `GtkTreeListModel` to represent items.
/// 
/// It allows navigating the model as a tree and modify the state of rows.
/// 
/// `GtkTreeListRow` instances are created by a `GtkTreeListModel` only
/// when the [property`Gtk.TreeListModel:passthrough`] property is not set.
/// 
/// There are various support objects that can make use of `GtkTreeListRow`
/// objects, such as the [class`Gtk.TreeExpander`] widget that allows displaying
/// an icon to expand or collapse a row or [class`Gtk.TreeListRowSorter`] that
/// makes it possible to sort trees properly.
///
/// The `TreeListRow` type acts as a reference-counted owner of an underlying `GtkTreeListRow` instance.
/// It provides the methods that can operate on this data type through `TreeListRowProtocol` conformance.
/// Use `TreeListRow` as a strong reference or owner of a `GtkTreeListRow` instance.
///
open class TreeListRow: GLibObject.Object, TreeListRowProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeListRow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeListRow>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeListRow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeListRow>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeListRow` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeListRow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeListRow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeListRow>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeListRow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeListRow>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTreeListRow`.
    /// i.e., ownership is transferred to the `TreeListRow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeListRow>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TreeListRowProtocol`
    /// Will retain `GtkTreeListRow`.
    /// - Parameter other: an instance of a related type that implements `TreeListRowProtocol`
    @inlinable public init<T: TreeListRowProtocol>(treeListRow other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum TreeListRowPropertyName: String, PropertyNameProtocol {
    /// The model holding the row's children.
    case children = "children"
    /// The depth in the tree of this row.
    case depth = "depth"
    /// If this row can ever be expanded.
    case expandable = "expandable"
    /// If this row is currently expanded.
    case expanded = "expanded"
    /// The item held in this row.
    case item = "item"
}

public extension TreeListRowProtocol {
    /// Bind a `TreeListRowPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeListRowPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TreeListRow property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TreeListRowPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TreeListRow property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TreeListRowPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TreeListRowSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The model holding the row's children.
    case notifyChildren = "notify::children"
    /// The depth in the tree of this row.
    case notifyDepth = "notify::depth"
    /// If this row can ever be expanded.
    case notifyExpandable = "notify::expandable"
    /// If this row is currently expanded.
    case notifyExpanded = "notify::expanded"
    /// The item held in this row.
    case notifyItem = "notify::item"
}

// MARK: TreeListRow has no signals
// MARK: TreeListRow Class: TreeListRowProtocol extension (methods and fields)
public extension TreeListRowProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeListRow` instance.
    @inlinable var tree_list_row_ptr: UnsafeMutablePointer<GtkTreeListRow>! { return ptr?.assumingMemoryBound(to: GtkTreeListRow.self) }

    /// If `self` is not expanded or `position` is greater than the
    /// number of children, `nil` is returned.
    @inlinable func getChildRow(position: Int) -> TreeListRowRef! {
        let result = gtk_tree_list_row_get_child_row(tree_list_row_ptr, guint(position))
        guard let rv = TreeListRowRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// If the row is expanded, gets the model holding the children of `self`.
    /// 
    /// This model is the model created by the
    /// [callback`Gtk.TreeListModelCreateModelFunc`]
    /// and contains the original items, no matter what value
    /// [property`Gtk.TreeListModel:passthrough`] is set to.
    @inlinable func getChildren() -> GIO.ListModelRef! {
        let result = gtk_tree_list_row_get_children(tree_list_row_ptr)
        let rv = GIO.ListModelRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Gets the depth of this row.
    /// 
    /// Rows that correspond to items in the root model have a depth
    /// of zero, rows corresponding to items of models of direct children
    /// of the root model have a depth of 1 and so on.
    /// 
    /// The depth of a row never changes until the row is destroyed.
    @inlinable func getDepth() -> Int {
        let result = gtk_tree_list_row_get_depth(tree_list_row_ptr)
        let rv = Int(result)
        return rv
    }

    /// Gets if a row is currently expanded.
    @inlinable func getExpanded() -> Bool {
        let result = gtk_tree_list_row_get_expanded(tree_list_row_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the item corresponding to this row,
    /// 
    /// The value returned by this function never changes until the
    /// row is destroyed.
    @inlinable func getItem() -> GLibObject.ObjectRef! {
        let result = gtk_tree_list_row_get_item(tree_list_row_ptr)
        guard let rv = GLibObject.ObjectRef(gpointer: result) else { return nil }
        return rv
    }

    /// Gets the row representing the parent for `self`.
    /// 
    /// That is the row that would need to be collapsed
    /// to make this row disappear.
    /// 
    /// If `self` is a row corresponding to the root model,
    /// `nil` is returned.
    /// 
    /// The value returned by this function never changes
    /// until the row is destroyed.
    @inlinable func getParent() -> TreeListRowRef! {
        let result = gtk_tree_list_row_get_parent(tree_list_row_ptr)
        guard let rv = TreeListRowRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Returns the position in the `GtkTreeListModel` that `self` occupies
    /// at the moment.
    @inlinable func getPosition() -> Int {
        let result = gtk_tree_list_row_get_position(tree_list_row_ptr)
        let rv = Int(result)
        return rv
    }

    /// Expands or collapses a row.
    /// 
    /// If a row is expanded, the model of calling the
    /// [callback`Gtk.TreeListModelCreateModelFunc`] for the row's
    /// item will be inserted after this row. If a row is collapsed,
    /// those items will be removed from the model.
    /// 
    /// If the row is not expandable, this function does nothing.
    @inlinable func set(expanded: Bool) {
        
        gtk_tree_list_row_set_expanded(tree_list_row_ptr, gboolean((expanded) ? 1 : 0))
        
    }
    /// The model holding the row's children.
    @inlinable var children: GIO.ListModelRef! {
        /// If the row is expanded, gets the model holding the children of `self`.
        /// 
        /// This model is the model created by the
        /// [callback`Gtk.TreeListModelCreateModelFunc`]
        /// and contains the original items, no matter what value
        /// [property`Gtk.TreeListModel:passthrough`] is set to.
        get {
            let result = gtk_tree_list_row_get_children(tree_list_row_ptr)
        let rv = GIO.ListModelRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// The depth in the tree of this row.
    @inlinable var depth: Int {
        /// Gets the depth of this row.
        /// 
        /// Rows that correspond to items in the root model have a depth
        /// of zero, rows corresponding to items of models of direct children
        /// of the root model have a depth of 1 and so on.
        /// 
        /// The depth of a row never changes until the row is destroyed.
        get {
            let result = gtk_tree_list_row_get_depth(tree_list_row_ptr)
        let rv = Int(result)
            return rv
        }
    }

    /// If this row is currently expanded.
    @inlinable var expanded: Bool {
        /// Gets if a row is currently expanded.
        get {
            let result = gtk_tree_list_row_get_expanded(tree_list_row_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Expands or collapses a row.
        /// 
        /// If a row is expanded, the model of calling the
        /// [callback`Gtk.TreeListModelCreateModelFunc`] for the row's
        /// item will be inserted after this row. If a row is collapsed,
        /// those items will be removed from the model.
        /// 
        /// If the row is not expandable, this function does nothing.
        nonmutating set {
            gtk_tree_list_row_set_expanded(tree_list_row_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Checks if a row can be expanded.
    /// 
    /// This does not mean that the row is actually expanded,
    /// this can be checked with [method`Gtk.TreeListRow.get_expanded`].
    /// 
    /// If a row is expandable never changes until the row is destroyed.
    @inlinable var isExpandable: Bool {
        /// Checks if a row can be expanded.
        /// 
        /// This does not mean that the row is actually expanded,
        /// this can be checked with [method`Gtk.TreeListRow.get_expanded`].
        /// 
        /// If a row is expandable never changes until the row is destroyed.
        get {
            let result = gtk_tree_list_row_is_expandable(tree_list_row_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// The item held in this row.
    @inlinable var item: GLibObject.ObjectRef! {
        /// Gets the item corresponding to this row,
        /// 
        /// The value returned by this function never changes until the
        /// row is destroyed.
        get {
            let result = gtk_tree_list_row_get_item(tree_list_row_ptr)
        guard let rv = GLibObject.ObjectRef(gpointer: result) else { return nil }
            return rv
        }
    }

    /// Gets the row representing the parent for `self`.
    /// 
    /// That is the row that would need to be collapsed
    /// to make this row disappear.
    /// 
    /// If `self` is a row corresponding to the root model,
    /// `nil` is returned.
    /// 
    /// The value returned by this function never changes
    /// until the row is destroyed.
    @inlinable var parent: TreeListRowRef! {
        /// Gets the row representing the parent for `self`.
        /// 
        /// That is the row that would need to be collapsed
        /// to make this row disappear.
        /// 
        /// If `self` is a row corresponding to the root model,
        /// `nil` is returned.
        /// 
        /// The value returned by this function never changes
        /// until the row is destroyed.
        get {
            let result = gtk_tree_list_row_get_parent(tree_list_row_ptr)
        guard let rv = TreeListRowRef(gconstpointer: gconstpointer(result)) else { return nil }
            return rv
        }
    }

    /// Returns the position in the `GtkTreeListModel` that `self` occupies
    /// at the moment.
    @inlinable var position: Int {
        /// Returns the position in the `GtkTreeListModel` that `self` occupies
        /// at the moment.
        get {
            let result = gtk_tree_list_row_get_position(tree_list_row_ptr)
        let rv = Int(result)
            return rv
        }
    }


}



// MARK: - TreeListRowSorter Class

/// `GtkTreeListRowSorter` is a special-purpose sorter that will apply a given
/// sorter to the levels in a tree.
/// 
/// Here is an example for setting up a column view with a tree model and
/// a `GtkTreeListSorter`:
/// 
/// ```c
/// column_sorter = gtk_column_view_get_sorter (view);
/// sorter = gtk_tree_list_row_sorter_new (g_object_ref (column_sorter));
/// sort_model = gtk_sort_list_model_new (tree_model, sorter);
/// selection = gtk_single_selection_new (sort_model);
/// gtk_column_view_set_model (view, G_LIST_MODEL (selection));
/// ```
///
/// The `TreeListRowSorterProtocol` protocol exposes the methods and properties of an underlying `GtkTreeListRowSorter` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeListRowSorter`.
/// Alternatively, use `TreeListRowSorterRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeListRowSorterProtocol: SorterProtocol {
        /// Untyped pointer to the underlying `GtkTreeListRowSorter` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeListRowSorter` instance.
    var tree_list_row_sorter_ptr: UnsafeMutablePointer<GtkTreeListRowSorter>! { get }

    /// Required Initialiser for types conforming to `TreeListRowSorterProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkTreeListRowSorter` is a special-purpose sorter that will apply a given
/// sorter to the levels in a tree.
/// 
/// Here is an example for setting up a column view with a tree model and
/// a `GtkTreeListSorter`:
/// 
/// ```c
/// column_sorter = gtk_column_view_get_sorter (view);
/// sorter = gtk_tree_list_row_sorter_new (g_object_ref (column_sorter));
/// sort_model = gtk_sort_list_model_new (tree_model, sorter);
/// selection = gtk_single_selection_new (sort_model);
/// gtk_column_view_set_model (view, G_LIST_MODEL (selection));
/// ```
///
/// The `TreeListRowSorterRef` type acts as a lightweight Swift reference to an underlying `GtkTreeListRowSorter` instance.
/// It exposes methods that can operate on this data type through `TreeListRowSorterProtocol` conformance.
/// Use `TreeListRowSorterRef` only as an `unowned` reference to an existing `GtkTreeListRowSorter` instance.
///
public struct TreeListRowSorterRef: TreeListRowSorterProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTreeListRowSorter` instance.
    /// For type-safe access, use the generated, typed pointer `tree_list_row_sorter_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeListRowSorterRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeListRowSorter>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeListRowSorter>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeListRowSorter>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeListRowSorter>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeListRowSorterProtocol`
    @inlinable init<T: TreeListRowSorterProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TreeListRowSorterProtocol>(_ other: T) -> TreeListRowSorterRef { TreeListRowSorterRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowSorterProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowSorterProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowSorterProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowSorterProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowSorterProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Create a special-purpose sorter that applies the sorting
    /// of `sorter` to the levels of a `GtkTreeListModel`.
    /// 
    /// Note that this sorter relies on [property`Gtk.TreeListModel:passthrough`]
    /// being `false` as it can only sort [class`Gtk.TreeListRow`]s.
    @inlinable init<SorterT: SorterProtocol>( sorter: SorterT?) {
            let result = gtk_tree_list_row_sorter_new(sorter?.sorter_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkTreeListRowSorter` is a special-purpose sorter that will apply a given
/// sorter to the levels in a tree.
/// 
/// Here is an example for setting up a column view with a tree model and
/// a `GtkTreeListSorter`:
/// 
/// ```c
/// column_sorter = gtk_column_view_get_sorter (view);
/// sorter = gtk_tree_list_row_sorter_new (g_object_ref (column_sorter));
/// sort_model = gtk_sort_list_model_new (tree_model, sorter);
/// selection = gtk_single_selection_new (sort_model);
/// gtk_column_view_set_model (view, G_LIST_MODEL (selection));
/// ```
///
/// The `TreeListRowSorter` type acts as a reference-counted owner of an underlying `GtkTreeListRowSorter` instance.
/// It provides the methods that can operate on this data type through `TreeListRowSorterProtocol` conformance.
/// Use `TreeListRowSorter` as a strong reference or owner of a `GtkTreeListRowSorter` instance.
///
open class TreeListRowSorter: Sorter, TreeListRowSorterProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeListRowSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeListRowSorter>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeListRowSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeListRowSorter>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeListRowSorter` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeListRowSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeListRowSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeListRowSorter>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeListRowSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeListRowSorter>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTreeListRowSorter`.
    /// i.e., ownership is transferred to the `TreeListRowSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeListRowSorter>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TreeListRowSorterProtocol`
    /// Will retain `GtkTreeListRowSorter`.
    /// - Parameter other: an instance of a related type that implements `TreeListRowSorterProtocol`
    @inlinable public init<T: TreeListRowSorterProtocol>(treeListRowSorter other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowSorterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowSorterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowSorterProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowSorterProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowSorterProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowSorterProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowSorterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeListRowSorterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Create a special-purpose sorter that applies the sorting
    /// of `sorter` to the levels of a `GtkTreeListModel`.
    /// 
    /// Note that this sorter relies on [property`Gtk.TreeListModel:passthrough`]
    /// being `false` as it can only sort [class`Gtk.TreeListRow`]s.
    @inlinable override public init<SorterT: SorterProtocol>( sorter: SorterT?) {
            let result = gtk_tree_list_row_sorter_new(sorter?.sorter_ptr)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum TreeListRowSorterPropertyName: String, PropertyNameProtocol {
    /// The underlying sorter
    case sorter = "sorter"
}

public extension TreeListRowSorterProtocol {
    /// Bind a `TreeListRowSorterPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeListRowSorterPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TreeListRowSorter property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TreeListRowSorterPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TreeListRowSorter property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TreeListRowSorterPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TreeListRowSorterSignalName: String, SignalNameProtocol {
    /// Emitted whenever the sorter changed.
    /// 
    /// Users of the sorter should then update the sort order
    /// again via `gtk_sorter_compare()`.
    /// 
    /// [class`Gtk.SortListModel`] handles this signal automatically.
    /// 
    /// Depending on the `change` parameter, it may be possible to update
    /// the sort order without a full resorting. Refer to the
    /// [enum`Gtk.SorterChange`] documentation for details.
    case changed = "changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The underlying sorter
    case notifySorter = "notify::sorter"
}

// MARK: TreeListRowSorter has no signals
// MARK: TreeListRowSorter Class: TreeListRowSorterProtocol extension (methods and fields)
public extension TreeListRowSorterProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeListRowSorter` instance.
    @inlinable var tree_list_row_sorter_ptr: UnsafeMutablePointer<GtkTreeListRowSorter>! { return ptr?.assumingMemoryBound(to: GtkTreeListRowSorter.self) }

    /// Returns the sorter used by `self`.
    @inlinable func getSorter() -> SorterRef! {
        let result = gtk_tree_list_row_sorter_get_sorter(tree_list_row_sorter_ptr)
        guard let rv = SorterRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }

    /// Sets the sorter to use for items with the same parent.
    /// 
    /// This sorter will be passed the [property`Gtk.TreeListRow:item`] of
    /// the tree list rows passed to `self`.
    @inlinable func set(sorter: SorterRef? = nil) {
            
        gtk_tree_list_row_sorter_set_sorter(tree_list_row_sorter_ptr, sorter?.sorter_ptr)
            
    }
    /// Sets the sorter to use for items with the same parent.
    /// 
    /// This sorter will be passed the [property`Gtk.TreeListRow:item`] of
    /// the tree list rows passed to `self`.
    @inlinable func set<SorterT: SorterProtocol>(sorter: SorterT?) {
        
        gtk_tree_list_row_sorter_set_sorter(tree_list_row_sorter_ptr, sorter?.sorter_ptr)
        
    }
    /// The underlying sorter
    @inlinable var sorter: SorterRef! {
        /// Returns the sorter used by `self`.
        get {
            let result = gtk_tree_list_row_sorter_get_sorter(tree_list_row_sorter_ptr)
        guard let rv = SorterRef(gconstpointer: gconstpointer(result)) else { return nil }
            return rv
        }
        /// Sets the sorter to use for items with the same parent.
        /// 
        /// This sorter will be passed the [property`Gtk.TreeListRow:item`] of
        /// the tree list rows passed to `self`.
        nonmutating set {
            gtk_tree_list_row_sorter_set_sorter(tree_list_row_sorter_ptr, UnsafeMutablePointer<GtkSorter>(newValue?.sorter_ptr))
        }
    }


}



// MARK: - TreeModelFilter Class

/// A `GtkTreeModel` which hides parts of an underlying tree model
/// 
/// A `GtkTreeModelFilter` is a tree model which wraps another tree model,
/// and can do the following things:
/// 
/// - Filter specific rows, based on data from a “visible column”, a column
///   storing booleans indicating whether the row should be filtered or not,
///   or based on the return value of a “visible function”, which gets a
///   model, iter and user_data and returns a boolean indicating whether the
///   row should be filtered or not.
/// 
/// - Modify the “appearance” of the model, using a modify function.
///   This is extremely powerful and allows for just changing some
///   values and also for creating a completely different model based
///   on the given child model.
/// 
/// - Set a different root node, also known as a “virtual root”. You can pass
///   in a `GtkTreePath` indicating the root node for the filter at construction
///   time.
/// 
/// The basic API is similar to `GtkTreeModelSort`. For an example on its usage,
/// see the section on `GtkTreeModelSort`.
/// 
/// When using `GtkTreeModelFilter`, it is important to realize that
/// `GtkTreeModelFilter` maintains an internal cache of all nodes which are
/// visible in its clients. The cache is likely to be a subtree of the tree
/// exposed by the child model. `GtkTreeModelFilter` will not cache the entire
/// child model when unnecessary to not compromise the caching mechanism
/// that is exposed by the reference counting scheme. If the child model
/// implements reference counting, unnecessary signals may not be emitted
/// because of reference counting rule 3, see the `GtkTreeModel`
/// documentation. (Note that e.g. `GtkTreeStore` does not implement
/// reference counting and will always emit all signals, even when
/// the receiving node is not visible).
/// 
/// Because of this, limitations for possible visible functions do apply.
/// In general, visible functions should only use data or properties from
/// the node for which the visibility state must be determined, its siblings
/// or its parents. Usually, having a dependency on the state of any child
/// node is not possible, unless references are taken on these explicitly.
/// When no such reference exists, no signals may be received for these child
/// nodes (see reference counting rule number 3 in the `GtkTreeModel` section).
/// 
/// Determining the visibility state of a given node based on the state
/// of its child nodes is a frequently occurring use case. Therefore,
/// `GtkTreeModelFilter` explicitly supports this. For example, when a node
/// does not have any children, you might not want the node to be visible.
/// As soon as the first row is added to the node’s child level (or the
/// last row removed), the node’s visibility should be updated.
/// 
/// This introduces a dependency from the node on its child nodes. In order
/// to accommodate this, `GtkTreeModelFilter` must make sure the necessary
/// signals are received from the child model. This is achieved by building,
/// for all nodes which are exposed as visible nodes to `GtkTreeModelFilter`'s
/// clients, the child level (if any) and take a reference on the first node
/// in this level. Furthermore, for every row-inserted, row-changed or
/// row-deleted signal (also these which were not handled because the node
/// was not cached), `GtkTreeModelFilter` will check if the visibility state
/// of any parent node has changed.
/// 
/// Beware, however, that this explicit support is limited to these two
/// cases. For example, if you want a node to be visible only if two nodes
/// in a child’s child level (2 levels deeper) are visible, you are on your
/// own. In this case, either rely on `GtkTreeStore` to emit all signals
/// because it does not implement reference counting, or for models that
/// do implement reference counting, obtain references on these child levels
/// yourself.
///
/// The `TreeModelFilterProtocol` protocol exposes the methods and properties of an underlying `GtkTreeModelFilter` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeModelFilter`.
/// Alternatively, use `TreeModelFilterRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeModelFilterProtocol: GLibObject.ObjectProtocol, TreeDragSourceProtocol, TreeModelProtocol {
        /// Untyped pointer to the underlying `GtkTreeModelFilter` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeModelFilter` instance.
    var tree_model_filter_ptr: UnsafeMutablePointer<GtkTreeModelFilter>! { get }

    /// Required Initialiser for types conforming to `TreeModelFilterProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkTreeModel` which hides parts of an underlying tree model
/// 
/// A `GtkTreeModelFilter` is a tree model which wraps another tree model,
/// and can do the following things:
/// 
/// - Filter specific rows, based on data from a “visible column”, a column
///   storing booleans indicating whether the row should be filtered or not,
///   or based on the return value of a “visible function”, which gets a
///   model, iter and user_data and returns a boolean indicating whether the
///   row should be filtered or not.
/// 
/// - Modify the “appearance” of the model, using a modify function.
///   This is extremely powerful and allows for just changing some
///   values and also for creating a completely different model based
///   on the given child model.
/// 
/// - Set a different root node, also known as a “virtual root”. You can pass
///   in a `GtkTreePath` indicating the root node for the filter at construction
///   time.
/// 
/// The basic API is similar to `GtkTreeModelSort`. For an example on its usage,
/// see the section on `GtkTreeModelSort`.
/// 
/// When using `GtkTreeModelFilter`, it is important to realize that
/// `GtkTreeModelFilter` maintains an internal cache of all nodes which are
/// visible in its clients. The cache is likely to be a subtree of the tree
/// exposed by the child model. `GtkTreeModelFilter` will not cache the entire
/// child model when unnecessary to not compromise the caching mechanism
/// that is exposed by the reference counting scheme. If the child model
/// implements reference counting, unnecessary signals may not be emitted
/// because of reference counting rule 3, see the `GtkTreeModel`
/// documentation. (Note that e.g. `GtkTreeStore` does not implement
/// reference counting and will always emit all signals, even when
/// the receiving node is not visible).
/// 
/// Because of this, limitations for possible visible functions do apply.
/// In general, visible functions should only use data or properties from
/// the node for which the visibility state must be determined, its siblings
/// or its parents. Usually, having a dependency on the state of any child
/// node is not possible, unless references are taken on these explicitly.
/// When no such reference exists, no signals may be received for these child
/// nodes (see reference counting rule number 3 in the `GtkTreeModel` section).
/// 
/// Determining the visibility state of a given node based on the state
/// of its child nodes is a frequently occurring use case. Therefore,
/// `GtkTreeModelFilter` explicitly supports this. For example, when a node
/// does not have any children, you might not want the node to be visible.
/// As soon as the first row is added to the node’s child level (or the
/// last row removed), the node’s visibility should be updated.
/// 
/// This introduces a dependency from the node on its child nodes. In order
/// to accommodate this, `GtkTreeModelFilter` must make sure the necessary
/// signals are received from the child model. This is achieved by building,
/// for all nodes which are exposed as visible nodes to `GtkTreeModelFilter`'s
/// clients, the child level (if any) and take a reference on the first node
/// in this level. Furthermore, for every row-inserted, row-changed or
/// row-deleted signal (also these which were not handled because the node
/// was not cached), `GtkTreeModelFilter` will check if the visibility state
/// of any parent node has changed.
/// 
/// Beware, however, that this explicit support is limited to these two
/// cases. For example, if you want a node to be visible only if two nodes
/// in a child’s child level (2 levels deeper) are visible, you are on your
/// own. In this case, either rely on `GtkTreeStore` to emit all signals
/// because it does not implement reference counting, or for models that
/// do implement reference counting, obtain references on these child levels
/// yourself.
///
/// The `TreeModelFilterRef` type acts as a lightweight Swift reference to an underlying `GtkTreeModelFilter` instance.
/// It exposes methods that can operate on this data type through `TreeModelFilterProtocol` conformance.
/// Use `TreeModelFilterRef` only as an `unowned` reference to an existing `GtkTreeModelFilter` instance.
///
public struct TreeModelFilterRef: TreeModelFilterProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTreeModelFilter` instance.
    /// For type-safe access, use the generated, typed pointer `tree_model_filter_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeModelFilterRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeModelFilter>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeModelFilter>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeModelFilter>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeModelFilter>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeModelFilterProtocol`
    @inlinable init<T: TreeModelFilterProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TreeModelFilterProtocol>(_ other: T) -> TreeModelFilterRef { TreeModelFilterRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// A `GtkTreeModel` which hides parts of an underlying tree model
/// 
/// A `GtkTreeModelFilter` is a tree model which wraps another tree model,
/// and can do the following things:
/// 
/// - Filter specific rows, based on data from a “visible column”, a column
///   storing booleans indicating whether the row should be filtered or not,
///   or based on the return value of a “visible function”, which gets a
///   model, iter and user_data and returns a boolean indicating whether the
///   row should be filtered or not.
/// 
/// - Modify the “appearance” of the model, using a modify function.
///   This is extremely powerful and allows for just changing some
///   values and also for creating a completely different model based
///   on the given child model.
/// 
/// - Set a different root node, also known as a “virtual root”. You can pass
///   in a `GtkTreePath` indicating the root node for the filter at construction
///   time.
/// 
/// The basic API is similar to `GtkTreeModelSort`. For an example on its usage,
/// see the section on `GtkTreeModelSort`.
/// 
/// When using `GtkTreeModelFilter`, it is important to realize that
/// `GtkTreeModelFilter` maintains an internal cache of all nodes which are
/// visible in its clients. The cache is likely to be a subtree of the tree
/// exposed by the child model. `GtkTreeModelFilter` will not cache the entire
/// child model when unnecessary to not compromise the caching mechanism
/// that is exposed by the reference counting scheme. If the child model
/// implements reference counting, unnecessary signals may not be emitted
/// because of reference counting rule 3, see the `GtkTreeModel`
/// documentation. (Note that e.g. `GtkTreeStore` does not implement
/// reference counting and will always emit all signals, even when
/// the receiving node is not visible).
/// 
/// Because of this, limitations for possible visible functions do apply.
/// In general, visible functions should only use data or properties from
/// the node for which the visibility state must be determined, its siblings
/// or its parents. Usually, having a dependency on the state of any child
/// node is not possible, unless references are taken on these explicitly.
/// When no such reference exists, no signals may be received for these child
/// nodes (see reference counting rule number 3 in the `GtkTreeModel` section).
/// 
/// Determining the visibility state of a given node based on the state
/// of its child nodes is a frequently occurring use case. Therefore,
/// `GtkTreeModelFilter` explicitly supports this. For example, when a node
/// does not have any children, you might not want the node to be visible.
/// As soon as the first row is added to the node’s child level (or the
/// last row removed), the node’s visibility should be updated.
/// 
/// This introduces a dependency from the node on its child nodes. In order
/// to accommodate this, `GtkTreeModelFilter` must make sure the necessary
/// signals are received from the child model. This is achieved by building,
/// for all nodes which are exposed as visible nodes to `GtkTreeModelFilter`'s
/// clients, the child level (if any) and take a reference on the first node
/// in this level. Furthermore, for every row-inserted, row-changed or
/// row-deleted signal (also these which were not handled because the node
/// was not cached), `GtkTreeModelFilter` will check if the visibility state
/// of any parent node has changed.
/// 
/// Beware, however, that this explicit support is limited to these two
/// cases. For example, if you want a node to be visible only if two nodes
/// in a child’s child level (2 levels deeper) are visible, you are on your
/// own. In this case, either rely on `GtkTreeStore` to emit all signals
/// because it does not implement reference counting, or for models that
/// do implement reference counting, obtain references on these child levels
/// yourself.
///
/// The `TreeModelFilter` type acts as a reference-counted owner of an underlying `GtkTreeModelFilter` instance.
/// It provides the methods that can operate on this data type through `TreeModelFilterProtocol` conformance.
/// Use `TreeModelFilter` as a strong reference or owner of a `GtkTreeModelFilter` instance.
///
open class TreeModelFilter: GLibObject.Object, TreeModelFilterProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeModelFilter>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeModelFilter>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelFilter` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeModelFilter>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeModelFilter>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTreeModelFilter`.
    /// i.e., ownership is transferred to the `TreeModelFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeModelFilter>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TreeModelFilterProtocol`
    /// Will retain `GtkTreeModelFilter`.
    /// - Parameter other: an instance of a related type that implements `TreeModelFilterProtocol`
    @inlinable public init<T: TreeModelFilterProtocol>(treeModelFilter other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum TreeModelFilterPropertyName: String, PropertyNameProtocol {
    case childModel = "child-model"
    case virtualRoot = "virtual-root"
}

public extension TreeModelFilterProtocol {
    /// Bind a `TreeModelFilterPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeModelFilterPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TreeModelFilter property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TreeModelFilterPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TreeModelFilter property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TreeModelFilterPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TreeModelFilterSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyChildModel = "notify::child-model"
    case notifyVirtualRoot = "notify::virtual-root"
}

// MARK: TreeModelFilter has no signals
// MARK: TreeModelFilter Class: TreeModelFilterProtocol extension (methods and fields)
public extension TreeModelFilterProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeModelFilter` instance.
    @inlinable var tree_model_filter_ptr: UnsafeMutablePointer<GtkTreeModelFilter>! { return ptr?.assumingMemoryBound(to: GtkTreeModelFilter.self) }

    /// This function should almost never be called. It clears the `filter`
    /// of any cached iterators that haven’t been reffed with
    /// `gtk_tree_model_ref_node()`. This might be useful if the child model
    /// being filtered is static (and doesn’t change often) and there has been
    /// a lot of unreffed access to nodes. As a side effect of this function,
    /// all unreffed iters will be invalid.
    @inlinable func clearCache() {
        
        gtk_tree_model_filter_clear_cache(tree_model_filter_ptr)
        
    }

    /// Sets `filter_iter` to point to the row in `filter` that corresponds to the
    /// row pointed at by `child_iter`.  If `filter_iter` was not set, `false` is
    /// returned.
    @inlinable func convertChildIterToIter<TreeIterT: TreeIterProtocol>(filterIter: TreeIterT, childIter: TreeIterT) -> Bool {
        let result = gtk_tree_model_filter_convert_child_iter_to_iter(tree_model_filter_ptr, filterIter.tree_iter_ptr, childIter.tree_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Converts `child_path` to a path relative to `filter`. That is, `child_path`
    /// points to a path in the child model. The rerturned path will point to the
    /// same row in the filtered model. If `child_path` isn’t a valid path on the
    /// child model or points to a row which is not visible in `filter`, then `nil`
    /// is returned.
    @inlinable func convertChildPathToPath<TreePathT: TreePathProtocol>(childPath: TreePathT) -> TreePathRef! {
        let result = gtk_tree_model_filter_convert_child_path_to_path(tree_model_filter_ptr, childPath.tree_path_ptr)
        let rv = TreePathRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Sets `child_iter` to point to the row pointed to by `filter_iter`.
    @inlinable func convertIterTo<TreeIterT: TreeIterProtocol>(childIter: TreeIterT, filterIter: TreeIterT) {
        
        gtk_tree_model_filter_convert_iter_to_child_iter(tree_model_filter_ptr, childIter.tree_iter_ptr, filterIter.tree_iter_ptr)
        
    }

    /// Converts `filter_path` to a path on the child model of `filter`. That is,
    /// `filter_path` points to a location in `filter`. The returned path will
    /// point to the same location in the model not being filtered. If `filter_path`
    /// does not point to a location in the child model, `nil` is returned.
    @inlinable func convertPathToChildPath<TreePathT: TreePathProtocol>(filterPath: TreePathT) -> TreePathRef! {
        let result = gtk_tree_model_filter_convert_path_to_child_path(tree_model_filter_ptr, filterPath.tree_path_ptr)
        let rv = TreePathRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns a pointer to the child model of `filter`.
    @inlinable func getModel() -> TreeModelRef! {
        let result = gtk_tree_model_filter_get_model(tree_model_filter_ptr)
        let rv = TreeModelRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Emits `row_changed` for each row in the child model, which causes
    /// the filter to re-evaluate whether a row is visible or not.
    @inlinable func refilter() {
        
        gtk_tree_model_filter_refilter(tree_model_filter_ptr)
        
    }

    /// With the `n_columns` and `types` parameters, you give an array of column
    /// types for this model (which will be exposed to the parent model/view).
    /// The `func`, `data` and `destroy` parameters are for specifying the modify
    /// function. The modify function will get called for each
    /// data access, the goal of the modify function is to return the data which
    /// should be displayed at the location specified using the parameters of the
    /// modify function.
    /// 
    /// Note that `gtk_tree_model_filter_set_modify_func()`
    /// can only be called once for a given filter model.
    @inlinable func setModifyFunc(nColumns: Int, types: UnsafeMutablePointer<GType>!, `func`: GtkTreeModelFilterModifyFunc?, data: gpointer? = nil, destroy: GDestroyNotify? = nil) {
        
        gtk_tree_model_filter_set_modify_func(tree_model_filter_ptr, gint(nColumns), types, `func`, data, destroy)
        
    }

    /// Sets `column` of the child_model to be the column where `filter` should
    /// look for visibility information. `columns` should be a column of type
    /// `G_TYPE_BOOLEAN`, where `true` means that a row is visible, and `false`
    /// if not.
    /// 
    /// Note that `gtk_tree_model_filter_set_visible_func()` or
    /// `gtk_tree_model_filter_set_visible_column()` can only be called
    /// once for a given filter model.
    @inlinable func setVisible(column: Int) {
        
        gtk_tree_model_filter_set_visible_column(tree_model_filter_ptr, gint(column))
        
    }

    /// Sets the visible function used when filtering the `filter` to be `func`.
    /// The function should return `true` if the given row should be visible and
    /// `false` otherwise.
    /// 
    /// If the condition calculated by the function changes over time (e.g.
    /// because it depends on some global parameters), you must call
    /// `gtk_tree_model_filter_refilter()` to keep the visibility information
    /// of the model up-to-date.
    /// 
    /// Note that `func` is called whenever a row is inserted, when it may still
    /// be empty. The visible function should therefore take special care of empty
    /// rows, like in the example below.
    /// 
    /// (C Language Example):
    /// ```C
    /// static gboolean
    /// visible_func (GtkTreeModel *model,
    ///               GtkTreeIter  *iter,
    ///               gpointer      data)
    /// {
    ///   // Visible if row is non-empty and first column is “HI”
    ///   char *str;
    ///   gboolean visible = FALSE;
    /// 
    ///   gtk_tree_model_get (model, iter, 0, &str, -1);
    ///   if (str && strcmp (str, "HI") == 0)
    ///     visible = TRUE;
    ///   g_free (str);
    /// 
    ///   return visible;
    /// }
    /// ```
    /// 
    /// Note that `gtk_tree_model_filter_set_visible_func()` or
    /// `gtk_tree_model_filter_set_visible_column()` can only be called
    /// once for a given filter model.
    @inlinable func setVisibleFunc(`func`: GtkTreeModelFilterVisibleFunc?, data: gpointer? = nil, destroy: GDestroyNotify? = nil) {
        
        gtk_tree_model_filter_set_visible_func(tree_model_filter_ptr, `func`, data, destroy)
        
    }
    /// Returns a pointer to the child model of `filter`.
    @inlinable var model: TreeModelRef! {
        /// Returns a pointer to the child model of `filter`.
        get {
            let result = gtk_tree_model_filter_get_model(tree_model_filter_ptr)
        let rv = TreeModelRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    @inlinable var parent: GObject {
        get {
            let rv = tree_model_filter_ptr.pointee.parent
    return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - TreeModelSort Class

/// A GtkTreeModel which makes an underlying tree model sortable
/// 
/// The `GtkTreeModelSort` is a model which implements the `GtkTreeSortable`
/// interface.  It does not hold any data itself, but rather is created with
/// a child model and proxies its data.  It has identical column types to
/// this child model, and the changes in the child are propagated.  The
/// primary purpose of this model is to provide a way to sort a different
/// model without modifying it. Note that the sort function used by
/// `GtkTreeModelSort` is not guaranteed to be stable.
/// 
/// The use of this is best demonstrated through an example.  In the
/// following sample code we create two `GtkTreeView` widgets each with a
/// view of the same data.  As the model is wrapped here by a
/// `GtkTreeModelSort`, the two `GtkTreeView`s can each sort their
/// view of the data without affecting the other.  By contrast, if we
/// simply put the same model in each widget, then sorting the first would
/// sort the second.
/// 
/// ## Using a `GtkTreeModelSort`
/// 
/// (C Language Example):
/// ```C
/// {
///   GtkTreeView *tree_view1;
///   GtkTreeView *tree_view2;
///   GtkTreeModel *sort_model1;
///   GtkTreeModel *sort_model2;
///   GtkTreeModel *child_model;
/// 
///   // get the child model
///   child_model = get_my_model ();
/// 
///   // Create the first tree
///   sort_model1 = gtk_tree_model_sort_new_with_model (child_model);
///   tree_view1 = gtk_tree_view_new_with_model (sort_model1);
/// 
///   // Create the second tree
///   sort_model2 = gtk_tree_model_sort_new_with_model (child_model);
///   tree_view2 = gtk_tree_view_new_with_model (sort_model2);
/// 
///   // Now we can sort the two models independently
///   gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model1),
///                                         COLUMN_1, GTK_SORT_ASCENDING);
///   gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model2),
///                                         COLUMN_1, GTK_SORT_DESCENDING);
/// }
/// ```
/// 
/// To demonstrate how to access the underlying child model from the sort
/// model, the next example will be a callback for the `GtkTreeSelection`
/// `GtkTreeSelection`changed`` signal.  In this callback, we get a string
/// from COLUMN_1 of the model.  We then modify the string, find the same
/// selected row on the child model, and change the row there.
/// 
/// ## Accessing the child model of in a selection changed callback
/// 
/// (C Language Example):
/// ```C
/// void
/// selection_changed (GtkTreeSelection *selection, gpointer data)
/// {
///   GtkTreeModel *sort_model = NULL;
///   GtkTreeModel *child_model;
///   GtkTreeIter sort_iter;
///   GtkTreeIter child_iter;
///   char *some_data = NULL;
///   char *modified_data;
/// 
///   // Get the current selected row and the model.
///   if (! gtk_tree_selection_get_selected (selection,
///                                          &sort_model,
///                                          &sort_iter))
///     return;
/// 
///   // Look up the current value on the selected row and get
///   // a new value to change it to.
///   gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
///                       COLUMN_1, &some_data,
///                       -1);
/// 
///   modified_data = change_the_data (some_data);
///   g_free (some_data);
/// 
///   // Get an iterator on the child model, instead of the sort model.
///   gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
///                                                   &child_iter,
///                                                   &sort_iter);
/// 
///   // Get the child model and change the value of the row. In this
///   // example, the child model is a GtkListStore. It could be any other
///   // type of model, though.
///   child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
///   gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
///                       COLUMN_1, &modified_data,
///                       -1);
///   g_free (modified_data);
/// }
/// ```
/// 
///
/// The `TreeModelSortProtocol` protocol exposes the methods and properties of an underlying `GtkTreeModelSort` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeModelSort`.
/// Alternatively, use `TreeModelSortRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeModelSortProtocol: GLibObject.ObjectProtocol, TreeDragSourceProtocol, TreeModelProtocol, TreeSortableProtocol {
        /// Untyped pointer to the underlying `GtkTreeModelSort` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeModelSort` instance.
    var tree_model_sort_ptr: UnsafeMutablePointer<GtkTreeModelSort>! { get }

    /// Required Initialiser for types conforming to `TreeModelSortProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A GtkTreeModel which makes an underlying tree model sortable
/// 
/// The `GtkTreeModelSort` is a model which implements the `GtkTreeSortable`
/// interface.  It does not hold any data itself, but rather is created with
/// a child model and proxies its data.  It has identical column types to
/// this child model, and the changes in the child are propagated.  The
/// primary purpose of this model is to provide a way to sort a different
/// model without modifying it. Note that the sort function used by
/// `GtkTreeModelSort` is not guaranteed to be stable.
/// 
/// The use of this is best demonstrated through an example.  In the
/// following sample code we create two `GtkTreeView` widgets each with a
/// view of the same data.  As the model is wrapped here by a
/// `GtkTreeModelSort`, the two `GtkTreeView`s can each sort their
/// view of the data without affecting the other.  By contrast, if we
/// simply put the same model in each widget, then sorting the first would
/// sort the second.
/// 
/// ## Using a `GtkTreeModelSort`
/// 
/// (C Language Example):
/// ```C
/// {
///   GtkTreeView *tree_view1;
///   GtkTreeView *tree_view2;
///   GtkTreeModel *sort_model1;
///   GtkTreeModel *sort_model2;
///   GtkTreeModel *child_model;
/// 
///   // get the child model
///   child_model = get_my_model ();
/// 
///   // Create the first tree
///   sort_model1 = gtk_tree_model_sort_new_with_model (child_model);
///   tree_view1 = gtk_tree_view_new_with_model (sort_model1);
/// 
///   // Create the second tree
///   sort_model2 = gtk_tree_model_sort_new_with_model (child_model);
///   tree_view2 = gtk_tree_view_new_with_model (sort_model2);
/// 
///   // Now we can sort the two models independently
///   gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model1),
///                                         COLUMN_1, GTK_SORT_ASCENDING);
///   gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model2),
///                                         COLUMN_1, GTK_SORT_DESCENDING);
/// }
/// ```
/// 
/// To demonstrate how to access the underlying child model from the sort
/// model, the next example will be a callback for the `GtkTreeSelection`
/// `GtkTreeSelection`changed`` signal.  In this callback, we get a string
/// from COLUMN_1 of the model.  We then modify the string, find the same
/// selected row on the child model, and change the row there.
/// 
/// ## Accessing the child model of in a selection changed callback
/// 
/// (C Language Example):
/// ```C
/// void
/// selection_changed (GtkTreeSelection *selection, gpointer data)
/// {
///   GtkTreeModel *sort_model = NULL;
///   GtkTreeModel *child_model;
///   GtkTreeIter sort_iter;
///   GtkTreeIter child_iter;
///   char *some_data = NULL;
///   char *modified_data;
/// 
///   // Get the current selected row and the model.
///   if (! gtk_tree_selection_get_selected (selection,
///                                          &sort_model,
///                                          &sort_iter))
///     return;
/// 
///   // Look up the current value on the selected row and get
///   // a new value to change it to.
///   gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
///                       COLUMN_1, &some_data,
///                       -1);
/// 
///   modified_data = change_the_data (some_data);
///   g_free (some_data);
/// 
///   // Get an iterator on the child model, instead of the sort model.
///   gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
///                                                   &child_iter,
///                                                   &sort_iter);
/// 
///   // Get the child model and change the value of the row. In this
///   // example, the child model is a GtkListStore. It could be any other
///   // type of model, though.
///   child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
///   gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
///                       COLUMN_1, &modified_data,
///                       -1);
///   g_free (modified_data);
/// }
/// ```
/// 
///
/// The `TreeModelSortRef` type acts as a lightweight Swift reference to an underlying `GtkTreeModelSort` instance.
/// It exposes methods that can operate on this data type through `TreeModelSortProtocol` conformance.
/// Use `TreeModelSortRef` only as an `unowned` reference to an existing `GtkTreeModelSort` instance.
///
public struct TreeModelSortRef: TreeModelSortProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTreeModelSort` instance.
    /// For type-safe access, use the generated, typed pointer `tree_model_sort_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeModelSortRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeModelSort>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeModelSort>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeModelSort>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeModelSort>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeModelSortProtocol`
    @inlinable init<T: TreeModelSortProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TreeModelSortProtocol>(_ other: T) -> TreeModelSortRef { TreeModelSortRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// A GtkTreeModel which makes an underlying tree model sortable
/// 
/// The `GtkTreeModelSort` is a model which implements the `GtkTreeSortable`
/// interface.  It does not hold any data itself, but rather is created with
/// a child model and proxies its data.  It has identical column types to
/// this child model, and the changes in the child are propagated.  The
/// primary purpose of this model is to provide a way to sort a different
/// model without modifying it. Note that the sort function used by
/// `GtkTreeModelSort` is not guaranteed to be stable.
/// 
/// The use of this is best demonstrated through an example.  In the
/// following sample code we create two `GtkTreeView` widgets each with a
/// view of the same data.  As the model is wrapped here by a
/// `GtkTreeModelSort`, the two `GtkTreeView`s can each sort their
/// view of the data without affecting the other.  By contrast, if we
/// simply put the same model in each widget, then sorting the first would
/// sort the second.
/// 
/// ## Using a `GtkTreeModelSort`
/// 
/// (C Language Example):
/// ```C
/// {
///   GtkTreeView *tree_view1;
///   GtkTreeView *tree_view2;
///   GtkTreeModel *sort_model1;
///   GtkTreeModel *sort_model2;
///   GtkTreeModel *child_model;
/// 
///   // get the child model
///   child_model = get_my_model ();
/// 
///   // Create the first tree
///   sort_model1 = gtk_tree_model_sort_new_with_model (child_model);
///   tree_view1 = gtk_tree_view_new_with_model (sort_model1);
/// 
///   // Create the second tree
///   sort_model2 = gtk_tree_model_sort_new_with_model (child_model);
///   tree_view2 = gtk_tree_view_new_with_model (sort_model2);
/// 
///   // Now we can sort the two models independently
///   gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model1),
///                                         COLUMN_1, GTK_SORT_ASCENDING);
///   gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model2),
///                                         COLUMN_1, GTK_SORT_DESCENDING);
/// }
/// ```
/// 
/// To demonstrate how to access the underlying child model from the sort
/// model, the next example will be a callback for the `GtkTreeSelection`
/// `GtkTreeSelection`changed`` signal.  In this callback, we get a string
/// from COLUMN_1 of the model.  We then modify the string, find the same
/// selected row on the child model, and change the row there.
/// 
/// ## Accessing the child model of in a selection changed callback
/// 
/// (C Language Example):
/// ```C
/// void
/// selection_changed (GtkTreeSelection *selection, gpointer data)
/// {
///   GtkTreeModel *sort_model = NULL;
///   GtkTreeModel *child_model;
///   GtkTreeIter sort_iter;
///   GtkTreeIter child_iter;
///   char *some_data = NULL;
///   char *modified_data;
/// 
///   // Get the current selected row and the model.
///   if (! gtk_tree_selection_get_selected (selection,
///                                          &sort_model,
///                                          &sort_iter))
///     return;
/// 
///   // Look up the current value on the selected row and get
///   // a new value to change it to.
///   gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
///                       COLUMN_1, &some_data,
///                       -1);
/// 
///   modified_data = change_the_data (some_data);
///   g_free (some_data);
/// 
///   // Get an iterator on the child model, instead of the sort model.
///   gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
///                                                   &child_iter,
///                                                   &sort_iter);
/// 
///   // Get the child model and change the value of the row. In this
///   // example, the child model is a GtkListStore. It could be any other
///   // type of model, though.
///   child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
///   gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
///                       COLUMN_1, &modified_data,
///                       -1);
///   g_free (modified_data);
/// }
/// ```
/// 
///
/// The `TreeModelSort` type acts as a reference-counted owner of an underlying `GtkTreeModelSort` instance.
/// It provides the methods that can operate on this data type through `TreeModelSortProtocol` conformance.
/// Use `TreeModelSort` as a strong reference or owner of a `GtkTreeModelSort` instance.
///
open class TreeModelSort: GLibObject.Object, TreeModelSortProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelSort` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeModelSort>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelSort` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeModelSort>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelSort` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelSort` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelSort` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeModelSort>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelSort` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeModelSort>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTreeModelSort`.
    /// i.e., ownership is transferred to the `TreeModelSort` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeModelSort>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TreeModelSortProtocol`
    /// Will retain `GtkTreeModelSort`.
    /// - Parameter other: an instance of a related type that implements `TreeModelSortProtocol`
    @inlinable public init<T: TreeModelSortProtocol>(treeModelSort other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum TreeModelSortPropertyName: String, PropertyNameProtocol {
    case model = "model"
}

public extension TreeModelSortProtocol {
    /// Bind a `TreeModelSortPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeModelSortPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TreeModelSort property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TreeModelSortPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TreeModelSort property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TreeModelSortPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TreeModelSortSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyModel = "notify::model"
}

// MARK: TreeModelSort has no signals
// MARK: TreeModelSort Class: TreeModelSortProtocol extension (methods and fields)
public extension TreeModelSortProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeModelSort` instance.
    @inlinable var tree_model_sort_ptr: UnsafeMutablePointer<GtkTreeModelSort>! { return ptr?.assumingMemoryBound(to: GtkTreeModelSort.self) }

    /// This function should almost never be called.  It clears the `tree_model_sort`
    /// of any cached iterators that haven’t been reffed with
    /// `gtk_tree_model_ref_node()`.  This might be useful if the child model being
    /// sorted is static (and doesn’t change often) and there has been a lot of
    /// unreffed access to nodes.  As a side effect of this function, all unreffed
    /// iters will be invalid.
    @inlinable func clearCache() {
        
        gtk_tree_model_sort_clear_cache(tree_model_sort_ptr)
        
    }

    /// Sets `sort_iter` to point to the row in `tree_model_sort` that corresponds to
    /// the row pointed at by `child_iter`.  If `sort_iter` was not set, `false`
    /// is returned.  Note: a boolean is only returned since 2.14.
    @inlinable func convertChildIterToIter<TreeIterT: TreeIterProtocol>(sortIter: TreeIterT, childIter: TreeIterT) -> Bool {
        let result = gtk_tree_model_sort_convert_child_iter_to_iter(tree_model_sort_ptr, sortIter.tree_iter_ptr, childIter.tree_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Converts `child_path` to a path relative to `tree_model_sort`.  That is,
    /// `child_path` points to a path in the child model.  The returned path will
    /// point to the same row in the sorted model.  If `child_path` isn’t a valid
    /// path on the child model, then `nil` is returned.
    @inlinable func convertChildPathToPath<TreePathT: TreePathProtocol>(childPath: TreePathT) -> TreePathRef! {
        let result = gtk_tree_model_sort_convert_child_path_to_path(tree_model_sort_ptr, childPath.tree_path_ptr)
        let rv = TreePathRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Sets `child_iter` to point to the row pointed to by `sorted_iter`.
    @inlinable func convertIterTo<TreeIterT: TreeIterProtocol>(childIter: TreeIterT, sortedIter: TreeIterT) {
        
        gtk_tree_model_sort_convert_iter_to_child_iter(tree_model_sort_ptr, childIter.tree_iter_ptr, sortedIter.tree_iter_ptr)
        
    }

    /// Converts `sorted_path` to a path on the child model of `tree_model_sort`.
    /// That is, `sorted_path` points to a location in `tree_model_sort`.  The
    /// returned path will point to the same location in the model not being
    /// sorted.  If `sorted_path` does not point to a location in the child model,
    /// `nil` is returned.
    @inlinable func convertPathToChildPath<TreePathT: TreePathProtocol>(sortedPath: TreePathT) -> TreePathRef! {
        let result = gtk_tree_model_sort_convert_path_to_child_path(tree_model_sort_ptr, sortedPath.tree_path_ptr)
        let rv = TreePathRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns the model the `GtkTreeModelSort` is sorting.
    @inlinable func getModel() -> TreeModelRef! {
        let result = gtk_tree_model_sort_get_model(tree_model_sort_ptr)
        let rv = TreeModelRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// >&gt; This function is slow. Only use it for debugging and/or testing
    /// &gt; purposes.
    /// 
    /// Checks if the given iter is a valid iter for this `GtkTreeModelSort`.
    @inlinable func iterIsValid<TreeIterT: TreeIterProtocol>(iter: TreeIterT) -> Bool {
        let result = gtk_tree_model_sort_iter_is_valid(tree_model_sort_ptr, iter.tree_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// This resets the default sort function to be in the “unsorted” state.  That
    /// is, it is in the same order as the child model. It will re-sort the model
    /// to be in the same order as the child model only if the `GtkTreeModelSort`
    /// is in “unsorted” state.
    @inlinable func resetDefaultSortFunc() {
        
        gtk_tree_model_sort_reset_default_sort_func(tree_model_sort_ptr)
        
    }
    @inlinable var model: TreeModelRef! {
        /// Returns the model the `GtkTreeModelSort` is sorting.
        get {
            let result = gtk_tree_model_sort_get_model(tree_model_sort_ptr)
        let rv = TreeModelRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    @inlinable var parent: GObject {
        get {
            let rv = tree_model_sort_ptr.pointee.parent
    return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - TreeSelection Class

/// The selection object for GtkTreeView
/// 
/// The `GtkTreeSelection` object is a helper object to manage the selection
/// for a `GtkTreeView` widget.  The `GtkTreeSelection` object is
/// automatically created when a new `GtkTreeView` widget is created, and
/// cannot exist independently of this widget.  The primary reason the
/// `GtkTreeSelection` objects exists is for cleanliness of code and API.
/// That is, there is no conceptual reason all these functions could not be
/// methods on the `GtkTreeView` widget instead of a separate function.
/// 
/// The `GtkTreeSelection` object is gotten from a `GtkTreeView` by calling
/// `gtk_tree_view_get_selection()`.  It can be manipulated to check the
/// selection status of the tree, as well as select and deselect individual
/// rows.  Selection is done completely view side.  As a result, multiple
/// views of the same model can have completely different selections.
/// Additionally, you cannot change the selection of a row on the model that
/// is not currently displayed by the view without expanding its parents
/// first.
/// 
/// One of the important things to remember when monitoring the selection of
/// a view is that the `GtkTreeSelection``changed` signal is mostly a hint.
/// That is, it may only emit one signal when a range of rows is selected.
/// Additionally, it may on occasion emit a `GtkTreeSelection``changed` signal
/// when nothing has happened (mostly as a result of programmers calling
/// select_row on an already selected row).
///
/// The `TreeSelectionProtocol` protocol exposes the methods and properties of an underlying `GtkTreeSelection` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeSelection`.
/// Alternatively, use `TreeSelectionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeSelectionProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkTreeSelection` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeSelection` instance.
    var tree_selection_ptr: UnsafeMutablePointer<GtkTreeSelection>! { get }

    /// Required Initialiser for types conforming to `TreeSelectionProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The selection object for GtkTreeView
/// 
/// The `GtkTreeSelection` object is a helper object to manage the selection
/// for a `GtkTreeView` widget.  The `GtkTreeSelection` object is
/// automatically created when a new `GtkTreeView` widget is created, and
/// cannot exist independently of this widget.  The primary reason the
/// `GtkTreeSelection` objects exists is for cleanliness of code and API.
/// That is, there is no conceptual reason all these functions could not be
/// methods on the `GtkTreeView` widget instead of a separate function.
/// 
/// The `GtkTreeSelection` object is gotten from a `GtkTreeView` by calling
/// `gtk_tree_view_get_selection()`.  It can be manipulated to check the
/// selection status of the tree, as well as select and deselect individual
/// rows.  Selection is done completely view side.  As a result, multiple
/// views of the same model can have completely different selections.
/// Additionally, you cannot change the selection of a row on the model that
/// is not currently displayed by the view without expanding its parents
/// first.
/// 
/// One of the important things to remember when monitoring the selection of
/// a view is that the `GtkTreeSelection``changed` signal is mostly a hint.
/// That is, it may only emit one signal when a range of rows is selected.
/// Additionally, it may on occasion emit a `GtkTreeSelection``changed` signal
/// when nothing has happened (mostly as a result of programmers calling
/// select_row on an already selected row).
///
/// The `TreeSelectionRef` type acts as a lightweight Swift reference to an underlying `GtkTreeSelection` instance.
/// It exposes methods that can operate on this data type through `TreeSelectionProtocol` conformance.
/// Use `TreeSelectionRef` only as an `unowned` reference to an existing `GtkTreeSelection` instance.
///
public struct TreeSelectionRef: TreeSelectionProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTreeSelection` instance.
    /// For type-safe access, use the generated, typed pointer `tree_selection_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeSelectionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeSelection>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeSelection>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeSelection>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeSelection>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeSelectionProtocol`
    @inlinable init<T: TreeSelectionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TreeSelectionProtocol>(_ other: T) -> TreeSelectionRef { TreeSelectionRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The selection object for GtkTreeView
/// 
/// The `GtkTreeSelection` object is a helper object to manage the selection
/// for a `GtkTreeView` widget.  The `GtkTreeSelection` object is
/// automatically created when a new `GtkTreeView` widget is created, and
/// cannot exist independently of this widget.  The primary reason the
/// `GtkTreeSelection` objects exists is for cleanliness of code and API.
/// That is, there is no conceptual reason all these functions could not be
/// methods on the `GtkTreeView` widget instead of a separate function.
/// 
/// The `GtkTreeSelection` object is gotten from a `GtkTreeView` by calling
/// `gtk_tree_view_get_selection()`.  It can be manipulated to check the
/// selection status of the tree, as well as select and deselect individual
/// rows.  Selection is done completely view side.  As a result, multiple
/// views of the same model can have completely different selections.
/// Additionally, you cannot change the selection of a row on the model that
/// is not currently displayed by the view without expanding its parents
/// first.
/// 
/// One of the important things to remember when monitoring the selection of
/// a view is that the `GtkTreeSelection``changed` signal is mostly a hint.
/// That is, it may only emit one signal when a range of rows is selected.
/// Additionally, it may on occasion emit a `GtkTreeSelection``changed` signal
/// when nothing has happened (mostly as a result of programmers calling
/// select_row on an already selected row).
///
/// The `TreeSelection` type acts as a reference-counted owner of an underlying `GtkTreeSelection` instance.
/// It provides the methods that can operate on this data type through `TreeSelectionProtocol` conformance.
/// Use `TreeSelection` as a strong reference or owner of a `GtkTreeSelection` instance.
///
open class TreeSelection: GLibObject.Object, TreeSelectionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeSelection>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeSelection>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeSelection` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeSelection>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeSelection>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTreeSelection`.
    /// i.e., ownership is transferred to the `TreeSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeSelection>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TreeSelectionProtocol`
    /// Will retain `GtkTreeSelection`.
    /// - Parameter other: an instance of a related type that implements `TreeSelectionProtocol`
    @inlinable public init<T: TreeSelectionProtocol>(treeSelection other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum TreeSelectionPropertyName: String, PropertyNameProtocol {
    /// Selection mode.
    /// See `gtk_tree_selection_set_mode()` for more information on this property.
    case mode = "mode"
}

public extension TreeSelectionProtocol {
    /// Bind a `TreeSelectionPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeSelectionPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TreeSelection property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TreeSelectionPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TreeSelection property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TreeSelectionPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TreeSelectionSignalName: String, SignalNameProtocol {
    /// Emitted whenever the selection has (possibly) changed. Please note that
    /// this signal is mostly a hint.  It may only be emitted once when a range
    /// of rows are selected, and it may occasionally be emitted when nothing
    /// has happened.
    case changed = "changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Selection mode.
    /// See `gtk_tree_selection_set_mode()` for more information on this property.
    case notifyMode = "notify::mode"
}

// MARK: TreeSelection signals
public extension TreeSelectionProtocol {
    /// Connect a Swift signal handler to the given, typed `TreeSelectionSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TreeSelectionSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `TreeSelectionSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TreeSelectionSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted whenever the selection has (possibly) changed. Please note that
    /// this signal is mostly a hint.  It may only be emitted once when a range
    /// of rows are selected, and it may occasionally be emitted when nothing
    /// has happened.
    /// - Note: This represents the underlying `changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `changed` signal is emitted
    @discardableResult @inlinable func onChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeSelectionRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeSelectionRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeSelectionRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .changed,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `changed` signal for using the `connect(signal:)` methods
    static var changedSignal: TreeSelectionSignalName { .changed }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::mode` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMode` signal is emitted
    @discardableResult @inlinable func onNotifyMode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeSelectionRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeSelectionRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeSelectionRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyMode,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::mode` signal for using the `connect(signal:)` methods
    static var notifyModeSignal: TreeSelectionSignalName { .notifyMode }
    
}

// MARK: TreeSelection Class: TreeSelectionProtocol extension (methods and fields)
public extension TreeSelectionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeSelection` instance.
    @inlinable var tree_selection_ptr: UnsafeMutablePointer<GtkTreeSelection>! { return ptr?.assumingMemoryBound(to: GtkTreeSelection.self) }

    /// Returns the number of rows that have been selected in `tree`.
    @inlinable func countSelectedRows() -> Int {
        let result = gtk_tree_selection_count_selected_rows(tree_selection_ptr)
        let rv = Int(result)
        return rv
    }

    /// Gets the selection mode for `selection`. See
    /// `gtk_tree_selection_set_mode()`.
    @inlinable func getMode() -> GtkSelectionMode {
        let result = gtk_tree_selection_get_mode(tree_selection_ptr)
        let rv = result
        return rv
    }

    /// Returns the current selection function.
    @inlinable func getSelectFunction() -> GtkTreeSelectionFunc! {
        let result = gtk_tree_selection_get_select_function(tree_selection_ptr)
        let rv = result
        return rv
    }

    /// Sets `iter` to the currently selected node if `selection` is set to
    /// `GTK_SELECTION_SINGLE` or `GTK_SELECTION_BROWSE`.  `iter` may be NULL if you
    /// just want to test if `selection` has any selected nodes.  `model` is filled
    /// with the current model as a convenience.  This function will not work if you
    /// use `selection` is `GTK_SELECTION_MULTIPLE`.
    @inlinable func getSelected(model: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreeModel>?>! = nil, iter: TreeIterRef? = nil) -> Bool {
            let result = gtk_tree_selection_get_selected(tree_selection_ptr, model, iter?.tree_iter_ptr)
        let rv = ((result) != 0)
            return rv
    }
    /// Sets `iter` to the currently selected node if `selection` is set to
    /// `GTK_SELECTION_SINGLE` or `GTK_SELECTION_BROWSE`.  `iter` may be NULL if you
    /// just want to test if `selection` has any selected nodes.  `model` is filled
    /// with the current model as a convenience.  This function will not work if you
    /// use `selection` is `GTK_SELECTION_MULTIPLE`.
    @inlinable func getSelected<TreeIterT: TreeIterProtocol>(model: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreeModel>?>! = nil, iter: TreeIterT?) -> Bool {
        let result = gtk_tree_selection_get_selected(tree_selection_ptr, model, iter?.tree_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Creates a list of path of all selected rows. Additionally, if you are
    /// planning on modifying the model after calling this function, you may
    /// want to convert the returned list into a list of `GtkTreeRowReference`s.
    /// To do this, you can use `gtk_tree_row_reference_new()`.
    /// 
    /// To free the return value, use:
    /// (C Language Example):
    /// ```C
    /// g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);
    /// ```
    /// 
    @inlinable func getSelectedRows(model: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreeModel>?>! = nil) -> GLib.ListRef! {
        let result = gtk_tree_selection_get_selected_rows(tree_selection_ptr, model)
        let rv = GLib.ListRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns the tree view associated with `selection`.
    @inlinable func getTreeView() -> TreeViewRef! {
        let result = gtk_tree_selection_get_tree_view(tree_selection_ptr)
        let rv = TreeViewRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns the user data for the selection function.
    @inlinable func getUserData() -> gpointer? {
        let result = gtk_tree_selection_get_user_data(tree_selection_ptr)
        let rv = result
        return rv
    }

    /// Returns `true` if the row at `iter` is currently selected.
    @inlinable func iterIsSelected<TreeIterT: TreeIterProtocol>(iter: TreeIterT) -> Bool {
        let result = gtk_tree_selection_iter_is_selected(tree_selection_ptr, iter.tree_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns `true` if the row pointed to by `path` is currently selected.  If `path`
    /// does not point to a valid location, `false` is returned
    @inlinable func pathIsSelected<TreePathT: TreePathProtocol>(path: TreePathT) -> Bool {
        let result = gtk_tree_selection_path_is_selected(tree_selection_ptr, path.tree_path_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Selects all the nodes. `selection` must be set to `GTK_SELECTION_MULTIPLE`
    /// mode.
    @inlinable func selectAll() {
        
        gtk_tree_selection_select_all(tree_selection_ptr)
        
    }

    /// Selects the specified iterator.
    @inlinable func select<TreeIterT: TreeIterProtocol>(iter: TreeIterT) {
        
        gtk_tree_selection_select_iter(tree_selection_ptr, iter.tree_iter_ptr)
        
    }

    /// Select the row at `path`.
    @inlinable func select<TreePathT: TreePathProtocol>(path: TreePathT) {
        
        gtk_tree_selection_select_path(tree_selection_ptr, path.tree_path_ptr)
        
    }

    /// Selects a range of nodes, determined by `start_path` and `end_path` inclusive.
    /// `selection` must be set to `GTK_SELECTION_MULTIPLE` mode.
    @inlinable func selectRange<TreePathT: TreePathProtocol>(startPath: TreePathT, endPath: TreePathT) {
        
        gtk_tree_selection_select_range(tree_selection_ptr, startPath.tree_path_ptr, endPath.tree_path_ptr)
        
    }

    /// Calls a function for each selected node. Note that you cannot modify
    /// the tree or selection from within this function. As a result,
    /// `gtk_tree_selection_get_selected_rows()` might be more useful.
    @inlinable func selectedForeach(`func`: GtkTreeSelectionForeachFunc?, data: gpointer? = nil) {
        
        gtk_tree_selection_selected_foreach(tree_selection_ptr, `func`, data)
        
    }

    /// Sets the selection mode of the `selection`.  If the previous type was
    /// `GTK_SELECTION_MULTIPLE`, then the anchor is kept selected, if it was
    /// previously selected.
    @inlinable func setMode(type: GtkSelectionMode) {
        
        gtk_tree_selection_set_mode(tree_selection_ptr, type)
        
    }

    /// Sets the selection function.
    /// 
    /// If set, this function is called before any node is selected or unselected,
    /// giving some control over which nodes are selected. The select function
    /// should return `true` if the state of the node may be toggled, and `false`
    /// if the state of the node should be left unchanged.
    @inlinable func setSelectFunction(`func`: GtkTreeSelectionFunc? = nil, data: gpointer? = nil, destroy: GDestroyNotify?) {
        
        gtk_tree_selection_set_select_function(tree_selection_ptr, `func`, data, destroy)
        
    }

    /// Unselects all the nodes.
    @inlinable func unselectAll() {
        
        gtk_tree_selection_unselect_all(tree_selection_ptr)
        
    }

    /// Unselects the specified iterator.
    @inlinable func unselect<TreeIterT: TreeIterProtocol>(iter: TreeIterT) {
        
        gtk_tree_selection_unselect_iter(tree_selection_ptr, iter.tree_iter_ptr)
        
    }

    /// Unselects the row at `path`.
    @inlinable func unselect<TreePathT: TreePathProtocol>(path: TreePathT) {
        
        gtk_tree_selection_unselect_path(tree_selection_ptr, path.tree_path_ptr)
        
    }

    /// Unselects a range of nodes, determined by `start_path` and `end_path`
    /// inclusive.
    @inlinable func unselectRange<TreePathT: TreePathProtocol>(startPath: TreePathT, endPath: TreePathT) {
        
        gtk_tree_selection_unselect_range(tree_selection_ptr, startPath.tree_path_ptr, endPath.tree_path_ptr)
        
    }
    /// Selection mode.
    /// See `gtk_tree_selection_set_mode()` for more information on this property.
    @inlinable var mode: GtkSelectionMode {
        /// Gets the selection mode for `selection`. See
        /// `gtk_tree_selection_set_mode()`.
        get {
            let result = gtk_tree_selection_get_mode(tree_selection_ptr)
        let rv = result
            return rv
        }
        /// Sets the selection mode of the `selection`.  If the previous type was
        /// `GTK_SELECTION_MULTIPLE`, then the anchor is kept selected, if it was
        /// previously selected.
        nonmutating set {
            gtk_tree_selection_set_mode(tree_selection_ptr, newValue)
        }
    }

    /// Returns the current selection function.
    @inlinable var selectFunction: GtkTreeSelectionFunc! {
        /// Returns the current selection function.
        get {
            let result = gtk_tree_selection_get_select_function(tree_selection_ptr)
        let rv = result
            return rv
        }
    }

    /// Returns the tree view associated with `selection`.
    @inlinable var treeView: TreeViewRef! {
        /// Returns the tree view associated with `selection`.
        get {
            let result = gtk_tree_selection_get_tree_view(tree_selection_ptr)
        let rv = TreeViewRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Returns the user data for the selection function.
    @inlinable var userData: gpointer? {
        /// Returns the user data for the selection function.
        get {
            let result = gtk_tree_selection_get_user_data(tree_selection_ptr)
        let rv = result
            return rv
        }
    }


}



// MARK: - TreeStore Class

/// A tree-like data structure that can be used with the GtkTreeView
/// 
/// The `GtkTreeStore` object is a list model for use with a `GtkTreeView`
/// widget.  It implements the `GtkTreeModel` interface, and consequently,
/// can use all of the methods available there.  It also implements the
/// `GtkTreeSortable` interface so it can be sorted by the view.  Finally,
/// it also implements the tree
/// [drag and drop](#gtk3-GtkTreeView-drag-and-drop)
/// interfaces.
/// 
/// # GtkTreeStore as GtkBuildable
/// 
/// The GtkTreeStore implementation of the `GtkBuildable` interface allows
/// to specify the model columns with a &lt;columns&gt; element that may contain
/// multiple &lt;column&gt; elements, each specifying one model column. The “type”
/// attribute specifies the data type for the column.
/// 
/// An example of a UI Definition fragment for a tree store:
/// ```
/// <object class="GtkTreeStore">
///   <columns>
///     <column type="gchararray"/>
///     <column type="gchararray"/>
///     <column type="gint"/>
///   </columns>
/// </object>
/// ```
/// 
///
/// The `TreeStoreProtocol` protocol exposes the methods and properties of an underlying `GtkTreeStore` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeStore`.
/// Alternatively, use `TreeStoreRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeStoreProtocol: GLibObject.ObjectProtocol, BuildableProtocol, TreeDragDestProtocol, TreeDragSourceProtocol, TreeModelProtocol, TreeSortableProtocol {
        /// Untyped pointer to the underlying `GtkTreeStore` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeStore` instance.
    var tree_store_ptr: UnsafeMutablePointer<GtkTreeStore>! { get }

    /// Required Initialiser for types conforming to `TreeStoreProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A tree-like data structure that can be used with the GtkTreeView
/// 
/// The `GtkTreeStore` object is a list model for use with a `GtkTreeView`
/// widget.  It implements the `GtkTreeModel` interface, and consequently,
/// can use all of the methods available there.  It also implements the
/// `GtkTreeSortable` interface so it can be sorted by the view.  Finally,
/// it also implements the tree
/// [drag and drop](#gtk3-GtkTreeView-drag-and-drop)
/// interfaces.
/// 
/// # GtkTreeStore as GtkBuildable
/// 
/// The GtkTreeStore implementation of the `GtkBuildable` interface allows
/// to specify the model columns with a &lt;columns&gt; element that may contain
/// multiple &lt;column&gt; elements, each specifying one model column. The “type”
/// attribute specifies the data type for the column.
/// 
/// An example of a UI Definition fragment for a tree store:
/// ```
/// <object class="GtkTreeStore">
///   <columns>
///     <column type="gchararray"/>
///     <column type="gchararray"/>
///     <column type="gint"/>
///   </columns>
/// </object>
/// ```
/// 
///
/// The `TreeStoreRef` type acts as a lightweight Swift reference to an underlying `GtkTreeStore` instance.
/// It exposes methods that can operate on this data type through `TreeStoreProtocol` conformance.
/// Use `TreeStoreRef` only as an `unowned` reference to an existing `GtkTreeStore` instance.
///
public struct TreeStoreRef: TreeStoreProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTreeStore` instance.
    /// For type-safe access, use the generated, typed pointer `tree_store_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeStoreRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeStore>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeStore>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeStore>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeStore>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeStoreProtocol`
    @inlinable init<T: TreeStoreProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TreeStoreProtocol>(_ other: T) -> TreeStoreRef { TreeStoreRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    
    // *** new() is not available because it has a varargs (...) parameter!


    /// Non vararg creation function.  Used primarily by language bindings.
    @inlinable init(nColumns: Int, types: UnsafeMutablePointer<GType>!) {
            let result = gtk_tree_store_newv(gint(nColumns), types)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
    /// Non vararg creation function.  Used primarily by language bindings.
    @inlinable static func treeStoreNewv(nColumns: Int, types: UnsafeMutablePointer<GType>!) -> TreeStoreRef! {
            let result = gtk_tree_store_newv(gint(nColumns), types)
        guard let rv = TreeStoreRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }
}

/// A tree-like data structure that can be used with the GtkTreeView
/// 
/// The `GtkTreeStore` object is a list model for use with a `GtkTreeView`
/// widget.  It implements the `GtkTreeModel` interface, and consequently,
/// can use all of the methods available there.  It also implements the
/// `GtkTreeSortable` interface so it can be sorted by the view.  Finally,
/// it also implements the tree
/// [drag and drop](#gtk3-GtkTreeView-drag-and-drop)
/// interfaces.
/// 
/// # GtkTreeStore as GtkBuildable
/// 
/// The GtkTreeStore implementation of the `GtkBuildable` interface allows
/// to specify the model columns with a &lt;columns&gt; element that may contain
/// multiple &lt;column&gt; elements, each specifying one model column. The “type”
/// attribute specifies the data type for the column.
/// 
/// An example of a UI Definition fragment for a tree store:
/// ```
/// <object class="GtkTreeStore">
///   <columns>
///     <column type="gchararray"/>
///     <column type="gchararray"/>
///     <column type="gint"/>
///   </columns>
/// </object>
/// ```
/// 
///
/// The `TreeStore` type acts as a reference-counted owner of an underlying `GtkTreeStore` instance.
/// It provides the methods that can operate on this data type through `TreeStoreProtocol` conformance.
/// Use `TreeStore` as a strong reference or owner of a `GtkTreeStore` instance.
///
open class TreeStore: GLibObject.Object, TreeStoreProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeStore` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeStore>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeStore` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeStore>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeStore` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeStore` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeStore` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeStore>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeStore` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeStore>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTreeStore`.
    /// i.e., ownership is transferred to the `TreeStore` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeStore>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TreeStoreProtocol`
    /// Will retain `GtkTreeStore`.
    /// - Parameter other: an instance of a related type that implements `TreeStoreProtocol`
    @inlinable public init<T: TreeStoreProtocol>(treeStore other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }


    // *** new() is not available because it has a varargs (...) parameter!


    /// Non vararg creation function.  Used primarily by language bindings.
    @inlinable public init(nColumns: Int, types: UnsafeMutablePointer<GType>!) {
            let result = gtk_tree_store_newv(gint(nColumns), types)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Non vararg creation function.  Used primarily by language bindings.
    @inlinable public static func treeStoreNewv(nColumns: Int, types: UnsafeMutablePointer<GType>!) -> TreeStore! {
            let result = gtk_tree_store_newv(gint(nColumns), types)
        guard let rv = TreeStore(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

}

// MARK: no TreeStore properties

public enum TreeStoreSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: TreeStore has no signals
// MARK: TreeStore Class: TreeStoreProtocol extension (methods and fields)
public extension TreeStoreProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeStore` instance.
    @inlinable var tree_store_ptr: UnsafeMutablePointer<GtkTreeStore>! { return ptr?.assumingMemoryBound(to: GtkTreeStore.self) }

    /// Appends a new row to `tree_store`.  If `parent` is non-`nil`, then it will append the
    /// new row after the last child of `parent`, otherwise it will append a row to
    /// the top level.  `iter` will be changed to point to this new row.  The row will
    /// be empty after this function is called.  To fill in values, you need to call
    /// `gtk_tree_store_set()` or `gtk_tree_store_set_value()`.
    @inlinable func append<TreeIterT: TreeIterProtocol>(iter: TreeIterT, parent: TreeIterT?) {
        
        gtk_tree_store_append(tree_store_ptr, iter.tree_iter_ptr, parent?.tree_iter_ptr)
        
    }

    /// Removes all rows from `tree_store`
    @inlinable func clear() {
        
        gtk_tree_store_clear(tree_store_ptr)
        
    }

    /// Creates a new row at `position`.  If parent is non-`nil`, then the row will be
    /// made a child of `parent`.  Otherwise, the row will be created at the toplevel.
    /// If `position` is -1 or is larger than the number of rows at that level, then
    /// the new row will be inserted to the end of the list.  `iter` will be changed
    /// to point to this new row.  The row will be empty after this function is
    /// called.  To fill in values, you need to call `gtk_tree_store_set()` or
    /// `gtk_tree_store_set_value()`.
    @inlinable func insert<TreeIterT: TreeIterProtocol>(iter: TreeIterT, parent: TreeIterT?, position: Int) {
        
        gtk_tree_store_insert(tree_store_ptr, iter.tree_iter_ptr, parent?.tree_iter_ptr, gint(position))
        
    }

    /// Inserts a new row after `sibling`.  If `sibling` is `nil`, then the row will be
    /// prepended to `parent` ’s children.  If `parent` and `sibling` are `nil`, then
    /// the row will be prepended to the toplevel.  If both `sibling` and `parent` are
    /// set, then `parent` must be the parent of `sibling`.  When `sibling` is set,
    /// `parent` is optional.
    /// 
    /// `iter` will be changed to point to this new row.  The row will be empty after
    /// this function is called.  To fill in values, you need to call
    /// `gtk_tree_store_set()` or `gtk_tree_store_set_value()`.
    @inlinable func insertAfter<TreeIterT: TreeIterProtocol>(iter: TreeIterT, parent: TreeIterT?, sibling: TreeIterT?) {
        
        gtk_tree_store_insert_after(tree_store_ptr, iter.tree_iter_ptr, parent?.tree_iter_ptr, sibling?.tree_iter_ptr)
        
    }

    /// Inserts a new row before `sibling`.  If `sibling` is `nil`, then the row will
    /// be appended to `parent` ’s children.  If `parent` and `sibling` are `nil`, then
    /// the row will be appended to the toplevel.  If both `sibling` and `parent` are
    /// set, then `parent` must be the parent of `sibling`.  When `sibling` is set,
    /// `parent` is optional.
    /// 
    /// `iter` will be changed to point to this new row.  The row will be empty after
    /// this function is called.  To fill in values, you need to call
    /// `gtk_tree_store_set()` or `gtk_tree_store_set_value()`.
    @inlinable func insertBefore<TreeIterT: TreeIterProtocol>(iter: TreeIterT, parent: TreeIterT?, sibling: TreeIterT?) {
        
        gtk_tree_store_insert_before(tree_store_ptr, iter.tree_iter_ptr, parent?.tree_iter_ptr, sibling?.tree_iter_ptr)
        
    }


    // *** insertWithValues() is not available because it has a varargs (...) parameter!


    /// A variant of `gtk_tree_store_insert_with_values()` which takes
    /// the columns and values as two arrays, instead of varargs.  This
    /// function is mainly intended for language bindings.
    @inlinable func insertWithValuesv(iter: TreeIterRef? = nil, parent: TreeIterRef? = nil, position: Int, columns: UnsafeMutablePointer<CInt>!, values: UnsafeMutablePointer<GValue>!, nValues: Int) {
            
        gtk_tree_store_insert_with_valuesv(tree_store_ptr, iter?.tree_iter_ptr, parent?.tree_iter_ptr, gint(position), columns, values, gint(nValues))
            
    }
    /// A variant of `gtk_tree_store_insert_with_values()` which takes
    /// the columns and values as two arrays, instead of varargs.  This
    /// function is mainly intended for language bindings.
    @inlinable func insertWithValuesv<TreeIterT: TreeIterProtocol>(iter: TreeIterT?, parent: TreeIterT?, position: Int, columns: UnsafeMutablePointer<CInt>!, values: UnsafeMutablePointer<GValue>!, nValues: Int) {
        
        gtk_tree_store_insert_with_valuesv(tree_store_ptr, iter?.tree_iter_ptr, parent?.tree_iter_ptr, gint(position), columns, values, gint(nValues))
        
    }

    /// Returns `true` if `iter` is an ancestor of `descendant`.  That is, `iter` is the
    /// parent (or grandparent or great-grandparent) of `descendant`.
    @inlinable func isAncestor<TreeIterT: TreeIterProtocol>(iter: TreeIterT, descendant: TreeIterT) -> Bool {
        let result = gtk_tree_store_is_ancestor(tree_store_ptr, iter.tree_iter_ptr, descendant.tree_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns the depth of `iter`.  This will be 0 for anything on the root level, 1
    /// for anything down a level, etc.
    @inlinable func iterDepth<TreeIterT: TreeIterProtocol>(iter: TreeIterT) -> Int {
        let result = gtk_tree_store_iter_depth(tree_store_ptr, iter.tree_iter_ptr)
        let rv = Int(result)
        return rv
    }

    /// Checks if the given iter is a valid iter for this `GtkTreeStore`.
    /// 
    /// This function is slow. Only use it for debugging and/or testing
    /// purposes.
    @inlinable func iterIsValid<TreeIterT: TreeIterProtocol>(iter: TreeIterT) -> Bool {
        let result = gtk_tree_store_iter_is_valid(tree_store_ptr, iter.tree_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves `iter` in `tree_store` to the position after `position`. `iter` and
    /// `position` should be in the same level. Note that this function only
    /// works with unsorted stores. If `position` is `nil`, `iter` will be moved
    /// to the start of the level.
    @inlinable func moveAfter<TreeIterT: TreeIterProtocol>(iter: TreeIterT, position: TreeIterT?) {
        
        gtk_tree_store_move_after(tree_store_ptr, iter.tree_iter_ptr, position?.tree_iter_ptr)
        
    }

    /// Moves `iter` in `tree_store` to the position before `position`. `iter` and
    /// `position` should be in the same level. Note that this function only
    /// works with unsorted stores. If `position` is `nil`, `iter` will be
    /// moved to the end of the level.
    @inlinable func moveBefore<TreeIterT: TreeIterProtocol>(iter: TreeIterT, position: TreeIterT?) {
        
        gtk_tree_store_move_before(tree_store_ptr, iter.tree_iter_ptr, position?.tree_iter_ptr)
        
    }

    /// Prepends a new row to `tree_store`.  If `parent` is non-`nil`, then it will prepend
    /// the new row before the first child of `parent`, otherwise it will prepend a row
    /// to the top level.  `iter` will be changed to point to this new row.  The row
    /// will be empty after this function is called.  To fill in values, you need to
    /// call `gtk_tree_store_set()` or `gtk_tree_store_set_value()`.
    @inlinable func prepend<TreeIterT: TreeIterProtocol>(iter: TreeIterT, parent: TreeIterT?) {
        
        gtk_tree_store_prepend(tree_store_ptr, iter.tree_iter_ptr, parent?.tree_iter_ptr)
        
    }

    /// Removes `iter` from `tree_store`.  After being removed, `iter` is set to the
    /// next valid row at that level, or invalidated if it previously pointed to the
    /// last one.
    @inlinable func remove<TreeIterT: TreeIterProtocol>(iter: TreeIterT) -> Bool {
        let result = gtk_tree_store_remove(tree_store_ptr, iter.tree_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Reorders the children of `parent` in `tree_store` to follow the order
    /// indicated by `new_order`. Note that this function only works with
    /// unsorted stores.
    @inlinable func reorder(parent: TreeIterRef? = nil, newOrder: UnsafeMutablePointer<CInt>!) {
            
        gtk_tree_store_reorder(tree_store_ptr, parent?.tree_iter_ptr, newOrder)
            
    }
    /// Reorders the children of `parent` in `tree_store` to follow the order
    /// indicated by `new_order`. Note that this function only works with
    /// unsorted stores.
    @inlinable func reorder<TreeIterT: TreeIterProtocol>(parent: TreeIterT?, newOrder: UnsafeMutablePointer<CInt>!) {
        
        gtk_tree_store_reorder(tree_store_ptr, parent?.tree_iter_ptr, newOrder)
        
    }


    // *** set() is not available because it has a varargs (...) parameter!


    /// This function is meant primarily for `GObjects` that inherit from
    /// `GtkTreeStore`, and should only be used when constructing a new
    /// `GtkTreeStore`.  It will not function after a row has been added,
    /// or a method on the `GtkTreeModel` interface is called.
    @inlinable func setColumnTypes(nColumns: Int, types: UnsafeMutablePointer<GType>!) {
        
        gtk_tree_store_set_column_types(tree_store_ptr, gint(nColumns), types)
        
    }

    /// See `gtk_tree_store_set()`; this version takes a va_list for
    /// use by language bindings.
    @inlinable func setValist<TreeIterT: TreeIterProtocol>(iter: TreeIterT, varArgs: CVaListPointer) {
        
        gtk_tree_store_set_valist(tree_store_ptr, iter.tree_iter_ptr, varArgs)
        
    }

    /// Sets the data in the cell specified by `iter` and `column`.
    /// The type of `value` must be convertible to the type of the
    /// column.
    @inlinable func setValue<GObjectValueT: GLibObject.ValueProtocol, TreeIterT: TreeIterProtocol>(iter: TreeIterT, column: Int, value: GObjectValueT) {
        
        gtk_tree_store_set_value(tree_store_ptr, iter.tree_iter_ptr, gint(column), value.value_ptr)
        
    }

    /// A variant of `gtk_tree_store_set_valist()` which takes
    /// the columns and values as two arrays, instead of varargs.  This
    /// function is mainly intended for language bindings or in case
    /// the number of columns to change is not known until run-time.
    @inlinable func setValuesv<TreeIterT: TreeIterProtocol>(iter: TreeIterT, columns: UnsafeMutablePointer<CInt>!, values: UnsafeMutablePointer<GValue>!, nValues: Int) {
        
        gtk_tree_store_set_valuesv(tree_store_ptr, iter.tree_iter_ptr, columns, values, gint(nValues))
        
    }

    /// Swaps `a` and `b` in the same level of `tree_store`. Note that this function
    /// only works with unsorted stores.
    @inlinable func swap<TreeIterT: TreeIterProtocol>(a: TreeIterT, b: TreeIterT) {
        
        gtk_tree_store_swap(tree_store_ptr, a.tree_iter_ptr, b.tree_iter_ptr)
        
    }

    @inlinable var parent: GObject {
        get {
            let rv = tree_store_ptr.pointee.parent
    return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - TreeView Class

/// A widget for displaying both trees and lists
/// 
/// Widget that displays any object that implements the [iface`Gtk.TreeModel`] interface.
/// 
/// Please refer to the [tree widget conceptual overview](section-tree-widget.html)
/// for an overview of all the objects and data types related to the tree
/// widget and how they work together.
/// 
/// ## Coordinate systems in GtkTreeView API
/// 
/// Several different coordinate systems are exposed in the `GtkTreeView` API.
/// These are:
/// 
/// ![](tree-view-coordinates.png)
/// 
/// - Widget coordinates: Coordinates relative to the widget (usually `widget-&gt;window`).
/// 
/// - Bin window coordinates: Coordinates relative to the window that GtkTreeView renders to.
/// 
/// - Tree coordinates: Coordinates relative to the entire scrollable area of GtkTreeView. These
///   coordinates start at (0, 0) for row 0 of the tree.
/// 
/// Several functions are available for converting between the different
/// coordinate systems.  The most common translations are between widget and bin
/// window coordinates and between bin window and tree coordinates. For the
/// former you can use [method`Gtk.TreeView.convert_widget_to_bin_window_coords`]
/// (and vice versa), for the latter [method`Gtk.TreeView.convert_bin_window_to_tree_coords`]
/// (and vice versa).
/// 
/// ## `GtkTreeView` as `GtkBuildable`
/// 
/// The `GtkTreeView` implementation of the `GtkBuildable` interface accepts
/// [class`Gtk.TreeViewColumn`] objects as `&lt;child&gt;` elements and exposes the
/// internal [class`Gtk.TreeSelection`] in UI definitions.
/// 
/// An example of a UI definition fragment with `GtkTreeView`:
/// 
/// ```xml
/// &lt;object class="GtkTreeView" id="treeview"&gt;
///   &lt;property name="model"&gt;liststore1&lt;/property&gt;
///   &lt;child&gt;
///     &lt;object class="GtkTreeViewColumn" id="test-column"&gt;
///       &lt;property name="title"&gt;Test&lt;/property&gt;
///       &lt;child&gt;
///         &lt;object class="GtkCellRendererText" id="test-renderer"/&gt;
///         &lt;attributes&gt;
///           &lt;attribute name="text"&gt;1&lt;/attribute&gt;
///         &lt;/attributes&gt;
///       &lt;/child&gt;
///     &lt;/object&gt;
///   &lt;/child&gt;
///   &lt;child internal-child="selection"&gt;
///     &lt;object class="GtkTreeSelection" id="selection"&gt;
///       &lt;signal name="changed" handler="on_treeview_selection_changed"/&gt;
///     &lt;/object&gt;
///   &lt;/child&gt;
/// &lt;/object&gt;
/// ```
/// 
/// ## CSS nodes
/// 
/// ```
/// treeview.view
/// ├── header
/// │   ├── button
/// │   │   ╰── [sort-indicator]
/// ┊   ┊
/// │   ╰── button
/// │       ╰── [sort-indicator]
/// │
/// ├── [rubberband]
/// ╰── [dndtarget]
/// ```
/// 
/// `GtkTreeView` has a main CSS node with name `treeview` and style class `.view`.
/// It has a subnode with name `header`, which is the parent for all the column
/// header widgets' CSS nodes.
/// 
/// Each column header consists of a `button`, which among other content, has a
/// child with name `sort-indicator`, which carries the `.ascending` or `.descending`
/// style classes when the column header should show a sort indicator. The CSS
/// is expected to provide a suitable image using the `-gtk-icon-source` property.
/// 
/// For rubberband selection, a subnode with name `rubberband` is used.
/// 
/// For the drop target location during DND, a subnode with name `dndtarget` is used.
///
/// The `TreeViewProtocol` protocol exposes the methods and properties of an underlying `GtkTreeView` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeView`.
/// Alternatively, use `TreeViewRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeViewProtocol: WidgetProtocol, ScrollableProtocol {
        /// Untyped pointer to the underlying `GtkTreeView` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeView` instance.
    var tree_view_ptr: UnsafeMutablePointer<GtkTreeView>! { get }

    /// Required Initialiser for types conforming to `TreeViewProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A widget for displaying both trees and lists
/// 
/// Widget that displays any object that implements the [iface`Gtk.TreeModel`] interface.
/// 
/// Please refer to the [tree widget conceptual overview](section-tree-widget.html)
/// for an overview of all the objects and data types related to the tree
/// widget and how they work together.
/// 
/// ## Coordinate systems in GtkTreeView API
/// 
/// Several different coordinate systems are exposed in the `GtkTreeView` API.
/// These are:
/// 
/// ![](tree-view-coordinates.png)
/// 
/// - Widget coordinates: Coordinates relative to the widget (usually `widget-&gt;window`).
/// 
/// - Bin window coordinates: Coordinates relative to the window that GtkTreeView renders to.
/// 
/// - Tree coordinates: Coordinates relative to the entire scrollable area of GtkTreeView. These
///   coordinates start at (0, 0) for row 0 of the tree.
/// 
/// Several functions are available for converting between the different
/// coordinate systems.  The most common translations are between widget and bin
/// window coordinates and between bin window and tree coordinates. For the
/// former you can use [method`Gtk.TreeView.convert_widget_to_bin_window_coords`]
/// (and vice versa), for the latter [method`Gtk.TreeView.convert_bin_window_to_tree_coords`]
/// (and vice versa).
/// 
/// ## `GtkTreeView` as `GtkBuildable`
/// 
/// The `GtkTreeView` implementation of the `GtkBuildable` interface accepts
/// [class`Gtk.TreeViewColumn`] objects as `&lt;child&gt;` elements and exposes the
/// internal [class`Gtk.TreeSelection`] in UI definitions.
/// 
/// An example of a UI definition fragment with `GtkTreeView`:
/// 
/// ```xml
/// &lt;object class="GtkTreeView" id="treeview"&gt;
///   &lt;property name="model"&gt;liststore1&lt;/property&gt;
///   &lt;child&gt;
///     &lt;object class="GtkTreeViewColumn" id="test-column"&gt;
///       &lt;property name="title"&gt;Test&lt;/property&gt;
///       &lt;child&gt;
///         &lt;object class="GtkCellRendererText" id="test-renderer"/&gt;
///         &lt;attributes&gt;
///           &lt;attribute name="text"&gt;1&lt;/attribute&gt;
///         &lt;/attributes&gt;
///       &lt;/child&gt;
///     &lt;/object&gt;
///   &lt;/child&gt;
///   &lt;child internal-child="selection"&gt;
///     &lt;object class="GtkTreeSelection" id="selection"&gt;
///       &lt;signal name="changed" handler="on_treeview_selection_changed"/&gt;
///     &lt;/object&gt;
///   &lt;/child&gt;
/// &lt;/object&gt;
/// ```
/// 
/// ## CSS nodes
/// 
/// ```
/// treeview.view
/// ├── header
/// │   ├── button
/// │   │   ╰── [sort-indicator]
/// ┊   ┊
/// │   ╰── button
/// │       ╰── [sort-indicator]
/// │
/// ├── [rubberband]
/// ╰── [dndtarget]
/// ```
/// 
/// `GtkTreeView` has a main CSS node with name `treeview` and style class `.view`.
/// It has a subnode with name `header`, which is the parent for all the column
/// header widgets' CSS nodes.
/// 
/// Each column header consists of a `button`, which among other content, has a
/// child with name `sort-indicator`, which carries the `.ascending` or `.descending`
/// style classes when the column header should show a sort indicator. The CSS
/// is expected to provide a suitable image using the `-gtk-icon-source` property.
/// 
/// For rubberband selection, a subnode with name `rubberband` is used.
/// 
/// For the drop target location during DND, a subnode with name `dndtarget` is used.
///
/// The `TreeViewRef` type acts as a lightweight Swift reference to an underlying `GtkTreeView` instance.
/// It exposes methods that can operate on this data type through `TreeViewProtocol` conformance.
/// Use `TreeViewRef` only as an `unowned` reference to an existing `GtkTreeView` instance.
///
public struct TreeViewRef: TreeViewProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTreeView` instance.
    /// For type-safe access, use the generated, typed pointer `tree_view_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeViewRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeView>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeView>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeView>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeView>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeViewProtocol`
    @inlinable init<T: TreeViewProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TreeViewProtocol>(_ other: T) -> TreeViewRef { TreeViewRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkTreeView` widget.
    @inlinable init() {
            let result = gtk_tree_view_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkTreeView` widget with the model initialized to `model`.
    @inlinable init<TreeModelT: TreeModelProtocol>(model: TreeModelT) {
            let result = gtk_tree_view_new_with_model(model.tree_model_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkTreeView` widget with the model initialized to `model`.
    @inlinable static func newWith<TreeModelT: TreeModelProtocol>(model: TreeModelT) -> WidgetRef! {
            let result = gtk_tree_view_new_with_model(model.tree_model_ptr)
        guard let rv = WidgetRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }
}

/// A widget for displaying both trees and lists
/// 
/// Widget that displays any object that implements the [iface`Gtk.TreeModel`] interface.
/// 
/// Please refer to the [tree widget conceptual overview](section-tree-widget.html)
/// for an overview of all the objects and data types related to the tree
/// widget and how they work together.
/// 
/// ## Coordinate systems in GtkTreeView API
/// 
/// Several different coordinate systems are exposed in the `GtkTreeView` API.
/// These are:
/// 
/// ![](tree-view-coordinates.png)
/// 
/// - Widget coordinates: Coordinates relative to the widget (usually `widget-&gt;window`).
/// 
/// - Bin window coordinates: Coordinates relative to the window that GtkTreeView renders to.
/// 
/// - Tree coordinates: Coordinates relative to the entire scrollable area of GtkTreeView. These
///   coordinates start at (0, 0) for row 0 of the tree.
/// 
/// Several functions are available for converting between the different
/// coordinate systems.  The most common translations are between widget and bin
/// window coordinates and between bin window and tree coordinates. For the
/// former you can use [method`Gtk.TreeView.convert_widget_to_bin_window_coords`]
/// (and vice versa), for the latter [method`Gtk.TreeView.convert_bin_window_to_tree_coords`]
/// (and vice versa).
/// 
/// ## `GtkTreeView` as `GtkBuildable`
/// 
/// The `GtkTreeView` implementation of the `GtkBuildable` interface accepts
/// [class`Gtk.TreeViewColumn`] objects as `&lt;child&gt;` elements and exposes the
/// internal [class`Gtk.TreeSelection`] in UI definitions.
/// 
/// An example of a UI definition fragment with `GtkTreeView`:
/// 
/// ```xml
/// &lt;object class="GtkTreeView" id="treeview"&gt;
///   &lt;property name="model"&gt;liststore1&lt;/property&gt;
///   &lt;child&gt;
///     &lt;object class="GtkTreeViewColumn" id="test-column"&gt;
///       &lt;property name="title"&gt;Test&lt;/property&gt;
///       &lt;child&gt;
///         &lt;object class="GtkCellRendererText" id="test-renderer"/&gt;
///         &lt;attributes&gt;
///           &lt;attribute name="text"&gt;1&lt;/attribute&gt;
///         &lt;/attributes&gt;
///       &lt;/child&gt;
///     &lt;/object&gt;
///   &lt;/child&gt;
///   &lt;child internal-child="selection"&gt;
///     &lt;object class="GtkTreeSelection" id="selection"&gt;
///       &lt;signal name="changed" handler="on_treeview_selection_changed"/&gt;
///     &lt;/object&gt;
///   &lt;/child&gt;
/// &lt;/object&gt;
/// ```
/// 
/// ## CSS nodes
/// 
/// ```
/// treeview.view
/// ├── header
/// │   ├── button
/// │   │   ╰── [sort-indicator]
/// ┊   ┊
/// │   ╰── button
/// │       ╰── [sort-indicator]
/// │
/// ├── [rubberband]
/// ╰── [dndtarget]
/// ```
/// 
/// `GtkTreeView` has a main CSS node with name `treeview` and style class `.view`.
/// It has a subnode with name `header`, which is the parent for all the column
/// header widgets' CSS nodes.
/// 
/// Each column header consists of a `button`, which among other content, has a
/// child with name `sort-indicator`, which carries the `.ascending` or `.descending`
/// style classes when the column header should show a sort indicator. The CSS
/// is expected to provide a suitable image using the `-gtk-icon-source` property.
/// 
/// For rubberband selection, a subnode with name `rubberband` is used.
/// 
/// For the drop target location during DND, a subnode with name `dndtarget` is used.
///
/// The `TreeView` type acts as a reference-counted owner of an underlying `GtkTreeView` instance.
/// It provides the methods that can operate on this data type through `TreeViewProtocol` conformance.
/// Use `TreeView` as a strong reference or owner of a `GtkTreeView` instance.
///
open class TreeView: Widget, TreeViewProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeView>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeView>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeView` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeView>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeView>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTreeView`.
    /// i.e., ownership is transferred to the `TreeView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeView>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TreeViewProtocol`
    /// Will retain `GtkTreeView`.
    /// - Parameter other: an instance of a related type that implements `TreeViewProtocol`
    @inlinable public init<T: TreeViewProtocol>(treeView other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkTreeView` widget.
    @inlinable public init() {
            let result = gtk_tree_view_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkTreeView` widget with the model initialized to `model`.
    @inlinable public init<TreeModelT: TreeModelProtocol>(model: TreeModelT) {
            let result = gtk_tree_view_new_with_model(model.tree_model_ptr)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkTreeView` widget with the model initialized to `model`.
    @inlinable public static func newWith<TreeModelT: TreeModelProtocol>(model: TreeModelT) -> Widget! {
            let result = gtk_tree_view_new_with_model(model.tree_model_ptr)
        guard let rv = Widget(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }

}

public enum TreeViewPropertyName: String, PropertyNameProtocol {
    /// The activate-on-single-click property specifies whether the "row-activated" signal
    /// will be emitted after a single click.
    case activateOnSingleClick = "activate-on-single-click"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    case enableGridLines = "enable-grid-lines"
    case enableSearch = "enable-search"
    case enableTreeLines = "enable-tree-lines"
    case expanderColumn = "expander-column"
    /// Setting the `fixed-height-mode` property to `true` speeds up
    /// `GtkTreeView` by assuming that all rows have the same height.
    /// Only enable this option if all rows are the same height.
    /// Please see `gtk_tree_view_set_fixed_height_mode()` for more
    /// information on this option.
    case fixedHeightMode = "fixed-height-mode"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case headersClickable = "headers-clickable"
    case headersVisible = "headers-visible"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// Enables or disables the hover expansion mode of `tree_view`.
    /// Hover expansion makes rows expand or collapse if the pointer moves
    /// over them.
    /// 
    /// This mode is primarily intended for treeviews in popups, e.g.
    /// in `GtkComboBox` or `GtkEntryCompletion`.
    case hoverExpand = "hover-expand"
    /// Enables or disables the hover selection mode of `tree_view`.
    /// Hover selection makes the selected row follow the pointer.
    /// Currently, this works only for the selection modes
    /// `GTK_SELECTION_SINGLE` and `GTK_SELECTION_BROWSE`.
    /// 
    /// This mode is primarily intended for treeviews in popups, e.g.
    /// in `GtkComboBox` or `GtkEntryCompletion`.
    case hoverSelection = "hover-selection"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Extra indentation for each level.
    case levelIndentation = "level-indentation"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    case model = "model"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    case reorderable = "reorderable"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    case rubberBanding = "rubber-banding"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    case searchColumn = "search-column"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// `true` if the view has expanders.
    case showExpanders = "show-expanders"
    case tooltipColumn = "tooltip-column"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension TreeViewProtocol {
    /// Bind a `TreeViewPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeViewPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TreeView property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TreeViewPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TreeView property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TreeViewPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TreeViewSignalName: String, SignalNameProtocol {
    /// The number of columns of the treeview has changed.
    case columnsChanged = "columns-changed"
    /// The position of the cursor (focused cell) has changed.
    case cursorChanged = "cursor-changed"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    case expandCollapseCursorRow = "expand-collapse-cursor-row"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `GtkTreeView``move-cursor` signal is a [keybinding
    /// signal](#class@Gtk.SignalAction) which gets emitted when the user
    /// presses one of the cursor keys.
    /// 
    /// Applications should not connect to it, but may emit it with
    /// `g_signal_emit_by_name()` if they need to control the cursor
    /// programmatically. In contrast to `gtk_tree_view_set_cursor()` and
    /// `gtk_tree_view_set_cursor_on_cell()` when moving horizontally
    /// `GtkTreeView``move-cursor` does not reset the current selection.
    case moveCursor = "move-cursor"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// The "row-activated" signal is emitted when the method
    /// [`method`Gtk.TreeView.row_activated``] is called.
    /// 
    /// This signal is emitted when the user double-clicks a treeview row with the
    /// [property`Gtk.TreeView:activate-on-single-click`] property set to `false`,
    /// or when the user single-clicks a row when that property set to `true`.
    /// 
    /// This signal is also emitted when a non-editable row is selected and one
    /// of the keys: &lt;kbd&gt;Space&lt;/kbd&gt;, &lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Space&lt;/kbd&gt;,
    /// &lt;kbd&gt;Return&lt;/kbd&gt; or &lt;kbd&gt;Enter&lt;/kbd&gt; is pressed.
    /// 
    /// For selection handling refer to the
    /// [tree widget conceptual overview](section-tree-widget.html)
    /// as well as `GtkTreeSelection`.
    case rowActivated = "row-activated"
    /// The given row has been collapsed (child nodes are hidden).
    case rowCollapsed = "row-collapsed"
    /// The given row has been expanded (child nodes are shown).
    case rowExpanded = "row-expanded"
    case selectAll = "select-all"
    case selectCursorParent = "select-cursor-parent"
    case selectCursorRow = "select-cursor-row"
    /// Emitted when `widget` is shown.
    case show = "show"
    case startInteractiveSearch = "start-interactive-search"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// The given row is about to be collapsed (hide its children nodes). Use this
    /// signal if you need to control the collapsibility of individual rows.
    case testCollapseRow = "test-collapse-row"
    /// The given row is about to be expanded (show its children nodes). Use this
    /// signal if you need to control the expandability of individual rows.
    case testExpandRow = "test-expand-row"
    case toggleCursorRow = "toggle-cursor-row"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    case unselectAll = "unselect-all"
    /// The activate-on-single-click property specifies whether the "row-activated" signal
    /// will be emitted after a single click.
    case notifyActivateOnSingleClick = "notify::activate-on-single-click"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    case notifyEnableGridLines = "notify::enable-grid-lines"
    case notifyEnableSearch = "notify::enable-search"
    case notifyEnableTreeLines = "notify::enable-tree-lines"
    case notifyExpanderColumn = "notify::expander-column"
    /// Setting the `fixed-height-mode` property to `true` speeds up
    /// `GtkTreeView` by assuming that all rows have the same height.
    /// Only enable this option if all rows are the same height.
    /// Please see `gtk_tree_view_set_fixed_height_mode()` for more
    /// information on this option.
    case notifyFixedHeightMode = "notify::fixed-height-mode"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeadersClickable = "notify::headers-clickable"
    case notifyHeadersVisible = "notify::headers-visible"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// Enables or disables the hover expansion mode of `tree_view`.
    /// Hover expansion makes rows expand or collapse if the pointer moves
    /// over them.
    /// 
    /// This mode is primarily intended for treeviews in popups, e.g.
    /// in `GtkComboBox` or `GtkEntryCompletion`.
    case notifyHoverExpand = "notify::hover-expand"
    /// Enables or disables the hover selection mode of `tree_view`.
    /// Hover selection makes the selected row follow the pointer.
    /// Currently, this works only for the selection modes
    /// `GTK_SELECTION_SINGLE` and `GTK_SELECTION_BROWSE`.
    /// 
    /// This mode is primarily intended for treeviews in popups, e.g.
    /// in `GtkComboBox` or `GtkEntryCompletion`.
    case notifyHoverSelection = "notify::hover-selection"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Extra indentation for each level.
    case notifyLevelIndentation = "notify::level-indentation"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyModel = "notify::model"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    case notifyReorderable = "notify::reorderable"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    case notifyRubberBanding = "notify::rubber-banding"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySearchColumn = "notify::search-column"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// `true` if the view has expanders.
    case notifyShowExpanders = "notify::show-expanders"
    case notifyTooltipColumn = "notify::tooltip-column"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: TreeView signals
public extension TreeViewProtocol {
    /// Connect a Swift signal handler to the given, typed `TreeViewSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TreeViewSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `TreeViewSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TreeViewSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// The number of columns of the treeview has changed.
    /// - Note: This represents the underlying `columns-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `columnsChanged` signal is emitted
    @discardableResult @inlinable func onColumnsChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .columnsChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `columns-changed` signal for using the `connect(signal:)` methods
    static var columnsChangedSignal: TreeViewSignalName { .columnsChanged }
    
    /// The position of the cursor (focused cell) has changed.
    /// - Note: This represents the underlying `cursor-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `cursorChanged` signal is emitted
    @discardableResult @inlinable func onCursorChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .cursorChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `cursor-changed` signal for using the `connect(signal:)` methods
    static var cursorChangedSignal: TreeViewSignalName { .cursorChanged }
    
    /// - Note: This represents the underlying `expand-collapse-cursor-row` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter object: none
    /// - Parameter p0: none
    /// - Parameter p1: none
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `expandCollapseCursorRow` signal is emitted
    @discardableResult @inlinable func onExpandCollapseCursorRow(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ object: Bool, _ p0: Bool, _ p1: Bool) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, Bool, Bool, Bool), Bool>
        let cCallback: @convention(c) (gpointer, gboolean, gboolean, gboolean, gpointer) -> gboolean = { unownedSelf, arg1, arg2, arg3, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call((TreeViewRef(raw: unownedSelf), ((arg1) != 0), ((arg2) != 0), ((arg3) != 0)))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .expandCollapseCursorRow,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `expand-collapse-cursor-row` signal for using the `connect(signal:)` methods
    static var expandCollapseCursorRowSignal: TreeViewSignalName { .expandCollapseCursorRow }
    
    /// The `GtkTreeView``move-cursor` signal is a [keybinding
    /// signal](#class@Gtk.SignalAction) which gets emitted when the user
    /// presses one of the cursor keys.
    /// 
    /// Applications should not connect to it, but may emit it with
    /// `g_signal_emit_by_name()` if they need to control the cursor
    /// programmatically. In contrast to `gtk_tree_view_set_cursor()` and
    /// `gtk_tree_view_set_cursor_on_cell()` when moving horizontally
    /// `GtkTreeView``move-cursor` does not reset the current selection.
    /// - Note: This represents the underlying `move-cursor` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter step: the granularity of the move, as a `GtkMovementStep`.     `GTK_MOVEMENT_LOGICAL_POSITIONS`, `GTK_MOVEMENT_VISUAL_POSITIONS`,     `GTK_MOVEMENT_DISPLAY_LINES`, `GTK_MOVEMENT_PAGES` and     `GTK_MOVEMENT_BUFFER_ENDS` are supported.     `GTK_MOVEMENT_LOGICAL_POSITIONS` and `GTK_MOVEMENT_VISUAL_POSITIONS`     are treated identically.
    /// - Parameter direction: the direction to move: +1 to move forwards; -1 to move     backwards. The resulting movement is undefined for all other values.
    /// - Parameter extend: whether to extend the selection
    /// - Parameter modify: whether to modify the selection
    /// - Parameter handler: `true` if `step` is supported, `false` otherwise.
    /// Run the given callback whenever the `moveCursor` signal is emitted
    @discardableResult @inlinable func onMoveCursor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ step: MovementStep, _ direction: Int, _ extend: Bool, _ modify: Bool) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, MovementStep, Int, Bool, Bool), Bool>
        let cCallback: @convention(c) (gpointer, UInt32, gint, gboolean, gboolean, gpointer) -> gboolean = { unownedSelf, arg1, arg2, arg3, arg4, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call((TreeViewRef(raw: unownedSelf), MovementStep(arg1), Int(arg2), ((arg3) != 0), ((arg4) != 0)))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .moveCursor,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `move-cursor` signal for using the `connect(signal:)` methods
    static var moveCursorSignal: TreeViewSignalName { .moveCursor }
    
    /// The "row-activated" signal is emitted when the method
    /// [`method`Gtk.TreeView.row_activated``] is called.
    /// 
    /// This signal is emitted when the user double-clicks a treeview row with the
    /// [property`Gtk.TreeView:activate-on-single-click`] property set to `false`,
    /// or when the user single-clicks a row when that property set to `true`.
    /// 
    /// This signal is also emitted when a non-editable row is selected and one
    /// of the keys: &lt;kbd&gt;Space&lt;/kbd&gt;, &lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Space&lt;/kbd&gt;,
    /// &lt;kbd&gt;Return&lt;/kbd&gt; or &lt;kbd&gt;Enter&lt;/kbd&gt; is pressed.
    /// 
    /// For selection handling refer to the
    /// [tree widget conceptual overview](section-tree-widget.html)
    /// as well as `GtkTreeSelection`.
    /// - Note: This represents the underlying `row-activated` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter path: the `GtkTreePath` for the activated row
    /// - Parameter column: the `GtkTreeViewColumn` in which the activation occurred
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `rowActivated` signal is emitted
    @discardableResult @inlinable func onRowActivated(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ path: TreePathRef, _ column: TreeViewColumnRef?) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, TreePathRef, TreeViewColumnRef?), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer?, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf), TreePathRef(raw: arg1), arg2.flatMap(TreeViewColumnRef.init(raw:))))
            return output
        }
        return connect(
            signal: .rowActivated,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `row-activated` signal for using the `connect(signal:)` methods
    static var rowActivatedSignal: TreeViewSignalName { .rowActivated }
    
    /// The given row has been collapsed (child nodes are hidden).
    /// - Note: This represents the underlying `row-collapsed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter iter: the tree iter of the collapsed row
    /// - Parameter path: a tree path that points to the row
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `rowCollapsed` signal is emitted
    @discardableResult @inlinable func onRowCollapsed(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ iter: TreeIterRef, _ path: TreePathRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, TreeIterRef, TreePathRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf), TreeIterRef(raw: arg1), TreePathRef(raw: arg2)))
            return output
        }
        return connect(
            signal: .rowCollapsed,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `row-collapsed` signal for using the `connect(signal:)` methods
    static var rowCollapsedSignal: TreeViewSignalName { .rowCollapsed }
    
    /// The given row has been expanded (child nodes are shown).
    /// - Note: This represents the underlying `row-expanded` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter iter: the tree iter of the expanded row
    /// - Parameter path: a tree path that points to the row
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `rowExpanded` signal is emitted
    @discardableResult @inlinable func onRowExpanded(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ iter: TreeIterRef, _ path: TreePathRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, TreeIterRef, TreePathRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf), TreeIterRef(raw: arg1), TreePathRef(raw: arg2)))
            return output
        }
        return connect(
            signal: .rowExpanded,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `row-expanded` signal for using the `connect(signal:)` methods
    static var rowExpandedSignal: TreeViewSignalName { .rowExpanded }
    
    /// - Note: This represents the underlying `select-all` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `selectAll` signal is emitted
    @discardableResult @inlinable func onSelectAll(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef), Bool>
        let cCallback: @convention(c) (gpointer, gpointer) -> gboolean = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call((TreeViewRef(raw: unownedSelf)))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .selectAll,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `select-all` signal for using the `connect(signal:)` methods
    static var selectAllSignal: TreeViewSignalName { .selectAll }
    
    /// - Note: This represents the underlying `select-cursor-parent` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `selectCursorParent` signal is emitted
    @discardableResult @inlinable func onSelectCursorParent(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef), Bool>
        let cCallback: @convention(c) (gpointer, gpointer) -> gboolean = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call((TreeViewRef(raw: unownedSelf)))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .selectCursorParent,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `select-cursor-parent` signal for using the `connect(signal:)` methods
    static var selectCursorParentSignal: TreeViewSignalName { .selectCursorParent }
    
    /// - Note: This represents the underlying `select-cursor-row` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter object: none
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `selectCursorRow` signal is emitted
    @discardableResult @inlinable func onSelectCursorRow(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ object: Bool) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, Bool), Bool>
        let cCallback: @convention(c) (gpointer, gboolean, gpointer) -> gboolean = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call((TreeViewRef(raw: unownedSelf), ((arg1) != 0)))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .selectCursorRow,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `select-cursor-row` signal for using the `connect(signal:)` methods
    static var selectCursorRowSignal: TreeViewSignalName { .selectCursorRow }
    
    /// - Note: This represents the underlying `start-interactive-search` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `startInteractiveSearch` signal is emitted
    @discardableResult @inlinable func onStartInteractiveSearch(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef), Bool>
        let cCallback: @convention(c) (gpointer, gpointer) -> gboolean = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call((TreeViewRef(raw: unownedSelf)))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .startInteractiveSearch,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `start-interactive-search` signal for using the `connect(signal:)` methods
    static var startInteractiveSearchSignal: TreeViewSignalName { .startInteractiveSearch }
    
    /// The given row is about to be collapsed (hide its children nodes). Use this
    /// signal if you need to control the collapsibility of individual rows.
    /// - Note: This represents the underlying `test-collapse-row` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter iter: the tree iter of the row to collapse
    /// - Parameter path: a tree path that points to the row
    /// - Parameter handler: `false` to allow collapsing, `true` to reject
    /// Run the given callback whenever the `testCollapseRow` signal is emitted
    @discardableResult @inlinable func onTestCollapseRow(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ iter: TreeIterRef, _ path: TreePathRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, TreeIterRef, TreePathRef), Bool>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> gboolean = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call((TreeViewRef(raw: unownedSelf), TreeIterRef(raw: arg1), TreePathRef(raw: arg2)))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .testCollapseRow,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `test-collapse-row` signal for using the `connect(signal:)` methods
    static var testCollapseRowSignal: TreeViewSignalName { .testCollapseRow }
    
    /// The given row is about to be expanded (show its children nodes). Use this
    /// signal if you need to control the expandability of individual rows.
    /// - Note: This represents the underlying `test-expand-row` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter iter: the tree iter of the row to expand
    /// - Parameter path: a tree path that points to the row
    /// - Parameter handler: `false` to allow expansion, `true` to reject
    /// Run the given callback whenever the `testExpandRow` signal is emitted
    @discardableResult @inlinable func onTestExpandRow(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ iter: TreeIterRef, _ path: TreePathRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, TreeIterRef, TreePathRef), Bool>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> gboolean = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call((TreeViewRef(raw: unownedSelf), TreeIterRef(raw: arg1), TreePathRef(raw: arg2)))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .testExpandRow,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `test-expand-row` signal for using the `connect(signal:)` methods
    static var testExpandRowSignal: TreeViewSignalName { .testExpandRow }
    
    /// - Note: This represents the underlying `toggle-cursor-row` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `toggleCursorRow` signal is emitted
    @discardableResult @inlinable func onToggleCursorRow(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef), Bool>
        let cCallback: @convention(c) (gpointer, gpointer) -> gboolean = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call((TreeViewRef(raw: unownedSelf)))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .toggleCursorRow,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `toggle-cursor-row` signal for using the `connect(signal:)` methods
    static var toggleCursorRowSignal: TreeViewSignalName { .toggleCursorRow }
    
    /// - Note: This represents the underlying `unselect-all` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `unselectAll` signal is emitted
    @discardableResult @inlinable func onUnselectAll(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef), Bool>
        let cCallback: @convention(c) (gpointer, gpointer) -> gboolean = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call((TreeViewRef(raw: unownedSelf)))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .unselectAll,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `unselect-all` signal for using the `connect(signal:)` methods
    static var unselectAllSignal: TreeViewSignalName { .unselectAll }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::activate-on-single-click` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActivateOnSingleClick` signal is emitted
    @discardableResult @inlinable func onNotifyActivateOnSingleClick(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyActivateOnSingleClick,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::activate-on-single-click` signal for using the `connect(signal:)` methods
    static var notifyActivateOnSingleClickSignal: TreeViewSignalName { .notifyActivateOnSingleClick }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::enable-grid-lines` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEnableGridLines` signal is emitted
    @discardableResult @inlinable func onNotifyEnableGridLines(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyEnableGridLines,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::enable-grid-lines` signal for using the `connect(signal:)` methods
    static var notifyEnableGridLinesSignal: TreeViewSignalName { .notifyEnableGridLines }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::enable-search` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEnableSearch` signal is emitted
    @discardableResult @inlinable func onNotifyEnableSearch(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyEnableSearch,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::enable-search` signal for using the `connect(signal:)` methods
    static var notifyEnableSearchSignal: TreeViewSignalName { .notifyEnableSearch }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::enable-tree-lines` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEnableTreeLines` signal is emitted
    @discardableResult @inlinable func onNotifyEnableTreeLines(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyEnableTreeLines,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::enable-tree-lines` signal for using the `connect(signal:)` methods
    static var notifyEnableTreeLinesSignal: TreeViewSignalName { .notifyEnableTreeLines }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::expander-column` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyExpanderColumn` signal is emitted
    @discardableResult @inlinable func onNotifyExpanderColumn(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyExpanderColumn,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::expander-column` signal for using the `connect(signal:)` methods
    static var notifyExpanderColumnSignal: TreeViewSignalName { .notifyExpanderColumn }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::fixed-height-mode` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFixedHeightMode` signal is emitted
    @discardableResult @inlinable func onNotifyFixedHeightMode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyFixedHeightMode,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::fixed-height-mode` signal for using the `connect(signal:)` methods
    static var notifyFixedHeightModeSignal: TreeViewSignalName { .notifyFixedHeightMode }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::headers-clickable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHeadersClickable` signal is emitted
    @discardableResult @inlinable func onNotifyHeadersClickable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyHeadersClickable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::headers-clickable` signal for using the `connect(signal:)` methods
    static var notifyHeadersClickableSignal: TreeViewSignalName { .notifyHeadersClickable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::headers-visible` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHeadersVisible` signal is emitted
    @discardableResult @inlinable func onNotifyHeadersVisible(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyHeadersVisible,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::headers-visible` signal for using the `connect(signal:)` methods
    static var notifyHeadersVisibleSignal: TreeViewSignalName { .notifyHeadersVisible }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::hover-expand` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHoverExpand` signal is emitted
    @discardableResult @inlinable func onNotifyHoverExpand(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyHoverExpand,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::hover-expand` signal for using the `connect(signal:)` methods
    static var notifyHoverExpandSignal: TreeViewSignalName { .notifyHoverExpand }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::hover-selection` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHoverSelection` signal is emitted
    @discardableResult @inlinable func onNotifyHoverSelection(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyHoverSelection,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::hover-selection` signal for using the `connect(signal:)` methods
    static var notifyHoverSelectionSignal: TreeViewSignalName { .notifyHoverSelection }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::level-indentation` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyLevelIndentation` signal is emitted
    @discardableResult @inlinable func onNotifyLevelIndentation(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyLevelIndentation,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::level-indentation` signal for using the `connect(signal:)` methods
    static var notifyLevelIndentationSignal: TreeViewSignalName { .notifyLevelIndentation }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::model` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyModel` signal is emitted
    @discardableResult @inlinable func onNotifyModel(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyModel,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::model` signal for using the `connect(signal:)` methods
    static var notifyModelSignal: TreeViewSignalName { .notifyModel }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::reorderable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyReorderable` signal is emitted
    @discardableResult @inlinable func onNotifyReorderable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyReorderable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::reorderable` signal for using the `connect(signal:)` methods
    static var notifyReorderableSignal: TreeViewSignalName { .notifyReorderable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::rubber-banding` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyRubberBanding` signal is emitted
    @discardableResult @inlinable func onNotifyRubberBanding(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyRubberBanding,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::rubber-banding` signal for using the `connect(signal:)` methods
    static var notifyRubberBandingSignal: TreeViewSignalName { .notifyRubberBanding }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::search-column` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySearchColumn` signal is emitted
    @discardableResult @inlinable func onNotifySearchColumn(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifySearchColumn,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::search-column` signal for using the `connect(signal:)` methods
    static var notifySearchColumnSignal: TreeViewSignalName { .notifySearchColumn }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::show-expanders` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyShowExpanders` signal is emitted
    @discardableResult @inlinable func onNotifyShowExpanders(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyShowExpanders,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::show-expanders` signal for using the `connect(signal:)` methods
    static var notifyShowExpandersSignal: TreeViewSignalName { .notifyShowExpanders }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::tooltip-column` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTooltipColumn` signal is emitted
    @discardableResult @inlinable func onNotifyTooltipColumn(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyTooltipColumn,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::tooltip-column` signal for using the `connect(signal:)` methods
    static var notifyTooltipColumnSignal: TreeViewSignalName { .notifyTooltipColumn }
    
}

// MARK: TreeView Class: TreeViewProtocol extension (methods and fields)
public extension TreeViewProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeView` instance.
    @inlinable var tree_view_ptr: UnsafeMutablePointer<GtkTreeView>! { return ptr?.assumingMemoryBound(to: GtkTreeView.self) }

    /// Appends `column` to the list of columns. If `tree_view` has “fixed_height”
    /// mode enabled, then `column` must have its “sizing” property set to be
    /// GTK_TREE_VIEW_COLUMN_FIXED.
    @inlinable func append<TreeViewColumnT: TreeViewColumnProtocol>(column: TreeViewColumnT) -> Int {
        let result = gtk_tree_view_append_column(tree_view_ptr, column.tree_view_column_ptr)
        let rv = Int(result)
        return rv
    }

    /// Recursively collapses all visible, expanded nodes in `tree_view`.
    @inlinable func collapseAll() {
        
        gtk_tree_view_collapse_all(tree_view_ptr)
        
    }

    /// Collapses a row (hides its child rows, if they exist).
    @inlinable func collapseRow<TreePathT: TreePathProtocol>(path: TreePathT) -> Bool {
        let result = gtk_tree_view_collapse_row(tree_view_ptr, path.tree_path_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Resizes all columns to their optimal width. Only works after the
    /// treeview has been realized.
    @inlinable func columnsAutosize() {
        
        gtk_tree_view_columns_autosize(tree_view_ptr)
        
    }

    /// Converts bin_window coordinates to coordinates for the
    /// tree (the full scrollable area of the tree).
    @inlinable func convertBinWindowToTreeCoords(bx: Int, by: Int, tx: UnsafeMutablePointer<gint>!, ty: UnsafeMutablePointer<gint>!) {
        
        gtk_tree_view_convert_bin_window_to_tree_coords(tree_view_ptr, gint(bx), gint(by), tx, ty)
        
    }

    /// Converts bin_window coordinates to widget relative coordinates.
    @inlinable func convertBinWindowToWidgetCoords(bx: Int, by: Int, wx: UnsafeMutablePointer<gint>!, wy: UnsafeMutablePointer<gint>!) {
        
        gtk_tree_view_convert_bin_window_to_widget_coords(tree_view_ptr, gint(bx), gint(by), wx, wy)
        
    }

    /// Converts tree coordinates (coordinates in full scrollable area of the tree)
    /// to bin_window coordinates.
    @inlinable func convertTreeToBinWindowCoords(tx: Int, ty: Int, bx: UnsafeMutablePointer<gint>!, by: UnsafeMutablePointer<gint>!) {
        
        gtk_tree_view_convert_tree_to_bin_window_coords(tree_view_ptr, gint(tx), gint(ty), bx, by)
        
    }

    /// Converts tree coordinates (coordinates in full scrollable area of the tree)
    /// to widget coordinates.
    @inlinable func convertTreeToWidgetCoords(tx: Int, ty: Int, wx: UnsafeMutablePointer<gint>!, wy: UnsafeMutablePointer<gint>!) {
        
        gtk_tree_view_convert_tree_to_widget_coords(tree_view_ptr, gint(tx), gint(ty), wx, wy)
        
    }

    /// Converts widget coordinates to coordinates for the bin_window.
    @inlinable func convertWidgetToBinWindowCoords(wx: Int, wy: Int, bx: UnsafeMutablePointer<gint>!, by: UnsafeMutablePointer<gint>!) {
        
        gtk_tree_view_convert_widget_to_bin_window_coords(tree_view_ptr, gint(wx), gint(wy), bx, by)
        
    }

    /// Converts widget coordinates to coordinates for the
    /// tree (the full scrollable area of the tree).
    @inlinable func convertWidgetToTreeCoords(wx: Int, wy: Int, tx: UnsafeMutablePointer<gint>!, ty: UnsafeMutablePointer<gint>!) {
        
        gtk_tree_view_convert_widget_to_tree_coords(tree_view_ptr, gint(wx), gint(wy), tx, ty)
        
    }

    /// Creates a `cairo_surface_t` representation of the row at `path`.
    /// This image is used for a drag icon.
    @inlinable func createRowDragIcon<TreePathT: TreePathProtocol>(path: TreePathT) -> Gdk.PaintableRef! {
        let result = gtk_tree_view_create_row_drag_icon(tree_view_ptr, path.tree_path_ptr)
        let rv = Gdk.PaintableRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Turns `tree_view` into a drop destination for automatic DND. Calling
    /// this method sets `GtkTreeView`:reorderable to `false`.
    @inlinable func enableModelDragDest<GdkContentFormatsT: Gdk.ContentFormatsProtocol>(formats: GdkContentFormatsT, actions: Gdk.DragAction) {
        
        gtk_tree_view_enable_model_drag_dest(tree_view_ptr, formats.content_formats_ptr, actions.value)
        
    }

    /// Turns `tree_view` into a drag source for automatic DND. Calling this
    /// method sets `GtkTreeView`:reorderable to `false`.
    @inlinable func enableModelDragSource<GdkContentFormatsT: Gdk.ContentFormatsProtocol>(startButtonMask: Gdk.ModifierType, formats: GdkContentFormatsT, actions: Gdk.DragAction) {
        
        gtk_tree_view_enable_model_drag_source(tree_view_ptr, startButtonMask.value, formats.content_formats_ptr, actions.value)
        
    }

    /// Recursively expands all nodes in the `tree_view`.
    @inlinable func expandAll() {
        
        gtk_tree_view_expand_all(tree_view_ptr)
        
    }

    /// Opens the row so its children are visible.
    @inlinable func expandRow<TreePathT: TreePathProtocol>(path: TreePathT, openAll: Bool) -> Bool {
        let result = gtk_tree_view_expand_row(tree_view_ptr, path.tree_path_ptr, gboolean((openAll) ? 1 : 0))
        let rv = ((result) != 0)
        return rv
    }

    /// Expands the row at `path`. This will also expand all parent rows of
    /// `path` as necessary.
    @inlinable func expandTo<TreePathT: TreePathProtocol>(path: TreePathT) {
        
        gtk_tree_view_expand_to_path(tree_view_ptr, path.tree_path_ptr)
        
    }

    /// Gets the setting set by `gtk_tree_view_set_activate_on_single_click()`.
    @inlinable func getActivateOnSingleClick() -> Bool {
        let result = gtk_tree_view_get_activate_on_single_click(tree_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Fills the bounding rectangle in bin_window coordinates for the cell at the
    /// row specified by `path` and the column specified by `column`.  If `path` is
    /// `nil`, or points to a node not found in the tree, the `y` and `height` fields of
    /// the rectangle will be filled with 0. If `column` is `nil`, the `x` and `width`
    /// fields will be filled with 0.  The returned rectangle is equivalent to the
    /// `background_area` passed to `gtk_cell_renderer_render()`.  These background
    /// areas tile to cover the entire bin window.  Contrast with the `cell_area`,
    /// returned by `gtk_tree_view_get_cell_area()`, which returns only the cell
    /// itself, excluding surrounding borders and the tree expander area.
    @inlinable func getBackgroundArea<GdkRectangleT: Gdk.RectangleProtocol>(path: TreePathRef? = nil, column: TreeViewColumnRef? = nil, rect: GdkRectangleT) {
            
        gtk_tree_view_get_background_area(tree_view_ptr, path?.tree_path_ptr, column?.tree_view_column_ptr, rect.rectangle_ptr)
            
    }
    /// Fills the bounding rectangle in bin_window coordinates for the cell at the
    /// row specified by `path` and the column specified by `column`.  If `path` is
    /// `nil`, or points to a node not found in the tree, the `y` and `height` fields of
    /// the rectangle will be filled with 0. If `column` is `nil`, the `x` and `width`
    /// fields will be filled with 0.  The returned rectangle is equivalent to the
    /// `background_area` passed to `gtk_cell_renderer_render()`.  These background
    /// areas tile to cover the entire bin window.  Contrast with the `cell_area`,
    /// returned by `gtk_tree_view_get_cell_area()`, which returns only the cell
    /// itself, excluding surrounding borders and the tree expander area.
    @inlinable func getBackgroundArea<GdkRectangleT: Gdk.RectangleProtocol, TreePathT: TreePathProtocol, TreeViewColumnT: TreeViewColumnProtocol>(path: TreePathT?, column: TreeViewColumnT?, rect: GdkRectangleT) {
        
        gtk_tree_view_get_background_area(tree_view_ptr, path?.tree_path_ptr, column?.tree_view_column_ptr, rect.rectangle_ptr)
        
    }

    /// Fills the bounding rectangle in bin_window coordinates for the cell at the
    /// row specified by `path` and the column specified by `column`.  If `path` is
    /// `nil`, or points to a path not currently displayed, the `y` and `height` fields
    /// of the rectangle will be filled with 0. If `column` is `nil`, the `x` and `width`
    /// fields will be filled with 0.  The sum of all cell rects does not cover the
    /// entire tree; there are extra pixels in between rows, for example. The
    /// returned rectangle is equivalent to the `cell_area` passed to
    /// `gtk_cell_renderer_render()`.  This function is only valid if `tree_view` is
    /// realized.
    @inlinable func getCellArea<GdkRectangleT: Gdk.RectangleProtocol>(path: TreePathRef? = nil, column: TreeViewColumnRef? = nil, rect: GdkRectangleT) {
            
        gtk_tree_view_get_cell_area(tree_view_ptr, path?.tree_path_ptr, column?.tree_view_column_ptr, rect.rectangle_ptr)
            
    }
    /// Fills the bounding rectangle in bin_window coordinates for the cell at the
    /// row specified by `path` and the column specified by `column`.  If `path` is
    /// `nil`, or points to a path not currently displayed, the `y` and `height` fields
    /// of the rectangle will be filled with 0. If `column` is `nil`, the `x` and `width`
    /// fields will be filled with 0.  The sum of all cell rects does not cover the
    /// entire tree; there are extra pixels in between rows, for example. The
    /// returned rectangle is equivalent to the `cell_area` passed to
    /// `gtk_cell_renderer_render()`.  This function is only valid if `tree_view` is
    /// realized.
    @inlinable func getCellArea<GdkRectangleT: Gdk.RectangleProtocol, TreePathT: TreePathProtocol, TreeViewColumnT: TreeViewColumnProtocol>(path: TreePathT?, column: TreeViewColumnT?, rect: GdkRectangleT) {
        
        gtk_tree_view_get_cell_area(tree_view_ptr, path?.tree_path_ptr, column?.tree_view_column_ptr, rect.rectangle_ptr)
        
    }

    /// Gets the `GtkTreeViewColumn` at the given position in the `tree_view`.
    @inlinable func getColumn(n: Int) -> TreeViewColumnRef! {
        let result = gtk_tree_view_get_column(tree_view_ptr, gint(n))
        let rv = TreeViewColumnRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns a `GList` of all the `GtkTreeViewColumn`s currently in `tree_view`.
    /// The returned list must be freed with g_list_free ().
    @inlinable func getColumns() -> GLib.ListRef! {
        let result = gtk_tree_view_get_columns(tree_view_ptr)
        let rv = GLib.ListRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Fills in `path` and `focus_column` with the current path and focus column.  If
    /// the cursor isn’t currently set, then *`path` will be `nil`.  If no column
    /// currently has focus, then *`focus_column` will be `nil`.
    /// 
    /// The returned `GtkTreePath` must be freed with `gtk_tree_path_free()` when
    /// you are done with it.
    @inlinable func getCursor(path: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreePath>?>? = nil, focusColumn: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreeViewColumn>?>? = nil) {
        
        gtk_tree_view_get_cursor(tree_view_ptr, path, focusColumn)
        
    }

    /// Determines the destination row for a given position.  `drag_x` and
    /// `drag_y` are expected to be in widget coordinates.  This function is only
    /// meaningful if `tree_view` is realized.  Therefore this function will always
    /// return `false` if `tree_view` is not realized or does not have a model.
    @inlinable func getDestRowAtPos(dragX: Int, dragY: Int, path: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreePath>?>? = nil, pos: UnsafeMutablePointer<GtkTreeViewDropPosition>! = nil) -> Bool {
        let result = gtk_tree_view_get_dest_row_at_pos(tree_view_ptr, gint(dragX), gint(dragY), path, pos)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets information about the row that is highlighted for feedback.
    @inlinable func getDragDestRow(path: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreePath>?>? = nil, pos: UnsafeMutablePointer<GtkTreeViewDropPosition>! = nil) {
        
        gtk_tree_view_get_drag_dest_row(tree_view_ptr, path, pos)
        
    }

    /// Returns whether or not the tree allows to start interactive searching
    /// by typing in text.
    @inlinable func getEnableSearch() -> Bool {
        let result = gtk_tree_view_get_enable_search(tree_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns whether or not tree lines are drawn in `tree_view`.
    @inlinable func getEnableTreeLines() -> Bool {
        let result = gtk_tree_view_get_enable_tree_lines(tree_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns the column that is the current expander column,
    /// or `nil` if none has been set.
    /// This column has the expander arrow drawn next to it.
    @inlinable func getExpanderColumn() -> TreeViewColumnRef! {
        let result = gtk_tree_view_get_expander_column(tree_view_ptr)
        let rv = TreeViewColumnRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns whether fixed height mode is turned on for `tree_view`.
    @inlinable func getFixedHeightMode() -> Bool {
        let result = gtk_tree_view_get_fixed_height_mode(tree_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns which grid lines are enabled in `tree_view`.
    @inlinable func getGridLines() -> GtkTreeViewGridLines {
        let result = gtk_tree_view_get_grid_lines(tree_view_ptr)
        let rv = result
        return rv
    }

    /// Returns whether all header columns are clickable.
    @inlinable func getHeadersClickable() -> Bool {
        let result = gtk_tree_view_get_headers_clickable(tree_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns `true` if the headers on the `tree_view` are visible.
    @inlinable func getHeadersVisible() -> Bool {
        let result = gtk_tree_view_get_headers_visible(tree_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns whether hover expansion mode is turned on for `tree_view`.
    @inlinable func getHoverExpand() -> Bool {
        let result = gtk_tree_view_get_hover_expand(tree_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns whether hover selection mode is turned on for `tree_view`.
    @inlinable func getHoverSelection() -> Bool {
        let result = gtk_tree_view_get_hover_selection(tree_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns the amount, in pixels, of extra indentation for child levels
    /// in `tree_view`.
    @inlinable func getLevelIndentation() -> Int {
        let result = gtk_tree_view_get_level_indentation(tree_view_ptr)
        let rv = Int(result)
        return rv
    }

    /// Returns the model the `GtkTreeView` is based on.  Returns `nil` if the
    /// model is unset.
    @inlinable func getModel() -> TreeModelRef! {
        let result = gtk_tree_view_get_model(tree_view_ptr)
        let rv = TreeModelRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Queries the number of columns in the given `tree_view`.
    @inlinable func getNColumns() -> Int {
        let result = gtk_tree_view_get_n_columns(tree_view_ptr)
        let rv = Int(result)
        return rv
    }

    /// Finds the path at the point (`x`, `y`), relative to bin_window coordinates.
    /// That is, `x` and `y` are relative to an events coordinates. Widget-relative
    /// coordinates must be converted using
    /// `gtk_tree_view_convert_widget_to_bin_window_coords()`. It is primarily for
    /// things like popup menus. If `path` is non-`nil`, then it will be filled
    /// with the `GtkTreePath` at that point.  This path should be freed with
    /// `gtk_tree_path_free()`.  If `column` is non-`nil`, then it will be filled
    /// with the column at that point.  `cell_x` and `cell_y` return the coordinates
    /// relative to the cell background (i.e. the `background_area` passed to
    /// `gtk_cell_renderer_render()`).  This function is only meaningful if
    /// `tree_view` is realized.  Therefore this function will always return `false`
    /// if `tree_view` is not realized or does not have a model.
    /// 
    /// For converting widget coordinates (eg. the ones you get from
    /// GtkWidget`query-tooltip`), please see
    /// `gtk_tree_view_convert_widget_to_bin_window_coords()`.
    @inlinable func getPathAtPos(x: Int, y: Int, path: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreePath>?>? = nil, column: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreeViewColumn>?>? = nil, cellX: UnsafeMutablePointer<gint>! = nil, cellY: UnsafeMutablePointer<gint>! = nil) -> Bool {
        let result = gtk_tree_view_get_path_at_pos(tree_view_ptr, gint(x), gint(y), path, column, cellX, cellY)
        let rv = ((result) != 0)
        return rv
    }

    /// Retrieves whether the user can reorder the tree via drag-and-drop. See
    /// `gtk_tree_view_set_reorderable()`.
    @inlinable func getReorderable() -> Bool {
        let result = gtk_tree_view_get_reorderable(tree_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns the current row separator function.
    @inlinable func getRowSeparatorFunc() -> GtkTreeViewRowSeparatorFunc! {
        let result = gtk_tree_view_get_row_separator_func(tree_view_ptr)
        let rv = result
        return rv
    }

    /// Returns whether rubber banding is turned on for `tree_view`.  If the
    /// selection mode is `GTK_SELECTION_MULTIPLE`, rubber banding will allow the
    /// user to select multiple rows by dragging the mouse.
    @inlinable func getRubberBanding() -> Bool {
        let result = gtk_tree_view_get_rubber_banding(tree_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the column searched on by the interactive search code.
    @inlinable func getSearchColumn() -> Int {
        let result = gtk_tree_view_get_search_column(tree_view_ptr)
        let rv = Int(result)
        return rv
    }

    /// Returns the `GtkEntry` which is currently in use as interactive search
    /// entry for `tree_view`.  In case the built-in entry is being used, `nil`
    /// will be returned.
    @inlinable func getSearchEntry() -> EditableRef! {
        let result = gtk_tree_view_get_search_entry(tree_view_ptr)
        let rv = EditableRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns the compare function currently in use.
    @inlinable func getSearchEqualFunc() -> GtkTreeViewSearchEqualFunc! {
        let result = gtk_tree_view_get_search_equal_func(tree_view_ptr)
        let rv = result
        return rv
    }

    /// Gets the `GtkTreeSelection` associated with `tree_view`.
    @inlinable func getSelection() -> TreeSelectionRef! {
        let result = gtk_tree_view_get_selection(tree_view_ptr)
        let rv = TreeSelectionRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns whether or not expanders are drawn in `tree_view`.
    @inlinable func getShowExpanders() -> Bool {
        let result = gtk_tree_view_get_show_expanders(tree_view_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns the column of `tree_view`’s model which is being used for
    /// displaying tooltips on `tree_view`’s rows.
    @inlinable func getTooltipColumn() -> Int {
        let result = gtk_tree_view_get_tooltip_column(tree_view_ptr)
        let rv = Int(result)
        return rv
    }

    /// This function is supposed to be used in a `query-tooltip`
    /// signal handler for `GtkTreeView`. The `x`, `y` and `keyboard_tip` values
    /// which are received in the signal handler, should be passed to this
    /// function without modification.
    /// 
    /// The return value indicates whether there is a tree view row at the given
    /// coordinates (`true`) or not (`false`) for mouse tooltips. For keyboard
    /// tooltips the row returned will be the cursor row. When `true`, then any of
    /// `model`, `path` and `iter` which have been provided will be set to point to
    /// that row and the corresponding model. `x` and `y` will always be converted
    /// to be relative to `tree_view`’s bin_window if `keyboard_tooltip` is `false`.
    @inlinable func getTooltipContext(x: Int, y: Int, keyboardTip: Bool, model: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreeModel>?>? = nil, path: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreePath>?>! = nil, iter: TreeIterRef? = nil) -> Bool {
            let result = gtk_tree_view_get_tooltip_context(tree_view_ptr, gint(x), gint(y), gboolean((keyboardTip) ? 1 : 0), model, path, iter?.tree_iter_ptr)
        let rv = ((result) != 0)
            return rv
    }
    /// This function is supposed to be used in a `query-tooltip`
    /// signal handler for `GtkTreeView`. The `x`, `y` and `keyboard_tip` values
    /// which are received in the signal handler, should be passed to this
    /// function without modification.
    /// 
    /// The return value indicates whether there is a tree view row at the given
    /// coordinates (`true`) or not (`false`) for mouse tooltips. For keyboard
    /// tooltips the row returned will be the cursor row. When `true`, then any of
    /// `model`, `path` and `iter` which have been provided will be set to point to
    /// that row and the corresponding model. `x` and `y` will always be converted
    /// to be relative to `tree_view`’s bin_window if `keyboard_tooltip` is `false`.
    @inlinable func getTooltipContext<TreeIterT: TreeIterProtocol>(x: Int, y: Int, keyboardTip: Bool, model: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreeModel>?>? = nil, path: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreePath>?>! = nil, iter: TreeIterT?) -> Bool {
        let result = gtk_tree_view_get_tooltip_context(tree_view_ptr, gint(x), gint(y), gboolean((keyboardTip) ? 1 : 0), model, path, iter?.tree_iter_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Sets `start_path` and `end_path` to be the first and last visible path.
    /// Note that there may be invisible paths in between.
    /// 
    /// The paths should be freed with `gtk_tree_path_free()` after use.
    @inlinable func getVisibleRange(startPath: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreePath>?>! = nil, endPath: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreePath>?>! = nil) -> Bool {
        let result = gtk_tree_view_get_visible_range(tree_view_ptr, startPath, endPath)
        let rv = ((result) != 0)
        return rv
    }

    /// Fills `visible_rect` with the currently-visible region of the
    /// buffer, in tree coordinates. Convert to bin_window coordinates with
    /// `gtk_tree_view_convert_tree_to_bin_window_coords()`.
    /// Tree coordinates start at 0,0 for row 0 of the tree, and cover the entire
    /// scrollable area of the tree.
    @inlinable func get<GdkRectangleT: Gdk.RectangleProtocol>(visibleRect: GdkRectangleT) {
        
        gtk_tree_view_get_visible_rect(tree_view_ptr, visibleRect.rectangle_ptr)
        
    }

    /// This inserts the `column` into the `tree_view` at `position`.  If `position` is
    /// -1, then the column is inserted at the end. If `tree_view` has
    /// “fixed_height” mode enabled, then `column` must have its “sizing” property
    /// set to be GTK_TREE_VIEW_COLUMN_FIXED.
    @inlinable func insert<TreeViewColumnT: TreeViewColumnProtocol>(column: TreeViewColumnT, position: Int) -> Int {
        let result = gtk_tree_view_insert_column(tree_view_ptr, column.tree_view_column_ptr, gint(position))
        let rv = Int(result)
        return rv
    }


    // *** insertColumnWithAttributes() is not available because it has a varargs (...) parameter!


    /// Convenience function that inserts a new column into the `GtkTreeView`
    /// with the given cell renderer and a `GtkTreeCellDataFunc` to set cell renderer
    /// attributes (normally using data from the model). See also
    /// `gtk_tree_view_column_set_cell_data_func()`, `gtk_tree_view_column_pack_start()`.
    /// If `tree_view` has “fixed_height” mode enabled, then the new column will have its
    /// “sizing” property set to be GTK_TREE_VIEW_COLUMN_FIXED.
    @inlinable func insertColumnWithDataFunc<CellRendererT: CellRendererProtocol>(position: Int, title: UnsafePointer<CChar>!, cell: CellRendererT, `func`: GtkTreeCellDataFunc?, data: gpointer? = nil, dnotify: GDestroyNotify?) -> Int {
        let result = gtk_tree_view_insert_column_with_data_func(tree_view_ptr, gint(position), title, cell.cell_renderer_ptr, `func`, data, dnotify)
        let rv = Int(result)
        return rv
    }

    /// Determine whether the point (`x`, `y`) in `tree_view` is blank, that is no
    /// cell content nor an expander arrow is drawn at the location. If so, the
    /// location can be considered as the background. You might wish to take
    /// special action on clicks on the background, such as clearing a current
    /// selection, having a custom context menu or starting rubber banding.
    /// 
    /// The `x` and `y` coordinate that are provided must be relative to bin_window
    /// coordinates.  Widget-relative coordinates must be converted using
    /// `gtk_tree_view_convert_widget_to_bin_window_coords()`.
    /// 
    /// For converting widget coordinates (eg. the ones you get from
    /// GtkWidget`query-tooltip`), please see
    /// `gtk_tree_view_convert_widget_to_bin_window_coords()`.
    /// 
    /// The `path`, `column`, `cell_x` and `cell_y` arguments will be filled in
    /// likewise as for `gtk_tree_view_get_path_at_pos()`.  Please see
    /// `gtk_tree_view_get_path_at_pos()` for more information.
    @inlinable func isBlankAtPos(x: Int, y: Int, path: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreePath>?>? = nil, column: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreeViewColumn>?>? = nil, cellX: UnsafeMutablePointer<gint>! = nil, cellY: UnsafeMutablePointer<gint>! = nil) -> Bool {
        let result = gtk_tree_view_is_blank_at_pos(tree_view_ptr, gint(x), gint(y), path, column, cellX, cellY)
        let rv = ((result) != 0)
        return rv
    }

    /// Calls `func` on all expanded rows.
    @inlinable func mapExpandedRows(`func`: GtkTreeViewMappingFunc?, data: gpointer? = nil) {
        
        gtk_tree_view_map_expanded_rows(tree_view_ptr, `func`, data)
        
    }

    /// Moves `column` to be after to `base_column`.  If `base_column` is `nil`, then
    /// `column` is placed in the first position.
    @inlinable func moveColumnAfter<TreeViewColumnT: TreeViewColumnProtocol>(column: TreeViewColumnT, baseColumn: TreeViewColumnT?) {
        
        gtk_tree_view_move_column_after(tree_view_ptr, column.tree_view_column_ptr, baseColumn?.tree_view_column_ptr)
        
    }

    /// Removes `column` from `tree_view`.
    @inlinable func remove<TreeViewColumnT: TreeViewColumnProtocol>(column: TreeViewColumnT) -> Int {
        let result = gtk_tree_view_remove_column(tree_view_ptr, column.tree_view_column_ptr)
        let rv = Int(result)
        return rv
    }

    /// Activates the cell determined by `path` and `column`.
    @inlinable func rowActivated<TreePathT: TreePathProtocol>(path: TreePathT, column: TreeViewColumnRef? = nil) {
            
        gtk_tree_view_row_activated(tree_view_ptr, path.tree_path_ptr, column?.tree_view_column_ptr)
            
    }
    /// Activates the cell determined by `path` and `column`.
    @inlinable func rowActivated<TreePathT: TreePathProtocol, TreeViewColumnT: TreeViewColumnProtocol>(path: TreePathT, column: TreeViewColumnT?) {
        
        gtk_tree_view_row_activated(tree_view_ptr, path.tree_path_ptr, column?.tree_view_column_ptr)
        
    }

    /// Returns `true` if the node pointed to by `path` is expanded in `tree_view`.
    @inlinable func rowExpanded<TreePathT: TreePathProtocol>(path: TreePathT) -> Bool {
        let result = gtk_tree_view_row_expanded(tree_view_ptr, path.tree_path_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Moves the alignments of `tree_view` to the position specified by `column` and
    /// `path`.  If `column` is `nil`, then no horizontal scrolling occurs.  Likewise,
    /// if `path` is `nil` no vertical scrolling occurs.  At a minimum, one of `column`
    /// or `path` need to be non-`nil`.  `row_align` determines where the row is
    /// placed, and `col_align` determines where `column` is placed.  Both are expected
    /// to be between 0.0 and 1.0. 0.0 means left/top alignment, 1.0 means
    /// right/bottom alignment, 0.5 means center.
    /// 
    /// If `use_align` is `false`, then the alignment arguments are ignored, and the
    /// tree does the minimum amount of work to scroll the cell onto the screen.
    /// This means that the cell will be scrolled to the edge closest to its current
    /// position.  If the cell is currently visible on the screen, nothing is done.
    /// 
    /// This function only works if the model is set, and `path` is a valid row on the
    /// model.  If the model changes before the `tree_view` is realized, the centered
    /// path will be modified to reflect this change.
    @inlinable func scrollToCell(path: TreePathRef? = nil, column: TreeViewColumnRef? = nil, useAlign: Bool, rowAlign: CFloat, colAlign: CFloat) {
            
        gtk_tree_view_scroll_to_cell(tree_view_ptr, path?.tree_path_ptr, column?.tree_view_column_ptr, gboolean((useAlign) ? 1 : 0), rowAlign, colAlign)
            
    }
    /// Moves the alignments of `tree_view` to the position specified by `column` and
    /// `path`.  If `column` is `nil`, then no horizontal scrolling occurs.  Likewise,
    /// if `path` is `nil` no vertical scrolling occurs.  At a minimum, one of `column`
    /// or `path` need to be non-`nil`.  `row_align` determines where the row is
    /// placed, and `col_align` determines where `column` is placed.  Both are expected
    /// to be between 0.0 and 1.0. 0.0 means left/top alignment, 1.0 means
    /// right/bottom alignment, 0.5 means center.
    /// 
    /// If `use_align` is `false`, then the alignment arguments are ignored, and the
    /// tree does the minimum amount of work to scroll the cell onto the screen.
    /// This means that the cell will be scrolled to the edge closest to its current
    /// position.  If the cell is currently visible on the screen, nothing is done.
    /// 
    /// This function only works if the model is set, and `path` is a valid row on the
    /// model.  If the model changes before the `tree_view` is realized, the centered
    /// path will be modified to reflect this change.
    @inlinable func scrollToCell<TreePathT: TreePathProtocol, TreeViewColumnT: TreeViewColumnProtocol>(path: TreePathT?, column: TreeViewColumnT?, useAlign: Bool, rowAlign: CFloat, colAlign: CFloat) {
        
        gtk_tree_view_scroll_to_cell(tree_view_ptr, path?.tree_path_ptr, column?.tree_view_column_ptr, gboolean((useAlign) ? 1 : 0), rowAlign, colAlign)
        
    }

    /// Scrolls the tree view such that the top-left corner of the visible
    /// area is `tree_x`, `tree_y`, where `tree_x` and `tree_y` are specified
    /// in tree coordinates.  The `tree_view` must be realized before
    /// this function is called.  If it isn't, you probably want to be
    /// using `gtk_tree_view_scroll_to_cell()`.
    /// 
    /// If either `tree_x` or `tree_y` are -1, then that direction isn’t scrolled.
    @inlinable func scrollToPoint(treeX: Int, treeY: Int) {
        
        gtk_tree_view_scroll_to_point(tree_view_ptr, gint(treeX), gint(treeY))
        
    }

    /// Cause the `GtkTreeView``row-activated` signal to be emitted
    /// on a single click instead of a double click.
    @inlinable func setActivateOnSingleClick(single: Bool) {
        
        gtk_tree_view_set_activate_on_single_click(tree_view_ptr, gboolean((single) ? 1 : 0))
        
    }

    /// Sets a user function for determining where a column may be dropped when
    /// dragged.  This function is called on every column pair in turn at the
    /// beginning of a column drag to determine where a drop can take place.  The
    /// arguments passed to `func` are: the `tree_view`, the `GtkTreeViewColumn` being
    /// dragged, the two `GtkTreeViewColumn`s determining the drop spot, and
    /// `user_data`.  If either of the `GtkTreeViewColumn` arguments for the drop spot
    /// are `nil`, then they indicate an edge.  If `func` is set to be `nil`, then
    /// `tree_view` reverts to the default behavior of allowing all columns to be
    /// dropped everywhere.
    @inlinable func setColumnDragFunction(`func`: GtkTreeViewColumnDropFunc? = nil, userData: gpointer? = nil, destroy: GDestroyNotify? = nil) {
        
        gtk_tree_view_set_column_drag_function(tree_view_ptr, `func`, userData, destroy)
        
    }

    /// Sets the current keyboard focus to be at `path`, and selects it.  This is
    /// useful when you want to focus the user’s attention on a particular row.  If
    /// `focus_column` is not `nil`, then focus is given to the column specified by
    /// it. Additionally, if `focus_column` is specified, and `start_editing` is
    /// `true`, then editing should be started in the specified cell.
    /// This function is often followed by `gtk_widget_grab_focus` (`tree_view`)
    /// in order to give keyboard focus to the widget.  Please note that editing
    /// can only happen when the widget is realized.
    /// 
    /// If `path` is invalid for `model`, the current cursor (if any) will be unset
    /// and the function will return without failing.
    @inlinable func setCursor<TreePathT: TreePathProtocol>(path: TreePathT, focusColumn: TreeViewColumnRef? = nil, startEditing: Bool) {
            
        gtk_tree_view_set_cursor(tree_view_ptr, path.tree_path_ptr, focusColumn?.tree_view_column_ptr, gboolean((startEditing) ? 1 : 0))
            
    }
    /// Sets the current keyboard focus to be at `path`, and selects it.  This is
    /// useful when you want to focus the user’s attention on a particular row.  If
    /// `focus_column` is not `nil`, then focus is given to the column specified by
    /// it. Additionally, if `focus_column` is specified, and `start_editing` is
    /// `true`, then editing should be started in the specified cell.
    /// This function is often followed by `gtk_widget_grab_focus` (`tree_view`)
    /// in order to give keyboard focus to the widget.  Please note that editing
    /// can only happen when the widget is realized.
    /// 
    /// If `path` is invalid for `model`, the current cursor (if any) will be unset
    /// and the function will return without failing.
    @inlinable func setCursor<TreePathT: TreePathProtocol, TreeViewColumnT: TreeViewColumnProtocol>(path: TreePathT, focusColumn: TreeViewColumnT?, startEditing: Bool) {
        
        gtk_tree_view_set_cursor(tree_view_ptr, path.tree_path_ptr, focusColumn?.tree_view_column_ptr, gboolean((startEditing) ? 1 : 0))
        
    }

    /// Sets the current keyboard focus to be at `path`, and selects it.  This is
    /// useful when you want to focus the user’s attention on a particular row.  If
    /// `focus_column` is not `nil`, then focus is given to the column specified by
    /// it. If `focus_column` and `focus_cell` are not `nil`, and `focus_column`
    /// contains 2 or more editable or activatable cells, then focus is given to
    /// the cell specified by `focus_cell`. Additionally, if `focus_column` is
    /// specified, and `start_editing` is `true`, then editing should be started in
    /// the specified cell.  This function is often followed by
    /// `gtk_widget_grab_focus` (`tree_view`) in order to give keyboard focus to the
    /// widget.  Please note that editing can only happen when the widget is
    /// realized.
    /// 
    /// If `path` is invalid for `model`, the current cursor (if any) will be unset
    /// and the function will return without failing.
    @inlinable func setCursorOnCell<TreePathT: TreePathProtocol>(path: TreePathT, focusColumn: TreeViewColumnRef? = nil, focusCell: CellRendererRef? = nil, startEditing: Bool) {
            
        gtk_tree_view_set_cursor_on_cell(tree_view_ptr, path.tree_path_ptr, focusColumn?.tree_view_column_ptr, focusCell?.cell_renderer_ptr, gboolean((startEditing) ? 1 : 0))
            
    }
    /// Sets the current keyboard focus to be at `path`, and selects it.  This is
    /// useful when you want to focus the user’s attention on a particular row.  If
    /// `focus_column` is not `nil`, then focus is given to the column specified by
    /// it. If `focus_column` and `focus_cell` are not `nil`, and `focus_column`
    /// contains 2 or more editable or activatable cells, then focus is given to
    /// the cell specified by `focus_cell`. Additionally, if `focus_column` is
    /// specified, and `start_editing` is `true`, then editing should be started in
    /// the specified cell.  This function is often followed by
    /// `gtk_widget_grab_focus` (`tree_view`) in order to give keyboard focus to the
    /// widget.  Please note that editing can only happen when the widget is
    /// realized.
    /// 
    /// If `path` is invalid for `model`, the current cursor (if any) will be unset
    /// and the function will return without failing.
    @inlinable func setCursorOnCell<CellRendererT: CellRendererProtocol, TreePathT: TreePathProtocol, TreeViewColumnT: TreeViewColumnProtocol>(path: TreePathT, focusColumn: TreeViewColumnT?, focusCell: CellRendererT?, startEditing: Bool) {
        
        gtk_tree_view_set_cursor_on_cell(tree_view_ptr, path.tree_path_ptr, focusColumn?.tree_view_column_ptr, focusCell?.cell_renderer_ptr, gboolean((startEditing) ? 1 : 0))
        
    }

    /// Sets the row that is highlighted for feedback.
    /// If `path` is `nil`, an existing highlight is removed.
    @inlinable func setDragDestRow(path: TreePathRef? = nil, pos: GtkTreeViewDropPosition) {
            
        gtk_tree_view_set_drag_dest_row(tree_view_ptr, path?.tree_path_ptr, pos)
            
    }
    /// Sets the row that is highlighted for feedback.
    /// If `path` is `nil`, an existing highlight is removed.
    @inlinable func setDragDestRow<TreePathT: TreePathProtocol>(path: TreePathT?, pos: GtkTreeViewDropPosition) {
        
        gtk_tree_view_set_drag_dest_row(tree_view_ptr, path?.tree_path_ptr, pos)
        
    }

    /// If `enable_search` is set, then the user can type in text to search through
    /// the tree interactively (this is sometimes called "typeahead find").
    /// 
    /// Note that even if this is `false`, the user can still initiate a search
    /// using the “start-interactive-search” key binding.
    @inlinable func set(enableSearch: Bool) {
        
        gtk_tree_view_set_enable_search(tree_view_ptr, gboolean((enableSearch) ? 1 : 0))
        
    }

    /// Sets whether to draw lines interconnecting the expanders in `tree_view`.
    /// This does not have any visible effects for lists.
    @inlinable func setEnableTreeLines(enabled: Bool) {
        
        gtk_tree_view_set_enable_tree_lines(tree_view_ptr, gboolean((enabled) ? 1 : 0))
        
    }

    /// Sets the column to draw the expander arrow at. It must be in `tree_view`.
    /// If `column` is `nil`, then the expander arrow is always at the first
    /// visible column.
    /// 
    /// If you do not want expander arrow to appear in your tree, set the
    /// expander column to a hidden column.
    @inlinable func setExpander(column: TreeViewColumnRef? = nil) {
            
        gtk_tree_view_set_expander_column(tree_view_ptr, column?.tree_view_column_ptr)
            
    }
    /// Sets the column to draw the expander arrow at. It must be in `tree_view`.
    /// If `column` is `nil`, then the expander arrow is always at the first
    /// visible column.
    /// 
    /// If you do not want expander arrow to appear in your tree, set the
    /// expander column to a hidden column.
    @inlinable func setExpander<TreeViewColumnT: TreeViewColumnProtocol>(column: TreeViewColumnT?) {
        
        gtk_tree_view_set_expander_column(tree_view_ptr, column?.tree_view_column_ptr)
        
    }

    /// Enables or disables the fixed height mode of `tree_view`.
    /// Fixed height mode speeds up `GtkTreeView` by assuming that all
    /// rows have the same height.
    /// Only enable this option if all rows are the same height and all
    /// columns are of type `GTK_TREE_VIEW_COLUMN_FIXED`.
    @inlinable func setFixedHeightMode(enable: Bool) {
        
        gtk_tree_view_set_fixed_height_mode(tree_view_ptr, gboolean((enable) ? 1 : 0))
        
    }

    /// Sets which grid lines to draw in `tree_view`.
    @inlinable func set(gridLines: GtkTreeViewGridLines) {
        
        gtk_tree_view_set_grid_lines(tree_view_ptr, gridLines)
        
    }

    /// Allow the column title buttons to be clicked.
    @inlinable func setHeadersClickable(setting: Bool) {
        
        gtk_tree_view_set_headers_clickable(tree_view_ptr, gboolean((setting) ? 1 : 0))
        
    }

    /// Sets the visibility state of the headers.
    @inlinable func set(headersVisible: Bool) {
        
        gtk_tree_view_set_headers_visible(tree_view_ptr, gboolean((headersVisible) ? 1 : 0))
        
    }

    /// Enables or disables the hover expansion mode of `tree_view`.
    /// Hover expansion makes rows expand or collapse if the pointer
    /// moves over them.
    @inlinable func setHover(expand: Bool) {
        
        gtk_tree_view_set_hover_expand(tree_view_ptr, gboolean((expand) ? 1 : 0))
        
    }

    /// Enables or disables the hover selection mode of `tree_view`.
    /// Hover selection makes the selected row follow the pointer.
    /// Currently, this works only for the selection modes
    /// `GTK_SELECTION_SINGLE` and `GTK_SELECTION_BROWSE`.
    @inlinable func setHoverSelection(hover: Bool) {
        
        gtk_tree_view_set_hover_selection(tree_view_ptr, gboolean((hover) ? 1 : 0))
        
    }

    /// Sets the amount of extra indentation for child levels to use in `tree_view`
    /// in addition to the default indentation.  The value should be specified in
    /// pixels, a value of 0 disables this feature and in this case only the default
    /// indentation will be used.
    /// This does not have any visible effects for lists.
    @inlinable func setLevel(indentation: Int) {
        
        gtk_tree_view_set_level_indentation(tree_view_ptr, gint(indentation))
        
    }

    /// Sets the model for a `GtkTreeView`.  If the `tree_view` already has a model
    /// set, it will remove it before setting the new model.  If `model` is `nil`,
    /// then it will unset the old model.
    @inlinable func set(model: TreeModelRef? = nil) {
            
        gtk_tree_view_set_model(tree_view_ptr, model?.tree_model_ptr)
            
    }
    /// Sets the model for a `GtkTreeView`.  If the `tree_view` already has a model
    /// set, it will remove it before setting the new model.  If `model` is `nil`,
    /// then it will unset the old model.
    @inlinable func set<TreeModelT: TreeModelProtocol>(model: TreeModelT?) {
        
        gtk_tree_view_set_model(tree_view_ptr, model?.tree_model_ptr)
        
    }

    /// This function is a convenience function to allow you to reorder
    /// models that support the `GtkTreeDragSourceIface` and the
    /// `GtkTreeDragDestIface`.  Both `GtkTreeStore` and `GtkListStore` support
    /// these.  If `reorderable` is `true`, then the user can reorder the
    /// model by dragging and dropping rows. The developer can listen to
    /// these changes by connecting to the model’s `GtkTreeModel`row-inserted``
    /// and `GtkTreeModel`row-deleted`` signals. The reordering is implemented
    /// by setting up the tree view as a drag source and destination.
    /// Therefore, drag and drop can not be used in a reorderable view for any
    /// other purpose.
    /// 
    /// This function does not give you any degree of control over the order -- any
    /// reordering is allowed.  If more control is needed, you should probably
    /// handle drag and drop manually.
    @inlinable func set(reorderable: Bool) {
        
        gtk_tree_view_set_reorderable(tree_view_ptr, gboolean((reorderable) ? 1 : 0))
        
    }

    /// Sets the row separator function, which is used to determine
    /// whether a row should be drawn as a separator. If the row separator
    /// function is `nil`, no separators are drawn. This is the default value.
    @inlinable func setRowSeparatorFunc(`func`: GtkTreeViewRowSeparatorFunc? = nil, data: gpointer? = nil, destroy: GDestroyNotify? = nil) {
        
        gtk_tree_view_set_row_separator_func(tree_view_ptr, `func`, data, destroy)
        
    }

    /// Enables or disables rubber banding in `tree_view`.  If the selection mode
    /// is `GTK_SELECTION_MULTIPLE`, rubber banding will allow the user to select
    /// multiple rows by dragging the mouse.
    @inlinable func setRubberBanding(enable: Bool) {
        
        gtk_tree_view_set_rubber_banding(tree_view_ptr, gboolean((enable) ? 1 : 0))
        
    }

    /// Sets `column` as the column where the interactive search code should
    /// search in for the current model.
    /// 
    /// If the search column is set, users can use the “start-interactive-search”
    /// key binding to bring up search popup. The enable-search property controls
    /// whether simply typing text will also start an interactive search.
    /// 
    /// Note that `column` refers to a column of the current model. The search
    /// column is reset to -1 when the model is changed.
    @inlinable func setSearch(column: Int) {
        
        gtk_tree_view_set_search_column(tree_view_ptr, gint(column))
        
    }

    /// Sets the entry which the interactive search code will use for this
    /// `tree_view`.  This is useful when you want to provide a search entry
    /// in our interface at all time at a fixed position.  Passing `nil` for
    /// `entry` will make the interactive search code use the built-in popup
    /// entry again.
    @inlinable func setSearch(entry: EditableRef? = nil) {
            
        gtk_tree_view_set_search_entry(tree_view_ptr, entry?.editable_ptr)
            
    }
    /// Sets the entry which the interactive search code will use for this
    /// `tree_view`.  This is useful when you want to provide a search entry
    /// in our interface at all time at a fixed position.  Passing `nil` for
    /// `entry` will make the interactive search code use the built-in popup
    /// entry again.
    @inlinable func setSearch<EditableT: EditableProtocol>(entry: EditableT?) {
        
        gtk_tree_view_set_search_entry(tree_view_ptr, entry?.editable_ptr)
        
    }

    /// Sets the compare function for the interactive search capabilities; note
    /// that somewhat like `strcmp()` returning 0 for equality
    /// `GtkTreeView`SearchEqualFunc returns `false` on matches.
    @inlinable func set(searchEqualFunc: GtkTreeViewSearchEqualFunc?, searchUserData: gpointer? = nil, searchDestroy: GDestroyNotify? = nil) {
        
        gtk_tree_view_set_search_equal_func(tree_view_ptr, searchEqualFunc, searchUserData, searchDestroy)
        
    }

    /// Sets whether to draw and enable expanders and indent child rows in
    /// `tree_view`.  When disabled there will be no expanders visible in trees
    /// and there will be no way to expand and collapse rows by default.  Also
    /// note that hiding the expanders will disable the default indentation.  You
    /// can set a custom indentation in this case using
    /// `gtk_tree_view_set_level_indentation()`.
    /// This does not have any visible effects for lists.
    @inlinable func setShowExpanders(enabled: Bool) {
        
        gtk_tree_view_set_show_expanders(tree_view_ptr, gboolean((enabled) ? 1 : 0))
        
    }

    /// Sets the tip area of `tooltip` to the area `path`, `column` and `cell` have
    /// in common.  For example if `path` is `nil` and `column` is set, the tip
    /// area will be set to the full area covered by `column`.  See also
    /// `gtk_tooltip_set_tip_area()`.
    /// 
    /// Note that if `path` is not specified and `cell` is set and part of a column
    /// containing the expander, the tooltip might not show and hide at the correct
    /// position.  In such cases `path` must be set to the current node under the
    /// mouse cursor for this function to operate correctly.
    /// 
    /// See also `gtk_tree_view_set_tooltip_column()` for a simpler alternative.
    @inlinable func setTooltipCell<TooltipT: TooltipProtocol>(tooltip: TooltipT, path: TreePathRef? = nil, column: TreeViewColumnRef? = nil, cell: CellRendererRef? = nil) {
            
        gtk_tree_view_set_tooltip_cell(tree_view_ptr, tooltip.tooltip_ptr, path?.tree_path_ptr, column?.tree_view_column_ptr, cell?.cell_renderer_ptr)
            
    }
    /// Sets the tip area of `tooltip` to the area `path`, `column` and `cell` have
    /// in common.  For example if `path` is `nil` and `column` is set, the tip
    /// area will be set to the full area covered by `column`.  See also
    /// `gtk_tooltip_set_tip_area()`.
    /// 
    /// Note that if `path` is not specified and `cell` is set and part of a column
    /// containing the expander, the tooltip might not show and hide at the correct
    /// position.  In such cases `path` must be set to the current node under the
    /// mouse cursor for this function to operate correctly.
    /// 
    /// See also `gtk_tree_view_set_tooltip_column()` for a simpler alternative.
    @inlinable func setTooltipCell<CellRendererT: CellRendererProtocol, TooltipT: TooltipProtocol, TreePathT: TreePathProtocol, TreeViewColumnT: TreeViewColumnProtocol>(tooltip: TooltipT, path: TreePathT?, column: TreeViewColumnT?, cell: CellRendererT?) {
        
        gtk_tree_view_set_tooltip_cell(tree_view_ptr, tooltip.tooltip_ptr, path?.tree_path_ptr, column?.tree_view_column_ptr, cell?.cell_renderer_ptr)
        
    }

    /// If you only plan to have simple (text-only) tooltips on full rows, you
    /// can use this function to have `GtkTreeView` handle these automatically
    /// for you. `column` should be set to the column in `tree_view`’s model
    /// containing the tooltip texts, or -1 to disable this feature.
    /// 
    /// When enabled, `GtkWidget:has-tooltip` will be set to `true` and
    /// `tree_view` will connect a `GtkWidget`query-tooltip`` signal handler.
    /// 
    /// Note that the signal handler sets the text with `gtk_tooltip_set_markup()`,
    /// so &, &lt;, etc have to be escaped in the text.
    @inlinable func setTooltip(column: Int) {
        
        gtk_tree_view_set_tooltip_column(tree_view_ptr, gint(column))
        
    }

    /// Sets the tip area of `tooltip` to be the area covered by the row at `path`.
    /// See also `gtk_tree_view_set_tooltip_column()` for a simpler alternative.
    /// See also `gtk_tooltip_set_tip_area()`.
    @inlinable func setTooltipRow<TooltipT: TooltipProtocol, TreePathT: TreePathProtocol>(tooltip: TooltipT, path: TreePathT) {
        
        gtk_tree_view_set_tooltip_row(tree_view_ptr, tooltip.tooltip_ptr, path.tree_path_ptr)
        
    }

    /// Undoes the effect of
    /// `gtk_tree_view_enable_model_drag_dest()`. Calling this method sets
    /// `GtkTreeView`:reorderable to `false`.
    @inlinable func unsetRowsDragDest() {
        
        gtk_tree_view_unset_rows_drag_dest(tree_view_ptr)
        
    }

    /// Undoes the effect of
    /// `gtk_tree_view_enable_model_drag_source()`. Calling this method sets
    /// `GtkTreeView`:reorderable to `false`.
    @inlinable func unsetRowsDragSource() {
        
        gtk_tree_view_unset_rows_drag_source(tree_view_ptr)
        
    }
    /// Gets the setting set by `gtk_tree_view_set_activate_on_single_click()`.
    @inlinable var activateOnSingleClick: Bool {
        /// Gets the setting set by `gtk_tree_view_set_activate_on_single_click()`.
        get {
            let result = gtk_tree_view_get_activate_on_single_click(tree_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Cause the `GtkTreeView``row-activated` signal to be emitted
        /// on a single click instead of a double click.
        nonmutating set {
            gtk_tree_view_set_activate_on_single_click(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns a `GList` of all the `GtkTreeViewColumn`s currently in `tree_view`.
    /// The returned list must be freed with g_list_free ().
    @inlinable var columns: GLib.ListRef! {
        /// Returns a `GList` of all the `GtkTreeViewColumn`s currently in `tree_view`.
        /// The returned list must be freed with g_list_free ().
        get {
            let result = gtk_tree_view_get_columns(tree_view_ptr)
        let rv = GLib.ListRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Returns whether or not the tree allows to start interactive searching
    /// by typing in text.
    @inlinable var enableSearch: Bool {
        /// Returns whether or not the tree allows to start interactive searching
        /// by typing in text.
        get {
            let result = gtk_tree_view_get_enable_search(tree_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// If `enable_search` is set, then the user can type in text to search through
        /// the tree interactively (this is sometimes called "typeahead find").
        /// 
        /// Note that even if this is `false`, the user can still initiate a search
        /// using the “start-interactive-search” key binding.
        nonmutating set {
            gtk_tree_view_set_enable_search(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether or not tree lines are drawn in `tree_view`.
    @inlinable var enableTreeLines: Bool {
        /// Returns whether or not tree lines are drawn in `tree_view`.
        get {
            let result = gtk_tree_view_get_enable_tree_lines(tree_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether to draw lines interconnecting the expanders in `tree_view`.
        /// This does not have any visible effects for lists.
        nonmutating set {
            gtk_tree_view_set_enable_tree_lines(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns the column that is the current expander column,
    /// or `nil` if none has been set.
    /// This column has the expander arrow drawn next to it.
    @inlinable var expanderColumn: TreeViewColumnRef! {
        /// Returns the column that is the current expander column,
        /// or `nil` if none has been set.
        /// This column has the expander arrow drawn next to it.
        get {
            let result = gtk_tree_view_get_expander_column(tree_view_ptr)
        let rv = TreeViewColumnRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets the column to draw the expander arrow at. It must be in `tree_view`.
        /// If `column` is `nil`, then the expander arrow is always at the first
        /// visible column.
        /// 
        /// If you do not want expander arrow to appear in your tree, set the
        /// expander column to a hidden column.
        nonmutating set {
            gtk_tree_view_set_expander_column(tree_view_ptr, UnsafeMutablePointer<GtkTreeViewColumn>(newValue?.tree_view_column_ptr))
        }
    }

    /// Returns whether fixed height mode is turned on for `tree_view`.
    @inlinable var fixedHeightMode: Bool {
        /// Returns whether fixed height mode is turned on for `tree_view`.
        get {
            let result = gtk_tree_view_get_fixed_height_mode(tree_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Enables or disables the fixed height mode of `tree_view`.
        /// Fixed height mode speeds up `GtkTreeView` by assuming that all
        /// rows have the same height.
        /// Only enable this option if all rows are the same height and all
        /// columns are of type `GTK_TREE_VIEW_COLUMN_FIXED`.
        nonmutating set {
            gtk_tree_view_set_fixed_height_mode(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns which grid lines are enabled in `tree_view`.
    @inlinable var gridLines: GtkTreeViewGridLines {
        /// Returns which grid lines are enabled in `tree_view`.
        get {
            let result = gtk_tree_view_get_grid_lines(tree_view_ptr)
        let rv = result
            return rv
        }
        /// Sets which grid lines to draw in `tree_view`.
        nonmutating set {
            gtk_tree_view_set_grid_lines(tree_view_ptr, newValue)
        }
    }

    /// Returns whether all header columns are clickable.
    @inlinable var headersClickable: Bool {
        /// Returns whether all header columns are clickable.
        get {
            let result = gtk_tree_view_get_headers_clickable(tree_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Allow the column title buttons to be clicked.
        nonmutating set {
            gtk_tree_view_set_headers_clickable(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns `true` if the headers on the `tree_view` are visible.
    @inlinable var headersVisible: Bool {
        /// Returns `true` if the headers on the `tree_view` are visible.
        get {
            let result = gtk_tree_view_get_headers_visible(tree_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets the visibility state of the headers.
        nonmutating set {
            gtk_tree_view_set_headers_visible(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether hover expansion mode is turned on for `tree_view`.
    @inlinable var hoverExpand: Bool {
        /// Returns whether hover expansion mode is turned on for `tree_view`.
        get {
            let result = gtk_tree_view_get_hover_expand(tree_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Enables or disables the hover expansion mode of `tree_view`.
        /// Hover expansion makes rows expand or collapse if the pointer
        /// moves over them.
        nonmutating set {
            gtk_tree_view_set_hover_expand(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether hover selection mode is turned on for `tree_view`.
    @inlinable var hoverSelection: Bool {
        /// Returns whether hover selection mode is turned on for `tree_view`.
        get {
            let result = gtk_tree_view_get_hover_selection(tree_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Enables or disables the hover selection mode of `tree_view`.
        /// Hover selection makes the selected row follow the pointer.
        /// Currently, this works only for the selection modes
        /// `GTK_SELECTION_SINGLE` and `GTK_SELECTION_BROWSE`.
        nonmutating set {
            gtk_tree_view_set_hover_selection(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether a rubber banding operation is currently being done
    /// in `tree_view`.
    @inlinable var isRubberBandingActive: Bool {
        /// Returns whether a rubber banding operation is currently being done
        /// in `tree_view`.
        get {
            let result = gtk_tree_view_is_rubber_banding_active(tree_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
    }

    /// Returns the amount, in pixels, of extra indentation for child levels
    /// in `tree_view`.
    @inlinable var levelIndentation: Int {
        /// Returns the amount, in pixels, of extra indentation for child levels
        /// in `tree_view`.
        get {
            let result = gtk_tree_view_get_level_indentation(tree_view_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the amount of extra indentation for child levels to use in `tree_view`
        /// in addition to the default indentation.  The value should be specified in
        /// pixels, a value of 0 disables this feature and in this case only the default
        /// indentation will be used.
        /// This does not have any visible effects for lists.
        nonmutating set {
            gtk_tree_view_set_level_indentation(tree_view_ptr, gint(newValue))
        }
    }

    @inlinable var model: TreeModelRef! {
        /// Returns the model the `GtkTreeView` is based on.  Returns `nil` if the
        /// model is unset.
        get {
            let result = gtk_tree_view_get_model(tree_view_ptr)
        let rv = TreeModelRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets the model for a `GtkTreeView`.  If the `tree_view` already has a model
        /// set, it will remove it before setting the new model.  If `model` is `nil`,
        /// then it will unset the old model.
        nonmutating set {
            gtk_tree_view_set_model(tree_view_ptr, UnsafeMutablePointer<GtkTreeModel>(newValue?.tree_model_ptr))
        }
    }

    /// Queries the number of columns in the given `tree_view`.
    @inlinable var nColumns: Int {
        /// Queries the number of columns in the given `tree_view`.
        get {
            let result = gtk_tree_view_get_n_columns(tree_view_ptr)
        let rv = Int(result)
            return rv
        }
    }

    @inlinable var reorderable: Bool {
        /// Retrieves whether the user can reorder the tree via drag-and-drop. See
        /// `gtk_tree_view_set_reorderable()`.
        get {
            let result = gtk_tree_view_get_reorderable(tree_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// This function is a convenience function to allow you to reorder
        /// models that support the `GtkTreeDragSourceIface` and the
        /// `GtkTreeDragDestIface`.  Both `GtkTreeStore` and `GtkListStore` support
        /// these.  If `reorderable` is `true`, then the user can reorder the
        /// model by dragging and dropping rows. The developer can listen to
        /// these changes by connecting to the model’s `GtkTreeModel`row-inserted``
        /// and `GtkTreeModel`row-deleted`` signals. The reordering is implemented
        /// by setting up the tree view as a drag source and destination.
        /// Therefore, drag and drop can not be used in a reorderable view for any
        /// other purpose.
        /// 
        /// This function does not give you any degree of control over the order -- any
        /// reordering is allowed.  If more control is needed, you should probably
        /// handle drag and drop manually.
        nonmutating set {
            gtk_tree_view_set_reorderable(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns the current row separator function.
    @inlinable var rowSeparatorFunc: GtkTreeViewRowSeparatorFunc! {
        /// Returns the current row separator function.
        get {
            let result = gtk_tree_view_get_row_separator_func(tree_view_ptr)
        let rv = result
            return rv
        }
    }

    /// Returns whether rubber banding is turned on for `tree_view`.  If the
    /// selection mode is `GTK_SELECTION_MULTIPLE`, rubber banding will allow the
    /// user to select multiple rows by dragging the mouse.
    @inlinable var rubberBanding: Bool {
        /// Returns whether rubber banding is turned on for `tree_view`.  If the
        /// selection mode is `GTK_SELECTION_MULTIPLE`, rubber banding will allow the
        /// user to select multiple rows by dragging the mouse.
        get {
            let result = gtk_tree_view_get_rubber_banding(tree_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Enables or disables rubber banding in `tree_view`.  If the selection mode
        /// is `GTK_SELECTION_MULTIPLE`, rubber banding will allow the user to select
        /// multiple rows by dragging the mouse.
        nonmutating set {
            gtk_tree_view_set_rubber_banding(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the column searched on by the interactive search code.
    @inlinable var searchColumn: Int {
        /// Gets the column searched on by the interactive search code.
        get {
            let result = gtk_tree_view_get_search_column(tree_view_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets `column` as the column where the interactive search code should
        /// search in for the current model.
        /// 
        /// If the search column is set, users can use the “start-interactive-search”
        /// key binding to bring up search popup. The enable-search property controls
        /// whether simply typing text will also start an interactive search.
        /// 
        /// Note that `column` refers to a column of the current model. The search
        /// column is reset to -1 when the model is changed.
        nonmutating set {
            gtk_tree_view_set_search_column(tree_view_ptr, gint(newValue))
        }
    }

    /// Returns the `GtkEntry` which is currently in use as interactive search
    /// entry for `tree_view`.  In case the built-in entry is being used, `nil`
    /// will be returned.
    @inlinable var searchEntry: EditableRef! {
        /// Returns the `GtkEntry` which is currently in use as interactive search
        /// entry for `tree_view`.  In case the built-in entry is being used, `nil`
        /// will be returned.
        get {
            let result = gtk_tree_view_get_search_entry(tree_view_ptr)
        let rv = EditableRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets the entry which the interactive search code will use for this
        /// `tree_view`.  This is useful when you want to provide a search entry
        /// in our interface at all time at a fixed position.  Passing `nil` for
        /// `entry` will make the interactive search code use the built-in popup
        /// entry again.
        nonmutating set {
            gtk_tree_view_set_search_entry(tree_view_ptr, UnsafeMutablePointer<GtkEditable>(newValue?.editable_ptr))
        }
    }

    /// Returns the compare function currently in use.
    @inlinable var searchEqualFunc: GtkTreeViewSearchEqualFunc! {
        /// Returns the compare function currently in use.
        get {
            let result = gtk_tree_view_get_search_equal_func(tree_view_ptr)
        let rv = result
            return rv
        }
    }

    /// Gets the `GtkTreeSelection` associated with `tree_view`.
    @inlinable var selection: TreeSelectionRef! {
        /// Gets the `GtkTreeSelection` associated with `tree_view`.
        get {
            let result = gtk_tree_view_get_selection(tree_view_ptr)
        let rv = TreeSelectionRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    /// Returns whether or not expanders are drawn in `tree_view`.
    @inlinable var showExpanders: Bool {
        /// Returns whether or not expanders are drawn in `tree_view`.
        get {
            let result = gtk_tree_view_get_show_expanders(tree_view_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets whether to draw and enable expanders and indent child rows in
        /// `tree_view`.  When disabled there will be no expanders visible in trees
        /// and there will be no way to expand and collapse rows by default.  Also
        /// note that hiding the expanders will disable the default indentation.  You
        /// can set a custom indentation in this case using
        /// `gtk_tree_view_set_level_indentation()`.
        /// This does not have any visible effects for lists.
        nonmutating set {
            gtk_tree_view_set_show_expanders(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns the column of `tree_view`’s model which is being used for
    /// displaying tooltips on `tree_view`’s rows.
    @inlinable var tooltipColumn: Int {
        /// Returns the column of `tree_view`’s model which is being used for
        /// displaying tooltips on `tree_view`’s rows.
        get {
            let result = gtk_tree_view_get_tooltip_column(tree_view_ptr)
        let rv = Int(result)
            return rv
        }
        /// If you only plan to have simple (text-only) tooltips on full rows, you
        /// can use this function to have `GtkTreeView` handle these automatically
        /// for you. `column` should be set to the column in `tree_view`’s model
        /// containing the tooltip texts, or -1 to disable this feature.
        /// 
        /// When enabled, `GtkWidget:has-tooltip` will be set to `true` and
        /// `tree_view` will connect a `GtkWidget`query-tooltip`` signal handler.
        /// 
        /// Note that the signal handler sets the text with `gtk_tooltip_set_markup()`,
        /// so &, &lt;, etc have to be escaped in the text.
        nonmutating set {
            gtk_tree_view_set_tooltip_column(tree_view_ptr, gint(newValue))
        }
    }

    @inlinable var parentInstance: GtkWidget {
        get {
            let rv = tree_view_ptr.pointee.parent_instance
    return rv
        }
    }

}



// MARK: - TreeViewColumn Class

/// A visible column in a [class`Gtk.TreeView`] widget
/// 
/// The `GtkTreeViewColumn` object represents a visible column in a `GtkTreeView` widget.
/// It allows to set properties of the column header, and functions as a holding pen
/// for the cell renderers which determine how the data in the column is displayed.
/// 
/// Please refer to the [tree widget conceptual overview](section-tree-widget.html)
/// for an overview of all the objects and data types related to the tree widget and
/// how they work together, and to the [class`Gtk.TreeView`] documentation for specifics
/// about the CSS node structure for treeviews and their headers.
///
/// The `TreeViewColumnProtocol` protocol exposes the methods and properties of an underlying `GtkTreeViewColumn` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeViewColumn`.
/// Alternatively, use `TreeViewColumnRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeViewColumnProtocol: GLibObject.InitiallyUnownedProtocol, BuildableProtocol, CellLayoutProtocol {
        /// Untyped pointer to the underlying `GtkTreeViewColumn` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeViewColumn` instance.
    var tree_view_column_ptr: UnsafeMutablePointer<GtkTreeViewColumn>! { get }

    /// Required Initialiser for types conforming to `TreeViewColumnProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A visible column in a [class`Gtk.TreeView`] widget
/// 
/// The `GtkTreeViewColumn` object represents a visible column in a `GtkTreeView` widget.
/// It allows to set properties of the column header, and functions as a holding pen
/// for the cell renderers which determine how the data in the column is displayed.
/// 
/// Please refer to the [tree widget conceptual overview](section-tree-widget.html)
/// for an overview of all the objects and data types related to the tree widget and
/// how they work together, and to the [class`Gtk.TreeView`] documentation for specifics
/// about the CSS node structure for treeviews and their headers.
///
/// The `TreeViewColumnRef` type acts as a lightweight Swift reference to an underlying `GtkTreeViewColumn` instance.
/// It exposes methods that can operate on this data type through `TreeViewColumnProtocol` conformance.
/// Use `TreeViewColumnRef` only as an `unowned` reference to an existing `GtkTreeViewColumn` instance.
///
public struct TreeViewColumnRef: TreeViewColumnProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTreeViewColumn` instance.
    /// For type-safe access, use the generated, typed pointer `tree_view_column_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeViewColumnRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeViewColumn>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeViewColumn>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeViewColumn>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeViewColumn>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeViewColumnProtocol`
    @inlinable init<T: TreeViewColumnProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TreeViewColumnProtocol>(_ other: T) -> TreeViewColumnRef { TreeViewColumnRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkTreeViewColumn`.
    @inlinable init() {
            let result = gtk_tree_view_column_new()
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkTreeViewColumn` using `area` to render its cells.
    @inlinable init<CellAreaT: CellAreaProtocol>(area: CellAreaT) {
            let result = gtk_tree_view_column_new_with_area(area.cell_area_ptr)
        let rv = result
            ptr = UnsafeMutableRawPointer(rv)
    }


    // *** newWithAttributes() is not available because it has a varargs (...) parameter!

    /// Creates a new `GtkTreeViewColumn` using `area` to render its cells.
    @inlinable static func newWith<CellAreaT: CellAreaProtocol>(area: CellAreaT) -> TreeViewColumnRef! {
            let result = gtk_tree_view_column_new_with_area(area.cell_area_ptr)
        guard let rv = TreeViewColumnRef(gconstpointer: gconstpointer(result)) else { return nil }
        return rv
    }


    // *** newWithAttributes() is not available because it has a varargs (...) parameter!

}

/// A visible column in a [class`Gtk.TreeView`] widget
/// 
/// The `GtkTreeViewColumn` object represents a visible column in a `GtkTreeView` widget.
/// It allows to set properties of the column header, and functions as a holding pen
/// for the cell renderers which determine how the data in the column is displayed.
/// 
/// Please refer to the [tree widget conceptual overview](section-tree-widget.html)
/// for an overview of all the objects and data types related to the tree widget and
/// how they work together, and to the [class`Gtk.TreeView`] documentation for specifics
/// about the CSS node structure for treeviews and their headers.
///
/// The `TreeViewColumn` type acts as a reference-counted owner of an underlying `GtkTreeViewColumn` instance.
/// It provides the methods that can operate on this data type through `TreeViewColumnProtocol` conformance.
/// Use `TreeViewColumn` as a strong reference or owner of a `GtkTreeViewColumn` instance.
///
open class TreeViewColumn: GLibObject.InitiallyUnowned, TreeViewColumnProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeViewColumn>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeViewColumn>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeViewColumn` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeViewColumn>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeViewColumn>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTreeViewColumn`.
    /// i.e., ownership is transferred to the `TreeViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeViewColumn>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TreeViewColumnProtocol`
    /// Will retain `GtkTreeViewColumn`.
    /// - Parameter other: an instance of a related type that implements `TreeViewColumnProtocol`
    @inlinable public init<T: TreeViewColumnProtocol>(treeViewColumn other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkTreeViewColumn`.
    @inlinable public init() {
            let result = gtk_tree_view_column_new()
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkTreeViewColumn` using `area` to render its cells.
    @inlinable public init<CellAreaT: CellAreaProtocol>(area: CellAreaT) {
            let result = gtk_tree_view_column_new_with_area(area.cell_area_ptr)
        let rv = result
            super.init(gpointer: gpointer(rv))
    if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


    // *** newWithAttributes() is not available because it has a varargs (...) parameter!


    /// Creates a new `GtkTreeViewColumn` using `area` to render its cells.
    @inlinable public static func newWith<CellAreaT: CellAreaProtocol>(area: CellAreaT) -> TreeViewColumn! {
            let result = gtk_tree_view_column_new_with_area(area.cell_area_ptr)
        guard let rv = TreeViewColumn(gconstpointer: gconstpointer(result)) else { return nil }
            if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
return rv
    }


    // *** newWithAttributes() is not available because it has a varargs (...) parameter!


}

public enum TreeViewColumnPropertyName: String, PropertyNameProtocol {
    case alignment = "alignment"
    /// The `GtkCellArea` used to layout cell renderers for this column.
    /// 
    /// If no area is specified when creating the tree view column with `gtk_tree_view_column_new_with_area()`
    /// a horizontally oriented `GtkCellAreaBox` will be used.
    case cellArea = "cell-area"
    case clickable = "clickable"
    case expand = "expand"
    case fixedWidth = "fixed-width"
    case maxWidth = "max-width"
    case minWidth = "min-width"
    case reorderable = "reorderable"
    case resizable = "resizable"
    case sizing = "sizing"
    /// Logical sort column ID this column sorts on when selected for sorting. Setting the sort column ID makes the column header
    /// clickable. Set to -1 to make the column unsortable.
    case sortColumnId = "sort-column-id"
    case sortIndicator = "sort-indicator"
    case sortOrder = "sort-order"
    case spacing = "spacing"
    case title = "title"
    case visible = "visible"
    case widget = "widget"
    case width = "width"
    case xOffset = "x-offset"
}

public extension TreeViewColumnProtocol {
    /// Bind a `TreeViewColumnPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeViewColumnPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TreeViewColumn property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TreeViewColumnPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TreeViewColumn property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TreeViewColumnPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TreeViewColumnSignalName: String, SignalNameProtocol {
    /// Emitted when the column's header has been clicked.
    case clicked = "clicked"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyAlignment = "notify::alignment"
    /// The `GtkCellArea` used to layout cell renderers for this column.
    /// 
    /// If no area is specified when creating the tree view column with `gtk_tree_view_column_new_with_area()`
    /// a horizontally oriented `GtkCellAreaBox` will be used.
    case notifyCellArea = "notify::cell-area"
    case notifyClickable = "notify::clickable"
    case notifyExpand = "notify::expand"
    case notifyFixedWidth = "notify::fixed-width"
    case notifyMaxWidth = "notify::max-width"
    case notifyMinWidth = "notify::min-width"
    case notifyReorderable = "notify::reorderable"
    case notifyResizable = "notify::resizable"
    case notifySizing = "notify::sizing"
    /// Logical sort column ID this column sorts on when selected for sorting. Setting the sort column ID makes the column header
    /// clickable. Set to -1 to make the column unsortable.
    case notifySortColumnId = "notify::sort-column-id"
    case notifySortIndicator = "notify::sort-indicator"
    case notifySortOrder = "notify::sort-order"
    case notifySpacing = "notify::spacing"
    case notifyTitle = "notify::title"
    case notifyVisible = "notify::visible"
    case notifyWidget = "notify::widget"
    case notifyWidth = "notify::width"
    case notifyXOffset = "notify::x-offset"
}

// MARK: TreeViewColumn signals
public extension TreeViewColumnProtocol {
    /// Connect a Swift signal handler to the given, typed `TreeViewColumnSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TreeViewColumnSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `TreeViewColumnSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TreeViewColumnSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when the column's header has been clicked.
    /// - Note: This represents the underlying `clicked` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `clicked` signal is emitted
    @discardableResult @inlinable func onClicked(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewColumnRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewColumnRef(raw: unownedSelf)))
            return output
        }
        return connect(
            signal: .clicked,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `clicked` signal for using the `connect(signal:)` methods
    static var clickedSignal: TreeViewColumnSignalName { .clicked }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::alignment` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAlignment` signal is emitted
    @discardableResult @inlinable func onNotifyAlignment(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewColumnRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewColumnRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyAlignment,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::alignment` signal for using the `connect(signal:)` methods
    static var notifyAlignmentSignal: TreeViewColumnSignalName { .notifyAlignment }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::cell-area` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyCellArea` signal is emitted
    @discardableResult @inlinable func onNotifyCellArea(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewColumnRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewColumnRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyCellArea,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::cell-area` signal for using the `connect(signal:)` methods
    static var notifyCellAreaSignal: TreeViewColumnSignalName { .notifyCellArea }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::clickable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyClickable` signal is emitted
    @discardableResult @inlinable func onNotifyClickable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewColumnRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewColumnRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyClickable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::clickable` signal for using the `connect(signal:)` methods
    static var notifyClickableSignal: TreeViewColumnSignalName { .notifyClickable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::expand` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyExpand` signal is emitted
    @discardableResult @inlinable func onNotifyExpand(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewColumnRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewColumnRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyExpand,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::expand` signal for using the `connect(signal:)` methods
    static var notifyExpandSignal: TreeViewColumnSignalName { .notifyExpand }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::fixed-width` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFixedWidth` signal is emitted
    @discardableResult @inlinable func onNotifyFixedWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewColumnRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewColumnRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyFixedWidth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::fixed-width` signal for using the `connect(signal:)` methods
    static var notifyFixedWidthSignal: TreeViewColumnSignalName { .notifyFixedWidth }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::max-width` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMaxWidth` signal is emitted
    @discardableResult @inlinable func onNotifyMaxWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewColumnRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewColumnRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyMaxWidth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::max-width` signal for using the `connect(signal:)` methods
    static var notifyMaxWidthSignal: TreeViewColumnSignalName { .notifyMaxWidth }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::min-width` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMinWidth` signal is emitted
    @discardableResult @inlinable func onNotifyMinWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewColumnRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewColumnRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyMinWidth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::min-width` signal for using the `connect(signal:)` methods
    static var notifyMinWidthSignal: TreeViewColumnSignalName { .notifyMinWidth }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::reorderable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyReorderable` signal is emitted
    @discardableResult @inlinable func onNotifyReorderable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewColumnRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewColumnRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyReorderable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::reorderable` signal for using the `connect(signal:)` methods
    static var notifyReorderableSignal: TreeViewColumnSignalName { .notifyReorderable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::resizable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyResizable` signal is emitted
    @discardableResult @inlinable func onNotifyResizable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewColumnRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewColumnRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyResizable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::resizable` signal for using the `connect(signal:)` methods
    static var notifyResizableSignal: TreeViewColumnSignalName { .notifyResizable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::sizing` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySizing` signal is emitted
    @discardableResult @inlinable func onNotifySizing(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewColumnRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewColumnRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifySizing,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::sizing` signal for using the `connect(signal:)` methods
    static var notifySizingSignal: TreeViewColumnSignalName { .notifySizing }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::sort-column-id` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySortColumnId` signal is emitted
    @discardableResult @inlinable func onNotifySortColumnId(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewColumnRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewColumnRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifySortColumnId,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::sort-column-id` signal for using the `connect(signal:)` methods
    static var notifySortColumnIdSignal: TreeViewColumnSignalName { .notifySortColumnId }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::sort-indicator` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySortIndicator` signal is emitted
    @discardableResult @inlinable func onNotifySortIndicator(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewColumnRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewColumnRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifySortIndicator,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::sort-indicator` signal for using the `connect(signal:)` methods
    static var notifySortIndicatorSignal: TreeViewColumnSignalName { .notifySortIndicator }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::sort-order` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySortOrder` signal is emitted
    @discardableResult @inlinable func onNotifySortOrder(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewColumnRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewColumnRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifySortOrder,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::sort-order` signal for using the `connect(signal:)` methods
    static var notifySortOrderSignal: TreeViewColumnSignalName { .notifySortOrder }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::spacing` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySpacing` signal is emitted
    @discardableResult @inlinable func onNotifySpacing(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewColumnRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewColumnRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifySpacing,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::spacing` signal for using the `connect(signal:)` methods
    static var notifySpacingSignal: TreeViewColumnSignalName { .notifySpacing }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::title` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTitle` signal is emitted
    @discardableResult @inlinable func onNotifyTitle(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewColumnRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewColumnRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyTitle,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::title` signal for using the `connect(signal:)` methods
    static var notifyTitleSignal: TreeViewColumnSignalName { .notifyTitle }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::visible` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyVisible` signal is emitted
    @discardableResult @inlinable func onNotifyVisible(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewColumnRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewColumnRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyVisible,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::visible` signal for using the `connect(signal:)` methods
    static var notifyVisibleSignal: TreeViewColumnSignalName { .notifyVisible }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::widget` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWidget` signal is emitted
    @discardableResult @inlinable func onNotifyWidget(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewColumnRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewColumnRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyWidget,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::widget` signal for using the `connect(signal:)` methods
    static var notifyWidgetSignal: TreeViewColumnSignalName { .notifyWidget }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::width` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWidth` signal is emitted
    @discardableResult @inlinable func onNotifyWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewColumnRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewColumnRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyWidth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::width` signal for using the `connect(signal:)` methods
    static var notifyWidthSignal: TreeViewColumnSignalName { .notifyWidth }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::x-offset` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyXOffset` signal is emitted
    @discardableResult @inlinable func onNotifyXOffset(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: GLibObject.ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<(TreeViewColumnRef, GLibObject.ParamSpecRef), Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call((TreeViewColumnRef(raw: unownedSelf), GLibObject.ParamSpecRef(raw: arg1)))
            return output
        }
        return connect(
            signal: .notifyXOffset,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::x-offset` signal for using the `connect(signal:)` methods
    static var notifyXOffsetSignal: TreeViewColumnSignalName { .notifyXOffset }
    
}

// MARK: TreeViewColumn Class: TreeViewColumnProtocol extension (methods and fields)
public extension TreeViewColumnProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeViewColumn` instance.
    @inlinable var tree_view_column_ptr: UnsafeMutablePointer<GtkTreeViewColumn>! { return ptr?.assumingMemoryBound(to: GtkTreeViewColumn.self) }

    /// Adds an attribute mapping to the list in `tree_column`.
    /// 
    /// The `column` is the
    /// column of the model to get a value from, and the `attribute` is the
    /// parameter on `cell_renderer` to be set from the value. So for example
    /// if column 2 of the model contains strings, you could have the
    /// “text” attribute of a `GtkCellRendererText` get its values from
    /// column 2.
    @inlinable func addAttribute<CellRendererT: CellRendererProtocol>(cellRenderer: CellRendererT, attribute: UnsafePointer<CChar>!, column: Int) {
        
        gtk_tree_view_column_add_attribute(tree_view_column_ptr, cellRenderer.cell_renderer_ptr, attribute, gint(column))
        
    }

    /// Obtains the horizontal position and size of a cell in a column.
    /// 
    /// If the  cell is not found in the column, `start_pos` and `width`
    /// are not changed and `false` is returned.
    @inlinable func cellGetPosition<CellRendererT: CellRendererProtocol>(cellRenderer: CellRendererT, xOffset: UnsafeMutablePointer<gint>! = nil, width: UnsafeMutablePointer<gint>! = nil) -> Bool {
        let result = gtk_tree_view_column_cell_get_position(tree_view_column_ptr, cellRenderer.cell_renderer_ptr, xOffset, width)
        let rv = ((result) != 0)
        return rv
    }

    /// Obtains the width and height needed to render the column.  This is used
    /// primarily by the `GtkTreeView`.
    @inlinable func cellGetSize(xOffset: UnsafeMutablePointer<gint>! = nil, yOffset: UnsafeMutablePointer<gint>! = nil, width: UnsafeMutablePointer<gint>! = nil, height: UnsafeMutablePointer<gint>! = nil) {
        
        gtk_tree_view_column_cell_get_size(tree_view_column_ptr, xOffset, yOffset, width, height)
        
    }

    /// Returns `true` if any of the cells packed into the `tree_column` are visible.
    /// For this to be meaningful, you must first initialize the cells with
    /// `gtk_tree_view_column_cell_set_cell_data()`
    @inlinable func cellIsVisible() -> Bool {
        let result = gtk_tree_view_column_cell_is_visible(tree_view_column_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Sets the cell renderer based on the `tree_model` and `iter`.  That is, for
    /// every attribute mapping in `tree_column`, it will get a value from the set
    /// column on the `iter`, and use that value to set the attribute on the cell
    /// renderer.  This is used primarily by the `GtkTreeView`.
    @inlinable func cellSetCellData<TreeIterT: TreeIterProtocol, TreeModelT: TreeModelProtocol>(treeModel: TreeModelT, iter: TreeIterT, isExpander: Bool, isExpanded: Bool) {
        
        gtk_tree_view_column_cell_set_cell_data(tree_view_column_ptr, treeModel.tree_model_ptr, iter.tree_iter_ptr, gboolean((isExpander) ? 1 : 0), gboolean((isExpanded) ? 1 : 0))
        
    }

    /// Unsets all the mappings on all renderers on the `tree_column`.
    @inlinable func clear() {
        
        gtk_tree_view_column_clear(tree_view_column_ptr)
        
    }

    /// Clears all existing attributes previously set with
    /// `gtk_tree_view_column_set_attributes()`.
    @inlinable func clearAttributes<CellRendererT: CellRendererProtocol>(cellRenderer: CellRendererT) {
        
        gtk_tree_view_column_clear_attributes(tree_view_column_ptr, cellRenderer.cell_renderer_ptr)
        
    }

    /// Emits the “clicked” signal on the column.  This function will only work if
    /// `tree_column` is clickable.
    @inlinable func clicked() {
        
        gtk_tree_view_column_clicked(tree_view_column_ptr)
        
    }

    /// Sets the current keyboard focus to be at `cell`, if the column contains
    /// 2 or more editable and activatable cells.
    @inlinable func focus<CellRendererT: CellRendererProtocol>(cell: CellRendererT) {
        
        gtk_tree_view_column_focus_cell(tree_view_column_ptr, cell.cell_renderer_ptr)
        
    }

    /// Returns the current x alignment of `tree_column`.  This value can range
    /// between 0.0 and 1.0.
    @inlinable func getAlignment() -> CFloat {
        let result = gtk_tree_view_column_get_alignment(tree_view_column_ptr)
        let rv = result
        return rv
    }

    /// Returns the button used in the treeview column header
    @inlinable func getButton() -> WidgetRef! {
        let result = gtk_tree_view_column_get_button(tree_view_column_ptr)
        let rv = WidgetRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns `true` if the user can click on the header for the column.
    @inlinable func getClickable() -> Bool {
        let result = gtk_tree_view_column_get_clickable(tree_view_column_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns `true` if the column expands to fill available space.
    @inlinable func getExpand() -> Bool {
        let result = gtk_tree_view_column_get_expand(tree_view_column_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the fixed width of the column.  This may not be the actual displayed
    /// width of the column; for that, use `gtk_tree_view_column_get_width()`.
    @inlinable func getFixedWidth() -> Int {
        let result = gtk_tree_view_column_get_fixed_width(tree_view_column_ptr)
        let rv = Int(result)
        return rv
    }

    /// Returns the maximum width in pixels of the `tree_column`, or -1 if no maximum
    /// width is set.
    @inlinable func getMaxWidth() -> Int {
        let result = gtk_tree_view_column_get_max_width(tree_view_column_ptr)
        let rv = Int(result)
        return rv
    }

    /// Returns the minimum width in pixels of the `tree_column`, or -1 if no minimum
    /// width is set.
    @inlinable func getMinWidth() -> Int {
        let result = gtk_tree_view_column_get_min_width(tree_view_column_ptr)
        let rv = Int(result)
        return rv
    }

    /// Returns `true` if the `tree_column` can be reordered by the user.
    @inlinable func getReorderable() -> Bool {
        let result = gtk_tree_view_column_get_reorderable(tree_view_column_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns `true` if the `tree_column` can be resized by the end user.
    @inlinable func getResizable() -> Bool {
        let result = gtk_tree_view_column_get_resizable(tree_view_column_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns the current type of `tree_column`.
    @inlinable func getSizing() -> GtkTreeViewColumnSizing {
        let result = gtk_tree_view_column_get_sizing(tree_view_column_ptr)
        let rv = result
        return rv
    }

    /// Gets the logical `sort_column_id` that the model sorts on
    /// when this column is selected for sorting.
    /// 
    /// See [method`Gtk.TreeViewColumn.set_sort_column_id`].
    @inlinable func getSortColumnId() -> Int {
        let result = gtk_tree_view_column_get_sort_column_id(tree_view_column_ptr)
        let rv = Int(result)
        return rv
    }

    /// Gets the value set by `gtk_tree_view_column_set_sort_indicator()`.
    @inlinable func getSortIndicator() -> Bool {
        let result = gtk_tree_view_column_get_sort_indicator(tree_view_column_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Gets the value set by `gtk_tree_view_column_set_sort_order()`.
    @inlinable func getSortOrder() -> GtkSortType {
        let result = gtk_tree_view_column_get_sort_order(tree_view_column_ptr)
        let rv = result
        return rv
    }

    /// Returns the spacing of `tree_column`.
    @inlinable func getSpacing() -> Int {
        let result = gtk_tree_view_column_get_spacing(tree_view_column_ptr)
        let rv = Int(result)
        return rv
    }

    /// Returns the title of the widget.
    @inlinable func getTitle() -> String! {
        let result = gtk_tree_view_column_get_title(tree_view_column_ptr)
        let rv = result.map({ String(cString: $0) })
        return rv
    }

    /// Returns the `GtkTreeView` wherein `tree_column` has been inserted.
    /// If `column` is currently not inserted in any tree view, `nil` is
    /// returned.
    @inlinable func getTreeView() -> WidgetRef! {
        let result = gtk_tree_view_column_get_tree_view(tree_view_column_ptr)
        let rv = WidgetRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns `true` if `tree_column` is visible.
    @inlinable func getVisible() -> Bool {
        let result = gtk_tree_view_column_get_visible(tree_view_column_ptr)
        let rv = ((result) != 0)
        return rv
    }

    /// Returns the `GtkWidget` in the button on the column header.
    /// 
    /// If a custom widget has not been set then `nil` is returned.
    @inlinable func getWidget() -> WidgetRef! {
        let result = gtk_tree_view_column_get_widget(tree_view_column_ptr)
        let rv = WidgetRef(gconstpointer: gconstpointer(result))
        return rv
    }

    /// Returns the current size of `tree_column` in pixels.
    @inlinable func getWidth() -> Int {
        let result = gtk_tree_view_column_get_width(tree_view_column_ptr)
        let rv = Int(result)
        return rv
    }

    /// Returns the current X offset of `tree_column` in pixels.
    @inlinable func getXOffset() -> Int {
        let result = gtk_tree_view_column_get_x_offset(tree_view_column_ptr)
        let rv = Int(result)
        return rv
    }

    /// Adds the `cell` to end of the column. If `expand` is `false`, then the `cell`
    /// is allocated no more space than it needs. Any unused space is divided
    /// evenly between cells for which `expand` is `true`.
    @inlinable func packEnd<CellRendererT: CellRendererProtocol>(cell: CellRendererT, expand: Bool) {
        
        gtk_tree_view_column_pack_end(tree_view_column_ptr, cell.cell_renderer_ptr, gboolean((expand) ? 1 : 0))
        
    }

    /// Packs the `cell` into the beginning of the column. If `expand` is `false`, then
    /// the `cell` is allocated no more space than it needs. Any unused space is divided
    /// evenly between cells for which `expand` is `true`.
    @inlinable func packStart<CellRendererT: CellRendererProtocol>(cell: CellRendererT, expand: Bool) {
        
        gtk_tree_view_column_pack_start(tree_view_column_ptr, cell.cell_renderer_ptr, gboolean((expand) ? 1 : 0))
        
    }

    /// Flags the column, and the cell renderers added to this column, to have
    /// their sizes renegotiated.
    @inlinable func queueResize() {
        
        gtk_tree_view_column_queue_resize(tree_view_column_ptr)
        
    }

    /// Sets the alignment of the title or custom widget inside the column header.
    /// The alignment determines its location inside the button -- 0.0 for left, 0.5
    /// for center, 1.0 for right.
    @inlinable func setAlignment(xalign: CFloat) {
        
        gtk_tree_view_column_set_alignment(tree_view_column_ptr, xalign)
        
    }


    // *** setAttributes() is not available because it has a varargs (...) parameter!


    /// Sets the `GtkTreeCellDataFunc` to use for the column.
    /// 
    /// This
    /// function is used instead of the standard attributes mapping for
    /// setting the column value, and should set the value of `tree_column`'s
    /// cell renderer as appropriate.  `func` may be `nil` to remove an
    /// older one.
    @inlinable func setCellDataFunc<CellRendererT: CellRendererProtocol>(cellRenderer: CellRendererT, `func`: GtkTreeCellDataFunc? = nil, funcData: gpointer? = nil, destroy: GDestroyNotify?) {
        
        gtk_tree_view_column_set_cell_data_func(tree_view_column_ptr, cellRenderer.cell_renderer_ptr, `func`, funcData, destroy)
        
    }

    /// Sets the header to be active if `clickable` is `true`.  When the header is
    /// active, then it can take keyboard focus, and can be clicked.
    @inlinable func set(clickable: Bool) {
        
        gtk_tree_view_column_set_clickable(tree_view_column_ptr, gboolean((clickable) ? 1 : 0))
        
    }

    /// Sets the column to take available extra space.  This space is shared equally
    /// amongst all columns that have the expand set to `true`.  If no column has this
    /// option set, then the last column gets all extra space.  By default, every
    /// column is created with this `false`.
    /// 
    /// Along with “fixed-width”, the “expand” property changes when the column is
    /// resized by the user.
    @inlinable func set(expand: Bool) {
        
        gtk_tree_view_column_set_expand(tree_view_column_ptr, gboolean((expand) ? 1 : 0))
        
    }

    /// If `fixed_width` is not -1, sets the fixed width of `tree_column`; otherwise
    /// unsets it.  The effective value of `fixed_width` is clamped between the
    /// minimum and maximum width of the column; however, the value stored in the
    /// “fixed-width” property is not clamped.  If the column sizing is
    /// `GTK_TREE_VIEW_COLUMN_GROW_ONLY` or `GTK_TREE_VIEW_COLUMN_AUTOSIZE`, setting
    /// a fixed width overrides the automatically calculated width.  Note that
    /// `fixed_width` is only a hint to GTK; the width actually allocated to the
    /// column may be greater or less than requested.
    /// 
    /// Along with “expand”, the “fixed-width” property changes when the column is
    /// resized by the user.
    @inlinable func set(fixedWidth: Int) {
        
        gtk_tree_view_column_set_fixed_width(tree_view_column_ptr, gint(fixedWidth))
        
    }

    /// Sets the maximum width of the `tree_column`.  If `max_width` is -1, then the
    /// maximum width is unset.  Note, the column can actually be wider than max
    /// width if it’s the last column in a view.  In this case, the column expands to
    /// fill any extra space.
    @inlinable func set(maxWidth: Int) {
        
        gtk_tree_view_column_set_max_width(tree_view_column_ptr, gint(maxWidth))
        
    }

    /// Sets the minimum width of the `tree_column`.  If `min_width` is -1, then the
    /// minimum width is unset.
    @inlinable func set(minWidth: Int) {
        
        gtk_tree_view_column_set_min_width(tree_view_column_ptr, gint(minWidth))
        
    }

    /// If `reorderable` is `true`, then the column can be reordered by the end user
    /// dragging the header.
    @inlinable func set(reorderable: Bool) {
        
        gtk_tree_view_column_set_reorderable(tree_view_column_ptr, gboolean((reorderable) ? 1 : 0))
        
    }

    /// If `resizable` is `true`, then the user can explicitly resize the column by
    /// grabbing the outer edge of the column button.
    /// 
    /// If resizable is `true` and
    /// sizing mode of the column is `GTK_TREE_VIEW_COLUMN_AUTOSIZE`, then the sizing
    /// mode is changed to `GTK_TREE_VIEW_COLUMN_GROW_ONLY`.
    @inlinable func set(resizable: Bool) {
        
        gtk_tree_view_column_set_resizable(tree_view_column_ptr, gboolean((resizable) ? 1 : 0))
        
    }

    /// Sets the growth behavior of `tree_column` to `type`.
    @inlinable func setSizing(type: GtkTreeViewColumnSizing) {
        
        gtk_tree_view_column_set_sizing(tree_view_column_ptr, type)
        
    }

    /// Sets the logical `sort_column_id` that this column sorts on when this column
    /// is selected for sorting.  Doing so makes the column header clickable.
    @inlinable func set(sortColumnId: Int) {
        
        gtk_tree_view_column_set_sort_column_id(tree_view_column_ptr, gint(sortColumnId))
        
    }

    /// Call this function with a `setting` of `true` to display an arrow in
    /// the header button indicating the column is sorted. Call
    /// `gtk_tree_view_column_set_sort_order()` to change the direction of
    /// the arrow.
    @inlinable func setSortIndicator(setting: Bool) {
        
        gtk_tree_view_column_set_sort_indicator(tree_view_column_ptr, gboolean((setting) ? 1 : 0))
        
    }

    /// Changes the appearance of the sort indicator.
    /// 
    /// This does not actually sort the model.  Use
    /// `gtk_tree_view_column_set_sort_column_id()` if you want automatic sorting
    /// support.  This function is primarily for custom sorting behavior, and should
    /// be used in conjunction with `gtk_tree_sortable_set_sort_column_id()` to do
    /// that. For custom models, the mechanism will vary.
    /// 
    /// The sort indicator changes direction to indicate normal sort or reverse sort.
    /// Note that you must have the sort indicator enabled to see anything when
    /// calling this function; see `gtk_tree_view_column_set_sort_indicator()`.
    @inlinable func setSort(order: GtkSortType) {
        
        gtk_tree_view_column_set_sort_order(tree_view_column_ptr, order)
        
    }

    /// Sets the spacing field of `tree_column`, which is the number of pixels to
    /// place between cell renderers packed into it.
    @inlinable func set(spacing: Int) {
        
        gtk_tree_view_column_set_spacing(tree_view_column_ptr, gint(spacing))
        
    }

    /// Sets the title of the `tree_column`.  If a custom widget has been set, then
    /// this value is ignored.
    @inlinable func set(title: UnsafePointer<CChar>!) {
        
        gtk_tree_view_column_set_title(tree_view_column_ptr, title)
        
    }

    /// Sets the visibility of `tree_column`.
    @inlinable func set(visible: Bool) {
        
        gtk_tree_view_column_set_visible(tree_view_column_ptr, gboolean((visible) ? 1 : 0))
        
    }

    /// Sets the widget in the header to be `widget`.  If widget is `nil`, then the
    /// header button is set with a `GtkLabel` set to the title of `tree_column`.
    @inlinable func set(widget: WidgetRef? = nil) {
            
        gtk_tree_view_column_set_widget(tree_view_column_ptr, widget?.widget_ptr)
            
    }
    /// Sets the widget in the header to be `widget`.  If widget is `nil`, then the
    /// header button is set with a `GtkLabel` set to the title of `tree_column`.
    @inlinable func set<WidgetT: WidgetProtocol>(widget: WidgetT?) {
        
        gtk_tree_view_column_set_widget(tree_view_column_ptr, widget?.widget_ptr)
        
    }
    @inlinable var alignment: CFloat {
        /// Returns the current x alignment of `tree_column`.  This value can range
        /// between 0.0 and 1.0.
        get {
            let result = gtk_tree_view_column_get_alignment(tree_view_column_ptr)
        let rv = result
            return rv
        }
        /// Sets the alignment of the title or custom widget inside the column header.
        /// The alignment determines its location inside the button -- 0.0 for left, 0.5
        /// for center, 1.0 for right.
        nonmutating set {
            gtk_tree_view_column_set_alignment(tree_view_column_ptr, newValue)
        }
    }

    /// Returns the button used in the treeview column header
    @inlinable var button: WidgetRef! {
        /// Returns the button used in the treeview column header
        get {
            let result = gtk_tree_view_column_get_button(tree_view_column_ptr)
        let rv = WidgetRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    @inlinable var clickable: Bool {
        /// Returns `true` if the user can click on the header for the column.
        get {
            let result = gtk_tree_view_column_get_clickable(tree_view_column_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets the header to be active if `clickable` is `true`.  When the header is
        /// active, then it can take keyboard focus, and can be clicked.
        nonmutating set {
            gtk_tree_view_column_set_clickable(tree_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var expand: Bool {
        /// Returns `true` if the column expands to fill available space.
        get {
            let result = gtk_tree_view_column_get_expand(tree_view_column_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets the column to take available extra space.  This space is shared equally
        /// amongst all columns that have the expand set to `true`.  If no column has this
        /// option set, then the last column gets all extra space.  By default, every
        /// column is created with this `false`.
        /// 
        /// Along with “fixed-width”, the “expand” property changes when the column is
        /// resized by the user.
        nonmutating set {
            gtk_tree_view_column_set_expand(tree_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the fixed width of the column.  This may not be the actual displayed
    /// width of the column; for that, use `gtk_tree_view_column_get_width()`.
    @inlinable var fixedWidth: Int {
        /// Gets the fixed width of the column.  This may not be the actual displayed
        /// width of the column; for that, use `gtk_tree_view_column_get_width()`.
        get {
            let result = gtk_tree_view_column_get_fixed_width(tree_view_column_ptr)
        let rv = Int(result)
            return rv
        }
        /// If `fixed_width` is not -1, sets the fixed width of `tree_column`; otherwise
        /// unsets it.  The effective value of `fixed_width` is clamped between the
        /// minimum and maximum width of the column; however, the value stored in the
        /// “fixed-width” property is not clamped.  If the column sizing is
        /// `GTK_TREE_VIEW_COLUMN_GROW_ONLY` or `GTK_TREE_VIEW_COLUMN_AUTOSIZE`, setting
        /// a fixed width overrides the automatically calculated width.  Note that
        /// `fixed_width` is only a hint to GTK; the width actually allocated to the
        /// column may be greater or less than requested.
        /// 
        /// Along with “expand”, the “fixed-width” property changes when the column is
        /// resized by the user.
        nonmutating set {
            gtk_tree_view_column_set_fixed_width(tree_view_column_ptr, gint(newValue))
        }
    }

    /// Returns the maximum width in pixels of the `tree_column`, or -1 if no maximum
    /// width is set.
    @inlinable var maxWidth: Int {
        /// Returns the maximum width in pixels of the `tree_column`, or -1 if no maximum
        /// width is set.
        get {
            let result = gtk_tree_view_column_get_max_width(tree_view_column_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the maximum width of the `tree_column`.  If `max_width` is -1, then the
        /// maximum width is unset.  Note, the column can actually be wider than max
        /// width if it’s the last column in a view.  In this case, the column expands to
        /// fill any extra space.
        nonmutating set {
            gtk_tree_view_column_set_max_width(tree_view_column_ptr, gint(newValue))
        }
    }

    /// Returns the minimum width in pixels of the `tree_column`, or -1 if no minimum
    /// width is set.
    @inlinable var minWidth: Int {
        /// Returns the minimum width in pixels of the `tree_column`, or -1 if no minimum
        /// width is set.
        get {
            let result = gtk_tree_view_column_get_min_width(tree_view_column_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the minimum width of the `tree_column`.  If `min_width` is -1, then the
        /// minimum width is unset.
        nonmutating set {
            gtk_tree_view_column_set_min_width(tree_view_column_ptr, gint(newValue))
        }
    }

    @inlinable var reorderable: Bool {
        /// Returns `true` if the `tree_column` can be reordered by the user.
        get {
            let result = gtk_tree_view_column_get_reorderable(tree_view_column_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// If `reorderable` is `true`, then the column can be reordered by the end user
        /// dragging the header.
        nonmutating set {
            gtk_tree_view_column_set_reorderable(tree_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var resizable: Bool {
        /// Returns `true` if the `tree_column` can be resized by the end user.
        get {
            let result = gtk_tree_view_column_get_resizable(tree_view_column_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// If `resizable` is `true`, then the user can explicitly resize the column by
        /// grabbing the outer edge of the column button.
        /// 
        /// If resizable is `true` and
        /// sizing mode of the column is `GTK_TREE_VIEW_COLUMN_AUTOSIZE`, then the sizing
        /// mode is changed to `GTK_TREE_VIEW_COLUMN_GROW_ONLY`.
        nonmutating set {
            gtk_tree_view_column_set_resizable(tree_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var sizing: GtkTreeViewColumnSizing {
        /// Returns the current type of `tree_column`.
        get {
            let result = gtk_tree_view_column_get_sizing(tree_view_column_ptr)
        let rv = result
            return rv
        }
        /// Sets the growth behavior of `tree_column` to `type`.
        nonmutating set {
            gtk_tree_view_column_set_sizing(tree_view_column_ptr, newValue)
        }
    }

    /// Gets the logical `sort_column_id` that the model sorts on
    /// when this column is selected for sorting.
    /// 
    /// See [method`Gtk.TreeViewColumn.set_sort_column_id`].
    @inlinable var sortColumnId: Int {
        /// Gets the logical `sort_column_id` that the model sorts on
        /// when this column is selected for sorting.
        /// 
        /// See [method`Gtk.TreeViewColumn.set_sort_column_id`].
        get {
            let result = gtk_tree_view_column_get_sort_column_id(tree_view_column_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the logical `sort_column_id` that this column sorts on when this column
        /// is selected for sorting.  Doing so makes the column header clickable.
        nonmutating set {
            gtk_tree_view_column_set_sort_column_id(tree_view_column_ptr, gint(newValue))
        }
    }

    /// Gets the value set by `gtk_tree_view_column_set_sort_indicator()`.
    @inlinable var sortIndicator: Bool {
        /// Gets the value set by `gtk_tree_view_column_set_sort_indicator()`.
        get {
            let result = gtk_tree_view_column_get_sort_indicator(tree_view_column_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Call this function with a `setting` of `true` to display an arrow in
        /// the header button indicating the column is sorted. Call
        /// `gtk_tree_view_column_set_sort_order()` to change the direction of
        /// the arrow.
        nonmutating set {
            gtk_tree_view_column_set_sort_indicator(tree_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the value set by `gtk_tree_view_column_set_sort_order()`.
    @inlinable var sortOrder: GtkSortType {
        /// Gets the value set by `gtk_tree_view_column_set_sort_order()`.
        get {
            let result = gtk_tree_view_column_get_sort_order(tree_view_column_ptr)
        let rv = result
            return rv
        }
        /// Changes the appearance of the sort indicator.
        /// 
        /// This does not actually sort the model.  Use
        /// `gtk_tree_view_column_set_sort_column_id()` if you want automatic sorting
        /// support.  This function is primarily for custom sorting behavior, and should
        /// be used in conjunction with `gtk_tree_sortable_set_sort_column_id()` to do
        /// that. For custom models, the mechanism will vary.
        /// 
        /// The sort indicator changes direction to indicate normal sort or reverse sort.
        /// Note that you must have the sort indicator enabled to see anything when
        /// calling this function; see `gtk_tree_view_column_set_sort_indicator()`.
        nonmutating set {
            gtk_tree_view_column_set_sort_order(tree_view_column_ptr, newValue)
        }
    }

    @inlinable var spacing: Int {
        /// Returns the spacing of `tree_column`.
        get {
            let result = gtk_tree_view_column_get_spacing(tree_view_column_ptr)
        let rv = Int(result)
            return rv
        }
        /// Sets the spacing field of `tree_column`, which is the number of pixels to
        /// place between cell renderers packed into it.
        nonmutating set {
            gtk_tree_view_column_set_spacing(tree_view_column_ptr, gint(newValue))
        }
    }

    @inlinable var title: String! {
        /// Returns the title of the widget.
        get {
            let result = gtk_tree_view_column_get_title(tree_view_column_ptr)
        let rv = result.map({ String(cString: $0) })
            return rv
        }
        /// Sets the title of the `tree_column`.  If a custom widget has been set, then
        /// this value is ignored.
        nonmutating set {
            gtk_tree_view_column_set_title(tree_view_column_ptr, newValue)
        }
    }

    /// Returns the `GtkTreeView` wherein `tree_column` has been inserted.
    /// If `column` is currently not inserted in any tree view, `nil` is
    /// returned.
    @inlinable var treeView: WidgetRef! {
        /// Returns the `GtkTreeView` wherein `tree_column` has been inserted.
        /// If `column` is currently not inserted in any tree view, `nil` is
        /// returned.
        get {
            let result = gtk_tree_view_column_get_tree_view(tree_view_column_ptr)
        let rv = WidgetRef(gconstpointer: gconstpointer(result))
            return rv
        }
    }

    @inlinable var visible: Bool {
        /// Returns `true` if `tree_column` is visible.
        get {
            let result = gtk_tree_view_column_get_visible(tree_view_column_ptr)
        let rv = ((result) != 0)
            return rv
        }
        /// Sets the visibility of `tree_column`.
        nonmutating set {
            gtk_tree_view_column_set_visible(tree_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var widget: WidgetRef! {
        /// Returns the `GtkWidget` in the button on the column header.
        /// 
        /// If a custom widget has not been set then `nil` is returned.
        get {
            let result = gtk_tree_view_column_get_widget(tree_view_column_ptr)
        let rv = WidgetRef(gconstpointer: gconstpointer(result))
            return rv
        }
        /// Sets the widget in the header to be `widget`.  If widget is `nil`, then the
        /// header button is set with a `GtkLabel` set to the title of `tree_column`.
        nonmutating set {
            gtk_tree_view_column_set_widget(tree_view_column_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    @inlinable var width: Int {
        /// Returns the current size of `tree_column` in pixels.
        get {
            let result = gtk_tree_view_column_get_width(tree_view_column_ptr)
        let rv = Int(result)
            return rv
        }
    }

    /// Returns the current X offset of `tree_column` in pixels.
    @inlinable var xOffset: Int {
        /// Returns the current X offset of `tree_column` in pixels.
        get {
            let result = gtk_tree_view_column_get_x_offset(tree_view_column_ptr)
        let rv = Int(result)
            return rv
        }
    }


}



